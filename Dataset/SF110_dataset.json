[
    {
        "project_name": "69_lhamacaw",
        "class": "DisplayableListPanel",
        "source_code": "package macaw.util;\n\nimport macaw.businessLayer.*;\nimport java.awt.*;\nimport macaw.system.*;\nimport javax.swing.*;\nimport java.util.*;\nimport java.awt.event.*;\n\npublic class DisplayableListPanel implements ActionListener\n{\n    private boolean isNewRecord;\n    private ArrayList<Displayable> masterList;\n    private SessionProperties sessionProperties;\n    private Log log;\n    private String panelTitleText;\n    private String currentUserID;\n    private UserInterfaceFactory userInterfaceFactory;\n    private DisplayableListParentForm parentForm;\n    private DisplayableListItemSelector listItemSelector;\n    private DisplayableListItemAdder listItemAdder;\n    private DisplayableListItemEditor listItemEditor;\n    private DisplayableListItemViewer listItemViewer;\n    private DisplayableListItemDeleter listItemDeleter;\n    private String listOwnerName;\n    private boolean allowWriteAccess;\n    private boolean allowRecordEditing;\n    private ArrayList<Displayable> masterSourceVariableCollection;\n    private JPanel panel;\n    private DisplayableList displayableList;\n    private JButton select;\n    private JButton add;\n    private JButton edit;\n    private JButton view;\n    private JButton delete;\n    \n    public DisplayableListPanel(final SessionProperties sessionProperties, final DisplayableListParentForm parentForm, final String panelTitleText, final boolean allowWriteAccess) {\n        this.init(sessionProperties, parentForm, panelTitleText, allowWriteAccess, allowWriteAccess);\n    }\n    \n    public DisplayableListPanel(final SessionProperties sessionProperties, final DisplayableListParentForm parentForm, final String panelTitleText, final boolean allowWriteAccess, final boolean allowRecordEditing) {\n        this.init(sessionProperties, parentForm, panelTitleText, allowWriteAccess, allowRecordEditing);\n    }\n    \n    private void init(final SessionProperties sessionProperties, final DisplayableListParentForm parentForm, final String panelTitleText, final boolean allowWriteAccess, final boolean allowRecordEditing) {\n        this.sessionProperties = sessionProperties;\n        this.log = sessionProperties.getLog();\n        this.parentForm = parentForm;\n        this.panelTitleText = panelTitleText;\n        this.allowWriteAccess = allowWriteAccess;\n        this.allowRecordEditing = allowRecordEditing;\n        this.userInterfaceFactory = sessionProperties.getUserInterfaceFactory();\n        final User currentUser = (User)sessionProperties.getProperty(\"currentUser\");\n        this.currentUserID = currentUser.getUserID();\n        this.masterList = new ArrayList<Displayable>();\n        this.displayableList = new DisplayableList(this.userInterfaceFactory);\n        final String selectText = MacawMessages.getMessage(\"general.buttons.select\");\n        (this.select = this.userInterfaceFactory.createButton(selectText)).addActionListener(this);\n        final String addText = MacawMessages.getMessage(\"general.buttons.add\");\n        (this.add = this.userInterfaceFactory.createButton(addText)).addActionListener(this);\n        final String editText = MacawMessages.getMessage(\"general.buttons.edit\");\n        (this.edit = this.userInterfaceFactory.createButton(editText)).addActionListener(this);\n        final String viewText = MacawMessages.getMessage(\"general.buttons.view\");\n        (this.view = this.userInterfaceFactory.createButton(viewText)).addActionListener(this);\n        final String deleteText = MacawMessages.getMessage(\"general.buttons.delete\");\n        (this.delete = this.userInterfaceFactory.createButton(deleteText)).addActionListener(this);\n    }\n    \n    private void buildUI() {\n        this.panel = this.userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = this.userInterfaceFactory.createGridBagConstraints();\n        final JLabel titleLabel = this.userInterfaceFactory.createLabel(this.panelTitleText);\n        this.panel.add(titleLabel, panelGC);\n        final GridBagConstraints gridBagConstraints = panelGC;\n        ++gridBagConstraints.gridy;\n        panelGC.fill = 1;\n        panelGC.weightx = 100.0;\n        panelGC.weighty = 100.0;\n        final JScrollPane scrollPane = this.displayableList.getListScrollPane();\n        this.panel.add(scrollPane, panelGC);\n        final GridBagConstraints gridBagConstraints2 = panelGC;\n        ++gridBagConstraints2.gridy;\n        panelGC.anchor = 14;\n        panelGC.fill = 0;\n        panelGC.weightx = 0.0;\n        panelGC.weighty = 0.0;\n        this.panel.add(this.createControlButtonPanel(), panelGC);\n    }\n    \n    private JPanel createControlButtonPanel() {\n        final JPanel panel = this.userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = this.userInterfaceFactory.createGridBagConstraints();\n        if (this.listItemSelector != null && this.allowWriteAccess) {\n            panel.add(this.select, panelGC);\n            final GridBagConstraints gridBagConstraints = panelGC;\n            ++gridBagConstraints.gridx;\n        }\n        if (this.listItemAdder != null) {\n            panel.add(this.add, panelGC);\n            final GridBagConstraints gridBagConstraints2 = panelGC;\n            ++gridBagConstraints2.gridx;\n        }\n        if (this.allowRecordEditing && this.listItemEditor != null) {\n            panel.add(this.edit, panelGC);\n            final GridBagConstraints gridBagConstraints3 = panelGC;\n            ++gridBagConstraints3.gridx;\n        }\n        else if (this.listItemViewer != null) {\n            panel.add(this.view, panelGC);\n            final GridBagConstraints gridBagConstraints4 = panelGC;\n            ++gridBagConstraints4.gridx;\n        }\n        if (this.listItemDeleter != null) {\n            panel.add(this.delete, panelGC);\n        }\n        return panel;\n    }\n    \n    public void setNewRecord(final boolean isNewRecord) {\n        this.isNewRecord = isNewRecord;\n        this.updateButtonStates();\n    }\n    \n    public JPanel getPanel() {\n        this.buildUI();\n        return this.panel;\n    }\n    \n    public void setDisplayableListItemSelector(final DisplayableListItemSelector listItemSelector) {\n        this.listItemSelector = listItemSelector;\n    }\n    \n    public void setDisplayableListItemAdder(final DisplayableListItemAdder listItemAdder) {\n        this.listItemAdder = listItemAdder;\n    }\n    \n    public void setDisplayableListItemEditor(final DisplayableListItemEditor listItemEditor) {\n        this.listItemEditor = listItemEditor;\n    }\n    \n    public void setDisplayableListItemViewer(final DisplayableListItemViewer listItemViewer) {\n        this.listItemViewer = listItemViewer;\n    }\n    \n    public void setDisplayableListItemDeleter(final DisplayableListItemDeleter listItemDeleter) {\n        this.listItemDeleter = listItemDeleter;\n    }\n    \n    public void addListItem() {\n        try {\n            if (this.listItemAdder == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingAdder\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_ADDER, errorMessage);\n                throw exception;\n            }\n            this.parentForm.commitChanges();\n            this.listItemAdder.addItems(this.listOwnerName, this.displayableList);\n            this.updateButtonStates();\n        }\n        catch (MacawException exception2) {\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(exception2);\n        }\n    }\n    \n    private void editSelectedListItem() {\n        if (!this.displayableList.itemsAreSelected()) {\n            final String errorMessage = MacawMessages.getMessage(\"general.error.unselectedItems\");\n            final Log log = (Log)this.sessionProperties.getProperty(\"log\");\n            log.displayErrorDialog(errorMessage);\n            return;\n        }\n        try {\n            if (this.listItemEditor == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingEditor\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_EDITOR, errorMessage);\n                throw exception;\n            }\n            this.parentForm.commitChanges();\n            final Displayable selectedListItem = this.displayableList.getSelectedItem();\n            final String oldDisplayName = selectedListItem.getDisplayName();\n            this.listItemEditor.editListItem(this.listOwnerName, selectedListItem, this.displayableList);\n        }\n        catch (MacawException exception2) {\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(exception2);\n        }\n    }\n    \n    private void viewSelectedListItem() {\n        if (!this.displayableList.itemsAreSelected()) {\n            final String errorMessage = MacawMessages.getMessage(\"general.error.unselectedItems\");\n            final Log log = (Log)this.sessionProperties.getProperty(\"log\");\n            log.displayErrorDialog(errorMessage);\n            return;\n        }\n        try {\n            if (this.listItemViewer == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingViewer\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_SELECTOR, errorMessage);\n                throw exception;\n            }\n            final Displayable selectedListItem = this.displayableList.getSelectedItem();\n            this.listItemViewer.viewListItem(selectedListItem);\n        }\n        catch (MacawException exception2) {\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(exception2);\n        }\n    }\n    \n    public void deleteSelectedListItems() {\n        if (!this.displayableList.itemsAreSelected()) {\n            final String errorMessage = MacawMessages.getMessage(\"general.error.unselectedItems\");\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(errorMessage);\n            return;\n        }\n        try {\n            this.parentForm.commitChanges();\n            if (this.listItemDeleter == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingDeleter\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_DELETER, errorMessage);\n                throw exception;\n            }\n            final String dialogTitle = MacawMessages.getMessage(\"general.warning.title\");\n            final String warningMessage = MacawMessages.getMessage(\"general.warning.deletionIsPermanent\");\n            final int result = JOptionPane.showConfirmDialog(null, warningMessage, dialogTitle, 0, 2);\n            if (result != 0) {\n                return;\n            }\n            this.listItemDeleter.deleteListItems(this.listOwnerName, this.displayableList);\n            this.updateButtonStates();\n        }\n        catch (MacawException exception2) {\n            this.log.displayErrorDialog(exception2);\n        }\n    }\n    \n    private void selectListItems() {\n        try {\n            this.listItemSelector.selectListItems(this.listOwnerName, this.displayableList);\n            this.updateButtonStates();\n        }\n        catch (MacawException exception) {\n            this.log.displayErrorDialog(exception);\n        }\n    }\n    \n    public void updateButtonStates() {\n        if (this.allowWriteAccess) {\n            if (this.isNewRecord) {\n                this.add.setEnabled(false);\n                this.delete.setEnabled(false);\n                this.edit.setEnabled(false);\n                this.view.setEnabled(false);\n                this.select.setEnabled(false);\n            }\n            else {\n                this.add.setEnabled(true);\n                this.select.setEnabled(true);\n                if (this.displayableList.isEmpty()) {\n                    this.delete.setEnabled(false);\n                    if (this.allowRecordEditing) {\n                        this.edit.setEnabled(false);\n                    }\n                    else {\n                        this.view.setEnabled(false);\n                    }\n                }\n                else {\n                    this.delete.setEnabled(true);\n                    if (this.allowRecordEditing) {\n                        this.edit.setEnabled(true);\n                    }\n                    else {\n                        this.view.setEnabled(true);\n                    }\n                }\n            }\n        }\n        else {\n            this.add.setEnabled(false);\n            this.delete.setEnabled(false);\n            if (this.displayableList.isEmpty()) {\n                this.view.setEnabled(false);\n            }\n            else if (!this.isNewRecord) {\n                this.view.setEnabled(true);\n            }\n        }\n    }\n    \n    public void setDisplayableItems(final ArrayList<Displayable> masterList) {\n        this.masterList = masterList;\n        this.displayableList.setDisplayItems(masterList);\n        this.updateButtonStates();\n    }\n    \n    public void save() {\n        this.masterList.clear();\n        final ArrayList<Displayable> currentList = this.displayableList.getAllItems();\n        this.masterList.addAll(currentList);\n    }\n    \n    public ArrayList<Displayable> getAllListItems() {\n        return this.displayableList.getAllItems();\n    }\n    \n    public void setListOwnerName(final String listOwnerName) {\n        this.listOwnerName = listOwnerName;\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent event) {\n        final Object button = event.getSource();\n        if (button == this.select) {\n            this.selectListItems();\n        }\n        else if (button == this.add) {\n            this.addListItem();\n        }\n        else if (button == this.edit) {\n            this.editSelectedListItem();\n        }\n        else if (button == this.view) {\n            this.viewSelectedListItem();\n        }\n        else if (button == this.delete) {\n            this.deleteSelectedListItems();\n        }\n    }\n}\n",
        "token_number_zeroshot": 2653,
        "token_number_fewshot": 3051,
        "token_number_cot": 2766
    },
    {
        "project_name": "69_lhamacaw",
        "class": "MacawWorkBench",
        "source_code": "package macaw.presentationLayer;\n\nimport macaw.businessLayer.*;\nimport macaw.persistenceLayer.demo.*;\nimport macaw.persistenceLayer.production.*;\nimport javax.swing.border.*;\nimport macaw.system.*;\nimport javax.swing.*;\nimport java.awt.*;\nimport macaw.io.*;\nimport java.awt.event.*;\n\npublic class MacawWorkBench implements ActionListener\n{\n    private SessionProperties sessionProperties;\n    private JDialog dialog;\n    private JButton editConstants;\n    private JButton editVariables;\n    private JButton exportVariableData;\n    private JButton exit;\n    \n    public static void main(final String[] arguments) {\n        final String dbUser = null;\n        final String dbPassword = null;\n        try {\n            final SessionProperties sessionProperties = new SessionProperties();\n            final StartupOptions startupOptions = (StartupOptions)sessionProperties.getProperty(\"startupOptions\");\n            startupOptions.processCommandLineArguments(arguments);\n            final User currentUser = new User(\"jsmith\", \"cool\");\n            sessionProperties.setProperty(\"currentUser\", currentUser);\n            if (startupOptions.useDemo()) {\n                final DemonstrationCurationService database = new DemonstrationCurationService(false);\n                final DemonstrationRetrievalService demonstratinRetrievalService = new DemonstrationRetrievalService(sessionProperties);\n                sessionProperties.setProperty(\"retrievalService\", demonstratinRetrievalService);\n                sessionProperties.setProperty(\"database\", database);\n            }\n            else {\n                final ProductionCurationService database2 = new ProductionCurationService(sessionProperties);\n                final ProductionRetrievalService macawRetrievalAPI = new ProductionRetrievalService(sessionProperties);\n                sessionProperties.setProperty(\"retrievalService\", macawRetrievalAPI);\n                sessionProperties.setProperty(\"database\", database2);\n            }\n            int numberOfAttempts;\n            LoginDialog loginDialog;\n            for (numberOfAttempts = 0, numberOfAttempts = 0; numberOfAttempts < 3; ++numberOfAttempts) {\n                loginDialog = new LoginDialog(sessionProperties, numberOfAttempts);\n                loginDialog.show();\n                if (loginDialog.isLoginSuccessful()) {\n                    break;\n                }\n                if (loginDialog.isCancelled()) {\n                    System.exit(0);\n                }\n            }\n            if (numberOfAttempts == 3) {\n                System.exit(0);\n            }\n            final MacawWorkBench macawWorkBench = new MacawWorkBench(sessionProperties);\n            macawWorkBench.show();\n        }\n        catch (Exception exception) {\n            exception.printStackTrace(System.out);\n        }\n    }\n    \n    public MacawWorkBench(final SessionProperties sessionProperties) {\n        this.sessionProperties = sessionProperties;\n        final UserInterfaceFactory userInterfaceFactory = sessionProperties.getUserInterfaceFactory();\n        this.dialog = userInterfaceFactory.createDialog();\n        final String dialogTitle = MacawMessages.getMessage(\"macawWorkBench.title\");\n        this.dialog.setTitle(dialogTitle);\n        final JPanel panel = userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = userInterfaceFactory.createGridBagConstraints();\n        panelGC.anchor = 18;\n        panelGC.fill = 2;\n        panelGC.weightx = 1.0;\n        final JTextArea instructionsArea = userInterfaceFactory.createImmutableTextArea(3, 20);\n        final String instructionsText = MacawMessages.getMessage(\"macawWorkBench.instructions\");\n        instructionsArea.setText(instructionsText);\n        instructionsArea.setBorder(LineBorder.createGrayLineBorder());\n        panel.add(instructionsArea, panelGC);\n        final GridBagConstraints gridBagConstraints = panelGC;\n        ++gridBagConstraints.gridy;\n        panelGC.anchor = 10;\n        panelGC.fill = 0;\n        panelGC.weightx = 0.0;\n        panel.add(this.createButtonPanel(userInterfaceFactory), panelGC);\n        this.dialog.getContentPane().add(panel);\n        this.dialog.setModal(true);\n        this.dialog.setSize(300, 300);\n    }\n    \n    private JPanel createButtonPanel(final UserInterfaceFactory userInterfaceFactory) {\n        final JPanel panel = userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = userInterfaceFactory.createGridBagConstraints();\n        panelGC.ipady = 10;\n        panelGC.insets = new Insets(2, 2, 2, 2);\n        panelGC.fill = 0;\n        panelGC.weightx = 1.0;\n        final String editConstantsText = MacawMessages.getMessage(\"macawWorkBench.editConstants\");\n        this.editConstants = userInterfaceFactory.createButton(editConstantsText);\n        final String editConstantsInformationText = MacawMessages.getMessage(\"macawWorkBench.editConstants.instructions\");\n        this.editConstants.setToolTipText(editConstantsInformationText);\n        this.editConstants.addActionListener(this);\n        panel.add(this.editConstants, panelGC);\n        final GridBagConstraints gridBagConstraints = panelGC;\n        ++gridBagConstraints.gridy;\n        final String editVariablesText = MacawMessages.getMessage(\"macawWorkBench.editVariables\");\n        (this.editVariables = userInterfaceFactory.createButton(editVariablesText)).addActionListener(this);\n        final String editVariablesInformationText = MacawMessages.getMessage(\"macawWorkBench.editVariables.instructions\");\n        this.editVariables.setToolTipText(editVariablesInformationText);\n        panel.add(this.editVariables, panelGC);\n        final GridBagConstraints gridBagConstraints2 = panelGC;\n        ++gridBagConstraints2.gridy;\n        final String exportVariableText = MacawMessages.getMessage(\"macawWorkBench.exportVariableData\");\n        (this.exportVariableData = userInterfaceFactory.createButton(exportVariableText)).addActionListener(this);\n        final String exportVariableInformationText = MacawMessages.getMessage(\"macawWorkBench.exportVariableData.instructions\");\n        this.exportVariableData.setToolTipText(exportVariableInformationText);\n        panel.add(this.exportVariableData, panelGC);\n        final GridBagConstraints gridBagConstraints3 = panelGC;\n        ++gridBagConstraints3.gridy;\n        final String exitText = MacawMessages.getMessage(\"general.buttons.exit\");\n        (this.exit = userInterfaceFactory.createButton(exitText)).addActionListener(this);\n        panel.add(this.exit, panelGC);\n        return panel;\n    }\n    \n    public void show() {\n        this.dialog.setVisible(true);\n    }\n    \n    private void editConstants() {\n        final VariableConstantsEditor variableConstantsEditor = new VariableConstantsEditor(this.sessionProperties, true);\n        variableConstantsEditor.show();\n    }\n    \n    private void editVariables() {\n        final MacawVariableBrowser macawVariableBrowser = new MacawVariableBrowser(this.sessionProperties);\n        macawVariableBrowser.show();\n    }\n    \n    private void exportVariableData() {\n        final ExportVariablesToMacawXML exportToDSSFormat = new ExportVariablesToMacawXML(this.sessionProperties);\n        exportToDSSFormat.export();\n    }\n    \n    private void exit() {\n        System.exit(0);\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent event) {\n        final Object button = event.getSource();\n        if (button == this.editConstants) {\n            this.editConstants();\n        }\n        else if (button == this.editVariables) {\n            this.editVariables();\n        }\n        else if (button == this.exportVariableData) {\n            this.exportVariableData();\n        }\n        else {\n            this.exit();\n        }\n    }\n}\n",
        "token_number_zeroshot": 1476,
        "token_number_fewshot": 1874,
        "token_number_cot": 1590
    },
    {
        "project_name": "14_omjstate",
        "class": "Transition",
        "source_code": "package uk.me.jockmacmad.jstate.state;\n\nimport uk.me.jockmacmad.jstate.predicate.*;\nimport org.apache.commons.lang.builder.*;\nimport java.util.*;\n\npublic class Transition\n{\n    private final IState initialState;\n    private final IState outcomeState;\n    private final List<IGuardCondition> guardConditions;\n    private final Event triggerEvent;\n    private final String name;\n    \n    public Transition(final String pName, final Event pTriggerEvent, final IState pInitialState, final IState pOutcomeState) {\n        this.guardConditions = new ArrayList<IGuardCondition>();\n        this.name = pName;\n        this.initialState = pInitialState;\n        this.outcomeState = pOutcomeState;\n        this.triggerEvent = pTriggerEvent;\n    }\n    \n    public final void addGuardCondition(final IPredicate pGuard) {\n        this.guardConditions.add((IGuardCondition)pGuard);\n    }\n    \n    public final void addGuardCondition(final IGuardCondition pGuard) {\n        this.guardConditions.add(pGuard);\n    }\n    \n    @Override\n    public final boolean equals(final Object pTransition) {\n        return EqualsBuilder.reflectionEquals((Object)this, pTransition);\n    }\n    \n    @Override\n    public final int hashCode() {\n        return HashCodeBuilder.reflectionHashCode((Object)this);\n    }\n    \n    protected void evaluateGuardConditions() {\n    }\n    \n    public final IState getInitialState() {\n        return this.initialState;\n    }\n    \n    public final IState getOutcomeState() {\n        return this.outcomeState;\n    }\n    \n    public final Event getTriggerEvent() {\n        return this.triggerEvent;\n    }\n    \n    @Override\n    public final String toString() {\n        return ToStringBuilder.reflectionToString((Object)this);\n    }\n    \n    public final IState trigger(final IState pCurrentState, final Event pEvent) {\n        IState retVal = pCurrentState;\n        boolean passesGuards = false;\n        if (this.initialState.equals(pCurrentState) && this.triggerEvent.equals(pEvent)) {\n            if (this.guardConditions.isEmpty()) {\n                passesGuards = true;\n            }\n            else {\n                for (final IGuardCondition ig : this.guardConditions) {\n                    passesGuards = ig.evaluate(pEvent);\n                }\n            }\n            if (passesGuards) {\n                retVal = this.outcomeState;\n            }\n        }\n        return retVal;\n    }\n    \n    public final boolean willTrigger(final IState pCurrentState, final Event pEvent) {\n        boolean retVal = false;\n        boolean passesGuards = false;\n        if (this.initialState.equals(pCurrentState) && this.triggerEvent.equals(pEvent)) {\n            for (final IGuardCondition ig : this.guardConditions) {\n                passesGuards = ig.evaluate(pEvent);\n            }\n            if (passesGuards) {\n                retVal = true;\n            }\n        }\n        return retVal;\n    }\n}\n",
        "token_number_zeroshot": 627,
        "token_number_fewshot": 1025,
        "token_number_cot": 737
    },
    {
        "project_name": "60_sugar",
        "class": "FSPathResult",
        "source_code": "/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * FSPathResult.java\n *\n * Created on 08 April 2008, 16:21\n *\n */\n\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.net.URI;\nimport java.util.Date;\n\n/**\n * This class is a simple wrapper for any of the possible result types\n * that may be returned by an FSPath query.\n *\n *\n * Most FSPath queries are likely to return list of java.io.File object\n * which will be wrapped by an instance of this class.\n *\n *\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResult {\n\n    private File resultFile;\n\n    private String resultString;\n\n    private Double resultDouble;\n\n    private Date resultDate;\n\n    private URI resultURI;\n\n    private Boolean resultBoolean;\n\n    /** Creates a new instance of FSPathResult */\n    public FSPathResult(File file) {\n        this.resultFile = file;\n    }\n\n    public FSPathResult(String string) {\n        this.resultString = string;\n    }\n\n    public FSPathResult(Double resultLong) {\n        this.resultDouble = resultLong;\n    }\n\n    public FSPathResult(Date date) {\n        this.resultDate = date;\n    }\n\n    public FSPathResult(URI uri) {\n        this.resultURI = uri;\n    }\n\n    public FSPathResult(Boolean resultBoolean) {\n        this.resultBoolean = resultBoolean;\n    }\n\n    public File getFile() {\n        return this.resultFile;\n    }\n\n    public String getString() {\n        return this.resultString;\n    }\n\n    public Double getDouble() {\n        return this.resultDouble;\n    }\n\n    public Date getDate() {\n        return this.resultDate;\n    }\n\n    public URI getURI() {\n        return this.resultURI;\n    }\n\n    public Boolean getBoolean() {\n        return this.resultBoolean;\n    }\n\n\t/**\n\t *  Returns a String representation of the underlying object which\n\t *  this class wraps.\n\t *\n\t *\tThe following rules apply : <br/>\n\t *  <br/>\n\t *  if the underlying object is a java.io.File, then getAbsolutePath() method is called on it.<br/>\n\t *  if the underlying object is any of Boolean, Date, Double, String or URI then toString() is called in<br/>\n\t *\n\t *  @returns String\n\t */\n    public String toString() {\n\n\t\tif (this.resultFile != null) {\n\t\t\treturn this.resultFile.getAbsolutePath();\n\t\t}\n\n\t\tif (this.resultString != null) {\n\t\t\treturn this.resultString;\n\t\t}\n\n\t\tif (this.resultDouble != null) {\n\t\t\treturn this.resultDouble.toString();\n\t\t}\n\n\t\tif (this.resultBoolean != null) {\n\t\t\treturn this.resultBoolean.toString();\n\t\t}\n\n\t\tif (this.resultDate != null) {\n\t\t\treturn this.resultDate.toString();\n\t\t}\n\n\t\tif (this.resultURI != null) {\n\t\t\treturn this.resultURI.toString();\n\t\t}\n\n\t\treturn \"FSPathResult : empty\";\n\t}\n}\n",
        "token_number_zeroshot": 823,
        "token_number_fewshot": 1221,
        "token_number_cot": 935
    },
    {
        "project_name": "60_sugar",
        "class": "FSPathExplorer",
        "source_code": "/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net) \n * \n * All rights reserved.\n * \n * This file is part of FSPath.\n * \n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage net.sf.sugar.fspath.cli;\n/*\n * FSPathExplorer.java\n *\n * Created on 04 April 2008, 16:36\n *\n * To change this template, choose Tools | Template Manager\n * and open the template in the editor.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport net.sf.sugar.fspath.FSPath;\nimport net.sf.sugar.fspath.FSPathAttributes;\nimport net.sf.sugar.fspath.FSPathFactory;\nimport net.sf.sugar.fspath.FSPathResult;\nimport net.sf.sugar.fspath.FSPathResultList;\n\n\n/**\n *  This is a simple command line tool for interacting with the filesystem\n *\n * @author kbishop\n */\npublic class FSPathExplorer {\n   \n    public File rootPath;\n    \n    public String fsPathQuery = \"\";\n    \n    public FSPath fsPath;\n\n    public Prompt prompt;\n\n    public PrintStream out;\n\n    public PrintStream err;\n    \n    private enum Opt {\n        path, p, find, f\n    }\n    \n    /** Creates a new instance of FSPathExplorer */\n    public FSPathExplorer() {\n        this.out = System.out;\n        this.err = System.err;\n        this.prompt = new Prompt(System.in, out, err);\n        this.prompt.setPromptText(\"fspath>\");\n    }\n    \n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        \n        //checkArgs(args);\n        \n        showWelcome();\n        \n        FSPathExplorer explorer = new FSPathExplorer();\n        \n        explorer.configureExplorer(args);\n        \n        explorer.createFSPath();\n        \n        explorer.start();\n\n    }\n    \n//    protected static void checkArgs(String[] args) {\n//        if(args.length < 1) {\n//            showUsage();\n//            System.exit(1);\n//        }\n//    }\n    \n    \n//    protected static void showUsage() {\n//        \n//        StringBuffer usage = new StringBuffer(\"usage : java -jar FSPathExplorer [options] <-f|-find> <FSPath_query>\");\n//        usage.append(\"\\n\\n\\t Options : \")\n//               .append(\"\\n\\t\\t -path <root_path> : the relative or absolute path of the directory to start from.\")\n//               .append(\"\\n\\t\\t -p <root_path> :  see -path.\")\n//               .append(\"\\n\\n\\t Example FSPath queries :\")\n//               .append(\"\\n\\t\\t //dir[@name = 'var']/dir[@name = 'www']/dir[@name = 'htdocs']/file[contains(name, '.html')]\");\n//        \n//    }\n    \n    public static void showWelcome() {\n        \n        StringBuffer welcome = \n            new StringBuffer(\"\\n+-------------------------------------------------------+\");\n              welcome.append(\"\\n|                                                       |\")\n                     .append(\"\\n| FSPathExplorer                                        |\")\n                     .append(\"\\n|                                                       |\")\n                     .append(\"\\n+-------------------------------------------------------+\\n\")\n                     .append(\"\\nType 'help' for commands...\\n\")\n                     .append(\"\\nScanning filesystem metadata...\\n\")\n                     .append(\"\\n+-------------------------------------------------------+\")\n                     .append(\"\\n| PLEASE NOTE running FSPathExplorer from the top level |\")\n                     .append(\"\\n| of your filesystem is not advised                     |\")\n                     .append(\"\\n+-------------------------------------------------------+\");\n        \n        System.out.println(welcome);\n    }\n    \n    public static void showHelp() {\n        \n        StringBuffer help = new StringBuffer(\"FSPathExplorer help :\");\n        help.append(\"\\n\\nEnter an FSPath query to search the filesystem\")\n            .append(\"\\n\\nExamples :\")\n            .append(\"\\n\\n1) //dir[@name = 'foo'] \\n   finds any directory under the current directory named 'foo'\")\n            .append(\"\\n\\n2) //dir[@name = 'src']//file[@length > 10000] \\n   finds any file which is nested anywhere below a 'src' directory\")\n            .append(\"\\n   with a file size greater than 10000 bytes\")\n            .append(\"\\n\\n3) //dir[fs:matches(@name, '^[.].*')] \\n   finds all directories in the directory sructure which begin with a '.'\");\n            \n        help.append(\"\\n\\nAttributes : (see javadoc for java.io.File for more info)\")\n            .append(\"\\n\");\n        \n        for (FSPathAttributes a : FSPathAttributes.values()) {\n            if (!(a.name().equals(\"dir\") || a.name().equals(\"file\"))) {\n                help.append(\"\\n\").append(\"@\").append(a);\n            }\n        }\n        \n        help.append(\"\\n\\nCommands :\\n\");\n        \n        for (Commands c : Commands.values()) {\n            help.append(\"\\n\").append(c.getCommandText()).append(\"\\t: \").append(c.getDescription());\n        }\n        \n        System.out.println(help.append(\"\\n\"));\n    }\n    \n    /**\n     *  Assumes args is not null or 0 length.\n     */\n    public void configureExplorer(String[] args) {\n              \n        Map<Opt, Integer> arguments = new HashMap<Opt, Integer>();\n        \n        for (int i = 0; i < args.length; i++) {\n\n            if (args[i].equals(\"-\" + Opt.p.toString()) || args[i].equals(\"-\" + Opt.path.toString())) {\n                arguments.put(Opt.path, i);\n            }\n            \n            if (args[i].equals(\"-\" + Opt.f.toString()) || args[i].equals(\"-\" + Opt.find.toString())){              \n                arguments.put(Opt.find, i);\n            }\n        }\n        \n        Integer pathIndex = arguments.get(Opt.path);\n        \n        if (pathIndex != null) {\n            this.rootPath = new File(args[pathIndex.intValue() + 1]);\n        }  \n        \n        Integer queryIndex = arguments.get(Opt.find);\n        \n        if (queryIndex != null) {\n            for(int i = (queryIndex + 1); i < args.length; i++) {\n                this.fsPathQuery += args[i];\n            }\n        } \n        \n    }\n    \n    public void createFSPath() {\n        if (this.rootPath != null) {\n            this.fsPath = FSPathFactory.newFSPath(this.rootPath);\n        } else {\n            this.fsPath = FSPathFactory.newFSPath();\n        }\n\n    }\n    \n    public void start() {\n        \n        boolean running = true;\n        \n        while (running) {  \n\n            try {\n                String currentExpression = this.prompt.readLine();\n                \n                String[] expressionWords = currentExpression.split(\" \");\n                \n                if (expressionWords[0] != null && Commands.isCommand(expressionWords[0])) {\n\n                    if (expressionWords[0].equals(Commands.EXIT.getCommandText())) {\n                        this.prompt.close();\n                        out.println(\"exiting.....\");\n                        break;\n                    }\n                    \n                    if (expressionWords[0].equals(Commands.PWD.getCommandText())) {\n                        out.println(\"Current directory : \" + this.fsPath.getRootDirectory().getAbsolutePath());\n                    }\n                    \n                    if (expressionWords[0].equals(Commands.CD.getCommandText())) {\n                        try {\n                            File newDir = new File(expressionWords[1]);\n                            if (newDir.exists() \n                                && newDir.isDirectory()\n                                && newDir.canRead()) {\n                                \n                                this.fsPath = FSPathFactory.newFSPath(newDir);\n                                \n                                out.println(\"changed to : \" + newDir.getAbsolutePath());\n                            }\n                        } catch (Throwable t) {\n                            out.println(\"unable to change to \" + expressionWords[1] \n                                    + \" please make sure that the directory exitst and a is readable\");\n                        }\n                    }\n                    \n                    if (expressionWords[0].equals(Commands.HELP.getCommandText())) {\n                        showHelp();\n                    }\n                    \n                } else {\n                    //assume its an FSPath query and try to execute it\n                    this.fsPathQuery = currentExpression;\n                    \n                    FSPathResultList results = this.fsPath.query(this.fsPathQuery);\n\n                    for (FSPathResult result : results) {\n                        out.println(result.getFile().getPath());\n                    }\n                }\n          \n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n    \n}\n",
        "token_number_zeroshot": 1927,
        "token_number_fewshot": 2325,
        "token_number_cot": 2039
    },
    {
        "project_name": "jsci",
        "class": "SimpleCharStream",
        "source_code": "package JSci.maths.symbolic;\n\nimport java.io.*;\n\nclass SimpleCharStream\n{\n    public static final boolean staticFlag = true;\n    static int bufsize;\n    static int available;\n    static int tokenBegin;\n    public static int bufpos;\n    protected static int[] bufline;\n    protected static int[] bufcolumn;\n    protected static int column;\n    protected static int line;\n    protected static boolean prevCharIsCR;\n    protected static boolean prevCharIsLF;\n    protected static Reader inputStream;\n    protected static char[] buffer;\n    protected static int maxNextCharInd;\n    protected static int inBuf;\n    \n    protected static void ExpandBuff(final boolean wrapAround) {\n        final char[] newbuffer = new char[SimpleCharStream.bufsize + 2048];\n        final int[] newbufline = new int[SimpleCharStream.bufsize + 2048];\n        final int[] newbufcolumn = new int[SimpleCharStream.bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, newbuffer, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                System.arraycopy(SimpleCharStream.buffer, 0, newbuffer, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin, SimpleCharStream.bufpos);\n                SimpleCharStream.buffer = newbuffer;\n                System.arraycopy(SimpleCharStream.bufline, SimpleCharStream.tokenBegin, newbufline, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                System.arraycopy(SimpleCharStream.bufline, 0, newbufline, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin, SimpleCharStream.bufpos);\n                SimpleCharStream.bufline = newbufline;\n                System.arraycopy(SimpleCharStream.bufcolumn, SimpleCharStream.tokenBegin, newbufcolumn, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                System.arraycopy(SimpleCharStream.bufcolumn, 0, newbufcolumn, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin, SimpleCharStream.bufpos);\n                SimpleCharStream.bufcolumn = newbufcolumn;\n                SimpleCharStream.maxNextCharInd = (SimpleCharStream.bufpos += SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n            }\n            else {\n                System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, newbuffer, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                SimpleCharStream.buffer = newbuffer;\n                System.arraycopy(SimpleCharStream.bufline, SimpleCharStream.tokenBegin, newbufline, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                SimpleCharStream.bufline = newbufline;\n                System.arraycopy(SimpleCharStream.bufcolumn, SimpleCharStream.tokenBegin, newbufcolumn, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                SimpleCharStream.bufcolumn = newbufcolumn;\n                SimpleCharStream.maxNextCharInd = (SimpleCharStream.bufpos -= SimpleCharStream.tokenBegin);\n            }\n        }\n        catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        SimpleCharStream.bufsize += 2048;\n        SimpleCharStream.available = SimpleCharStream.bufsize;\n        SimpleCharStream.tokenBegin = 0;\n    }\n    \n    protected static void FillBuff() throws IOException {\n        if (SimpleCharStream.maxNextCharInd == SimpleCharStream.available) {\n            if (SimpleCharStream.available == SimpleCharStream.bufsize) {\n                if (SimpleCharStream.tokenBegin > 2048) {\n                    SimpleCharStream.bufpos = (SimpleCharStream.maxNextCharInd = 0);\n                    SimpleCharStream.available = SimpleCharStream.tokenBegin;\n                }\n                else if (SimpleCharStream.tokenBegin < 0) {\n                    SimpleCharStream.bufpos = (SimpleCharStream.maxNextCharInd = 0);\n                }\n                else {\n                    ExpandBuff(false);\n                }\n            }\n            else if (SimpleCharStream.available > SimpleCharStream.tokenBegin) {\n                SimpleCharStream.available = SimpleCharStream.bufsize;\n            }\n            else if (SimpleCharStream.tokenBegin - SimpleCharStream.available < 2048) {\n                ExpandBuff(true);\n            }\n            else {\n                SimpleCharStream.available = SimpleCharStream.tokenBegin;\n            }\n        }\n        try {\n            final int i;\n            if ((i = SimpleCharStream.inputStream.read(SimpleCharStream.buffer, SimpleCharStream.maxNextCharInd, SimpleCharStream.available - SimpleCharStream.maxNextCharInd)) == -1) {\n                SimpleCharStream.inputStream.close();\n                throw new IOException();\n            }\n            SimpleCharStream.maxNextCharInd += i;\n        }\n        catch (IOException e) {\n            --SimpleCharStream.bufpos;\n            backup(0);\n            if (SimpleCharStream.tokenBegin == -1) {\n                SimpleCharStream.tokenBegin = SimpleCharStream.bufpos;\n            }\n            throw e;\n        }\n    }\n    \n    public static char BeginToken() throws IOException {\n        SimpleCharStream.tokenBegin = -1;\n        final char c = readChar();\n        SimpleCharStream.tokenBegin = SimpleCharStream.bufpos;\n        return c;\n    }\n    \n    protected static void UpdateLineColumn(final char c) {\n        ++SimpleCharStream.column;\n        if (SimpleCharStream.prevCharIsLF) {\n            SimpleCharStream.prevCharIsLF = false;\n            SimpleCharStream.line += (SimpleCharStream.column = 1);\n        }\n        else if (SimpleCharStream.prevCharIsCR) {\n            SimpleCharStream.prevCharIsCR = false;\n            if (c == '\\n') {\n                SimpleCharStream.prevCharIsLF = true;\n            }\n            else {\n                SimpleCharStream.line += (SimpleCharStream.column = 1);\n            }\n        }\n        switch (c) {\n            case '\\r': {\n                SimpleCharStream.prevCharIsCR = true;\n                break;\n            }\n            case '\\n': {\n                SimpleCharStream.prevCharIsLF = true;\n                break;\n            }\n            case '\\t': {\n                --SimpleCharStream.column;\n                SimpleCharStream.column += 8 - (SimpleCharStream.column & 0x7);\n                break;\n            }\n        }\n        SimpleCharStream.bufline[SimpleCharStream.bufpos] = SimpleCharStream.line;\n        SimpleCharStream.bufcolumn[SimpleCharStream.bufpos] = SimpleCharStream.column;\n    }\n    \n    public static char readChar() throws IOException {\n        if (SimpleCharStream.inBuf > 0) {\n            --SimpleCharStream.inBuf;\n            if (++SimpleCharStream.bufpos == SimpleCharStream.bufsize) {\n                SimpleCharStream.bufpos = 0;\n            }\n            return SimpleCharStream.buffer[SimpleCharStream.bufpos];\n        }\n        if (++SimpleCharStream.bufpos >= SimpleCharStream.maxNextCharInd) {\n            FillBuff();\n        }\n        final char c = SimpleCharStream.buffer[SimpleCharStream.bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n    \n    public static int getColumn() {\n        return SimpleCharStream.bufcolumn[SimpleCharStream.bufpos];\n    }\n    \n    public static int getLine() {\n        return SimpleCharStream.bufline[SimpleCharStream.bufpos];\n    }\n    \n    public static int getEndColumn() {\n        return SimpleCharStream.bufcolumn[SimpleCharStream.bufpos];\n    }\n    \n    public static int getEndLine() {\n        return SimpleCharStream.bufline[SimpleCharStream.bufpos];\n    }\n    \n    public static int getBeginColumn() {\n        return SimpleCharStream.bufcolumn[SimpleCharStream.tokenBegin];\n    }\n    \n    public static int getBeginLine() {\n        return SimpleCharStream.bufline[SimpleCharStream.tokenBegin];\n    }\n    \n    public static void backup(final int amount) {\n        SimpleCharStream.inBuf += amount;\n        if ((SimpleCharStream.bufpos -= amount) < 0) {\n            SimpleCharStream.bufpos += SimpleCharStream.bufsize;\n        }\n    }\n    \n    public SimpleCharStream(final Reader dstream, final int startline, final int startcolumn, final int buffersize) {\n        if (SimpleCharStream.inputStream != null) {\n            throw new Error(\"\\n   ERROR: Second call to the constructor of a static SimpleCharStream.  You must\\n       either use ReInit() or set the JavaCC option STATIC to false\\n       during the generation of this class.\");\n        }\n        SimpleCharStream.inputStream = dstream;\n        SimpleCharStream.line = startline;\n        SimpleCharStream.column = startcolumn - 1;\n        SimpleCharStream.bufsize = buffersize;\n        SimpleCharStream.available = buffersize;\n        SimpleCharStream.buffer = new char[buffersize];\n        SimpleCharStream.bufline = new int[buffersize];\n        SimpleCharStream.bufcolumn = new int[buffersize];\n    }\n    \n    public SimpleCharStream(final Reader dstream, final int startline, final int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n    \n    public SimpleCharStream(final Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n    \n    public void ReInit(final Reader dstream, final int startline, final int startcolumn, final int buffersize) {\n        SimpleCharStream.inputStream = dstream;\n        SimpleCharStream.line = startline;\n        SimpleCharStream.column = startcolumn - 1;\n        if (SimpleCharStream.buffer == null || buffersize != SimpleCharStream.buffer.length) {\n            SimpleCharStream.bufsize = buffersize;\n            SimpleCharStream.available = buffersize;\n            SimpleCharStream.buffer = new char[buffersize];\n            SimpleCharStream.bufline = new int[buffersize];\n            SimpleCharStream.bufcolumn = new int[buffersize];\n        }\n        SimpleCharStream.prevCharIsLF = (SimpleCharStream.prevCharIsCR = false);\n        SimpleCharStream.tokenBegin = (SimpleCharStream.inBuf = (SimpleCharStream.maxNextCharInd = 0));\n        SimpleCharStream.bufpos = -1;\n    }\n    \n    public void ReInit(final Reader dstream, final int startline, final int startcolumn) {\n        this.ReInit(dstream, startline, startcolumn, 4096);\n    }\n    \n    public void ReInit(final Reader dstream) {\n        this.ReInit(dstream, 1, 1, 4096);\n    }\n    \n    public SimpleCharStream(final InputStream dstream, final int startline, final int startcolumn, final int buffersize) {\n        this(new InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n    \n    public SimpleCharStream(final InputStream dstream, final int startline, final int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n    \n    public SimpleCharStream(final InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n    \n    public void ReInit(final InputStream dstream, final int startline, final int startcolumn, final int buffersize) {\n        this.ReInit(new InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n    \n    public void ReInit(final InputStream dstream) {\n        this.ReInit(dstream, 1, 1, 4096);\n    }\n    \n    public void ReInit(final InputStream dstream, final int startline, final int startcolumn) {\n        this.ReInit(dstream, startline, startcolumn, 4096);\n    }\n    \n    public static String GetImage() {\n        if (SimpleCharStream.bufpos >= SimpleCharStream.tokenBegin) {\n            return new String(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, SimpleCharStream.bufpos - SimpleCharStream.tokenBegin + 1);\n        }\n        return new String(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin) + new String(SimpleCharStream.buffer, 0, SimpleCharStream.bufpos + 1);\n    }\n    \n    public static char[] GetSuffix(final int len) {\n        final char[] ret = new char[len];\n        if (SimpleCharStream.bufpos + 1 >= len) {\n            System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.bufpos - len + 1, ret, 0, len);\n        }\n        else {\n            System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.bufsize - (len - SimpleCharStream.bufpos - 1), ret, 0, len - SimpleCharStream.bufpos - 1);\n            System.arraycopy(SimpleCharStream.buffer, 0, ret, len - SimpleCharStream.bufpos - 1, SimpleCharStream.bufpos + 1);\n        }\n        return ret;\n    }\n    \n    public static void Done() {\n        SimpleCharStream.buffer = null;\n        SimpleCharStream.bufline = null;\n        SimpleCharStream.bufcolumn = null;\n    }\n    \n    public static void adjustBeginLineColumn(int newLine, final int newCol) {\n        int start = SimpleCharStream.tokenBegin;\n        int len;\n        if (SimpleCharStream.bufpos >= SimpleCharStream.tokenBegin) {\n            len = SimpleCharStream.bufpos - SimpleCharStream.tokenBegin + SimpleCharStream.inBuf + 1;\n        }\n        else {\n            len = SimpleCharStream.bufsize - SimpleCharStream.tokenBegin + SimpleCharStream.bufpos + 1 + SimpleCharStream.inBuf;\n        }\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        int nextColDiff = 0;\n        int columnDiff = 0;\n        while (i < len && SimpleCharStream.bufline[j = start % SimpleCharStream.bufsize] == SimpleCharStream.bufline[k = ++start % SimpleCharStream.bufsize]) {\n            SimpleCharStream.bufline[j] = newLine;\n            nextColDiff = columnDiff + SimpleCharStream.bufcolumn[k] - SimpleCharStream.bufcolumn[j];\n            SimpleCharStream.bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            ++i;\n        }\n        if (i < len) {\n            SimpleCharStream.bufline[j] = newLine++;\n            SimpleCharStream.bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (SimpleCharStream.bufline[j = start % SimpleCharStream.bufsize] != SimpleCharStream.bufline[++start % SimpleCharStream.bufsize]) {\n                    SimpleCharStream.bufline[j] = newLine++;\n                }\n                else {\n                    SimpleCharStream.bufline[j] = newLine;\n                }\n            }\n        }\n        SimpleCharStream.line = SimpleCharStream.bufline[j];\n        SimpleCharStream.column = SimpleCharStream.bufcolumn[j];\n    }\n    \n    static {\n        SimpleCharStream.bufpos = -1;\n        SimpleCharStream.column = 0;\n        SimpleCharStream.line = 1;\n        SimpleCharStream.prevCharIsCR = false;\n        SimpleCharStream.prevCharIsLF = false;\n        SimpleCharStream.maxNextCharInd = 0;\n        SimpleCharStream.inBuf = 0;\n    }\n}\n",
        "token_number_zeroshot": 3233,
        "token_number_fewshot": 3631,
        "token_number_cot": 3345
    },
    {
        "project_name": "29_apbsmem",
        "class": "PlotAxis",
        "source_code": "package jahuwaldt.plot;\n\nimport java.io.*;\nimport java.text.*;\nimport java.awt.*;\n\npublic abstract class PlotAxis implements Cloneable, Serializable\n{\n    private static final boolean DEBUG = false;\n    public static final int kTick = 5;\n    public static final int kNoGrid = 0;\n    public static final int kTickMarksOnly = 1;\n    public static final int kMajorGrid = 2;\n    protected boolean manualLB;\n    protected boolean manualUB;\n    protected boolean manualQuant;\n    protected double xA;\n    protected double xB;\n    protected double aLB;\n    protected double aUB;\n    protected double quantum;\n    protected int gridStyle;\n    protected PlotAxisScale scale;\n    protected NumberFormat nf;\n    protected String label;\n    \n    protected PlotAxis() {\n        this.xA = 1.0;\n        this.xB = 1.0;\n        this.aLB = Double.MAX_VALUE;\n        this.aUB = -1.7976931348623157E308;\n        this.gridStyle = 1;\n        this.scale = new LinearAxisScale();\n        this.nf = NumberFormat.getInstance();\n    }\n    \n    protected PlotAxis(final String label, final PlotAxisScale scale, final NumberFormat nf, final int gridStyle) {\n        this.xA = 1.0;\n        this.xB = 1.0;\n        this.aLB = Double.MAX_VALUE;\n        this.aUB = -1.7976931348623157E308;\n        this.gridStyle = 1;\n        this.scale = new LinearAxisScale();\n        this.nf = NumberFormat.getInstance();\n        this.label = label;\n        if (scale != null) {\n            this.scale = scale;\n        }\n        if (nf != null) {\n            this.nf = nf;\n        }\n        this.gridStyle = gridStyle;\n    }\n    \n    public void setLabel(final String newLabel) {\n        this.label = newLabel;\n    }\n    \n    public String getLabel() {\n        return this.label;\n    }\n    \n    public void setScale(final PlotAxisScale scale) {\n        if (scale == null) {\n            this.scale = new LinearAxisScale();\n        }\n        else {\n            this.scale = scale;\n        }\n    }\n    \n    public PlotAxisScale getScale() {\n        return this.scale;\n    }\n    \n    public void setNumberFormat(final NumberFormat format) {\n        if (format == null) {\n            this.nf = NumberFormat.getInstance();\n        }\n        else {\n            this.nf = format;\n        }\n    }\n    \n    public NumberFormat getNumberFormat() {\n        return this.nf;\n    }\n    \n    public void setGridStyle(final int style) {\n        this.gridStyle = style;\n    }\n    \n    public int getGridStyle() {\n        return this.gridStyle;\n    }\n    \n    public void manualLowerBounds(final boolean flag) {\n        this.manualLB = flag;\n    }\n    \n    public void setLowerBounds(final double value) {\n        this.aLB = value;\n    }\n    \n    public double getLowerBounds() {\n        return this.aLB;\n    }\n    \n    public String lowerBoundsAsString() {\n        return this.nf.format((float)this.aLB);\n    }\n    \n    public void manualUpperBounds(final boolean flag) {\n        this.manualUB = flag;\n    }\n    \n    public void setUpperBounds(final double value) {\n        this.aUB = value;\n    }\n    \n    public double getUpperBounds() {\n        return this.aUB;\n    }\n    \n    public String upperBoundsAsString() {\n        return this.nf.format((float)this.aUB);\n    }\n    \n    public void manualTickStepSize(final boolean flag) {\n        this.manualQuant = flag;\n    }\n    \n    public void setTickStepSize(final double value) {\n        this.quantum = value;\n    }\n    \n    public double getTickStepSize() {\n        return this.quantum;\n    }\n    \n    public abstract void setAxisBounds(final PlotRunList p0);\n    \n    public void setSize(final Rectangle plotFrame) {\n        this.setAxisTickLimits();\n        this.resizeAxis(plotFrame);\n    }\n    \n    protected void setAxisTickLimits() {\n        if (this.manualQuant) {\n            return;\n        }\n        boolean lbf = this.manualLB;\n        boolean ubf = this.manualUB;\n        double sign = 1.0;\n        double lb = this.aLB;\n        double ub = this.aUB;\n        final double delta = this.aUB - this.aLB;\n        if (delta < 0.0) {\n            sign = -1.0;\n            final double temp = lb;\n            lb = ub;\n            ub = temp;\n            final boolean btemp = lbf;\n            lbf = ubf;\n            ubf = btemp;\n        }\n        final AxisLimitData limData = this.scale.findGoodLimits(lb, ub);\n        if (!this.manualLB) {\n            if (sign > 0.0) {\n                this.aLB = limData.lb;\n            }\n            else {\n                this.aLB = limData.ub;\n            }\n        }\n        if (!this.manualUB) {\n            if (sign > 0.0) {\n                this.aUB = limData.ub;\n            }\n            else {\n                this.aUB = limData.lb;\n            }\n        }\n        this.quantum = sign * limData.quantum;\n    }\n    \n    protected abstract void resizeAxis(final Rectangle p0);\n    \n    public abstract void draw(final Graphics p0, final Component p1, final Rectangle p2);\n    \n    public int scaleCoord(final double x) {\n        return (int)(this.xA * this.scale.func(x) + this.xB);\n    }\n    \n    public Object clone() {\n        PlotAxis newObject = null;\n        try {\n            newObject = (PlotAxis)super.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        return newObject;\n    }\n}\n",
        "token_number_zeroshot": 1271,
        "token_number_fewshot": 1669,
        "token_number_cot": 1382
    },
    
    {
        "project_name": "84_ifx-framework",
        "class": "IFXObject",
        "source_code": "package org.sourceforge.ifx.basetypes;\n\nimport java.lang.reflect.*;\n\npublic class IFXObject\n{\n    private static final String TABSTOP = \"  \";\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (!(obj instanceof IFXObject)) {\n            return false;\n        }\n        final IFXObject that = (IFXObject)obj;\n        return this.doCheckEquals(this, that);\n    }\n    \n    @Override\n    public String toString() {\n        return this.stringify(this, 0);\n    }\n    \n    private String stringify(final IFXObject obj, final int level) {\n        int depth = level;\n        final StringBuffer buf = new StringBuffer();\n        try {\n            final Class objClass = obj.getClass();\n            buf.append(objClass.getName()).append(\" = {\");\n            ++depth;\n            final Method[] methods = objClass.getMethods();\n            for (int i = 0; i < methods.length; ++i) {\n                final Method method = methods[i];\n                final String methodName = method.getName();\n                if (!methodName.equals(\"getClass\") && methodName.startsWith(\"get\")) {\n                    final String memberName = methodName.substring(3);\n                    buf.append(\"\\n\").append(this.tab(depth)).append(memberName).append(\" = \");\n                    final Object retObj = method.invoke(obj, (Object[])null);\n                    if (retObj == null) {\n                        buf.append(\"NULL\");\n                    }\n                    else if (retObj.getClass().isArray()) {\n                        final int numObjs = Array.getLength(retObj);\n                        buf.append(\"[\\n\");\n                        ++depth;\n                        for (int j = 0; j < numObjs; ++j) {\n                            if (j > 0) {\n                                buf.append(\",\\n\");\n                            }\n                            buf.append(this.tab(depth)).append(\"[\").append(j).append(\"]:\");\n                            final IFXObject arrayObj = (IFXObject)Array.get(retObj, j);\n                            buf.append(this.stringify(arrayObj, depth));\n                        }\n                        --depth;\n                        buf.append(\"\\n\").append(this.tab(depth)).append(\"]\");\n                    }\n                    else if (retObj instanceof IBaseType) {\n                        buf.append(((IBaseType)retObj).getString());\n                    }\n                    else {\n                        buf.append(this.stringify((IFXObject)retObj, depth));\n                    }\n                }\n            }\n        }\n        catch (Exception e) {\n            buf.append(\"Exception! \" + e.toString());\n        }\n        --depth;\n        buf.append(\"\\n\").append(this.tab(depth)).append(\"}\");\n        return buf.toString();\n    }\n    \n    private boolean doCheckEquals(final IFXObject thisObj, final IFXObject thatObj) {\n        if (thisObj == null && thatObj == null) {\n            return true;\n        }\n        if (thisObj == null ^ thatObj == null) {\n            return false;\n        }\n        if (!thisObj.getClass().getName().equals(thatObj.getClass().getName())) {\n            return false;\n        }\n        final Method[] thisMethods = thisObj.getClass().getMethods();\n        final Method[] thatMethods = thatObj.getClass().getMethods();\n        boolean matched = true;\n        for (int i = 0; i < thisMethods.length; ++i) {\n            if (thisMethods[i].getName().startsWith(\"get\") && !thisMethods[i].getName().equals(\"getClass\")) {\n                Method thatMethod = null;\n                for (int j = 0; j < thatMethods.length; ++j) {\n                    if (thatMethods[j].getName().equals(thisMethods[i].getName())) {\n                        thatMethod = thatMethods[j];\n                        break;\n                    }\n                }\n                IFXObject thatRetVal = null;\n                IFXObject thisRetVal = null;\n                try {\n                    if (thisMethods[i].getReturnType().isArray()) {\n                        final Object thisRetValObj = thisMethods[i].invoke(thisObj, (Object[])null);\n                        final Object thatRetValObj = thatMethod.invoke(thatObj, (Object[])null);\n                        int thisNumElements = 0;\n                        int thatNumElements = 0;\n                        if (thisRetValObj != null) {\n                            thisNumElements = Array.getLength(thisRetValObj);\n                        }\n                        if (thatRetValObj != null) {\n                            thatNumElements = Array.getLength(thatRetValObj);\n                        }\n                        if (thisNumElements != thatNumElements) {\n                            matched = false;\n                        }\n                        for (int k = 0; k < thisNumElements && matched; matched = this.doCheckEquals(thisRetVal, thatRetVal), ++k) {\n                            thisRetVal = (IFXObject)Array.get(thisRetValObj, k);\n                            thatRetVal = (IFXObject)Array.get(thatRetValObj, k);\n                        }\n                    }\n                    else {\n                        thisRetVal = (IFXObject)thisMethods[i].invoke(thisObj, (Object[])null);\n                        thatRetVal = (IFXObject)thatMethod.invoke(thatObj, (Object[])null);\n                        if (thisRetVal instanceof IBaseType && thatRetVal instanceof IBaseType) {\n                            final String thisRetValAsString = ((IBaseType)thisRetVal).getString();\n                            final String thatRetValAsString = ((IBaseType)thatRetVal).getString();\n                            matched = ((thisRetValAsString == null && thatRetValAsString == null) || (!(thisRetValAsString == null ^ thatRetValAsString == null) && thisRetValAsString.equals(thatRetValAsString)));\n                        }\n                        else {\n                            matched = this.doCheckEquals(thisRetVal, thatRetVal);\n                        }\n                    }\n                }\n                catch (Exception e) {\n                    e.printStackTrace(System.out);\n                    matched = false;\n                }\n                if (!matched) {\n                    break;\n                }\n            }\n        }\n        return matched;\n    }\n    \n    private String tab(final int level) {\n        final StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < level; ++i) {\n            buf.append(\"  \");\n        }\n        return buf.toString();\n    }\n}\n",
        "token_number_zeroshot": 1242,
        "token_number_fewshot": 1640,
        "token_number_cot": 1353
    },
    {
        "project_name": "21_geo-google",
        "class": "GeoStatusCode",
        "source_code": "package geo.google.datamodel;\n\npublic enum GeoStatusCode\n{\n    G_GEO_SUCCESS(200, \"No errors occurred; the address was successfully parsed and its geocode has been returned. (Since 2.55)\"), \n    G_GEO_BAD_REQUEST(400, \"A directions request could not be successfully parsed. (Since 2.81)\"), \n    G_GEO_SERVER_ERROR(500, \"A geocoding or directions request could not be successfully processed, yet the exact reason for the failure is not known. (Since 2.55)\"), \n    G_GEO_MISSING_QUERY(601, \"The HTTP q parameter was either missing or had no value. For geocoding requests, this means that an empty address was specified as input. For directions requests, this means that no query was specified in the input. (Since 2.81)\"), \n    G_GEO_UNKNOWN_ADDRESS(602, \"No corresponding geographic location could be found for the specified address. This may be due to the fact that the address is relatively new, or it may be incorrect. (Since 2.55)\"), \n    G_GEO_UNAVAILABLE_ADDRESS(603, \"The geocode for the given address or the route for the given directions query cannot be returned due to legal or contractual reasons. (Since 2.55)\"), \n    G_GEO_UNKNOWN_DIRECTIONS(604, \"The GDirections object could not compute directions between the points mentioned in the query. This is usually because there is no route available between the two points, or because we do not have data for routing in that region. (Since 2.81)\"), \n    G_GEO_BAD_KEY(610, \"The given key is either invalid or does not match the domain for which it was given. (Since 2.55)\"), \n    G_GEO_TOO_MANY_QUERIES(620, \"The given key has gone over the requests limit in the 24 hour period. \"), \n    G_GEO_UNKOWN_STATUS(-1, \"Uknown Status\");\n    \n    private String _description;\n    private int _code;\n    \n    private GeoStatusCode(final int code, final String description) {\n        this._code = code;\n        this._description = description;\n    }\n    \n    public int getCode() {\n        return this._code;\n    }\n    \n    public String getCodeName() {\n        return this.name();\n    }\n    \n    public String getDescription() {\n        return this._description;\n    }\n    \n    public static GeoStatusCode getStatusCode(final int code) {\n        switch (code) {\n            case 200: {\n                return GeoStatusCode.G_GEO_SUCCESS;\n            }\n            case 400: {\n                return GeoStatusCode.G_GEO_BAD_REQUEST;\n            }\n            case 500: {\n                return GeoStatusCode.G_GEO_SERVER_ERROR;\n            }\n            case 601: {\n                return GeoStatusCode.G_GEO_MISSING_QUERY;\n            }\n            case 602: {\n                return GeoStatusCode.G_GEO_UNKNOWN_ADDRESS;\n            }\n            case 603: {\n                return GeoStatusCode.G_GEO_UNAVAILABLE_ADDRESS;\n            }\n            case 604: {\n                return GeoStatusCode.G_GEO_UNKNOWN_DIRECTIONS;\n            }\n            case 610: {\n                return GeoStatusCode.G_GEO_BAD_KEY;\n            }\n            case 620: {\n                return GeoStatusCode.G_GEO_TOO_MANY_QUERIES;\n            }\n            default: {\n                return GeoStatusCode.G_GEO_UNKOWN_STATUS;\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 754,
        "token_number_fewshot": 1152,
        "token_number_cot": 865
    },
    {
        "project_name": "21_geo-google",
        "class": "AddressToUsAddressFunctor",
        "source_code": "package geo.google.mapping;\n\nimport geo.google.datamodel.*;\nimport geo.google.*;\nimport org.apache.commons.collections.*;\nimport oasis.names.tc.ciq.xsdschema.xal._2.*;\nimport java.util.*;\n\npublic final class AddressToUsAddressFunctor implements Functor<GeoUsAddress, GeoAddress, GeoException>\n{\n    private static final AddressToUsAddressFunctor _instance;\n    \n    public static AddressToUsAddressFunctor getInstance() {\n        return AddressToUsAddressFunctor._instance;\n    }\n    \n    @Override\n    public GeoUsAddress execute(final GeoAddress addr) {\n        final GeoUsAddress ret = new GeoUsAddress();\n        final AddressDetails.Country country = addr.getAddressDetails().getCountry();\n        if (country != null) {\n            final List<AddressDetails.Country.CountryNameCode> countryNames = country.getCountryNameCode();\n            if (CollectionUtils.isNotEmpty((Collection)countryNames)) {\n                ret.setCountry(countryNames.get(0).getContent());\n            }\n            final AdministrativeArea adminArea = country.getAdministrativeArea();\n            if (adminArea != null) {\n                final List<AdministrativeArea.AdministrativeAreaName> names = adminArea.getAdministrativeAreaName();\n                if (CollectionUtils.isNotEmpty((Collection)names)) {\n                    ret.setState(names.get(0).getContent());\n                }\n                final AdministrativeArea.SubAdministrativeArea subAdminArea = adminArea.getSubAdministrativeArea();\n                final Locality locality = (subAdminArea == null) ? adminArea.getLocality() : subAdminArea.getLocality();\n                if (subAdminArea != null) {\n                    final List<AdministrativeArea.SubAdministrativeArea.SubAdministrativeAreaName> subNames = subAdminArea.getSubAdministrativeAreaName();\n                    if (CollectionUtils.isNotEmpty((Collection)subNames)) {\n                        ret.setCounty(subNames.get(0).getContent());\n                    }\n                }\n                if (locality != null) {\n                    final List<Locality.LocalityName> localNames = locality.getLocalityName();\n                    if (CollectionUtils.isNotEmpty((Collection)localNames)) {\n                        ret.setCity(localNames.get(0).getContent());\n                    }\n                    final PostalCode postalCode = locality.getPostalCode();\n                    final List<PostalCode.PostalCodeNumber> numbers = postalCode.getPostalCodeNumber();\n                    if (CollectionUtils.isNotEmpty((Collection)numbers)) {\n                        ret.setPostalCode(numbers.get(0).getContent());\n                    }\n                    if (locality.getThoroughfare() != null) {\n                        final List<ThoroughfareNameType> thoroughfares = locality.getThoroughfare().getThoroughfareName();\n                        if (CollectionUtils.isNotEmpty((Collection)thoroughfares)) {\n                            ret.setAddressLine1(thoroughfares.get(0).getContent());\n                            if (thoroughfares.size() > 1) {\n                                ret.setAddressLine2(thoroughfares.get(1).getContent());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (addr.getCoordinate() != null) {\n            ret.setCoordinate(addr.getCoordinate().clone());\n        }\n        ret.setAccuracy(addr.getAccuracy());\n        return ret;\n    }\n    \n    static {\n        _instance = new AddressToUsAddressFunctor();\n    }\n}\n",
        "token_number_zeroshot": 704,
        "token_number_fewshot": 1102,
        "token_number_cot": 819
    },
    {
        "project_name": "79_twfbplayer",
        "class": "SimpleSector",
        "source_code": "package de.outstare.fortbattleplayer.model.impl;\n\nimport java.util.*;\nimport de.outstare.fortbattleplayer.model.*;\n\npublic class SimpleSector implements Sector\n{\n    private final int height;\n    private final boolean defenderSpawn;\n    private final boolean attackerSpawn;\n    private final int attackBonus;\n    private final int defendBonus;\n    private final boolean flag;\n    private final int classBonus;\n    private final CharacterClass classType;\n    private CombatantSide occupier;\n    private int occupierCount;\n    private final Set<Area> areas;\n    private final Set<SectorObserver> observers;\n    \n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.occupier = null;\n        this.occupierCount = 0;\n        this.areas = new HashSet<Area>();\n        this.observers = new HashSet<SectorObserver>();\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        this.attackBonus = attackerBonus;\n        this.defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        this.classType = bonusClass;\n    }\n    \n    @Override\n    public void free() {\n        if (this.occupierCount > 0) {\n            --this.occupierCount;\n        }\n        assert this.occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (this.occupierCount == 0) {\n            this.occupier = null;\n            this.occupierChanged();\n        }\n    }\n    \n    private void occupierChanged() {\n        for (final SectorObserver observer : this.observers) {\n            observer.occupierChanged();\n        }\n    }\n    \n    @Override\n    public void gainControl(final CombatantSide side) {\n        ++this.occupierCount;\n        if (this.occupier != side) {\n            this.occupier = side;\n            this.occupierChanged();\n        }\n    }\n    \n    @Override\n    public CombatantSide getOccupier() {\n        return this.occupier;\n    }\n    \n    @Override\n    public boolean isOccupied() {\n        return this.occupier != null;\n    }\n    \n    @Override\n    public int getHeight() {\n        return this.height;\n    }\n    \n    public boolean isDefenderSpawn() {\n        return this.defenderSpawn;\n    }\n    \n    public boolean isAttackerSpawn() {\n        return this.attackerSpawn;\n    }\n    \n    public boolean isFlag() {\n        return this.flag;\n    }\n    \n    @Override\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(this.getAttackBonus(charClass), this.getDefenseBonus(charClass), this.getDamageBonus());\n    }\n    \n    protected int getDamageBonus() {\n        return this.getBonusFromWeapons(SectorBonus.BonusType.DAMAGE);\n    }\n    \n    private int getBonusFromWeapons(final SectorBonus.BonusType type) {\n        int bonus = 0;\n        for (final Area area : this.areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    bonus = sectorBonus;\n                    break;\n                }\n                continue;\n            }\n        }\n        return bonus;\n    }\n    \n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = this.attackBonus + this.classBonus(charClass);\n        bonus += this.getBonusFromWeapons(SectorBonus.BonusType.ATTACK);\n        return bonus;\n    }\n    \n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = this.defendBonus + this.classBonus(charClass);\n        bonus += this.getBonusFromWeapons(SectorBonus.BonusType.DEFENSE);\n        return bonus;\n    }\n    \n    protected int classBonus(final CharacterClass charClass) {\n        if (this.classType != charClass) {\n            return 0;\n        }\n        return this.classBonus;\n    }\n    \n    @Override\n    public Set<Area> getAreas() {\n        return this.areas;\n    }\n    \n    @Override\n    public void _addArea(final Area area) {\n        this.areas.add(area);\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + ((this.areas == null) ? 0 : this.areas.hashCode());\n        result = 31 * result + this.attackBonus;\n        result = 31 * result + (this.attackerSpawn ? 1231 : 1237);\n        result = 31 * result + this.classBonus;\n        result = 31 * result + ((this.classType == null) ? 0 : this.classType.hashCode());\n        result = 31 * result + this.defendBonus;\n        result = 31 * result + (this.defenderSpawn ? 1231 : 1237);\n        result = 31 * result + (this.flag ? 1231 : 1237);\n        result = 31 * result + this.height;\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector)obj;\n        if (this.areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        }\n        else if (!this.areas.equals(other.areas)) {\n            return false;\n        }\n        return this.attackBonus == other.attackBonus && this.attackerSpawn == other.attackerSpawn && this.classBonus == other.classBonus && this.classType == other.classType && this.defendBonus == other.defendBonus && this.defenderSpawn == other.defenderSpawn && this.flag == other.flag && this.height == other.height;\n    }\n    \n    @Override\n    public void addObserver(final SectorObserver observer) {\n        this.observers.add(observer);\n    }\n    \n    @Override\n    public void removeObserver(final SectorObserver observer) {\n        this.observers.remove(observer);\n    }\n}\n",
        "token_number_zeroshot": 1404,
        "token_number_fewshot": 1802,
        "token_number_cot": 1515
    },
    {
        "project_name": "45_lotus",
        "class": "Phase",
        "source_code": "package lotus.core.phases;\n\nimport lotus.core.*;\nimport lotus.core.effect.*;\n\npublic abstract class Phase\n{\n    public abstract void doPhase();\n    \n    private static void changePhase(final Phase p) {\n        Game.currentPhase = p;\n        final ChangePhase effect = new ChangePhase(p);\n        effect.resolve();\n    }\n    \n    public static void nextPhase() {\n        if (Game.currentPhase instanceof UntapPhase) {\n            changePhase(new UpkeepPhase());\n        }\n        else if (Game.currentPhase instanceof UpkeepPhase) {\n            changePhase(new DrawPhase());\n        }\n        else if (Game.currentPhase instanceof DrawPhase) {\n            changePhase(new Main1Phase());\n        }\n        else if (Game.currentPhase instanceof Main1Phase) {\n            changePhase(new CombatBeginningPhase());\n        }\n        else if (Game.currentPhase instanceof CombatBeginningPhase) {\n            changePhase(new DeclareAttackersPhase());\n        }\n        else if (Game.currentPhase instanceof DeclareAttackersPhase) {\n            changePhase(new DeclareBlockersPhase());\n        }\n        else if (Game.currentPhase instanceof DeclareBlockersPhase) {\n            changePhase(new CombatDamagePhase());\n        }\n        else if (Game.currentPhase instanceof CombatDamagePhase) {\n            changePhase(new CombatEndPhase());\n        }\n        else if (Game.currentPhase instanceof CombatEndPhase) {\n            changePhase(new Main2Phase());\n        }\n        else if (Game.currentPhase instanceof Main2Phase) {\n            changePhase(new EndOfTurnPhase());\n        }\n        else if (Game.currentPhase instanceof EndOfTurnPhase) {\n            changePhase(new CleanupPhase());\n        }\n        else if (Game.currentPhase instanceof CleanupPhase) {\n            changePhase(new PlayerChangePhase());\n        }\n        else if (Game.currentPhase instanceof PlayerChangePhase) {\n            Game.playingPlayer = Game.playingPlayer % 2 + 1;\n            changePhase(new UntapPhase());\n        }\n    }\n}\n",
        "token_number_zeroshot": 427,
        "token_number_fewshot": 825,
        "token_number_cot": 537
    },
    {
        "project_name": "45_lotus",
        "class": "Game",
        "source_code": "package lotus.core;\n\nimport lotus.core.stack.*;\nimport lotus.core.interfaces.*;\nimport lotus.core.phases.*;\nimport lotus.core.card.*;\nimport java.util.*;\n\npublic class Game\n{\n    public static Combat combat;\n    public static Phase currentPhase;\n    public static int playingPlayer;\n    public static Player player1;\n    public static Player player2;\n    public static Stack stack;\n    \n    public static Player getPlayingPlayer() {\n        if (Game.playingPlayer == 1) {\n            return Game.player1;\n        }\n        return Game.player2;\n    }\n    \n    public static Player getNonPlayingPlayer() {\n        return getOtherPlayer(getPlayingPlayer());\n    }\n    \n    public static Player getOtherPlayer(final Player p) {\n        if (p == Game.player1) {\n            return Game.player2;\n        }\n        return Game.player1;\n    }\n    \n    public static void init(final UserInterface IP1, final UserInterface IP2, final String n1, final String n2, final CardCollection deck1, final CardCollection deck2) {\n        Game.player1 = new Player(IP1, n1, deck1);\n        Game.player2 = new Player(IP2, n2, deck2);\n        IP1.init(Game.player1);\n        IP2.init(Game.player2);\n        Game.playingPlayer = 1;\n        Game.currentPhase = new UntapPhase();\n        for (final Card c : deck1) {\n            c.owner = Game.player1;\n            c.zone = Game.player1.library;\n        }\n        for (final Card c : deck2) {\n            c.owner = Game.player2;\n            c.zone = Game.player2.library;\n        }\n    }\n    \n    public static void givePriorityToCurrentPlayer() {\n        boolean APdone = false;\n        boolean NAPdone = false;\n        do {\n            APdone = !getPlayingPlayer().letPlayerSpeak();\n            if (NAPdone && APdone) {\n                break;\n            }\n            NAPdone = !getNonPlayingPlayer().letPlayerSpeak();\n        } while (!NAPdone || !APdone);\n        if (!Game.stack.empty()) {\n            Game.stack.resolveLast();\n            givePriorityToCurrentPlayer();\n        }\n    }\n    \n    static {\n        Game.stack = new Stack();\n    }\n}\n",
        "token_number_zeroshot": 504,
        "token_number_fewshot": 902,
        "token_number_cot": 614
    },
    {
        "project_name": "checkstyle",
        "class": "FileContents",
        "source_code": "package com.puppycrawl.tools.checkstyle.api;\n\nimport com.puppycrawl.tools.checkstyle.grammars.*;\nimport java.util.regex.*;\nimport java.io.*;\nimport com.google.common.collect.*;\nimport java.util.*;\n\npublic final class FileContents implements CommentListener\n{\n    private static final String MATCH_SINGLELINE_COMMENT_PAT = \"^\\\\s*//.*$\";\n    private static final Pattern MATCH_SINGLELINE_COMMENT;\n    private final String fileName;\n    private final FileText text;\n    private final Map<Integer, TextBlock> javadocComments;\n    private final Map<Integer, TextBlock> cppComments;\n    private final Map<Integer, List<TextBlock>> clangComments;\n    \n    public FileContents(final String filename, final String... lines) {\n        this.javadocComments = (Map<Integer, TextBlock>)Maps.newHashMap();\n        this.cppComments = (Map<Integer, TextBlock>)Maps.newHashMap();\n        this.clangComments = (Map<Integer, List<TextBlock>>)Maps.newHashMap();\n        this.fileName = filename;\n        this.text = FileText.fromLines(new File(filename), Arrays.asList(lines));\n    }\n    \n    public FileContents(final FileText text) {\n        this.javadocComments = (Map<Integer, TextBlock>)Maps.newHashMap();\n        this.cppComments = (Map<Integer, TextBlock>)Maps.newHashMap();\n        this.clangComments = (Map<Integer, List<TextBlock>>)Maps.newHashMap();\n        this.fileName = text.getFile().toString();\n        this.text = new FileText(text);\n    }\n    \n    @Override\n    public void reportSingleLineComment(final String type, final int startLineNo, final int startColNo) {\n        this.reportCppComment(startLineNo, startColNo);\n    }\n    \n    @Override\n    public void reportBlockComment(final String type, final int startLineNo, final int startColNo, final int endLineNo, final int endColNo) {\n        this.reportCComment(startLineNo, startColNo, endLineNo, endColNo);\n    }\n    \n    public void reportCppComment(final int startLineNo, final int startColNo) {\n        final String line = this.line(startLineNo - 1);\n        final String[] txt = { line.substring(startColNo) };\n        final Comment comment = new Comment(txt, startColNo, startLineNo, line.length() - 1);\n        this.cppComments.put(startLineNo, comment);\n    }\n    \n    public ImmutableMap<Integer, TextBlock> getCppComments() {\n        return ImmutableMap.copyOf((Map<? extends Integer, ? extends TextBlock>)this.cppComments);\n    }\n    \n    public void reportCComment(final int startLineNo, final int startColNo, final int endLineNo, final int endColNo) {\n        final String[] cComment = this.extractCComment(startLineNo, startColNo, endLineNo, endColNo);\n        final Comment comment = new Comment(cComment, startColNo, endLineNo, endColNo);\n        if (this.clangComments.containsKey(startLineNo)) {\n            final List<TextBlock> entries = this.clangComments.get(startLineNo);\n            entries.add(comment);\n        }\n        else {\n            final List<TextBlock> entries = (List<TextBlock>)Lists.newArrayList();\n            entries.add(comment);\n            this.clangComments.put(startLineNo, entries);\n        }\n        final String firstLine = this.line(startLineNo - 1);\n        if (firstLine.contains(\"/**\") && !firstLine.contains(\"/**/\")) {\n            this.javadocComments.put(endLineNo - 1, comment);\n        }\n    }\n    \n    public ImmutableMap<Integer, List<TextBlock>> getCComments() {\n        return ImmutableMap.copyOf((Map<? extends Integer, ? extends List<TextBlock>>)this.clangComments);\n    }\n    \n    private String[] extractCComment(final int startLineNo, final int startColNo, final int endLineNo, final int endColNo) {\n        String[] returnValue;\n        if (startLineNo == endLineNo) {\n            returnValue = new String[] { this.line(startLineNo - 1).substring(startColNo, endColNo + 1) };\n        }\n        else {\n            returnValue = new String[endLineNo - startLineNo + 1];\n            returnValue[0] = this.line(startLineNo - 1).substring(startColNo);\n            for (int i = startLineNo; i < endLineNo; ++i) {\n                returnValue[i - startLineNo + 1] = this.line(i);\n            }\n            returnValue[returnValue.length - 1] = this.line(endLineNo - 1).substring(0, endColNo + 1);\n        }\n        return returnValue;\n    }\n    \n    public TextBlock getJavadocBefore(final int lineNoBefore) {\n        int lineNo;\n        for (lineNo = lineNoBefore - 2; lineNo > 0 && (this.lineIsBlank(lineNo) || this.lineIsComment(lineNo)); --lineNo) {}\n        return this.javadocComments.get(lineNo);\n    }\n    \n    private String line(final int lineNo) {\n        return this.text.get(lineNo);\n    }\n    \n    public FileText getText() {\n        return new FileText(this.text);\n    }\n    \n    public String[] getLines() {\n        return this.text.toLinesArray();\n    }\n    \n    public String getLine(final int index) {\n        return this.text.get(index);\n    }\n    \n    public String getFileName() {\n        return this.fileName;\n    }\n    \n    @Deprecated\n    public String getFilename() {\n        return this.fileName;\n    }\n    \n    public boolean lineIsBlank(final int lineNo) {\n        return this.line(lineNo).trim().isEmpty();\n    }\n    \n    public boolean lineIsComment(final int lineNo) {\n        return FileContents.MATCH_SINGLELINE_COMMENT.matcher(this.line(lineNo)).matches();\n    }\n    \n    public boolean hasIntersectionWithComment(final int startLineNo, final int startColNo, final int endLineNo, final int endColNo) {\n        return this.hasIntersectionWithCComment(startLineNo, startColNo, endLineNo, endColNo) || this.hasIntersectionWithCppComment(startLineNo, startColNo, endLineNo, endColNo);\n    }\n    \n    public boolean inPackageInfo() {\n        return this.fileName.endsWith(\"package-info.java\");\n    }\n    \n    private boolean hasIntersectionWithCComment(final int startLineNo, final int startColNo, final int endLineNo, final int endColNo) {\n        final Collection<List<TextBlock>> values = this.clangComments.values();\n        for (final List<TextBlock> row : values) {\n            for (final TextBlock comment : row) {\n                if (comment.intersects(startLineNo, startColNo, endLineNo, endColNo)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean hasIntersectionWithCppComment(final int startLineNo, final int startColNo, final int endLineNo, final int endColNo) {\n        for (int lineNumber = startLineNo; lineNumber <= endLineNo; ++lineNumber) {\n            final TextBlock comment = this.cppComments.get(lineNumber);\n            if (comment != null && comment.intersects(startLineNo, startColNo, endLineNo, endColNo)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static {\n        MATCH_SINGLELINE_COMMENT = Pattern.compile(\"^\\\\s*//.*$\");\n    }\n}\n",
        "token_number_zeroshot": 1599,
        "token_number_fewshot": 1997,
        "token_number_cot": 1710
    },
    {
        "project_name": "checkstyle",
        "class": "AbstractLoader",
        "source_code": "package com.puppycrawl.tools.checkstyle.api;\n\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.google.common.collect.*;\nimport javax.xml.parsers.*;\nimport java.io.*;\nimport org.xml.sax.*;\n\npublic abstract class AbstractLoader extends DefaultHandler\n{\n    private final Map<String, String> publicIdToResourceNameMap;\n    private final XMLReader parser;\n    \n    protected AbstractLoader(final String publicId, final String dtdResourceName) throws SAXException, ParserConfigurationException {\n        this(new HashMap<String, String>(1));\n        this.publicIdToResourceNameMap.put(publicId, dtdResourceName);\n    }\n    \n    protected AbstractLoader(final Map<String, String> publicIdToResourceNameMap) throws SAXException, ParserConfigurationException {\n        this.publicIdToResourceNameMap = (Map<String, String>)Maps.newHashMap((Map<?, ?>)publicIdToResourceNameMap);\n        final SAXParserFactory factory = SAXParserFactory.newInstance();\n        factory.setValidating(true);\n        factory.setNamespaceAware(true);\n        (this.parser = factory.newSAXParser().getXMLReader()).setContentHandler(this);\n        this.parser.setEntityResolver(this);\n        this.parser.setErrorHandler(this);\n    }\n    \n    public void parseInputSource(final InputSource inputSource) throws IOException, SAXException {\n        this.parser.parse(inputSource);\n    }\n    \n    @Override\n    public InputSource resolveEntity(final String publicId, final String systemId) throws SAXException, IOException {\n        if (this.publicIdToResourceNameMap.keySet().contains(publicId)) {\n            final String dtdResourceName = this.publicIdToResourceNameMap.get(publicId);\n            final ClassLoader loader = this.getClass().getClassLoader();\n            final InputStream dtdIs = loader.getResourceAsStream(dtdResourceName);\n            return new InputSource(dtdIs);\n        }\n        return super.resolveEntity(publicId, systemId);\n    }\n    \n    @Override\n    public void error(final SAXParseException exception) throws SAXException {\n        throw exception;\n    }\n    \n    @Override\n    public void fatalError(final SAXParseException exception) throws SAXException {\n        throw exception;\n    }\n}\n",
        "token_number_zeroshot": 465,
        "token_number_fewshot": 863,
        "token_number_cot": 576
    },
    {
        "project_name": "checkstyle",
        "class": "AnnotationUtility",
        "source_code": "package com.puppycrawl.tools.checkstyle.utils;\n\nimport com.google.common.base.*;\nimport com.puppycrawl.tools.checkstyle.api.*;\n\npublic final class AnnotationUtility\n{\n    private static final String THE_AST_IS_NULL = \"the ast is null\";\n    \n    private AnnotationUtility() {\n        throw new UnsupportedOperationException(\"do not instantiate.\");\n    }\n    \n    public static boolean containsAnnotation(final DetailAST ast, final String annotation) {\n        if (ast == null) {\n            throw new IllegalArgumentException(\"the ast is null\");\n        }\n        return getAnnotation(ast, annotation) != null;\n    }\n    \n    public static boolean containsAnnotation(final DetailAST ast) {\n        if (ast == null) {\n            throw new IllegalArgumentException(\"the ast is null\");\n        }\n        final DetailAST holder = getAnnotationHolder(ast);\n        return holder != null && holder.branchContains(159);\n    }\n    \n    public static DetailAST getAnnotationHolder(final DetailAST ast) {\n        if (ast == null) {\n            throw new IllegalArgumentException(\"the ast is null\");\n        }\n        DetailAST annotationHolder;\n        if (ast.getType() == 155 || ast.getType() == 16) {\n            annotationHolder = ast.findFirstToken(158);\n        }\n        else {\n            annotationHolder = ast.findFirstToken(5);\n        }\n        return annotationHolder;\n    }\n    \n    public static DetailAST getAnnotation(final DetailAST ast, final String annotation) {\n        if (ast == null) {\n            throw new IllegalArgumentException(\"the ast is null\");\n        }\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"the annotation is null\");\n        }\n        if (CharMatcher.WHITESPACE.matchesAllOf(annotation)) {\n            throw new IllegalArgumentException(\"the annotation is empty or spaces\");\n        }\n        final DetailAST holder = getAnnotationHolder(ast);\n        for (DetailAST child = holder.getFirstChild(); child != null; child = child.getNextSibling()) {\n            if (child.getType() == 159) {\n                final DetailAST firstChild = child.getFirstChild();\n                final String name = FullIdent.createFullIdent(firstChild.getNextSibling()).getText();\n                if (annotation.equals(name)) {\n                    return child;\n                }\n            }\n        }\n        return null;\n    }\n}\n",
        "token_number_zeroshot": 486,
        "token_number_fewshot": 884,
        "token_number_cot": 597
    },
    {
        "project_name": "checkstyle",
        "class": "FileText",
        "source_code": "package com.puppycrawl.tools.checkstyle.api;\n\nimport java.nio.charset.*;\nimport com.google.common.io.*;\nimport java.util.regex.*;\nimport java.util.*;\nimport java.io.*;\n\npublic final class FileText extends AbstractList<String>\n{\n    private static final int READ_BUFFER_SIZE = 1024;\n    private static final Pattern LINE_TERMINATOR;\n    private final File file;\n    private final Charset charset;\n    private final String fullText;\n    private final String[] lines;\n    private int[] lineBreaks;\n    \n    public FileText(final File file, final String charsetName) throws IOException {\n        this.file = file;\n        CharsetDecoder decoder;\n        try {\n            this.charset = Charset.forName(charsetName);\n            decoder = this.charset.newDecoder();\n            decoder.onMalformedInput(CodingErrorAction.REPLACE);\n            decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        catch (UnsupportedCharsetException ex) {\n            final String message = \"Unsupported charset: \" + charsetName;\n            throw new IllegalStateException(message, ex);\n        }\n        this.fullText = readFile(file, decoder);\n        final ArrayList<String> textLines = new ArrayList<String>();\n        final BufferedReader reader = new BufferedReader(new StringReader(this.fullText));\n        while (true) {\n            final String line = reader.readLine();\n            if (line == null) {\n                break;\n            }\n            textLines.add(line);\n        }\n        this.lines = textLines.toArray(new String[textLines.size()]);\n    }\n    \n    public FileText(final FileText fileText) {\n        this.file = fileText.file;\n        this.charset = fileText.charset;\n        this.fullText = fileText.fullText;\n        this.lines = fileText.lines.clone();\n        if (fileText.lineBreaks == null) {\n            this.lineBreaks = null;\n        }\n        else {\n            this.lineBreaks = fileText.lineBreaks.clone();\n        }\n    }\n    \n    private FileText(final File file, final List<String> lines) {\n        final StringBuilder buf = new StringBuilder();\n        for (final String line : lines) {\n            buf.append(line).append('\\n');\n        }\n        buf.trimToSize();\n        this.file = file;\n        this.charset = null;\n        this.fullText = buf.toString();\n        this.lines = lines.toArray(new String[lines.size()]);\n    }\n    \n    private static String readFile(final File inputFile, final CharsetDecoder decoder) throws IOException {\n        if (!inputFile.exists()) {\n            throw new FileNotFoundException(inputFile.getPath() + \" (No such file or directory)\");\n        }\n        final StringBuilder buf = new StringBuilder();\n        final FileInputStream stream = new FileInputStream(inputFile);\n        final Reader reader = new InputStreamReader(stream, decoder);\n        try {\n            final char[] chars = new char[1024];\n            while (true) {\n                final int len = reader.read(chars);\n                if (len < 0) {\n                    break;\n                }\n                buf.append(chars, 0, len);\n            }\n        }\n        finally {\n            Closeables.closeQuietly(reader);\n        }\n        return buf.toString();\n    }\n    \n    public static FileText fromLines(final File file, final List<String> lines) {\n        if (lines instanceof FileText) {\n            return (FileText)lines;\n        }\n        return new FileText(file, lines);\n    }\n    \n    public File getFile() {\n        return this.file;\n    }\n    \n    public Charset getCharset() {\n        return this.charset;\n    }\n    \n    public CharSequence getFullText() {\n        return this.fullText;\n    }\n    \n    public String[] toLinesArray() {\n        return this.lines.clone();\n    }\n    \n    private int[] findLineBreaks() {\n        if (this.lineBreaks == null) {\n            final int[] lineBreakPositions = new int[this.size() + 1];\n            lineBreakPositions[0] = 0;\n            int lineNo = 1;\n            final Matcher matcher = FileText.LINE_TERMINATOR.matcher(this.fullText);\n            while (matcher.find()) {\n                lineBreakPositions[lineNo] = matcher.end();\n                ++lineNo;\n            }\n            if (lineNo < lineBreakPositions.length) {\n                lineBreakPositions[lineNo] = this.fullText.length();\n            }\n            this.lineBreaks = lineBreakPositions;\n        }\n        return this.lineBreaks;\n    }\n    \n    public LineColumn lineColumn(final int pos) {\n        final int[] lineBreakPositions = this.findLineBreaks();\n        int lineNo = Arrays.binarySearch(lineBreakPositions, pos);\n        if (lineNo < 0) {\n            lineNo = -lineNo - 2;\n        }\n        final int startOfLine = lineBreakPositions[lineNo];\n        final int columnNo = pos - startOfLine;\n        return new LineColumn(lineNo + 1, columnNo);\n    }\n    \n    @Override\n    public String get(final int lineNo) {\n        return this.lines[lineNo];\n    }\n    \n    @Override\n    public int size() {\n        return this.lines.length;\n    }\n    \n    static {\n        LINE_TERMINATOR = Pattern.compile(\"\\\\n|\\\\r\\\\n?\");\n    }\n}\n",
        "token_number_zeroshot": 1083,
        "token_number_fewshot": 1481,
        "token_number_cot": 1194
    },
    {
        "project_name": "checkstyle",
        "class": "AutomaticBean",
        "source_code": "package com.puppycrawl.tools.checkstyle.api;\n\nimport org.apache.commons.beanutils.converters.*;\nimport java.lang.reflect.*;\nimport org.apache.commons.beanutils.*;\nimport java.beans.*;\nimport com.google.common.collect.*;\nimport java.util.*;\n\npublic class AutomaticBean implements Configurable, Contextualizable\n{\n    private Configuration configuration;\n    \n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n        cub.register(new BooleanConverter(), Boolean.TYPE);\n        cub.register(new BooleanConverter(), Boolean.class);\n        cub.register(new ArrayConverter(boolean[].class, new BooleanConverter()), boolean[].class);\n        cub.register(new ByteConverter(), Byte.TYPE);\n        cub.register(new ByteConverter(), Byte.class);\n        cub.register(new ArrayConverter(byte[].class, new ByteConverter()), byte[].class);\n        cub.register(new CharacterConverter(), Character.TYPE);\n        cub.register(new CharacterConverter(), Character.class);\n        cub.register(new ArrayConverter(char[].class, new CharacterConverter()), char[].class);\n        cub.register(new DoubleConverter(), Double.TYPE);\n        cub.register(new DoubleConverter(), Double.class);\n        cub.register(new ArrayConverter(double[].class, new DoubleConverter()), double[].class);\n        cub.register(new FloatConverter(), Float.TYPE);\n        cub.register(new FloatConverter(), Float.class);\n        cub.register(new ArrayConverter(float[].class, new FloatConverter()), float[].class);\n        cub.register(new IntegerConverter(), Integer.TYPE);\n        cub.register(new IntegerConverter(), Integer.class);\n        cub.register(new ArrayConverter(int[].class, new IntegerConverter()), int[].class);\n        cub.register(new LongConverter(), Long.TYPE);\n        cub.register(new LongConverter(), Long.class);\n        cub.register(new ArrayConverter(long[].class, new LongConverter()), long[].class);\n        cub.register(new ShortConverter(), Short.TYPE);\n        cub.register(new ShortConverter(), Short.class);\n        cub.register(new ArrayConverter(short[].class, new ShortConverter()), short[].class);\n        cub.register(new RelaxedStringArrayConverter(), String[].class);\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n    \n    @Override\n    public final void configure(final Configuration config) throws CheckstyleException {\n        this.configuration = config;\n        final String[] attributeNames;\n        final String[] attributes = attributeNames = config.getAttributeNames();\n        for (final String key : attributeNames) {\n            final String value = config.getAttribute(key);\n            this.tryCopyProperty(config.getName(), key, value, true);\n        }\n        this.finishLocalSetup();\n        final Configuration[] children;\n        final Configuration[] childConfigs = children = config.getChildren();\n        for (final Configuration childConfig : children) {\n            this.setupChild(childConfig);\n        }\n    }\n    \n    private void tryCopyProperty(final String moduleName, final String key, final Object value, final boolean recheck) throws CheckstyleException {\n        final BeanUtilsBean beanUtils = createBeanUtilsBean();\n        try {\n            if (recheck) {\n                final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(this, key);\n                if (descriptor == null) {\n                    final String message = String.format(Locale.ROOT, \"Property '%s' in module %s does not exist, please check the documentation\", key, moduleName);\n                    throw new CheckstyleException(message);\n                }\n            }\n            beanUtils.copyProperty(this, key, value);\n        }\n        catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException ex5) {\n            final ReflectiveOperationException ex3;\n            final ReflectiveOperationException ex = ex3;\n            final String message = String.format(Locale.ROOT, \"Cannot set property '%s' to '%s' in module %s\", key, value, moduleName);\n            throw new CheckstyleException(message, ex);\n        }\n        catch (IllegalArgumentException | ConversionException ex6) {\n            final RuntimeException ex4;\n            final RuntimeException ex2 = ex4;\n            final String message = String.format(Locale.ROOT, \"illegal value '%s' for property '%s' of module %s\", value, key, moduleName);\n            throw new CheckstyleException(message, ex2);\n        }\n    }\n    \n    @Override\n    public final void contextualize(final Context context) throws CheckstyleException {\n        final Collection<String> attributes = context.getAttributeNames();\n        for (final String key : attributes) {\n            final Object value = context.get(key);\n            this.tryCopyProperty(this.getClass().getName(), key, value, false);\n        }\n    }\n    \n    protected final Configuration getConfiguration() {\n        return this.configuration;\n    }\n    \n    protected void finishLocalSetup() throws CheckstyleException {\n    }\n    \n    protected void setupChild(final Configuration childConf) throws CheckstyleException {\n        if (childConf != null) {\n            throw new CheckstyleException(childConf.getName() + \" is not allowed as a child in \" + this.getConfiguration().getName());\n        }\n    }\n    \n    private static class RelaxedStringArrayConverter implements Converter\n    {\n        @Override\n        public Object convert(final Class type, final Object value) {\n            final StringTokenizer tokenizer = new StringTokenizer(value.toString().trim(), \",\");\n            final List<String> result = (List<String>)Lists.newArrayList();\n            while (tokenizer.hasMoreTokens()) {\n                final String token = tokenizer.nextToken();\n                result.add(token.trim());\n            }\n            return result.toArray(new String[result.size()]);\n        }\n    }\n}\n",
        "token_number_zeroshot": 1119,
        "token_number_fewshot": 1517,
        "token_number_cot": 1230
    },
    {
        "project_name": "checkstyle",
        "class": "ScopeUtils",
        "source_code": "package com.puppycrawl.tools.checkstyle.utils;\n\nimport com.puppycrawl.tools.checkstyle.api.*;\nimport antlr.collections.*;\n\npublic final class ScopeUtils\n{\n    public static Scope getScopeFromMods(final DetailAST aMods) {\n        Scope returnValue = Scope.PACKAGE;\n        for (AST token = aMods.getFirstChild(); token != null && returnValue == Scope.PACKAGE; token = token.getNextSibling()) {\n            if (\"public\".equals(token.getText())) {\n                returnValue = Scope.PUBLIC;\n            }\n            else if (\"protected\".equals(token.getText())) {\n                returnValue = Scope.PROTECTED;\n            }\n            else if (\"private\".equals(token.getText())) {\n                returnValue = Scope.PRIVATE;\n            }\n        }\n        return returnValue;\n    }\n    \n    public static Scope getSurroundingScope(final DetailAST node) {\n        Scope returnValue = null;\n        for (DetailAST token = node.getParent(); token != null; token = token.getParent()) {\n            final int type = token.getType();\n            if (type == 14 || type == 15 || type == 157 || type == 154) {\n                final DetailAST mods = token.findFirstToken(5);\n                final Scope modScope = getScopeFromMods(mods);\n                if (returnValue == null || returnValue.isIn(modScope)) {\n                    returnValue = modScope;\n                }\n            }\n            else if (type == 136) {\n                returnValue = Scope.ANONINNER;\n                break;\n            }\n        }\n        return returnValue;\n    }\n    \n    public static boolean isInInterfaceBlock(final DetailAST node) {\n        boolean returnValue = false;\n        for (DetailAST token = node.getParent(); token != null && !returnValue; token = token.getParent()) {\n            final int type = token.getType();\n            if (type == 15) {\n                returnValue = true;\n            }\n            else {\n                if (type == 14 || type == 154 || type == 157) {\n                    break;\n                }\n                if (type == 136) {\n                    break;\n                }\n            }\n        }\n        return returnValue;\n    }\n    \n    public static boolean isInAnnotationBlock(final DetailAST node) {\n        boolean returnValue = false;\n        for (DetailAST token = node.getParent(); token != null && !returnValue; token = token.getParent()) {\n            final int type = token.getType();\n            if (type == 157) {\n                returnValue = true;\n            }\n            else {\n                if (type == 14 || type == 154 || type == 15) {\n                    break;\n                }\n                if (type == 136) {\n                    break;\n                }\n            }\n        }\n        return returnValue;\n    }\n    \n    public static boolean isInInterfaceOrAnnotationBlock(final DetailAST node) {\n        return isInInterfaceBlock(node) || isInAnnotationBlock(node);\n    }\n    \n    public static boolean isInEnumBlock(final DetailAST node) {\n        boolean returnValue = false;\n        for (DetailAST token = node.getParent(); token != null && !returnValue; token = token.getParent()) {\n            final int type = token.getType();\n            if (type == 154) {\n                returnValue = true;\n            }\n            else {\n                if (type == 15 || type == 157 || type == 14) {\n                    break;\n                }\n                if (type == 136) {\n                    break;\n                }\n            }\n        }\n        return returnValue;\n    }\n    \n    public static boolean isInCodeBlock(final DetailAST node) {\n        boolean returnValue = false;\n        for (DetailAST token = node.getParent(); token != null; token = token.getParent()) {\n            final int type = token.getType();\n            if (type == 9 || type == 8 || type == 11 || type == 12) {\n                returnValue = true;\n                break;\n            }\n        }\n        return returnValue;\n    }\n    \n    public static boolean isOuterMostType(final DetailAST node) {\n        boolean returnValue = true;\n        for (DetailAST parent = node.getParent(); parent != null; parent = parent.getParent()) {\n            if (parent.getType() == 14 || parent.getType() == 15 || parent.getType() == 157 || parent.getType() == 154) {\n                returnValue = false;\n                break;\n            }\n        }\n        return returnValue;\n    }\n    \n    public static boolean isLocalVariableDef(final DetailAST node) {\n        boolean localVariableDef = false;\n        if (node.getType() == 10) {\n            final DetailAST parent = node.getParent();\n            final int type = parent.getType();\n            localVariableDef = (type == 7 || type == 35 || type == 156);\n        }\n        if (node.getType() == 21) {\n            final DetailAST parent = node.getParent();\n            localVariableDef = (parent.getType() == 96);\n        }\n        return localVariableDef;\n    }\n    \n    public static boolean isClassFieldDef(final DetailAST node) {\n        return node.getType() == 10 && !isLocalVariableDef(node);\n    }\n    \n    public static boolean isInScope(final DetailAST ast, final Scope scope) {\n        final Scope surroundingScopeOfAstToken = getSurroundingScope(ast);\n        return surroundingScopeOfAstToken == scope;\n    }\n}\n",
        "token_number_zeroshot": 1100,
        "token_number_fewshot": 1498,
        "token_number_cot": 1211
    },
    {
        "project_name": "100_jgaap",
        "class": "jgaapGUI",
        "source_code": "import java.awt.*;\nimport javax.swing.*;\nimport java.awt.event.*;\nimport java.io.*;\n\npublic class jgaapGUI extends JPanel implements ActionListener\n{\n    guiDriver driver;\n    private JTextField currentAuthor;\n    private ButtonGroup buttonGroup1;\n    private ButtonGroup buttonGroup2;\n    private JFileChooser chooseFile;\n    private JButton buttonEvSet;\n    private JPanel paneEvProgress;\n    private JLabel labelev;\n    private JProgressBar progressEventSet;\n    private JMenuBar menuBar;\n    private JMenu menuFile;\n    private JMenuItem menuFileExit;\n    private JMenuItem menuFileDemo;\n    private JMenu menuHelp;\n    private JMenuItem menuHelpContents;\n    private JMenuItem menuHelpAbout;\n    private JTabbedPane paneOpts;\n    private JPanel panelAcquire;\n    private JPanel panelDocs;\n    private JLabel labelKnown;\n    private JScrollPane scrollPane1;\n    private JTextArea listKnown;\n    private JLabel labelUnknown;\n    private JScrollPane scrollPane2;\n    private JTextArea listUnknown;\n    private JPanel panelOpts;\n    private JRadioButton radioKnown;\n    private JRadioButton radioUnknown;\n    private JButton buttonLocal;\n    private JPanel panelCanonicize;\n    private JPanel panelCOpts;\n    private JCheckBox[] canonicizers;\n    private JRadioButton[] eventifiers;\n    private ButtonGroup esButtonGroup;\n    private JPanel panelProgress;\n    private JButton buttonCanonicize;\n    private JLabel label1;\n    private JProgressBar progressCanonicize;\n    private JLabel labelCanon;\n    private JPanel panelAnalyze;\n    private JLabel labelStatInf;\n    private JPanel panelMethods;\n    private JRadioButton radioCrossEnt;\n    private JRadioButton radioLZW;\n    private JPanel panelAnalProg;\n    private JButton buttonAnalyze;\n    private JLabel labelAnalProg;\n    private JProgressBar progressAnalysis;\n    private JScrollPane scrollPane3;\n    private JTextArea listResults;\n    private JPanel panelEventSet;\n    private JPanel panelEOpts;\n    private JPanel panelEvProgress;\n    private JButton buttonEventSet;\n    private JLabel labelevSet;\n    \n    public jgaapGUI() {\n        this.driver = new guiDriver();\n        this.initComponents();\n    }\n    \n    private void initComponents() {\n        this.currentAuthor = new JTextField();\n        this.chooseFile = new JFileChooser();\n        this.menuBar = new JMenuBar();\n        this.menuFile = new JMenu();\n        this.menuFileExit = new JMenuItem();\n        this.menuFileDemo = new JMenuItem();\n        this.menuHelp = new JMenu();\n        this.menuHelpContents = new JMenuItem();\n        this.menuHelpAbout = new JMenuItem();\n        this.paneOpts = new JTabbedPane();\n        this.panelAcquire = new JPanel();\n        this.panelDocs = new JPanel();\n        this.labelKnown = new JLabel();\n        this.scrollPane1 = new JScrollPane();\n        this.listKnown = new JTextArea(10, 30);\n        this.labelUnknown = new JLabel();\n        this.scrollPane2 = new JScrollPane();\n        this.listUnknown = new JTextArea(10, 30);\n        this.panelOpts = new JPanel();\n        this.radioKnown = new JRadioButton();\n        this.radioUnknown = new JRadioButton();\n        this.buttonLocal = new JButton();\n        this.panelCanonicize = new JPanel();\n        this.panelCOpts = new JPanel();\n        this.canonicizers = new JCheckBox[3];\n        this.eventifiers = new JRadioButton[2];\n        this.esButtonGroup = new ButtonGroup();\n        this.panelProgress = new JPanel();\n        this.buttonCanonicize = new JButton();\n        this.label1 = new JLabel();\n        this.progressCanonicize = new JProgressBar();\n        this.labelCanon = new JLabel();\n        this.panelAnalyze = new JPanel();\n        this.labelStatInf = new JLabel();\n        this.panelMethods = new JPanel();\n        this.radioCrossEnt = new JRadioButton();\n        this.radioLZW = new JRadioButton();\n        this.panelAnalProg = new JPanel();\n        this.buttonAnalyze = new JButton();\n        this.labelAnalProg = new JLabel();\n        this.progressAnalysis = new JProgressBar();\n        this.scrollPane3 = new JScrollPane();\n        this.listResults = new JTextArea(20, 30);\n        this.buttonEventSet = new JButton();\n        this.paneEvProgress = new JPanel();\n        this.labelevSet = new JLabel();\n        this.progressEventSet = new JProgressBar();\n        this.panelEventSet = new JPanel();\n        this.panelEOpts = new JPanel();\n        this.panelEvProgress = new JPanel();\n        this.setMinimumSize(new Dimension(400, 600));\n        this.setPreferredSize(new Dimension(600, 400));\n        this.setLayout(new BorderLayout());\n        this.menuFile.setText(\"File\");\n        this.menuFileExit.setText(\"Exit\");\n        this.menuFile.add(this.menuFileExit);\n        this.menuFileExit.addActionListener(this);\n        this.menuFileDemo.setText(\"Load Demo\");\n        this.menuFileDemo.setActionCommand(\"demo\");\n        this.menuFileDemo.addActionListener(this);\n        this.menuFile.add(this.menuFileDemo);\n        this.menuBar.add(this.menuFile);\n        this.menuHelp.setText(\"Help\");\n        this.menuHelpContents.setText(\"Contents (F1)\");\n        this.menuHelp.add(this.menuHelpContents);\n        this.menuHelpAbout.setText(\"About\");\n        this.menuHelp.add(this.menuHelpAbout);\n        this.menuBar.add(this.menuHelp);\n        this.add(this.menuBar, \"North\");\n        this.paneOpts.setFont(new Font(\"Garamond\", 0, 14));\n        this.panelAcquire.setLayout(new FlowLayout());\n        this.panelDocs.setLayout(new BoxLayout(this.panelDocs, 1));\n        this.labelKnown.setText(\"Registered Known Documents\");\n        this.labelKnown.setHorizontalAlignment(0);\n        this.labelKnown.setHorizontalTextPosition(0);\n        this.panelDocs.add(this.labelKnown);\n        this.listKnown.setEnabled(false);\n        this.scrollPane1.setViewportView(this.listKnown);\n        this.panelDocs.add(this.scrollPane1);\n        this.labelUnknown.setText(\"Registered Unknown Documents\");\n        this.labelUnknown.setHorizontalAlignment(0);\n        this.labelUnknown.setHorizontalTextPosition(0);\n        this.panelDocs.add(this.labelUnknown);\n        this.listUnknown.setEnabled(false);\n        this.scrollPane2.setViewportView(this.listUnknown);\n        this.panelDocs.add(this.scrollPane2);\n        this.panelAcquire.add(this.panelDocs);\n        this.panelOpts.setLayout(new BoxLayout(this.panelOpts, 1));\n        this.radioUnknown.setText(\"Unknown Author\");\n        this.radioUnknown.setActionCommand(\"unknownauthor\");\n        this.radioUnknown.addActionListener(this);\n        this.panelOpts.add(this.radioUnknown);\n        this.radioKnown.setText(\"Known Author\");\n        this.radioKnown.setActionCommand(\"knownauthor\");\n        this.radioKnown.addActionListener(this);\n        this.radioKnown.setSelected(true);\n        this.panelOpts.add(this.radioKnown);\n        this.panelOpts.add(new JLabel(\"Author:\"));\n        this.panelOpts.add(this.currentAuthor);\n        this.buttonLocal.setText(\"Local Document\");\n        this.panelOpts.add(this.buttonLocal);\n        this.buttonLocal.setActionCommand(\"Import\");\n        this.buttonLocal.addActionListener(this);\n        this.panelAcquire.add(this.panelOpts);\n        this.paneOpts.addTab(\"Acquire\", this.panelAcquire);\n        this.panelCanonicize.setLayout(new BorderLayout());\n        this.panelCOpts.setLayout(new GridLayout(12, 5));\n        (this.canonicizers[0] = new JCheckBox()).setText(\"Smash Case\");\n        this.canonicizers[0].setToolTipText(\"Converts all text to lower case\");\n        this.panelCOpts.add(this.canonicizers[0]);\n        (this.canonicizers[1] = new JCheckBox()).setText(\"Normalize Whitespace\");\n        this.canonicizers[1].setToolTipText(\"Converts all whitespace characters (newline, space and tab) to a single space\");\n        this.panelCOpts.add(this.canonicizers[1]);\n        (this.canonicizers[2] = new JCheckBox()).setText(\"Strip HTML\");\n        this.canonicizers[2].setToolTipText(\"Removes all HTML tags and converts hexidecimal representations to actual character representations\");\n        this.panelCOpts.add(this.canonicizers[2]);\n        this.panelCanonicize.add(this.panelCOpts, \"Center\");\n        this.panelProgress.setLayout(new BoxLayout(this.panelProgress, 0));\n        this.buttonCanonicize.setText(\"Canonicize\");\n        this.buttonCanonicize.addActionListener(this);\n        this.panelProgress.add(this.buttonCanonicize);\n        this.label1.setText(\"  Progress:  \");\n        this.label1.setHorizontalAlignment(0);\n        this.label1.setHorizontalTextPosition(0);\n        this.panelProgress.add(this.label1);\n        this.panelProgress.add(this.progressCanonicize);\n        this.panelCanonicize.add(this.panelProgress, \"South\");\n        this.labelCanon.setText(\"Document Canonicization\");\n        this.labelCanon.setHorizontalAlignment(0);\n        this.panelCanonicize.add(this.labelCanon, \"North\");\n        this.paneOpts.addTab(\"Canonicize\", this.panelCanonicize);\n        this.panelEventSet.setLayout(new BorderLayout());\n        this.panelEOpts.setLayout(new GridLayout(12, 5));\n        (this.eventifiers[0] = new JRadioButton()).setText(\"Individual Characters\");\n        this.eventifiers[0].setActionCommand(\"characters\");\n        this.esButtonGroup.add(this.eventifiers[0]);\n        this.panelEOpts.add(this.eventifiers[0]);\n        (this.eventifiers[1] = new JRadioButton()).setText(\"Entire Words\");\n        this.eventifiers[1].setActionCommand(\"words\");\n        this.esButtonGroup.add(this.eventifiers[1]);\n        this.panelEOpts.add(this.eventifiers[1]);\n        this.panelEventSet.add(this.panelEOpts, \"Center\");\n        this.panelEvProgress.setLayout(new BoxLayout(this.panelEvProgress, 0));\n        this.buttonEventSet.setText(\"Create Event Set\");\n        this.buttonEventSet.setActionCommand(\"CreateEventSet\");\n        this.buttonEventSet.addActionListener(this);\n        this.panelEvProgress.add(this.buttonEventSet);\n        this.labelevSet.setText(\"  Progress:  \");\n        this.labelevSet.setHorizontalAlignment(0);\n        this.labelevSet.setHorizontalTextPosition(0);\n        this.panelEvProgress.add(this.labelevSet);\n        this.panelEvProgress.add(this.progressEventSet);\n        this.panelEventSet.add(this.panelEvProgress, \"South\");\n        this.paneOpts.addTab(\"Event Set\", this.panelEventSet);\n        this.panelAnalyze.setLayout(new BorderLayout());\n        this.labelStatInf.setText(\"Statistical Inference\");\n        this.labelStatInf.setHorizontalAlignment(0);\n        this.panelAnalyze.add(this.labelStatInf, \"North\");\n        this.panelMethods.setLayout(new BoxLayout(this.panelMethods, 1));\n        this.radioCrossEnt.setText(\"Cross Entropy\");\n        this.radioCrossEnt.setActionCommand(\"crossentropy\");\n        this.panelMethods.add(this.radioCrossEnt);\n        this.radioLZW.setText(\"LZW\");\n        this.radioLZW.setActionCommand(\"lzw\");\n        this.panelMethods.add(this.radioLZW);\n        this.panelAnalyze.add(this.panelMethods, \"West\");\n        this.panelAnalProg.setLayout(new BoxLayout(this.panelAnalProg, 0));\n        this.buttonAnalyze.setText(\"Analyze\");\n        this.buttonAnalyze.addActionListener(this);\n        this.panelAnalProg.add(this.buttonAnalyze);\n        this.labelAnalProg.setText(\"  Progress:  \");\n        this.labelAnalProg.setHorizontalAlignment(0);\n        this.labelAnalProg.setHorizontalTextPosition(0);\n        this.panelAnalProg.add(this.labelAnalProg);\n        this.panelAnalProg.add(this.progressAnalysis);\n        this.panelAnalyze.add(this.panelAnalProg, \"South\");\n        this.listResults.setEnabled(false);\n        this.scrollPane3.setViewportView(this.listResults);\n        this.panelAnalyze.add(this.scrollPane3, \"Center\");\n        this.paneOpts.addTab(\"Analyze\", this.panelAnalyze);\n        this.add(this.paneOpts, \"Center\");\n        (this.buttonGroup1 = new ButtonGroup()).add(this.radioKnown);\n        this.buttonGroup1.add(this.radioUnknown);\n        (this.buttonGroup2 = new ButtonGroup()).add(this.radioCrossEnt);\n        this.buttonGroup2.add(this.radioLZW);\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        final String command = e.getActionCommand();\n        if (command.equals(\"Exit\")) {\n            System.exit(-1);\n        }\n        else if (command.equals(\"knownauthor\")) {\n            this.currentAuthor.setText(\"\");\n            this.currentAuthor.setEnabled(true);\n        }\n        else if (command.equals(\"unknownauthor\")) {\n            this.currentAuthor.setText(\"\");\n            this.currentAuthor.setEnabled(false);\n        }\n        else if (command.equals(\"Import\")) {\n            final String fcomp = new String();\n            System.out.println(this.buttonGroup1.getSelection().getActionCommand());\n            final int returnVal = this.chooseFile.showOpenDialog(this);\n            if (returnVal == 0) {\n                final File file = this.chooseFile.getSelectedFile();\n                this.driver.addDocument(file.toString(), this.currentAuthor.getText());\n                if (!this.currentAuthor.getText().equals(\"\")) {\n                    this.listKnown.append(this.currentAuthor.getText() + \" - \" + file.getName() + \"\\n\");\n                }\n                else {\n                    this.listUnknown.append(file.getName() + \"\\n\");\n                }\n                System.out.println(file);\n            }\n        }\n        else if (command.equals(\"Canonicize\")) {\n            final guiDriver.preprocessEngineDriver pe = this.driver.preprocessEngineDriver(this.canonicizers, this.paneOpts, this.progressCanonicize);\n            pe.start();\n        }\n        else if (command.equals(\"CreateEventSet\")) {\n            final guiDriver.createEventSetDriver esd = this.driver.createEventSetDriver(this.esButtonGroup.getSelection().getActionCommand(), this.paneOpts, this.progressEventSet);\n            esd.start();\n        }\n        else if (command.equals(\"Analyze\")) {\n            final guiDriver.runStatisticalAnalysisDriver rsad = this.driver.runStatisticalAnalysisDriver(this.buttonGroup2.getSelection().getActionCommand(), this.paneOpts, this.progressAnalysis);\n            rsad.start();\n            this.listResults.append(rsad.getResults());\n        }\n        else if (command.equals(\"demo\")) {\n            this.loadDemo();\n        }\n        else {\n            System.out.println(command);\n        }\n    }\n    \n    public void loadDemo() {\n        System.out.println(\"Need to Demo\");\n    }\n}\n",
        "token_number_zeroshot": 2973,
        "token_number_fewshot": 3371,
        "token_number_cot": 3086
    },
    {
        "project_name": "2_a4j",
        "class": "Product",
        "source_code": "package net.kencochrane.a4j.DAO;\n\nimport net.kencochrane.a4j.file.*;\nimport java.util.*;\nimport com.wutka.jox.*;\nimport net.kencochrane.a4j.beans.*;\nimport java.io.*;\n\npublic class Product\n{\n    public FullProduct getProduct(final String asin, final String offer, final String page) {\n        final FileUtil fileUtil = new FileUtil();\n        JOXBeanInputStream joxIn = null;\n        final FullProduct fullProduct = new FullProduct();\n        ProductDetails productDetails = new ProductDetails();\n        ProductDetails accessoryProductDetails = new ProductDetails();\n        Accessories accessories = new Accessories();\n        ArrayList accessoryArray = new ArrayList();\n        ArrayList detailsArray = new ArrayList();\n        MiniProduct miniProduct = new MiniProduct();\n        final Search search = new Search();\n        try {\n            FileInputStream fileIn = fileUtil.fetchASINFile(asin, \"heavy\", offer, page);\n            if (fileIn == null) {\n                return null;\n            }\n            joxIn = new JOXBeanInputStream((InputStream)fileIn);\n            ProductInfo productInfoBean = (ProductInfo)joxIn.readObject((Class)ProductInfo.class);\n            joxIn.close();\n            fileIn.close();\n            if (productInfoBean != null && productInfoBean.getDetails().length > 0) {\n                productDetails = productInfoBean.getDetails()[0];\n                fullProduct.setDetails(productDetails);\n                accessories = productDetails.getAccessories();\n                accessoryArray = accessories.getAccessoryArray();\n                if (accessoryArray != null && accessoryArray.size() > 0) {\n                    fileIn = fileUtil.fetchAccessories(asin, accessoryArray);\n                    if (fileIn != null) {\n                        joxIn = new JOXBeanInputStream((InputStream)fileIn);\n                        productInfoBean = (ProductInfo)joxIn.readObject((Class)ProductInfo.class);\n                        joxIn.close();\n                        fileIn.close();\n                        if (productInfoBean != null && productInfoBean.getProductsArrayList().size() > 0) {\n                            detailsArray = productInfoBean.getProductsArrayList();\n                            for (int x = 0; x < detailsArray.size(); ++x) {\n                                accessoryProductDetails = detailsArray.get(x);\n                                if (accessoryProductDetails != null) {\n                                    miniProduct = new MiniProduct();\n                                    miniProduct.setAsin(accessoryProductDetails.getAsin());\n                                    miniProduct.setImageURL(accessoryProductDetails.getImageUrlSmall());\n                                    miniProduct.setManufacturer(accessoryProductDetails.getManufacturer());\n                                    miniProduct.setName(accessoryProductDetails.getProductName());\n                                    miniProduct.setPrice(accessoryProductDetails.getOurPrice());\n                                    fullProduct.addAccessory(miniProduct);\n                                }\n                            }\n                        }\n                    }\n                }\n                productInfoBean = search.SimilaritesSearch(asin, \"1\");\n                if (productInfoBean != null && productInfoBean.getProductsArrayList() != null && productInfoBean.getProductsArrayList().size() > 0) {\n                    detailsArray = productInfoBean.getProductsArrayList();\n                    for (int x = 0; x < detailsArray.size(); ++x) {\n                        accessoryProductDetails = detailsArray.get(x);\n                        if (accessoryProductDetails != null) {\n                            miniProduct = new MiniProduct();\n                            miniProduct.setAsin(accessoryProductDetails.getAsin());\n                            miniProduct.setImageURL(accessoryProductDetails.getImageUrlSmall());\n                            miniProduct.setManufacturer(accessoryProductDetails.getManufacturer());\n                            miniProduct.setName(accessoryProductDetails.getProductName());\n                            miniProduct.setPrice(accessoryProductDetails.getOurPrice());\n                            fullProduct.addSimilarItem(miniProduct);\n                        }\n                    }\n                }\n            }\n        }\n        catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        return fullProduct;\n    }\n}\n",
        "token_number_zeroshot": 814,
        "token_number_fewshot": 1212,
        "token_number_cot": 924
    },
    {
        "project_name": "90_dcparseargs",
        "class": "ArgsParser",
        "source_code": "package de.devcity.parseargs;\n\nimport de.devcity.parseargs.arguments.*;\nimport java.util.*;\n\npublic class ArgsParser\n{\n    public static final String SHORT_ARGUMENT_INDICATOR = \"-\";\n    public static final String LONG_ARGUMENT_INDICATOR = \"--\";\n    private String[] args;\n    private String[] innerArgs;\n    \n    public ArgsParser() {\n    }\n    \n    public ArgsParser(final String[] args) {\n        this.setArgs(args);\n    }\n    \n    public int getArgsCount() {\n        return this.args.length;\n    }\n    \n    public String[] getArgs() {\n        return this.args;\n    }\n    \n    public void setArgs(final String[] args) {\n        if (args == null) {\n            throw new NullPointerException(\"args[] cannot be null.\");\n        }\n        this.args = new String[args.length];\n        this.innerArgs = new String[args.length];\n        for (int i = 0; i < args.length; ++i) {\n            this.args[i] = args[i];\n            this.innerArgs[i] = args[i];\n        }\n    }\n    \n    public int getArgsLeftCount() {\n        int result = 0;\n        for (int i = 0; i < this.innerArgs.length; ++i) {\n            if (this.innerArgs[i] != null) {\n                ++result;\n            }\n        }\n        return result;\n    }\n    \n    public SwitchArgument parseSwitchArgument(final String key) {\n        final boolean isLongKey = key.length() > 1;\n        if (isLongKey) {\n            final String searchFor = \"--\" + key;\n            for (int i = 0; i < this.args.length; ++i) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].equals(searchFor)) {\n                    this.innerArgs[i] = null;\n                    return new SwitchArgument(i, key, true);\n                }\n            }\n        }\n        else {\n            for (int i = 0; i < this.args.length; ++i) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].length() > 1 && this.innerArgs[i].startsWith(\"-\") && !this.innerArgs[i].startsWith(\"--\")) {\n                    final int index = this.innerArgs[i].lastIndexOf(key);\n                    if (index > 0) {\n                        final String before = this.innerArgs[i].substring(0, index);\n                        final String after = this.innerArgs[i].substring(index + 1, this.innerArgs[i].length());\n                        this.innerArgs[i] = before + after;\n                        if (this.innerArgs[i].replace(\"-\", \" \").trim().length() == 0) {\n                            this.innerArgs[i] = null;\n                        }\n                        return new SwitchArgument(i, key, true);\n                    }\n                }\n            }\n        }\n        return new SwitchArgument(-1, key, false);\n    }\n    \n    public ParameterArgument parseParameterArgument(final String key) {\n        final boolean isLongKey = key.length() > 1;\n        if (isLongKey) {\n            final String searchFor = \"--\" + key;\n            int i = 0;\n            while (i < this.innerArgs.length) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].equals(searchFor)) {\n                    if (this.innerArgs.length > i + 1 && this.innerArgs[i] != null && this.innerArgs[i + 1] != null) {\n                        final String value = this.innerArgs[i + 1];\n                        this.innerArgs[i] = null;\n                        this.innerArgs[i + 1] = null;\n                        return new ParameterArgument(i, key, value);\n                    }\n                    return null;\n                }\n                else {\n                    ++i;\n                }\n            }\n        }\n        else {\n            for (int i = 0; i < this.args.length; ++i) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].length() > 1 && this.innerArgs[i].startsWith(\"-\") && !this.innerArgs[i].startsWith(\"--\")) {\n                    final int index = this.innerArgs[i].indexOf(key);\n                    if (index > 0) {\n                        if (index + 1 != this.innerArgs[i].length()) {\n                            final String before = this.innerArgs[i].substring(0, index);\n                            final String value2 = this.innerArgs[i].substring(index + 1, this.innerArgs[i].length());\n                            this.innerArgs[i] = before;\n                            if (this.innerArgs[i].replace(\"-\", \" \").trim().length() == 0) {\n                                this.innerArgs[i] = null;\n                            }\n                            return new ParameterArgument(i, key, value2);\n                        }\n                        if (this.innerArgs.length > i + 1 && this.innerArgs[i] != null && this.innerArgs[i + 1] != null) {\n                            final String before = this.innerArgs[i].substring(0, index);\n                            final String after = this.innerArgs[i].substring(index + 1, this.innerArgs[i].length());\n                            this.innerArgs[i] = before + after;\n                            if (this.innerArgs[i].replace(\"-\", \" \").trim().length() == 0) {\n                                this.innerArgs[i] = null;\n                            }\n                            final String value3 = this.innerArgs[i + 1];\n                            this.innerArgs[i + 1] = null;\n                            return new ParameterArgument(i, key, value3);\n                        }\n                        return null;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    \n    public List<StringArgument> parseStringArgument() {\n        final List<StringArgument> result = new ArrayList<StringArgument>();\n        for (int i = 0; i < this.args.length; ++i) {\n            if (this.innerArgs[i] != null) {\n                result.add(new StringArgument(i, this.innerArgs[i]));\n                this.innerArgs[i] = null;\n            }\n        }\n        return result;\n    }\n}\n",
        "token_number_zeroshot": 1269,
        "token_number_fewshot": 1667,
        "token_number_cot": 1380
    },
    {
        "project_name": "74_fixsuite",
        "class": "Library",
        "source_code": "package org.fixsuite.message;\n\nimport org.fixsuite.message.info.*;\nimport java.io.*;\nimport java.text.*;\nimport org.fixsuite.message.parsers.fpl.*;\nimport java.util.*;\nimport org.slf4j.*;\n\npublic class Library\n{\n    private static final String FIELDS_FILE_NAME = \"Fields.xml\";\n    private static final String ENUMS_FILE_NAME = \"Enums.xml\";\n    private static final String COMPONENTS_FILE_NAME = \"Components.xml\";\n    private static final String MSG_TYPE_FILE_NAME = \"MsgType.xml\";\n    private static final String MSG_CONTENTS_FILE_NAME = \"MsgContents.xml\";\n    private static final int FIELDS_FILE_KEY = 1;\n    private static final int ENUMS_FILE_KEY = 2;\n    private static final int COMPONENTS_FILE_KEY = 3;\n    private static final int MSG_TYPE_FILE_KEY = 4;\n    private static final int MSG_CONTENTS_FILE_KEY = 5;\n    private static Logger logger;\n    private Map<String, DictionaryInfo> dictionaries;\n    \n    public Library() {\n        this.dictionaries = new TreeMap<String, DictionaryInfo>();\n    }\n    \n    public boolean loadFromDirectory(final String libraryPath) {\n        boolean result = true;\n        final long startTime = System.currentTimeMillis();\n        if (!this.dictionaries.isEmpty()) {\n            Library.logger.debug(\"Unloading previous dictionaries\");\n            this.dictionaries.clear();\n        }\n        System.gc();\n        final long startMemory = Runtime.getRuntime().freeMemory();\n        final File path = new File(libraryPath);\n        if (path.isDirectory()) {\n            final File[] files = path.listFiles();\n            if (files.length != 0) {\n                for (int i = 0; i < files.length; ++i) {\n                    if (files[i].isDirectory()) {\n                        this.loadDirectory(this.arrangeFiles(files[i].listFiles()), files[i].getName());\n                    }\n                }\n                if (!this.dictionaries.isEmpty()) {\n                    Library.logger.debug(\"Loaded \" + this.dictionaries.size() + \" FIX dictionaries.\");\n                }\n                else {\n                    Library.logger.error(\"Unable to load any dictionaries\");\n                }\n            }\n            else {\n                Library.logger.error(\"Supplied directory is empty.\");\n                result = false;\n            }\n        }\n        else {\n            Library.logger.error(\"Supplied path is not a directory.\");\n            result = false;\n        }\n        System.gc();\n        Library.logger.debug(\"Approximate memory allocation: \" + new DecimalFormat().format((Runtime.getRuntime().freeMemory() - startMemory) / 1000000.0) + \" MB.\");\n        Library.logger.info(\"Loading time: \" + (System.currentTimeMillis() - startTime) + \" milliseconds.\");\n        return result;\n    }\n    \n    public List<DictionaryInfo> getDictionaries() {\n        return new ArrayList<DictionaryInfo>(this.dictionaries.values());\n    }\n    \n    public DictionaryInfo getDictionary(final String version) {\n        return this.dictionaries.get(version);\n    }\n    \n    private void loadDirectory(final List<File> files, final String version) {\n        final DictionaryInfo dictionary = new DictionaryInfo(version);\n        for (final File file : files) {\n            MainParser.parse(dictionary, file);\n        }\n        if (dictionary.isLoaded()) {\n            this.dictionaries.put(dictionary.getVersion(), dictionary);\n        }\n        else {\n            Library.logger.debug(\"Unable to load dictionary from \" + version + \".\");\n        }\n    }\n    \n    private List<File> arrangeFiles(final File[] files) {\n        final Map<Integer, File> arrangedFiles = new TreeMap<Integer, File>();\n        for (int i = 0; i < files.length; ++i) {\n            if (files[i].getName().equals(\"Fields.xml\")) {\n                arrangedFiles.put(1, files[i]);\n            }\n            else if (files[i].getName().equals(\"Enums.xml\")) {\n                arrangedFiles.put(2, files[i]);\n            }\n            else if (files[i].getName().equals(\"Components.xml\")) {\n                arrangedFiles.put(3, files[i]);\n            }\n            else if (files[i].getName().equals(\"MsgType.xml\")) {\n                arrangedFiles.put(4, files[i]);\n            }\n            else if (files[i].getName().equals(\"MsgContents.xml\")) {\n                arrangedFiles.put(5, files[i]);\n            }\n        }\n        return new ArrayList<File>(arrangedFiles.values());\n    }\n    \n    static {\n        Library.logger = LoggerFactory.getLogger((Class)Library.class);\n    }\n}\n",
        "token_number_zeroshot": 929,
        "token_number_fewshot": 1327,
        "token_number_cot": 1039
    },
    {
        "project_name": "74_fixsuite",
        "class": "TreeView",
        "source_code": "package org.fixsuite.message.view;\n\nimport javax.swing.*;\nimport java.util.*;\nimport org.fixsuite.message.info.*;\nimport javax.swing.event.*;\nimport org.fixsuite.message.*;\nimport java.awt.event.*;\nimport javax.swing.tree.*;\nimport java.awt.*;\n\npublic class TreeView extends JPanel implements ActionListener, KeyListener, TreeSelectionListener\n{\n    private static final long serialVersionUID = 1L;\n    private JScrollPane mainScrollPane;\n    private JTree fixTree;\n    private JLabel searchLabel;\n    private JTextField searchTextField;\n    private JButton searchButton;\n    private JButton clearButton;\n    private JButton expandButton;\n    private JButton collapseButton;\n    private Library library;\n    \n    public TreeView(final Library library) {\n        this.library = library;\n        this.initGUI();\n    }\n    \n    private void initGUI() {\n        this.setLayout(new BorderLayout());\n        (this.mainScrollPane = new JScrollPane()).setPreferredSize(new Dimension(300, 400));\n        this.add(this.mainScrollPane, \"Center\");\n        (this.fixTree = new JTree(this.loadFIXTree())).setCellRenderer(new FixInfoCellRenderer());\n        this.fixTree.addTreeSelectionListener(this);\n        this.mainScrollPane.getViewport().add(this.fixTree);\n        this.searchLabel = new JLabel(\"Search \");\n        (this.searchTextField = new JTextField(20)).setToolTipText(\"Search for Item (regex)\");\n        this.searchTextField.addKeyListener(this);\n        (this.searchButton = new JButton(\"Go\")).addActionListener(this);\n        this.searchButton.setToolTipText(\"Start Search\");\n        (this.clearButton = new JButton(new ImageIcon(\".\\\\resources\\\\clear.gif\"))).addActionListener(this);\n        this.clearButton.setToolTipText(\"Clear the Search Results\");\n        (this.expandButton = new JButton(new ImageIcon(\".\\\\resources\\\\expand.gif\"))).addActionListener(this);\n        this.expandButton.setToolTipText(\"Expand the Tree\");\n        (this.collapseButton = new JButton(new ImageIcon(\".\\\\resources\\\\collapse.gif\"))).addActionListener(this);\n        this.collapseButton.setToolTipText(\"Collapse the Tree\");\n        final JToolBar toolbar = new JToolBar();\n        toolbar.setFloatable(false);\n        toolbar.add(this.clearButton);\n        toolbar.addSeparator();\n        toolbar.add(this.searchLabel);\n        toolbar.add(this.searchTextField);\n        toolbar.add(this.searchButton);\n        toolbar.addSeparator();\n        toolbar.add(this.expandButton);\n        toolbar.add(this.collapseButton);\n        this.add(toolbar, \"North\");\n    }\n    \n    private FixInfoTreeNode loadFIXTree() {\n        final FixInfoTreeNode root = new FixInfoTreeNode((Object)\"Dictionaries\");\n        for (final DictionaryInfo dictionary : this.library.getDictionaries()) {\n            final FixInfoTreeNode node = new FixInfoTreeNode((Object)dictionary.getVersion());\n            this.loadMessages(node, dictionary);\n            root.add(node);\n        }\n        return root;\n    }\n    \n    private void loadMessages(final FixInfoTreeNode versionNode, final DictionaryInfo dictionary) {\n        for (final MessageInfo message : dictionary.getMessages()) {\n            final FixInfoTreeNode node = new FixInfoTreeNode((Object)message);\n            this.loadItems(node, message, 0);\n            versionNode.add(node);\n        }\n    }\n    \n    private void loadItems(final FixInfoTreeNode branchNode, final CompositeFixInfo leafNode, int level) {\n        ++level;\n        for (final FixInfo info : leafNode.getItems()) {\n            final FixInfoTreeNode node = new FixInfoTreeNode((Object)info);\n            if (info instanceof CompositeFixInfo && level < 5) {\n                this.loadItems(node, (CompositeFixInfo)info, level);\n            }\n            branchNode.add(node);\n        }\n    }\n    \n    private void expandAll() {\n        synchronized (this.fixTree) {\n            for (int row = 0; row < this.fixTree.getRowCount(); ++row) {\n                this.fixTree.expandRow(row);\n            }\n        }\n    }\n    \n    private void collapseAll() {\n        synchronized (this.fixTree) {\n            for (int row = this.fixTree.getRowCount() - 1; row >= 0; --row) {\n                this.fixTree.collapseRow(row);\n            }\n        }\n    }\n    \n    private void search(final FixInfoTreeNode node, final String searchString) {\n        int count = 0;\n        if (node.getUserObject() instanceof FixInfo) {\n            final FixInfo info = (FixInfo)node.getUserObject();\n            if (info instanceof MessageInfo) {\n                if (((MessageInfo)info).getName().matches(searchString) || ((MessageInfo)info).getMessageType().matches(searchString)) {\n                    node.setHighlighted(true);\n                    this.fixTree.expandPath(new TreePath(node.getPath()));\n                }\n            }\n            else if (info instanceof ComponentInfo) {\n                if (((ComponentInfo)info).getName().matches(searchString)) {\n                    node.setHighlighted(true);\n                    this.fixTree.expandPath(new TreePath(node.getPath()));\n                }\n            }\n            else if (info instanceof FieldInfo) {\n                final String tagNumber = \"\" + ((FieldInfo)info).getTagNumber();\n                if (((FieldInfo)info).getName().matches(searchString) || tagNumber.matches(searchString)) {\n                    node.setHighlighted(true);\n                    if (node.getChildCount() > 0) {\n                        this.fixTree.expandPath(new TreePath(node.getPath()));\n                    }\n                    else {\n                        this.fixTree.expandPath(new TreePath(((FixInfoTreeNode)node.getParent()).getPath()));\n                    }\n                }\n            }\n        }\n        while (count < node.getChildCount()) {\n            final FixInfoTreeNode childNode = (FixInfoTreeNode)node.getChildAt(count);\n            this.search(childNode, searchString);\n            ++count;\n        }\n    }\n    \n    private void clear(final FixInfoTreeNode node) {\n        int count = 0;\n        node.setHighlighted(false);\n        while (count < node.getChildCount()) {\n            final FixInfoTreeNode childNode = (FixInfoTreeNode)node.getChildAt(count);\n            this.clear(childNode);\n            ++count;\n        }\n    }\n    \n    @Override\n    public void valueChanged(final TreeSelectionEvent event) {\n        final FixInfoTreeNode node = (FixInfoTreeNode)this.fixTree.getLastSelectedPathComponent();\n        if (node != null) {\n            if (node.getUserObject() instanceof FieldInfo) {\n                if (((FixInfoTreeNode)node.getParent()).getUserObject() instanceof ComponentInfo) {\n                    LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), (ComponentInfo)((FixInfoTreeNode)node.getParent()).getUserObject());\n                }\n                else {\n                    LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), (ComponentInfo)((FixInfoTreeNode)node.getPath()[2]).getUserObject());\n                }\n            }\n            else if (node.getUserObject() instanceof MessageInfo) {\n                LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), null);\n            }\n            else if (node.getUserObject() instanceof ComponentInfo) {\n                LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), null);\n            }\n            else {\n                LibrarySuite.getInstance().getDetailsPanel().clearDisplay();\n            }\n        }\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent event) {\n        if (event.getSource().equals(this.collapseButton)) {\n            this.collapseAll();\n        }\n        else if (event.getSource().equals(this.expandButton)) {\n            this.expandAll();\n        }\n        else if (event.getSource().equals(this.searchButton)) {\n            this.clear((FixInfoTreeNode)this.fixTree.getModel().getRoot());\n            this.collapseAll();\n            this.search((FixInfoTreeNode)this.fixTree.getModel().getRoot(), this.searchTextField.getText().trim());\n        }\n        else if (event.getSource().equals(this.clearButton)) {\n            this.clear((FixInfoTreeNode)this.fixTree.getModel().getRoot());\n            this.collapseAll();\n        }\n    }\n    \n    @Override\n    public void keyPressed(final KeyEvent event) {\n        if (event.getKeyCode() == 10) {\n            this.searchButton.doClick();\n        }\n    }\n    \n    @Override\n    public void keyReleased(final KeyEvent event) {\n    }\n    \n    @Override\n    public void keyTyped(final KeyEvent event) {\n    }\n    \n    private class FixInfoTreeNode extends DefaultMutableTreeNode\n    {\n        private static final long serialVersionUID = 1L;\n        private boolean isHighlighted;\n        \n        private FixInfoTreeNode(final Object userObject) {\n            super(userObject);\n            this.isHighlighted = false;\n        }\n        \n        private boolean isHighlighted() {\n            return this.isHighlighted;\n        }\n        \n        private void setHighlighted(final boolean isHighlighted) {\n            this.isHighlighted = isHighlighted;\n        }\n    }\n    \n    private class FixInfoCellRenderer extends DefaultTreeCellRenderer\n    {\n        private static final long serialVersionUID = 1L;\n        \n        @Override\n        public Component getTreeCellRendererComponent(final JTree tree, final Object value, final boolean sel, final boolean expanded, final boolean leaf, final int row, final boolean hasFocus) {\n            final JLabel label = (JLabel)super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n            if (((FixInfoTreeNode)value).getUserObject() instanceof FieldInfo) {\n                final FieldInfo field = (FieldInfo)((FixInfoTreeNode)value).getUserObject();\n                label.setText(field.getName() + \" (\" + field.getTagNumber() + \")\");\n            }\n            else if (((FixInfoTreeNode)value).getUserObject() instanceof MessageInfo) {\n                final MessageInfo message = (MessageInfo)((FixInfoTreeNode)value).getUserObject();\n                label.setText(message.getName() + \" (\" + message.getMessageType() + \")\");\n            }\n            else if (((FixInfoTreeNode)value).getUserObject() instanceof ComponentInfo) {\n                final ComponentInfo component = (ComponentInfo)((FixInfoTreeNode)value).getUserObject();\n                label.setText(\"[\" + component.getName() + \"]\");\n            }\n            if (((FixInfoTreeNode)value).isHighlighted()) {\n                label.setForeground(Color.BLUE);\n            }\n            return label;\n        }\n    }\n}\n",
        "token_number_zeroshot": 2089,
        "token_number_fewshot": 2487,
        "token_number_cot": 2200
    },
    {
        "project_name": "73_fim1",
        "class": "FontChooserDialog",
        "source_code": "package osa.ora.server.client.ui.utils;\n\nimport javax.swing.*;\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\nclass FontChooserDialog extends JDialog\n{\n    private Font initialFont;\n    private JFontChooser chooserPane;\n    \n    public FontChooserDialog(final Component c, final String title, final boolean modal, final JFontChooser chooserPane, final ActionListener okListener, final ActionListener cancelListener) {\n        super(JOptionPane.getFrameForComponent(c), title, modal);\n        final String okString = UIManager.getString(\"ColorChooser.okText\");\n        final String cancelString = UIManager.getString(\"ColorChooser.cancelText\");\n        final String resetString = UIManager.getString(\"ColorChooser.resetText\");\n        final JPanel buttonPane = new JPanel();\n        buttonPane.setLayout(new FlowLayout(1));\n        final JButton okButton = new JButton(okString);\n        this.getRootPane().setDefaultButton(okButton);\n        okButton.setActionCommand(\"OK\");\n        if (okListener != null) {\n            okButton.addActionListener(okListener);\n        }\n        okButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                FontChooserDialog.this.setVisible(false);\n            }\n        });\n        buttonPane.add(okButton);\n        final JButton cancelButton = new JButton(cancelString);\n        final Action cancelKeyAction = new AbstractAction() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n            }\n        };\n        final KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke('\\u001b');\n        final InputMap inputMap = cancelButton.getInputMap(2);\n        final ActionMap actionMap = cancelButton.getActionMap();\n        if (inputMap != null && actionMap != null) {\n            inputMap.put(cancelKeyStroke, \"cancel\");\n            actionMap.put(\"cancel\", cancelKeyAction);\n        }\n        cancelButton.setActionCommand(\"cancel\");\n        if (cancelListener != null) {\n            cancelButton.addActionListener(cancelListener);\n        }\n        cancelButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                FontChooserDialog.this.setVisible(false);\n            }\n        });\n        buttonPane.add(cancelButton);\n        final JButton resetButton = new JButton(resetString);\n        resetButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                FontChooserDialog.this.reset();\n            }\n        });\n        final int mnemonic = UIManager.getInt(\"ColorChooser.resetMnemonic\");\n        if (mnemonic != -1) {\n            resetButton.setMnemonic(mnemonic);\n        }\n        buttonPane.add(resetButton);\n        this.chooserPane = chooserPane;\n        final Container contentPane = this.getContentPane();\n        contentPane.setLayout(new BorderLayout());\n        contentPane.add(chooserPane, \"Center\");\n        contentPane.add(buttonPane, \"South\");\n        this.pack();\n        this.setLocationRelativeTo(c);\n    }\n    \n    @Override\n    public void setVisible(final boolean visible) {\n        if (visible) {\n            this.initialFont = this.chooserPane.getFont();\n        }\n        super.setVisible(visible);\n    }\n    \n    public void reset() {\n        this.chooserPane.setFont(this.initialFont);\n    }\n    \n    static class Closer extends WindowAdapter implements Serializable\n    {\n        @Override\n        public void windowClosing(final WindowEvent e) {\n            final Window w = e.getWindow();\n            w.setVisible(false);\n        }\n    }\n    \n    static class DisposeOnClose extends ComponentAdapter implements Serializable\n    {\n        @Override\n        public void componentHidden(final ComponentEvent e) {\n            final Window w = (Window)e.getComponent();\n            w.dispose();\n        }\n    }\n}\n",
        "token_number_zeroshot": 765,
        "token_number_fewshot": 1163,
        "token_number_cot": 877
    },
    {
        "project_name": "73_fim1",
        "class": "UpdateUserPanel",
        "source_code": "package osa.ora.server.admin.ui;\n\nimport osa.ora.server.admin.*;\nimport osa.ora.server.beans.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nimport java.util.*;\n\npublic class UpdateUserPanel extends JPanel\n{\n    AdminApp adminApp;\n    ControlPanel controlPanel;\n    private JButton jButton1;\n    private JButton jButton2;\n    private JButton jButton3;\n    private JButton jButton4;\n    private JCheckBox jCheckBox1;\n    private JCheckBox jCheckBox2;\n    private JCheckBox jCheckBox3;\n    private JComboBox jComboBox1;\n    private JComboBox jComboBox2;\n    private JLabel jLabel1;\n    private JLabel jLabel2;\n    private JLabel jLabel3;\n    private JLabel jLabel4;\n    private JLabel jLabel5;\n    private JLabel jLabel6;\n    private JTextField jTextField1;\n    private JTextField jTextField2;\n    private JTextField jTextField3;\n    private JTextField jTextField4;\n    \n    public UpdateUserPanel(final AdminApp adminApp, final ControlPanel controlPanel) {\n        this.adminApp = adminApp;\n        this.controlPanel = controlPanel;\n        this.initComponents();\n    }\n    \n    public void updateModel() {\n        this.jComboBox1.setModel(new DefaultComboBoxModel<Group>(this.adminApp.getGroups()));\n        this.reset();\n        if (this.adminApp.getGroups() != null && this.adminApp.getGroups().size() > 0) {\n            this.jComboBox2.setModel(new DefaultComboBoxModel<User>(this.adminApp.getGroups().get(0).getUsers()));\n            if (this.adminApp.getGroups().get(0).getUsers() != null && this.adminApp.getGroups().get(0).getUsers().size() > 0) {\n                final User user = this.adminApp.getGroups().get(0).getUsers().get(0);\n                this.fillUser(user);\n            }\n            else {\n                this.reset();\n            }\n        }\n        else {\n            this.jComboBox2.setModel(new DefaultComboBoxModel<Group>(this.adminApp.getGroups()));\n        }\n    }\n    \n    private void initComponents() {\n        this.jLabel1 = new JLabel();\n        this.jLabel2 = new JLabel();\n        this.jLabel3 = new JLabel();\n        this.jCheckBox1 = new JCheckBox();\n        this.jCheckBox2 = new JCheckBox();\n        this.jCheckBox3 = new JCheckBox();\n        this.jLabel4 = new JLabel();\n        this.jComboBox1 = new JComboBox();\n        this.jTextField2 = new JTextField();\n        this.jTextField3 = new JTextField();\n        this.jButton1 = new JButton();\n        this.jButton2 = new JButton();\n        this.jComboBox2 = new JComboBox();\n        this.jButton3 = new JButton();\n        this.jButton4 = new JButton();\n        this.jLabel5 = new JLabel();\n        this.jTextField1 = new JTextField();\n        this.jTextField4 = new JTextField();\n        this.jLabel6 = new JLabel();\n        this.setLayout(null);\n        this.jLabel1.setText(\"Username:\");\n        this.add(this.jLabel1);\n        this.jLabel1.setBounds(10, 50, 90, 14);\n        this.jLabel2.setText(\"Login Email:\");\n        this.add(this.jLabel2);\n        this.jLabel2.setBounds(10, 140, 100, 14);\n        this.jLabel3.setText(\"Phone:\");\n        this.add(this.jLabel3);\n        this.jLabel3.setBounds(10, 170, 110, 14);\n        this.jCheckBox1.setText(\"Show User Status To Others\");\n        this.add(this.jCheckBox1);\n        this.jCheckBox1.setBounds(30, 200, 260, 23);\n        this.jCheckBox2.setText(\"User Can Only Start Chat With Others\");\n        this.add(this.jCheckBox2);\n        this.jCheckBox2.setBounds(30, 220, 250, 23);\n        this.jCheckBox3.setText(\"Can be a Member of Chat Rooms\");\n        this.add(this.jCheckBox3);\n        this.jCheckBox3.setBounds(30, 240, 260, 23);\n        this.jLabel4.setText(\"User Group:\");\n        this.add(this.jLabel4);\n        this.jLabel4.setBounds(10, 20, 90, 14);\n        this.jComboBox1.setModel(new DefaultComboBoxModel<String>(new String[] { \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\" }));\n        this.jComboBox1.addItemListener(new ItemListener() {\n            @Override\n            public void itemStateChanged(final ItemEvent evt) {\n                UpdateUserPanel.this.jComboBox1ItemStateChanged(evt);\n            }\n        });\n        this.add(this.jComboBox1);\n        this.jComboBox1.setBounds(90, 20, 170, 20);\n        this.add(this.jTextField2);\n        this.jTextField2.setBounds(90, 140, 170, 20);\n        this.add(this.jTextField3);\n        this.jTextField3.setBounds(90, 170, 170, 20);\n        this.jButton1.setIcon(new ImageIcon(this.getClass().getResource(\"/images/close.jpg\")));\n        this.jButton1.setText(\"Cancel\");\n        this.jButton1.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton1ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton1);\n        this.jButton1.setBounds(80, 350, 100, 30);\n        this.jButton2.setIcon(new ImageIcon(this.getClass().getResource(\"/images/trash.png\")));\n        this.jButton2.setText(\"Delete\");\n        this.jButton2.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton2ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton2);\n        this.jButton2.setBounds(30, 310, 100, 30);\n        this.jComboBox2.setModel(new DefaultComboBoxModel<String>(new String[] { \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\" }));\n        this.jComboBox2.addItemListener(new ItemListener() {\n            @Override\n            public void itemStateChanged(final ItemEvent evt) {\n                UpdateUserPanel.this.jComboBox2ItemStateChanged(evt);\n            }\n        });\n        this.add(this.jComboBox2);\n        this.jComboBox2.setBounds(90, 50, 170, 20);\n        this.jButton3.setIcon(new ImageIcon(this.getClass().getResource(\"/images/login.gif\")));\n        this.jButton3.setText(\"Reset Password\");\n        this.jButton3.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton3ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton3);\n        this.jButton3.setBounds(30, 270, 210, 30);\n        this.jButton4.setIcon(new ImageIcon(this.getClass().getResource(\"/images/online.png\")));\n        this.jButton4.setText(\"Update\");\n        this.jButton4.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton4ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton4);\n        this.jButton4.setBounds(140, 310, 100, 30);\n        this.jLabel5.setText(\"Title:\");\n        this.add(this.jLabel5);\n        this.jLabel5.setBounds(10, 110, 80, 14);\n        this.add(this.jTextField1);\n        this.jTextField1.setBounds(90, 80, 170, 20);\n        this.add(this.jTextField4);\n        this.jTextField4.setBounds(90, 110, 170, 20);\n        this.jLabel6.setText(\"Username:\");\n        this.add(this.jLabel6);\n        this.jLabel6.setBounds(10, 80, 80, 14);\n    }\n    \n    private void jButton1ActionPerformed(final ActionEvent evt) {\n        this.controlPanel.getParentDialog().setVisible(false);\n        this.reset();\n    }\n    \n    private void jButton2ActionPerformed(final ActionEvent evt) {\n        final Group group = (Group)this.jComboBox1.getSelectedItem();\n        User user = (User)this.jComboBox2.getSelectedItem();\n        final int index = this.jComboBox2.getSelectedIndex();\n        if (user == null || index == -1) {\n            JOptionPane.showMessageDialog(this, \"Can't identify selected User!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        try {\n            user = this.adminApp.delUser(user);\n            if (user != null) {\n                group.getUsers().remove(index);\n                this.reset();\n                if (this.jComboBox2.getModel().getSize() > 0) {\n                    this.jComboBox2.setSelectedIndex(0);\n                    this.jComboBox2.validate();\n                }\n                else {\n                    this.jComboBox1.setSelectedIndex(0);\n                    this.jComboBox1.validate();\n                    this.jComboBox1ItemStateChanged(null);\n                }\n                JOptionPane.showMessageDialog(this, \"User Deleted Successfully!\");\n            }\n            else {\n                JOptionPane.showMessageDialog(this, \"Server Error!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            }\n        }\n        catch (Exception ex) {\n            System.out.println(\"Error \" + ex);\n            JOptionPane.showMessageDialog(this, \"Error Happen \" + ex.getMessage(), \"Error\", 0, this.adminApp.getErrorIcon());\n        }\n    }\n    \n    private void jButton3ActionPerformed(final ActionEvent evt) {\n        User user = (User)this.jComboBox2.getSelectedItem();\n        if (user == null) {\n            JOptionPane.showMessageDialog(this, \"Can't identify selected User!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        try {\n            user = this.adminApp.resetUserPass(user);\n            if (user != null) {\n                JOptionPane.showMessageDialog(this, \"User Password Reset Successfully!\");\n            }\n            else {\n                JOptionPane.showMessageDialog(this, \"Server Error!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            }\n        }\n        catch (Exception ex) {\n            System.out.println(\"Error \" + ex);\n            JOptionPane.showMessageDialog(this, \"Error Happen \" + ex.getMessage(), \"Error\", 0, this.adminApp.getErrorIcon());\n        }\n    }\n    \n    private void jButton4ActionPerformed(final ActionEvent evt) {\n        final Group group = (Group)this.jComboBox1.getSelectedItem();\n        User user = (User)this.jComboBox2.getSelectedItem();\n        final int index = this.jComboBox2.getSelectedIndex();\n        if (user == null) {\n            JOptionPane.showMessageDialog(this, \"Can't identify selected User!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        if (this.jTextField1.getText() == null || this.jTextField1.getText().equals(\"\")) {\n            JOptionPane.showMessageDialog(this, \"Please Enter User Name\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        if (this.jTextField2.getText() == null || this.jTextField2.getText().equals(\"\")) {\n            JOptionPane.showMessageDialog(this, \"Please Enter User email\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        for (int i = 0; i < this.adminApp.getGroups().size(); ++i) {\n            final Vector<User> tempUsers = this.adminApp.getGroups().get(i).getUsers();\n            for (int n = 0; n < tempUsers.size(); ++n) {\n                if (user.getId() != tempUsers.get(n).getId() && this.jTextField2.getText().equals(tempUsers.get(n).getEmail())) {\n                    JOptionPane.showMessageDialog(this, \"User with Same email Already Exist!\", \"Error\", 0, this.adminApp.getErrorIcon());\n                    return;\n                }\n            }\n        }\n        try {\n            user.setName(this.jTextField1.getText());\n            user.setEmail(this.jTextField2.getText());\n            user.setDirectPhone(this.jTextField3.getText());\n            if (this.jTextField3.getText() == null || \"\".equals(this.jTextField3.getText())) {\n                user.setDirectPhone(\"N/A\");\n            }\n            else {\n                user.setDirectPhone(this.jTextField3.getText());\n            }\n            if (this.jTextField4.getText() == null || \"\".equals(this.jTextField4.getText())) {\n                user.setJobTitle(\"N/A\");\n            }\n            else {\n                user.setJobTitle(this.jTextField4.getText());\n            }\n            user.setShowMyStatus(this.jCheckBox1.isSelected());\n            user.setOnlyStartChat(this.jCheckBox2.isSelected());\n            user.setCanJoinChatRoom(this.jCheckBox3.isSelected());\n            user = this.adminApp.updateUser(user);\n            if (user != null) {\n                group.getUsers().set(index, user);\n                if (this.jComboBox2.getModel().getSize() > 0) {\n                    this.jComboBox2.setSelectedIndex(0);\n                }\n                this.jComboBox2.validate();\n                JOptionPane.showMessageDialog(this, \"User Updated Successfully!\");\n            }\n            else {\n                JOptionPane.showMessageDialog(this, \"Server Error!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            }\n        }\n        catch (Exception ex) {\n            System.out.println(\"Error \" + ex);\n            JOptionPane.showMessageDialog(this, \"Error Happen \" + ex.getMessage(), \"Error\", 0, this.adminApp.getErrorIcon());\n        }\n    }\n    \n    private void jComboBox1ItemStateChanged(final ItemEvent evt) {\n        final Group group = (Group)this.jComboBox1.getSelectedItem();\n        this.jComboBox2.setModel(new DefaultComboBoxModel<User>(group.getUsers()));\n        if (group.getUsers() != null && group.getUsers().size() > 0) {\n            final User user = group.getUsers().get(0);\n            this.fillUser(user);\n        }\n        else {\n            this.reset();\n        }\n    }\n    \n    private void reset() {\n        this.jTextField1.setText(\"\");\n        this.jTextField2.setText(\"\");\n        this.jTextField3.setText(\"\");\n        this.jTextField4.setText(\"\");\n        this.jCheckBox1.setSelected(false);\n        this.jCheckBox2.setSelected(false);\n        this.jCheckBox3.setSelected(false);\n    }\n    \n    private void fillUser(final User user) {\n        this.jTextField1.setText(user.getName());\n        this.jTextField2.setText(user.getEmail());\n        this.jTextField3.setText(user.getDirectPhone());\n        this.jTextField4.setText(user.getJobTitle());\n        this.jCheckBox1.setSelected(user.isShowMyStatus());\n        this.jCheckBox2.setSelected(user.isOnlyStartChat());\n        this.jCheckBox3.setSelected(user.isCanJoinChatRoom());\n    }\n    \n    private void jComboBox2ItemStateChanged(final ItemEvent evt) {\n        final User user = (User)this.jComboBox2.getSelectedItem();\n        if (user != null) {\n            this.fillUser(user);\n        }\n        else {\n            this.reset();\n        }\n    }\n}\n",
        "token_number_zeroshot": 3058,
        "token_number_fewshot": 3456,
        "token_number_cot": 3170
    },
    {
        "project_name": "guava",
        "class": "Joiner",
        "source_code": "package com.google.common.base;\n\nimport java.io.*;\nimport javax.annotation.*;\nimport java.util.*;\nimport com.google.common.annotations.*;\n\n@GwtCompatible\npublic class Joiner\n{\n    private final String separator;\n    \n    public static Joiner on(final String separator) {\n        return new Joiner(separator);\n    }\n    \n    public static Joiner on(final char separator) {\n        return new Joiner(String.valueOf(separator));\n    }\n    \n    private Joiner(final String separator) {\n        this.separator = Preconditions.checkNotNull(separator);\n    }\n    \n    private Joiner(final Joiner prototype) {\n        this.separator = prototype.separator;\n    }\n    \n    public <A extends Appendable> A appendTo(final A appendable, final Iterable<?> parts) throws IOException {\n        return this.appendTo(appendable, parts.iterator());\n    }\n    \n    public <A extends Appendable> A appendTo(final A appendable, final Iterator<?> parts) throws IOException {\n        Preconditions.checkNotNull(appendable);\n        if (parts.hasNext()) {\n            appendable.append(this.toString(parts.next()));\n            while (parts.hasNext()) {\n                appendable.append(this.separator);\n                appendable.append(this.toString(parts.next()));\n            }\n        }\n        return appendable;\n    }\n    \n    public final <A extends Appendable> A appendTo(final A appendable, final Object[] parts) throws IOException {\n        return this.appendTo(appendable, Arrays.asList(parts));\n    }\n    \n    public final <A extends Appendable> A appendTo(final A appendable, @Nullable final Object first, @Nullable final Object second, final Object... rest) throws IOException {\n        return this.appendTo(appendable, iterable(first, second, rest));\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, final Iterable<?> parts) {\n        return this.appendTo(builder, parts.iterator());\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, final Iterator<?> parts) {\n        try {\n            this.appendTo(builder, parts);\n        }\n        catch (IOException impossible) {\n            throw new AssertionError((Object)impossible);\n        }\n        return builder;\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, final Object[] parts) {\n        return this.appendTo(builder, (Iterable<?>)Arrays.asList(parts));\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, @Nullable final Object first, @Nullable final Object second, final Object... rest) {\n        return this.appendTo(builder, (Iterable<?>)iterable(first, second, rest));\n    }\n    \n    public final String join(final Iterable<?> parts) {\n        return this.join(parts.iterator());\n    }\n    \n    public final String join(final Iterator<?> parts) {\n        return this.appendTo(new StringBuilder(), parts).toString();\n    }\n    \n    public final String join(final Object[] parts) {\n        return this.join(Arrays.asList(parts));\n    }\n    \n    public final String join(@Nullable final Object first, @Nullable final Object second, final Object... rest) {\n        return this.join(iterable(first, second, rest));\n    }\n    \n    @CheckReturnValue\n    public Joiner useForNull(final String nullText) {\n        Preconditions.checkNotNull(nullText);\n        return new Joiner(this) {\n            @Override\n            CharSequence toString(@Nullable final Object part) {\n                return (part == null) ? nullText : Joiner.this.toString(part);\n            }\n            \n            @Override\n            public Joiner useForNull(final String nullText) {\n                throw new UnsupportedOperationException(\"already specified useForNull\");\n            }\n            \n            @Override\n            public Joiner skipNulls() {\n                throw new UnsupportedOperationException(\"already specified useForNull\");\n            }\n        };\n    }\n    \n    @CheckReturnValue\n    public Joiner skipNulls() {\n        return new Joiner(this) {\n            @Override\n            public <A extends Appendable> A appendTo(final A appendable, final Iterator<?> parts) throws IOException {\n                Preconditions.checkNotNull(appendable, (Object)\"appendable\");\n                Preconditions.checkNotNull(parts, (Object)\"parts\");\n                while (parts.hasNext()) {\n                    final Object part = parts.next();\n                    if (part != null) {\n                        appendable.append(Joiner.this.toString(part));\n                        break;\n                    }\n                }\n                while (parts.hasNext()) {\n                    final Object part = parts.next();\n                    if (part != null) {\n                        appendable.append(Joiner.this.separator);\n                        appendable.append(Joiner.this.toString(part));\n                    }\n                }\n                return appendable;\n            }\n            \n            @Override\n            public Joiner useForNull(final String nullText) {\n                throw new UnsupportedOperationException(\"already specified skipNulls\");\n            }\n            \n            @Override\n            public MapJoiner withKeyValueSeparator(final String kvs) {\n                throw new UnsupportedOperationException(\"can't use .skipNulls() with maps\");\n            }\n        };\n    }\n    \n    @CheckReturnValue\n    public MapJoiner withKeyValueSeparator(final String keyValueSeparator) {\n        return new MapJoiner(this, keyValueSeparator);\n    }\n    \n    CharSequence toString(final Object part) {\n        Preconditions.checkNotNull(part);\n        return (part instanceof CharSequence) ? ((CharSequence)part) : part.toString();\n    }\n    \n    private static Iterable<Object> iterable(final Object first, final Object second, final Object[] rest) {\n        Preconditions.checkNotNull(rest);\n        return new AbstractList<Object>() {\n            @Override\n            public int size() {\n                return rest.length + 2;\n            }\n            \n            @Override\n            public Object get(final int index) {\n                switch (index) {\n                    case 0: {\n                        return first;\n                    }\n                    case 1: {\n                        return second;\n                    }\n                    default: {\n                        return rest[index - 2];\n                    }\n                }\n            }\n        };\n    }\n    \n    public static final class MapJoiner\n    {\n        private final Joiner joiner;\n        private final String keyValueSeparator;\n        \n        private MapJoiner(final Joiner joiner, final String keyValueSeparator) {\n            this.joiner = joiner;\n            this.keyValueSeparator = Preconditions.checkNotNull(keyValueSeparator);\n        }\n        \n        public <A extends Appendable> A appendTo(final A appendable, final Map<?, ?> map) throws IOException {\n            return this.appendTo(appendable, map.entrySet());\n        }\n        \n        public StringBuilder appendTo(final StringBuilder builder, final Map<?, ?> map) {\n            return this.appendTo(builder, (Iterable<? extends Map.Entry<?, ?>>)map.entrySet());\n        }\n        \n        public String join(final Map<?, ?> map) {\n            return this.join(map.entrySet());\n        }\n        \n        @Beta\n        public <A extends Appendable> A appendTo(final A appendable, final Iterable<? extends Map.Entry<?, ?>> entries) throws IOException {\n            return this.appendTo(appendable, entries.iterator());\n        }\n        \n        @Beta\n        public <A extends Appendable> A appendTo(final A appendable, final Iterator<? extends Map.Entry<?, ?>> parts) throws IOException {\n            Preconditions.checkNotNull(appendable);\n            if (parts.hasNext()) {\n                final Map.Entry<?, ?> entry = (Map.Entry<?, ?>)parts.next();\n                appendable.append(this.joiner.toString(entry.getKey()));\n                appendable.append(this.keyValueSeparator);\n                appendable.append(this.joiner.toString(entry.getValue()));\n                while (parts.hasNext()) {\n                    appendable.append(this.joiner.separator);\n                    final Map.Entry<?, ?> e = (Map.Entry<?, ?>)parts.next();\n                    appendable.append(this.joiner.toString(e.getKey()));\n                    appendable.append(this.keyValueSeparator);\n                    appendable.append(this.joiner.toString(e.getValue()));\n                }\n            }\n            return appendable;\n        }\n        \n        @Beta\n        public StringBuilder appendTo(final StringBuilder builder, final Iterable<? extends Map.Entry<?, ?>> entries) {\n            return this.appendTo(builder, entries.iterator());\n        }\n        \n        @Beta\n        public StringBuilder appendTo(final StringBuilder builder, final Iterator<? extends Map.Entry<?, ?>> entries) {\n            try {\n                this.appendTo(builder, entries);\n            }\n            catch (IOException impossible) {\n                throw new AssertionError((Object)impossible);\n            }\n            return builder;\n        }\n        \n        @Beta\n        public String join(final Iterable<? extends Map.Entry<?, ?>> entries) {\n            return this.join(entries.iterator());\n        }\n        \n        @Beta\n        public String join(final Iterator<? extends Map.Entry<?, ?>> entries) {\n            return this.appendTo(new StringBuilder(), entries).toString();\n        }\n        \n        @CheckReturnValue\n        public MapJoiner useForNull(final String nullText) {\n            return new MapJoiner(this.joiner.useForNull(nullText), this.keyValueSeparator);\n        }\n    }\n}\n",
        "token_number_zeroshot": 1787,
        "token_number_fewshot": 2185,
        "token_number_cot": 1898
    },
    {
        "project_name": "guava",
        "class": "Suppliers",
        "source_code": "package com.google.common.base;\n\nimport java.util.concurrent.*;\nimport javax.annotation.*;\nimport java.io.*;\nimport com.google.common.annotations.*;\n\n@GwtCompatible\npublic final class Suppliers\n{\n    public static <F, T> Supplier<T> compose(final Function<? super F, T> function, final Supplier<F> supplier) {\n        Preconditions.checkNotNull(function);\n        Preconditions.checkNotNull(supplier);\n        return new SupplierComposition<Object, T>(function, supplier);\n    }\n    \n    public static <T> Supplier<T> memoize(final Supplier<T> delegate) {\n        return (delegate instanceof MemoizingSupplier) ? delegate : new MemoizingSupplier<T>(Preconditions.checkNotNull(delegate));\n    }\n    \n    public static <T> Supplier<T> memoizeWithExpiration(final Supplier<T> delegate, final long duration, final TimeUnit unit) {\n        return new ExpiringMemoizingSupplier<T>(delegate, duration, unit);\n    }\n    \n    public static <T> Supplier<T> ofInstance(@Nullable final T instance) {\n        return new SupplierOfInstance<T>(instance);\n    }\n    \n    public static <T> Supplier<T> synchronizedSupplier(final Supplier<T> delegate) {\n        return new ThreadSafeSupplier<T>(Preconditions.checkNotNull(delegate));\n    }\n    \n    @Beta\n    public static <T> Function<Supplier<T>, T> supplierFunction() {\n        final SupplierFunction<T> sf = (SupplierFunction<T>)SupplierFunctionImpl.INSTANCE;\n        return sf;\n    }\n    \n    private static class SupplierComposition<F, T> implements Supplier<T>, Serializable\n    {\n        final Function<? super F, T> function;\n        final Supplier<F> supplier;\n        private static final long serialVersionUID = 0L;\n        \n        SupplierComposition(final Function<? super F, T> function, final Supplier<F> supplier) {\n            this.function = function;\n            this.supplier = supplier;\n        }\n        \n        @Override\n        public T get() {\n            return this.function.apply((Object)this.supplier.get());\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof SupplierComposition) {\n                final SupplierComposition<?, ?> that = (SupplierComposition<?, ?>)obj;\n                return this.function.equals(that.function) && this.supplier.equals(that.supplier);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hashCode(this.function, this.supplier);\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.function));\n            final String value2 = String.valueOf(String.valueOf(this.supplier));\n            return new StringBuilder(21 + value.length() + value2.length()).append(\"Suppliers.compose(\").append(value).append(\", \").append(value2).append(\")\").toString();\n        }\n    }\n    \n    @VisibleForTesting\n    static class MemoizingSupplier<T> implements Supplier<T>, Serializable\n    {\n        final Supplier<T> delegate;\n        transient volatile boolean initialized;\n        transient T value;\n        private static final long serialVersionUID = 0L;\n        \n        MemoizingSupplier(final Supplier<T> delegate) {\n            this.delegate = delegate;\n        }\n        \n        @Override\n        public T get() {\n            if (!this.initialized) {\n                synchronized (this) {\n                    if (!this.initialized) {\n                        final T t = this.delegate.get();\n                        this.value = t;\n                        this.initialized = true;\n                        return t;\n                    }\n                }\n            }\n            return this.value;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.delegate));\n            return new StringBuilder(19 + value.length()).append(\"Suppliers.memoize(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @VisibleForTesting\n    static class ExpiringMemoizingSupplier<T> implements Supplier<T>, Serializable\n    {\n        final Supplier<T> delegate;\n        final long durationNanos;\n        transient volatile T value;\n        transient volatile long expirationNanos;\n        private static final long serialVersionUID = 0L;\n        \n        ExpiringMemoizingSupplier(final Supplier<T> delegate, final long duration, final TimeUnit unit) {\n            this.delegate = Preconditions.checkNotNull(delegate);\n            this.durationNanos = unit.toNanos(duration);\n            Preconditions.checkArgument(duration > 0L);\n        }\n        \n        @Override\n        public T get() {\n            long nanos = this.expirationNanos;\n            final long now = Platform.systemNanoTime();\n            if (nanos == 0L || now - nanos >= 0L) {\n                synchronized (this) {\n                    if (nanos == this.expirationNanos) {\n                        final T t = this.delegate.get();\n                        this.value = t;\n                        nanos = now + this.durationNanos;\n                        this.expirationNanos = ((nanos == 0L) ? 1L : nanos);\n                        return t;\n                    }\n                }\n            }\n            return this.value;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.delegate));\n            return new StringBuilder(62 + value.length()).append(\"Suppliers.memoizeWithExpiration(\").append(value).append(\", \").append(this.durationNanos).append(\", NANOS)\").toString();\n        }\n    }\n    \n    private static class SupplierOfInstance<T> implements Supplier<T>, Serializable\n    {\n        final T instance;\n        private static final long serialVersionUID = 0L;\n        \n        SupplierOfInstance(@Nullable final T instance) {\n            this.instance = instance;\n        }\n        \n        @Override\n        public T get() {\n            return this.instance;\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof SupplierOfInstance) {\n                final SupplierOfInstance<?> that = (SupplierOfInstance<?>)obj;\n                return Objects.equal(this.instance, that.instance);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hashCode(this.instance);\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.instance));\n            return new StringBuilder(22 + value.length()).append(\"Suppliers.ofInstance(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class ThreadSafeSupplier<T> implements Supplier<T>, Serializable\n    {\n        final Supplier<T> delegate;\n        private static final long serialVersionUID = 0L;\n        \n        ThreadSafeSupplier(final Supplier<T> delegate) {\n            this.delegate = delegate;\n        }\n        \n        @Override\n        public T get() {\n            synchronized (this.delegate) {\n                return this.delegate.get();\n            }\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.delegate));\n            return new StringBuilder(32 + value.length()).append(\"Suppliers.synchronizedSupplier(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private enum SupplierFunctionImpl implements SupplierFunction<Object>\n    {\n        INSTANCE;\n        \n        @Override\n        public Object apply(final Supplier<Object> input) {\n            return input.get();\n        }\n        \n        @Override\n        public String toString() {\n            return \"Suppliers.supplierFunction()\";\n        }\n    }\n    \n    private interface SupplierFunction<T> extends Function<Supplier<T>, T>\n    {\n    }\n}\n",
        "token_number_zeroshot": 1548,
        "token_number_fewshot": 1946,
        "token_number_cot": 1658
    },
    {
        "project_name": "guava",
        "class": "Objects",
        "source_code": "package com.google.common.base;\n\nimport com.google.common.annotations.*;\nimport javax.annotation.*;\nimport java.util.*;\n\n@GwtCompatible\npublic final class Objects\n{\n    @CheckReturnValue\n    public static boolean equal(@Nullable final Object a, @Nullable final Object b) {\n        return a == b || (a != null && a.equals(b));\n    }\n    \n    public static int hashCode(@Nullable final Object... objects) {\n        return Arrays.hashCode(objects);\n    }\n    \n    @Deprecated\n    public static ToStringHelper toStringHelper(final Object self) {\n        return new ToStringHelper(MoreObjects.simpleName(self.getClass()));\n    }\n    \n    @Deprecated\n    public static ToStringHelper toStringHelper(final Class<?> clazz) {\n        return new ToStringHelper(MoreObjects.simpleName(clazz));\n    }\n    \n    @Deprecated\n    public static ToStringHelper toStringHelper(final String className) {\n        return new ToStringHelper(className);\n    }\n    \n    @Deprecated\n    public static <T> T firstNonNull(@Nullable final T first, @Nullable final T second) {\n        return MoreObjects.firstNonNull(first, second);\n    }\n    \n    @Deprecated\n    public static final class ToStringHelper\n    {\n        private final String className;\n        private ValueHolder holderHead;\n        private ValueHolder holderTail;\n        private boolean omitNullValues;\n        \n        private ToStringHelper(final String className) {\n            this.holderHead = new ValueHolder();\n            this.holderTail = this.holderHead;\n            this.omitNullValues = false;\n            this.className = Preconditions.checkNotNull(className);\n        }\n        \n        public ToStringHelper omitNullValues() {\n            this.omitNullValues = true;\n            return this;\n        }\n        \n        public ToStringHelper add(final String name, @Nullable final Object value) {\n            return this.addHolder(name, value);\n        }\n        \n        public ToStringHelper add(final String name, final boolean value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final char value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final double value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final float value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final int value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final long value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(@Nullable final Object value) {\n            return this.addHolder(value);\n        }\n        \n        public ToStringHelper addValue(final boolean value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final char value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final double value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final float value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final int value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final long value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        @Override\n        public String toString() {\n            final boolean omitNullValuesSnapshot = this.omitNullValues;\n            String nextSeparator = \"\";\n            final StringBuilder builder = new StringBuilder(32).append(this.className).append('{');\n            for (ValueHolder valueHolder = this.holderHead.next; valueHolder != null; valueHolder = valueHolder.next) {\n                if (!omitNullValuesSnapshot || valueHolder.value != null) {\n                    builder.append(nextSeparator);\n                    nextSeparator = \", \";\n                    if (valueHolder.name != null) {\n                        builder.append(valueHolder.name).append('=');\n                    }\n                    builder.append(valueHolder.value);\n                }\n            }\n            return builder.append('}').toString();\n        }\n        \n        private ValueHolder addHolder() {\n            final ValueHolder valueHolder = new ValueHolder();\n            final ValueHolder holderTail = this.holderTail;\n            final ValueHolder valueHolder2 = valueHolder;\n            holderTail.next = valueHolder2;\n            this.holderTail = valueHolder2;\n            return valueHolder;\n        }\n        \n        private ToStringHelper addHolder(@Nullable final Object value) {\n            final ValueHolder valueHolder = this.addHolder();\n            valueHolder.value = value;\n            return this;\n        }\n        \n        private ToStringHelper addHolder(final String name, @Nullable final Object value) {\n            final ValueHolder valueHolder = this.addHolder();\n            valueHolder.value = value;\n            valueHolder.name = Preconditions.checkNotNull(name);\n            return this;\n        }\n        \n        private static final class ValueHolder\n        {\n            String name;\n            Object value;\n            ValueHolder next;\n        }\n    }\n}\n",
        "token_number_zeroshot": 1060,
        "token_number_fewshot": 1458,
        "token_number_cot": 1170
    },
    {
        "project_name": "guava",
        "class": "Utf8",
        "source_code": "package com.google.common.base;\n\nimport com.google.common.annotations.*;\n\n@Beta\n@GwtCompatible\npublic final class Utf8\n{\n    public static int encodedLength(final CharSequence sequence) {\n        int utf8Length;\n        int utf16Length;\n        int i;\n        for (utf16Length = (utf8Length = sequence.length()), i = 0; i < utf16Length && sequence.charAt(i) < '\\u0080'; ++i) {}\n        while (i < utf16Length) {\n            final char c = sequence.charAt(i);\n            if (c >= '\\u0800') {\n                utf8Length += encodedLengthGeneral(sequence, i);\n                break;\n            }\n            utf8Length += '\\u007f' - c >>> 31;\n            ++i;\n        }\n        if (utf8Length < utf16Length) {\n            throw new IllegalArgumentException(new StringBuilder(54).append(\"UTF-8 length does not fit in int: \").append(utf8Length + 4294967296L).toString());\n        }\n        return utf8Length;\n    }\n    \n    private static int encodedLengthGeneral(final CharSequence sequence, final int start) {\n        final int utf16Length = sequence.length();\n        int utf8Length = 0;\n        for (int i = start; i < utf16Length; ++i) {\n            final char c = sequence.charAt(i);\n            if (c < '\\u0800') {\n                utf8Length += '\\u007f' - c >>> 31;\n            }\n            else {\n                utf8Length += 2;\n                if ('\\ud800' <= c && c <= '\\udfff') {\n                    final int cp = Character.codePointAt(sequence, i);\n                    if (cp < 65536) {\n                        throw new IllegalArgumentException(new StringBuilder(39).append(\"Unpaired surrogate at index \").append(i).toString());\n                    }\n                    ++i;\n                }\n            }\n        }\n        return utf8Length;\n    }\n    \n    public static boolean isWellFormed(final byte[] bytes) {\n        return isWellFormed(bytes, 0, bytes.length);\n    }\n    \n    public static boolean isWellFormed(final byte[] bytes, final int off, final int len) {\n        final int end = off + len;\n        Preconditions.checkPositionIndexes(off, end, bytes.length);\n        for (int i = off; i < end; ++i) {\n            if (bytes[i] < 0) {\n                return isWellFormedSlowPath(bytes, i, end);\n            }\n        }\n        return true;\n    }\n    \n    private static boolean isWellFormedSlowPath(final byte[] bytes, final int off, final int end) {\n        int index = off;\n        while (index < end) {\n            final int byte1;\n            if ((byte1 = bytes[index++]) < 0) {\n                if (byte1 < -32) {\n                    if (index == end) {\n                        return false;\n                    }\n                    if (byte1 < -62 || bytes[index++] > -65) {\n                        return false;\n                    }\n                    continue;\n                }\n                else if (byte1 < -16) {\n                    if (index + 1 >= end) {\n                        return false;\n                    }\n                    final int byte2 = bytes[index++];\n                    if (byte2 > -65 || (byte1 == -32 && byte2 < -96) || (byte1 == -19 && -96 <= byte2) || bytes[index++] > -65) {\n                        return false;\n                    }\n                    continue;\n                }\n                else {\n                    if (index + 2 >= end) {\n                        return false;\n                    }\n                    final int byte2 = bytes[index++];\n                    if (byte2 > -65 || (byte1 << 28) + (byte2 + 112) >> 30 != 0 || bytes[index++] > -65 || bytes[index++] > -65) {\n                        return false;\n                    }\n                    continue;\n                }\n            }\n        }\n        return true;\n    }\n}\n",
        "token_number_zeroshot": 865,
        "token_number_fewshot": 1263,
        "token_number_cot": 976
    },
    {
        "project_name": "guava",
        "class": "BigIntegerMath",
        "source_code": "package com.google.common.math;\n\nimport com.google.common.base.*;\nimport com.google.common.annotations.*;\nimport java.math.*;\nimport java.util.*;\n\n@GwtCompatible(emulated = true)\npublic final class BigIntegerMath\n{\n    @VisibleForTesting\n    static final int SQRT2_PRECOMPUTE_THRESHOLD = 256;\n    @VisibleForTesting\n    static final BigInteger SQRT2_PRECOMPUTED_BITS;\n    private static final double LN_10;\n    private static final double LN_2;\n    \n    public static boolean isPowerOfTwo(final BigInteger x) {\n        Preconditions.checkNotNull(x);\n        return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;\n    }\n    \n    public static int log2(final BigInteger x, final RoundingMode mode) {\n        MathPreconditions.checkPositive(\"x\", Preconditions.checkNotNull(x));\n        final int logFloor = x.bitLength() - 1;\n        switch (mode) {\n            case UNNECESSARY: {\n                MathPreconditions.checkRoundingUnnecessary(isPowerOfTwo(x));\n            }\n            case DOWN:\n            case FLOOR: {\n                return logFloor;\n            }\n            case UP:\n            case CEILING: {\n                return isPowerOfTwo(x) ? logFloor : (logFloor + 1);\n            }\n            case HALF_DOWN:\n            case HALF_UP:\n            case HALF_EVEN: {\n                if (logFloor >= 256) {\n                    final BigInteger x2 = x.pow(2);\n                    final int logX2Floor = x2.bitLength() - 1;\n                    return (logX2Floor < 2 * logFloor + 1) ? logFloor : (logFloor + 1);\n                }\n                final BigInteger halfPower = BigIntegerMath.SQRT2_PRECOMPUTED_BITS.shiftRight(256 - logFloor);\n                if (x.compareTo(halfPower) <= 0) {\n                    return logFloor;\n                }\n                return logFloor + 1;\n            }\n            default: {\n                throw new AssertionError();\n            }\n        }\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    public static int log10(final BigInteger x, final RoundingMode mode) {\n        MathPreconditions.checkPositive(\"x\", x);\n        if (fitsInLong(x)) {\n            return LongMath.log10(x.longValue(), mode);\n        }\n        int approxLog10 = (int)(log2(x, RoundingMode.FLOOR) * BigIntegerMath.LN_2 / BigIntegerMath.LN_10);\n        BigInteger approxPow = BigInteger.TEN.pow(approxLog10);\n        int approxCmp = approxPow.compareTo(x);\n        if (approxCmp > 0) {\n            do {\n                --approxLog10;\n                approxPow = approxPow.divide(BigInteger.TEN);\n                approxCmp = approxPow.compareTo(x);\n            } while (approxCmp > 0);\n        }\n        else {\n            BigInteger nextPow = BigInteger.TEN.multiply(approxPow);\n            for (int nextCmp = nextPow.compareTo(x); nextCmp <= 0; nextCmp = nextPow.compareTo(x)) {\n                ++approxLog10;\n                approxPow = nextPow;\n                approxCmp = nextCmp;\n                nextPow = BigInteger.TEN.multiply(approxPow);\n            }\n        }\n        final int floorLog = approxLog10;\n        final BigInteger floorPow = approxPow;\n        final int floorCmp = approxCmp;\n        switch (mode) {\n            case UNNECESSARY: {\n                MathPreconditions.checkRoundingUnnecessary(floorCmp == 0);\n            }\n            case DOWN:\n            case FLOOR: {\n                return floorLog;\n            }\n            case UP:\n            case CEILING: {\n                return floorPow.equals(x) ? floorLog : (floorLog + 1);\n            }\n            case HALF_DOWN:\n            case HALF_UP:\n            case HALF_EVEN: {\n                final BigInteger x2 = x.pow(2);\n                final BigInteger halfPowerSquared = floorPow.pow(2).multiply(BigInteger.TEN);\n                return (x2.compareTo(halfPowerSquared) <= 0) ? floorLog : (floorLog + 1);\n            }\n            default: {\n                throw new AssertionError();\n            }\n        }\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    public static BigInteger sqrt(final BigInteger x, final RoundingMode mode) {\n        MathPreconditions.checkNonNegative(\"x\", x);\n        if (fitsInLong(x)) {\n            return BigInteger.valueOf(LongMath.sqrt(x.longValue(), mode));\n        }\n        final BigInteger sqrtFloor = sqrtFloor(x);\n        switch (mode) {\n            case UNNECESSARY: {\n                MathPreconditions.checkRoundingUnnecessary(sqrtFloor.pow(2).equals(x));\n            }\n            case DOWN:\n            case FLOOR: {\n                return sqrtFloor;\n            }\n            case UP:\n            case CEILING: {\n                final int sqrtFloorInt = sqrtFloor.intValue();\n                final boolean sqrtFloorIsExact = sqrtFloorInt * sqrtFloorInt == x.intValue() && sqrtFloor.pow(2).equals(x);\n                return sqrtFloorIsExact ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n            }\n            case HALF_DOWN:\n            case HALF_UP:\n            case HALF_EVEN: {\n                final BigInteger halfSquare = sqrtFloor.pow(2).add(sqrtFloor);\n                return (halfSquare.compareTo(x) >= 0) ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n            }\n            default: {\n                throw new AssertionError();\n            }\n        }\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    private static BigInteger sqrtFloor(final BigInteger x) {\n        final int log2 = log2(x, RoundingMode.FLOOR);\n        BigInteger sqrt0;\n        if (log2 < 1023) {\n            sqrt0 = sqrtApproxWithDoubles(x);\n        }\n        else {\n            final int shift = log2 - 52 & 0xFFFFFFFE;\n            sqrt0 = sqrtApproxWithDoubles(x.shiftRight(shift)).shiftLeft(shift >> 1);\n        }\n        BigInteger sqrt2 = sqrt0.add(x.divide(sqrt0)).shiftRight(1);\n        if (sqrt0.equals(sqrt2)) {\n            return sqrt0;\n        }\n        do {\n            sqrt0 = sqrt2;\n            sqrt2 = sqrt0.add(x.divide(sqrt0)).shiftRight(1);\n        } while (sqrt2.compareTo(sqrt0) < 0);\n        return sqrt0;\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    private static BigInteger sqrtApproxWithDoubles(final BigInteger x) {\n        return DoubleMath.roundToBigInteger(Math.sqrt(DoubleUtils.bigToDouble(x)), RoundingMode.HALF_EVEN);\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    public static BigInteger divide(final BigInteger p, final BigInteger q, final RoundingMode mode) {\n        final BigDecimal pDec = new BigDecimal(p);\n        final BigDecimal qDec = new BigDecimal(q);\n        return pDec.divide(qDec, 0, mode).toBigIntegerExact();\n    }\n    \n    public static BigInteger factorial(final int n) {\n        MathPreconditions.checkNonNegative(\"n\", n);\n        if (n < LongMath.factorials.length) {\n            return BigInteger.valueOf(LongMath.factorials[n]);\n        }\n        final int approxSize = IntMath.divide(n * IntMath.log2(n, RoundingMode.CEILING), 64, RoundingMode.CEILING);\n        final ArrayList<BigInteger> bignums = new ArrayList<BigInteger>(approxSize);\n        final int startingNumber = LongMath.factorials.length;\n        long product = LongMath.factorials[startingNumber - 1];\n        int shift = Long.numberOfTrailingZeros(product);\n        product >>= shift;\n        int productBits = LongMath.log2(product, RoundingMode.FLOOR) + 1;\n        int bits = LongMath.log2(startingNumber, RoundingMode.FLOOR) + 1;\n        int nextPowerOfTwo = 1 << bits - 1;\n        for (long num = startingNumber; num <= n; ++num) {\n            if ((num & nextPowerOfTwo) != 0x0L) {\n                nextPowerOfTwo <<= 1;\n                ++bits;\n            }\n            final int tz = Long.numberOfTrailingZeros(num);\n            final long normalizedNum = num >> tz;\n            shift += tz;\n            final int normalizedBits = bits - tz;\n            if (normalizedBits + productBits >= 64) {\n                bignums.add(BigInteger.valueOf(product));\n                product = 1L;\n                productBits = 0;\n            }\n            product *= normalizedNum;\n            productBits = LongMath.log2(product, RoundingMode.FLOOR) + 1;\n        }\n        if (product > 1L) {\n            bignums.add(BigInteger.valueOf(product));\n        }\n        return listProduct(bignums).shiftLeft(shift);\n    }\n    \n    static BigInteger listProduct(final List<BigInteger> nums) {\n        return listProduct(nums, 0, nums.size());\n    }\n    \n    static BigInteger listProduct(final List<BigInteger> nums, final int start, final int end) {\n        switch (end - start) {\n            case 0: {\n                return BigInteger.ONE;\n            }\n            case 1: {\n                return nums.get(start);\n            }\n            case 2: {\n                return nums.get(start).multiply(nums.get(start + 1));\n            }\n            case 3: {\n                return nums.get(start).multiply(nums.get(start + 1)).multiply(nums.get(start + 2));\n            }\n            default: {\n                final int m = end + start >>> 1;\n                return listProduct(nums, start, m).multiply(listProduct(nums, m, end));\n            }\n        }\n    }\n    \n    public static BigInteger binomial(final int n, int k) {\n        MathPreconditions.checkNonNegative(\"n\", n);\n        MathPreconditions.checkNonNegative(\"k\", k);\n        Preconditions.checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n        if (k > n >> 1) {\n            k = n - k;\n        }\n        if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {\n            return BigInteger.valueOf(LongMath.binomial(n, k));\n        }\n        BigInteger accum = BigInteger.ONE;\n        long numeratorAccum = n;\n        long denominatorAccum = 1L;\n        int numeratorBits;\n        final int bits = numeratorBits = LongMath.log2(n, RoundingMode.CEILING);\n        for (int i = 1; i < k; ++i) {\n            final int p = n - i;\n            final int q = i + 1;\n            if (numeratorBits + bits >= 63) {\n                accum = accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));\n                numeratorAccum = p;\n                denominatorAccum = q;\n                numeratorBits = bits;\n            }\n            else {\n                numeratorAccum *= p;\n                denominatorAccum *= q;\n                numeratorBits += bits;\n            }\n        }\n        return accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    static boolean fitsInLong(final BigInteger x) {\n        return x.bitLength() <= 63;\n    }\n    \n    static {\n        SQRT2_PRECOMPUTED_BITS = new BigInteger(\"16a09e667f3bcc908b2fb1366ea957d3e3adec17512775099da2f590b0667322a\", 16);\n        LN_10 = Math.log(10.0);\n        LN_2 = Math.log(2.0);\n    }\n}\n",
        "token_number_zeroshot": 2486,
        "token_number_fewshot": 2884,
        "token_number_cot": 2597
    },
    {
        "project_name": "guava",
        "class": "CacheBuilderSpec",
        "source_code": "package com.google.common.cache;\n\nimport com.google.common.annotations.*;\nimport java.util.concurrent.*;\nimport com.google.common.collect.*;\nimport java.util.*;\nimport com.google.common.base.*;\nimport javax.annotation.*;\n\n@Beta\npublic final class CacheBuilderSpec\n{\n    private static final Splitter KEYS_SPLITTER;\n    private static final Splitter KEY_VALUE_SPLITTER;\n    private static final ImmutableMap<String, ValueParser> VALUE_PARSERS;\n    @VisibleForTesting\n    Integer initialCapacity;\n    @VisibleForTesting\n    Long maximumSize;\n    @VisibleForTesting\n    Long maximumWeight;\n    @VisibleForTesting\n    Integer concurrencyLevel;\n    @VisibleForTesting\n    LocalCache.Strength keyStrength;\n    @VisibleForTesting\n    LocalCache.Strength valueStrength;\n    @VisibleForTesting\n    Boolean recordStats;\n    @VisibleForTesting\n    long writeExpirationDuration;\n    @VisibleForTesting\n    TimeUnit writeExpirationTimeUnit;\n    @VisibleForTesting\n    long accessExpirationDuration;\n    @VisibleForTesting\n    TimeUnit accessExpirationTimeUnit;\n    @VisibleForTesting\n    long refreshDuration;\n    @VisibleForTesting\n    TimeUnit refreshTimeUnit;\n    private final String specification;\n    \n    private CacheBuilderSpec(final String specification) {\n        this.specification = specification;\n    }\n    \n    public static CacheBuilderSpec parse(final String cacheBuilderSpecification) {\n        final CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);\n        if (!cacheBuilderSpecification.isEmpty()) {\n            for (final String keyValuePair : CacheBuilderSpec.KEYS_SPLITTER.split(cacheBuilderSpecification)) {\n                final List<String> keyAndValue = (List<String>)ImmutableList.copyOf((Iterable<?>)CacheBuilderSpec.KEY_VALUE_SPLITTER.split(keyValuePair));\n                Preconditions.checkArgument(!keyAndValue.isEmpty(), (Object)\"blank key-value pair\");\n                Preconditions.checkArgument(keyAndValue.size() <= 2, \"key-value pair %s with more than one equals sign\", keyValuePair);\n                final String key = keyAndValue.get(0);\n                final ValueParser valueParser = CacheBuilderSpec.VALUE_PARSERS.get(key);\n                Preconditions.checkArgument(valueParser != null, \"unknown key %s\", key);\n                final String value = (keyAndValue.size() == 1) ? null : keyAndValue.get(1);\n                valueParser.parse(spec, key, value);\n            }\n        }\n        return spec;\n    }\n    \n    public static CacheBuilderSpec disableCaching() {\n        return parse(\"maximumSize=0\");\n    }\n    \n    CacheBuilder<Object, Object> toCacheBuilder() {\n        final CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();\n        if (this.initialCapacity != null) {\n            builder.initialCapacity(this.initialCapacity);\n        }\n        if (this.maximumSize != null) {\n            builder.maximumSize(this.maximumSize);\n        }\n        if (this.maximumWeight != null) {\n            builder.maximumWeight(this.maximumWeight);\n        }\n        if (this.concurrencyLevel != null) {\n            builder.concurrencyLevel(this.concurrencyLevel);\n        }\n        if (this.keyStrength != null) {\n            switch (this.keyStrength) {\n                case WEAK: {\n                    builder.weakKeys();\n                    break;\n                }\n                default: {\n                    throw new AssertionError();\n                }\n            }\n        }\n        if (this.valueStrength != null) {\n            switch (this.valueStrength) {\n                case SOFT: {\n                    builder.softValues();\n                    break;\n                }\n                case WEAK: {\n                    builder.weakValues();\n                    break;\n                }\n                default: {\n                    throw new AssertionError();\n                }\n            }\n        }\n        if (this.recordStats != null && this.recordStats) {\n            builder.recordStats();\n        }\n        if (this.writeExpirationTimeUnit != null) {\n            builder.expireAfterWrite(this.writeExpirationDuration, this.writeExpirationTimeUnit);\n        }\n        if (this.accessExpirationTimeUnit != null) {\n            builder.expireAfterAccess(this.accessExpirationDuration, this.accessExpirationTimeUnit);\n        }\n        if (this.refreshTimeUnit != null) {\n            builder.refreshAfterWrite(this.refreshDuration, this.refreshTimeUnit);\n        }\n        return builder;\n    }\n    \n    public String toParsableString() {\n        return this.specification;\n    }\n    \n    @Override\n    public String toString() {\n        return MoreObjects.toStringHelper(this).addValue(this.toParsableString()).toString();\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hashCode(this.initialCapacity, this.maximumSize, this.maximumWeight, this.concurrencyLevel, this.keyStrength, this.valueStrength, this.recordStats, durationInNanos(this.writeExpirationDuration, this.writeExpirationTimeUnit), durationInNanos(this.accessExpirationDuration, this.accessExpirationTimeUnit), durationInNanos(this.refreshDuration, this.refreshTimeUnit));\n    }\n    \n    @Override\n    public boolean equals(@Nullable final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof CacheBuilderSpec)) {\n            return false;\n        }\n        final CacheBuilderSpec that = (CacheBuilderSpec)obj;\n        return Objects.equal(this.initialCapacity, that.initialCapacity) && Objects.equal(this.maximumSize, that.maximumSize) && Objects.equal(this.maximumWeight, that.maximumWeight) && Objects.equal(this.concurrencyLevel, that.concurrencyLevel) && Objects.equal(this.keyStrength, that.keyStrength) && Objects.equal(this.valueStrength, that.valueStrength) && Objects.equal(this.recordStats, that.recordStats) && Objects.equal(durationInNanos(this.writeExpirationDuration, this.writeExpirationTimeUnit), durationInNanos(that.writeExpirationDuration, that.writeExpirationTimeUnit)) && Objects.equal(durationInNanos(this.accessExpirationDuration, this.accessExpirationTimeUnit), durationInNanos(that.accessExpirationDuration, that.accessExpirationTimeUnit)) && Objects.equal(durationInNanos(this.refreshDuration, this.refreshTimeUnit), durationInNanos(that.refreshDuration, that.refreshTimeUnit));\n    }\n    \n    @Nullable\n    private static Long durationInNanos(final long duration, @Nullable final TimeUnit unit) {\n        return (unit == null) ? null : unit.toNanos(duration);\n    }\n    \n    static {\n        KEYS_SPLITTER = Splitter.on(',').trimResults();\n        KEY_VALUE_SPLITTER = Splitter.on('=').trimResults();\n        VALUE_PARSERS = ImmutableMap.builder().put(\"initialCapacity\", new InitialCapacityParser()).put(\"maximumSize\", (InitialCapacityParser)new MaximumSizeParser()).put(\"maximumWeight\", (InitialCapacityParser)new MaximumWeightParser()).put(\"concurrencyLevel\", (InitialCapacityParser)new ConcurrencyLevelParser()).put(\"weakKeys\", (InitialCapacityParser)new KeyStrengthParser(LocalCache.Strength.WEAK)).put(\"softValues\", (InitialCapacityParser)new ValueStrengthParser(LocalCache.Strength.SOFT)).put(\"weakValues\", (InitialCapacityParser)new ValueStrengthParser(LocalCache.Strength.WEAK)).put(\"recordStats\", (InitialCapacityParser)new RecordStatsParser()).put(\"expireAfterAccess\", (InitialCapacityParser)new AccessDurationParser()).put(\"expireAfterWrite\", (InitialCapacityParser)new WriteDurationParser()).put(\"refreshAfterWrite\", (InitialCapacityParser)new RefreshDurationParser()).put(\"refreshInterval\", (InitialCapacityParser)new RefreshDurationParser()).build();\n    }\n    \n    abstract static class IntegerParser implements ValueParser\n    {\n        protected abstract void parseInteger(final CacheBuilderSpec p0, final int p1);\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, final String value) {\n            Preconditions.checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try {\n                this.parseInteger(spec, Integer.parseInt(value));\n            }\n            catch (NumberFormatException e) {\n                throw new IllegalArgumentException(String.format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n    \n    abstract static class LongParser implements ValueParser\n    {\n        protected abstract void parseLong(final CacheBuilderSpec p0, final long p1);\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, final String value) {\n            Preconditions.checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try {\n                this.parseLong(spec, Long.parseLong(value));\n            }\n            catch (NumberFormatException e) {\n                throw new IllegalArgumentException(String.format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n    \n    static class InitialCapacityParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(final CacheBuilderSpec spec, final int value) {\n            Preconditions.checkArgument(spec.initialCapacity == null, \"initial capacity was already set to \", spec.initialCapacity);\n            spec.initialCapacity = value;\n        }\n    }\n    \n    static class MaximumSizeParser extends LongParser\n    {\n        @Override\n        protected void parseLong(final CacheBuilderSpec spec, final long value) {\n            Preconditions.checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            Preconditions.checkArgument(spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            spec.maximumSize = value;\n        }\n    }\n    \n    static class MaximumWeightParser extends LongParser\n    {\n        @Override\n        protected void parseLong(final CacheBuilderSpec spec, final long value) {\n            Preconditions.checkArgument(spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            Preconditions.checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            spec.maximumWeight = value;\n        }\n    }\n    \n    static class ConcurrencyLevelParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(final CacheBuilderSpec spec, final int value) {\n            Preconditions.checkArgument(spec.concurrencyLevel == null, \"concurrency level was already set to \", spec.concurrencyLevel);\n            spec.concurrencyLevel = value;\n        }\n    }\n    \n    static class KeyStrengthParser implements ValueParser\n    {\n        private final LocalCache.Strength strength;\n        \n        public KeyStrengthParser(final LocalCache.Strength strength) {\n            this.strength = strength;\n        }\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, @Nullable final String value) {\n            Preconditions.checkArgument(value == null, \"key %s does not take values\", key);\n            Preconditions.checkArgument(spec.keyStrength == null, \"%s was already set to %s\", key, spec.keyStrength);\n            spec.keyStrength = this.strength;\n        }\n    }\n    \n    static class ValueStrengthParser implements ValueParser\n    {\n        private final LocalCache.Strength strength;\n        \n        public ValueStrengthParser(final LocalCache.Strength strength) {\n            this.strength = strength;\n        }\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, @Nullable final String value) {\n            Preconditions.checkArgument(value == null, \"key %s does not take values\", key);\n            Preconditions.checkArgument(spec.valueStrength == null, \"%s was already set to %s\", key, spec.valueStrength);\n            spec.valueStrength = this.strength;\n        }\n    }\n    \n    static class RecordStatsParser implements ValueParser\n    {\n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, @Nullable final String value) {\n            Preconditions.checkArgument(value == null, (Object)\"recordStats does not take values\");\n            Preconditions.checkArgument(spec.recordStats == null, (Object)\"recordStats already set\");\n            spec.recordStats = true;\n        }\n    }\n    \n    abstract static class DurationParser implements ValueParser\n    {\n        protected abstract void parseDuration(final CacheBuilderSpec p0, final long p1, final TimeUnit p2);\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, final String value) {\n            Preconditions.checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try {\n                final char lastChar = value.charAt(value.length() - 1);\n                TimeUnit timeUnit = null;\n                switch (lastChar) {\n                    case 'd': {\n                        timeUnit = TimeUnit.DAYS;\n                        break;\n                    }\n                    case 'h': {\n                        timeUnit = TimeUnit.HOURS;\n                        break;\n                    }\n                    case 'm': {\n                        timeUnit = TimeUnit.MINUTES;\n                        break;\n                    }\n                    case 's': {\n                        timeUnit = TimeUnit.SECONDS;\n                        break;\n                    }\n                    default: {\n                        throw new IllegalArgumentException(String.format(\"key %s invalid format.  was %s, must end with one of [dDhHmMsS]\", key, value));\n                    }\n                }\n                final long duration = Long.parseLong(value.substring(0, value.length() - 1));\n                this.parseDuration(spec, duration, timeUnit);\n            }\n            catch (NumberFormatException e) {\n                throw new IllegalArgumentException(String.format(\"key %s value set to %s, must be integer\", key, value));\n            }\n        }\n    }\n    \n    static class AccessDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(final CacheBuilderSpec spec, final long duration, final TimeUnit unit) {\n            Preconditions.checkArgument(spec.accessExpirationTimeUnit == null, (Object)\"expireAfterAccess already set\");\n            spec.accessExpirationDuration = duration;\n            spec.accessExpirationTimeUnit = unit;\n        }\n    }\n    \n    static class WriteDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(final CacheBuilderSpec spec, final long duration, final TimeUnit unit) {\n            Preconditions.checkArgument(spec.writeExpirationTimeUnit == null, (Object)\"expireAfterWrite already set\");\n            spec.writeExpirationDuration = duration;\n            spec.writeExpirationTimeUnit = unit;\n        }\n    }\n    \n    static class RefreshDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(final CacheBuilderSpec spec, final long duration, final TimeUnit unit) {\n            Preconditions.checkArgument(spec.refreshTimeUnit == null, (Object)\"refreshAfterWrite already set\");\n            spec.refreshDuration = duration;\n            spec.refreshTimeUnit = unit;\n        }\n    }\n    \n    private interface ValueParser\n    {\n        void parse(final CacheBuilderSpec p0, final String p1, @Nullable final String p2);\n    }\n}\n",
        "token_number_zeroshot": 3033,
        "token_number_fewshot": 3431,
        "token_number_cot": 3145
    },
    {
        "project_name": "guava",
        "class": "Splitter",
        "source_code": "package com.google.common.base;\n\nimport java.util.regex.*;\nimport javax.annotation.*;\nimport com.google.common.annotations.*;\nimport java.util.*;\n\n@GwtCompatible(emulated = true)\npublic final class Splitter\n{\n    private final CharMatcher trimmer;\n    private final boolean omitEmptyStrings;\n    private final Strategy strategy;\n    private final int limit;\n    \n    private Splitter(final Strategy strategy) {\n        this(strategy, false, CharMatcher.NONE, Integer.MAX_VALUE);\n    }\n    \n    private Splitter(final Strategy strategy, final boolean omitEmptyStrings, final CharMatcher trimmer, final int limit) {\n        this.strategy = strategy;\n        this.omitEmptyStrings = omitEmptyStrings;\n        this.trimmer = trimmer;\n        this.limit = limit;\n    }\n    \n    public static Splitter on(final char separator) {\n        return on(CharMatcher.is(separator));\n    }\n    \n    public static Splitter on(final CharMatcher separatorMatcher) {\n        Preconditions.checkNotNull(separatorMatcher);\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                return new SplittingIterator(splitter, toSplit) {\n                    @Override\n                    int separatorStart(final int start) {\n                        return separatorMatcher.indexIn(this.toSplit, start);\n                    }\n                    \n                    @Override\n                    int separatorEnd(final int separatorPosition) {\n                        return separatorPosition + 1;\n                    }\n                };\n            }\n        });\n    }\n    \n    public static Splitter on(final String separator) {\n        Preconditions.checkArgument(separator.length() != 0, (Object)\"The separator may not be the empty string.\");\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                return new SplittingIterator(splitter, toSplit) {\n                    public int separatorStart(final int start) {\n                        final int separatorLength = separator.length();\n                        int p = start;\n                        final int last = this.toSplit.length() - separatorLength;\n                    Label_0026:\n                        while (p <= last) {\n                            for (int i = 0; i < separatorLength; ++i) {\n                                if (this.toSplit.charAt(i + p) != separator.charAt(i)) {\n                                    ++p;\n                                    continue Label_0026;\n                                }\n                            }\n                            return p;\n                        }\n                        return -1;\n                    }\n                    \n                    public int separatorEnd(final int separatorPosition) {\n                        return separatorPosition + separator.length();\n                    }\n                };\n            }\n        });\n    }\n    \n    @GwtIncompatible(\"java.util.regex\")\n    public static Splitter on(final Pattern separatorPattern) {\n        Preconditions.checkNotNull(separatorPattern);\n        Preconditions.checkArgument(!separatorPattern.matcher(\"\").matches(), \"The pattern may not match the empty string: %s\", separatorPattern);\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                final Matcher matcher = separatorPattern.matcher(toSplit);\n                return new SplittingIterator(splitter, toSplit) {\n                    public int separatorStart(final int start) {\n                        return matcher.find(start) ? matcher.start() : -1;\n                    }\n                    \n                    public int separatorEnd(final int separatorPosition) {\n                        return matcher.end();\n                    }\n                };\n            }\n        });\n    }\n    \n    @GwtIncompatible(\"java.util.regex\")\n    public static Splitter onPattern(final String separatorPattern) {\n        return on(Pattern.compile(separatorPattern));\n    }\n    \n    public static Splitter fixedLength(final int length) {\n        Preconditions.checkArgument(length > 0, (Object)\"The length may not be less than 1\");\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                return new SplittingIterator(splitter, toSplit) {\n                    public int separatorStart(final int start) {\n                        final int nextChunkStart = start + length;\n                        return (nextChunkStart < this.toSplit.length()) ? nextChunkStart : -1;\n                    }\n                    \n                    public int separatorEnd(final int separatorPosition) {\n                        return separatorPosition;\n                    }\n                };\n            }\n        });\n    }\n    \n    @CheckReturnValue\n    public Splitter omitEmptyStrings() {\n        return new Splitter(this.strategy, true, this.trimmer, this.limit);\n    }\n    \n    @CheckReturnValue\n    public Splitter limit(final int limit) {\n        Preconditions.checkArgument(limit > 0, \"must be greater than zero: %s\", limit);\n        return new Splitter(this.strategy, this.omitEmptyStrings, this.trimmer, limit);\n    }\n    \n    @CheckReturnValue\n    public Splitter trimResults() {\n        return this.trimResults(CharMatcher.WHITESPACE);\n    }\n    \n    @CheckReturnValue\n    public Splitter trimResults(final CharMatcher trimmer) {\n        Preconditions.checkNotNull(trimmer);\n        return new Splitter(this.strategy, this.omitEmptyStrings, trimmer, this.limit);\n    }\n    \n    public Iterable<String> split(final CharSequence sequence) {\n        Preconditions.checkNotNull(sequence);\n        return new Iterable<String>() {\n            @Override\n            public Iterator<String> iterator() {\n                return Splitter.this.splittingIterator(sequence);\n            }\n            \n            @Override\n            public String toString() {\n                return Joiner.on(\", \").appendTo(new StringBuilder().append('['), (Iterable<?>)this).append(']').toString();\n            }\n        };\n    }\n    \n    private Iterator<String> splittingIterator(final CharSequence sequence) {\n        return this.strategy.iterator(this, sequence);\n    }\n    \n    @Beta\n    public List<String> splitToList(final CharSequence sequence) {\n        Preconditions.checkNotNull(sequence);\n        final Iterator<String> iterator = this.splittingIterator(sequence);\n        final List<String> result = new ArrayList<String>();\n        while (iterator.hasNext()) {\n            result.add(iterator.next());\n        }\n        return Collections.unmodifiableList((List<? extends String>)result);\n    }\n    \n    @CheckReturnValue\n    @Beta\n    public MapSplitter withKeyValueSeparator(final String separator) {\n        return this.withKeyValueSeparator(on(separator));\n    }\n    \n    @CheckReturnValue\n    @Beta\n    public MapSplitter withKeyValueSeparator(final char separator) {\n        return this.withKeyValueSeparator(on(separator));\n    }\n    \n    @CheckReturnValue\n    @Beta\n    public MapSplitter withKeyValueSeparator(final Splitter keyValueSplitter) {\n        return new MapSplitter(this, keyValueSplitter);\n    }\n    \n    @Beta\n    public static final class MapSplitter\n    {\n        private static final String INVALID_ENTRY_MESSAGE = \"Chunk [%s] is not a valid entry\";\n        private final Splitter outerSplitter;\n        private final Splitter entrySplitter;\n        \n        private MapSplitter(final Splitter outerSplitter, final Splitter entrySplitter) {\n            this.outerSplitter = outerSplitter;\n            this.entrySplitter = Preconditions.checkNotNull(entrySplitter);\n        }\n        \n        public Map<String, String> split(final CharSequence sequence) {\n            final Map<String, String> map = new LinkedHashMap<String, String>();\n            for (final String entry : this.outerSplitter.split(sequence)) {\n                final Iterator<String> entryFields = this.entrySplitter.splittingIterator(entry);\n                Preconditions.checkArgument(entryFields.hasNext(), \"Chunk [%s] is not a valid entry\", entry);\n                final String key = entryFields.next();\n                Preconditions.checkArgument(!map.containsKey(key), \"Duplicate key [%s] found.\", key);\n                Preconditions.checkArgument(entryFields.hasNext(), \"Chunk [%s] is not a valid entry\", entry);\n                final String value = entryFields.next();\n                map.put(key, value);\n                Preconditions.checkArgument(!entryFields.hasNext(), \"Chunk [%s] is not a valid entry\", entry);\n            }\n            return Collections.unmodifiableMap((Map<? extends String, ? extends String>)map);\n        }\n    }\n    \n    private abstract static class SplittingIterator extends AbstractIterator<String>\n    {\n        final CharSequence toSplit;\n        final CharMatcher trimmer;\n        final boolean omitEmptyStrings;\n        int offset;\n        int limit;\n        \n        abstract int separatorStart(final int p0);\n        \n        abstract int separatorEnd(final int p0);\n        \n        protected SplittingIterator(final Splitter splitter, final CharSequence toSplit) {\n            this.offset = 0;\n            this.trimmer = splitter.trimmer;\n            this.omitEmptyStrings = splitter.omitEmptyStrings;\n            this.limit = splitter.limit;\n            this.toSplit = toSplit;\n        }\n        \n        @Override\n        protected String computeNext() {\n            int nextStart = this.offset;\n            while (this.offset != -1) {\n                int start = nextStart;\n                final int separatorPosition = this.separatorStart(this.offset);\n                int end;\n                if (separatorPosition == -1) {\n                    end = this.toSplit.length();\n                    this.offset = -1;\n                }\n                else {\n                    end = separatorPosition;\n                    this.offset = this.separatorEnd(separatorPosition);\n                }\n                if (this.offset == nextStart) {\n                    ++this.offset;\n                    if (this.offset < this.toSplit.length()) {\n                        continue;\n                    }\n                    this.offset = -1;\n                }\n                else {\n                    while (start < end && this.trimmer.matches(this.toSplit.charAt(start))) {\n                        ++start;\n                    }\n                    while (end > start && this.trimmer.matches(this.toSplit.charAt(end - 1))) {\n                        --end;\n                    }\n                    if (!this.omitEmptyStrings || start != end) {\n                        if (this.limit == 1) {\n                            end = this.toSplit.length();\n                            this.offset = -1;\n                            while (end > start && this.trimmer.matches(this.toSplit.charAt(end - 1))) {\n                                --end;\n                            }\n                        }\n                        else {\n                            --this.limit;\n                        }\n                        return this.toSplit.subSequence(start, end).toString();\n                    }\n                    nextStart = this.offset;\n                }\n            }\n            return this.endOfData();\n        }\n    }\n    \n    private interface Strategy\n    {\n        Iterator<String> iterator(final Splitter p0, final CharSequence p1);\n    }\n}\n",
        "token_number_zeroshot": 2130,
        "token_number_fewshot": 2528,
        "token_number_cot": 2241
    },
    {
        "project_name": "guava",
        "class": "Predicates",
        "source_code": "package com.google.common.base;\n\nimport javax.annotation.*;\nimport com.google.common.annotations.*;\nimport java.util.regex.*;\nimport java.util.*;\nimport java.io.*;\n\n@GwtCompatible(emulated = true)\npublic final class Predicates\n{\n    private static final Joiner COMMA_JOINER;\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> alwaysTrue() {\n        return ObjectPredicate.ALWAYS_TRUE.withNarrowedType();\n    }\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> alwaysFalse() {\n        return ObjectPredicate.ALWAYS_FALSE.withNarrowedType();\n    }\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> isNull() {\n        return ObjectPredicate.IS_NULL.withNarrowedType();\n    }\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> notNull() {\n        return ObjectPredicate.NOT_NULL.withNarrowedType();\n    }\n    \n    public static <T> Predicate<T> not(final Predicate<T> predicate) {\n        return new NotPredicate<T>(predicate);\n    }\n    \n    public static <T> Predicate<T> and(final Iterable<? extends Predicate<? super T>> components) {\n        return new AndPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> and(final Predicate<? super T>... components) {\n        return new AndPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> and(final Predicate<? super T> first, final Predicate<? super T> second) {\n        return new AndPredicate<T>((List)asList(Preconditions.checkNotNull(first), Preconditions.checkNotNull(second)));\n    }\n    \n    public static <T> Predicate<T> or(final Iterable<? extends Predicate<? super T>> components) {\n        return new OrPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> or(final Predicate<? super T>... components) {\n        return new OrPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> or(final Predicate<? super T> first, final Predicate<? super T> second) {\n        return new OrPredicate<T>((List)asList(Preconditions.checkNotNull(first), Preconditions.checkNotNull(second)));\n    }\n    \n    public static <T> Predicate<T> equalTo(@Nullable final T target) {\n        return (target == null) ? isNull() : new IsEqualToPredicate<T>((Object)target);\n    }\n    \n    @GwtIncompatible(\"Class.isInstance\")\n    public static Predicate<Object> instanceOf(final Class<?> clazz) {\n        return new InstanceOfPredicate((Class)clazz);\n    }\n    \n    @GwtIncompatible(\"Class.isAssignableFrom\")\n    @Beta\n    public static Predicate<Class<?>> assignableFrom(final Class<?> clazz) {\n        return new AssignableFromPredicate((Class)clazz);\n    }\n    \n    public static <T> Predicate<T> in(final Collection<? extends T> target) {\n        return new InPredicate<T>((Collection)target);\n    }\n    \n    public static <A, B> Predicate<A> compose(final Predicate<B> predicate, final Function<A, ? extends B> function) {\n        return new CompositionPredicate<A, Object>((Predicate)predicate, (Function)function);\n    }\n    \n    @GwtIncompatible(\"java.util.regex.Pattern\")\n    public static Predicate<CharSequence> containsPattern(final String pattern) {\n        return new ContainsPatternFromStringPredicate(pattern);\n    }\n    \n    @GwtIncompatible(\"java.util.regex.Pattern\")\n    public static Predicate<CharSequence> contains(final Pattern pattern) {\n        return new ContainsPatternPredicate(pattern);\n    }\n    \n    private static <T> List<Predicate<? super T>> asList(final Predicate<? super T> first, final Predicate<? super T> second) {\n        return Arrays.asList(first, second);\n    }\n    \n    private static <T> List<T> defensiveCopy(final T... array) {\n        return defensiveCopy(Arrays.asList(array));\n    }\n    \n    static <T> List<T> defensiveCopy(final Iterable<T> iterable) {\n        final ArrayList<T> list = new ArrayList<T>();\n        for (final T element : iterable) {\n            list.add(Preconditions.checkNotNull(element));\n        }\n        return list;\n    }\n    \n    static {\n        COMMA_JOINER = Joiner.on(',');\n    }\n    \n    enum ObjectPredicate implements Predicate<Object>\n    {\n        ALWAYS_TRUE {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return true;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.alwaysTrue()\";\n            }\n        }, \n        ALWAYS_FALSE {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return false;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.alwaysFalse()\";\n            }\n        }, \n        IS_NULL {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return o == null;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.isNull()\";\n            }\n        }, \n        NOT_NULL {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return o != null;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.notNull()\";\n            }\n        };\n        \n         <T> Predicate<T> withNarrowedType() {\n            return (Predicate<T>)this;\n        }\n    }\n    \n    private static class NotPredicate<T> implements Predicate<T>, Serializable\n    {\n        final Predicate<T> predicate;\n        private static final long serialVersionUID = 0L;\n        \n        NotPredicate(final Predicate<T> predicate) {\n            this.predicate = Preconditions.checkNotNull(predicate);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            return !this.predicate.apply(t);\n        }\n        \n        @Override\n        public int hashCode() {\n            return ~this.predicate.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof NotPredicate) {\n                final NotPredicate<?> that = (NotPredicate<?>)obj;\n                return this.predicate.equals(that.predicate);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.predicate.toString()));\n            return new StringBuilder(16 + value.length()).append(\"Predicates.not(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class AndPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final List<? extends Predicate<? super T>> components;\n        private static final long serialVersionUID = 0L;\n        \n        private AndPredicate(final List<? extends Predicate<? super T>> components) {\n            this.components = components;\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            for (int i = 0; i < this.components.size(); ++i) {\n                if (!((Predicate)this.components.get(i)).apply(t)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.components.hashCode() + 306654252;\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof AndPredicate) {\n                final AndPredicate<?> that = (AndPredicate<?>)obj;\n                return this.components.equals(that.components);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(Predicates.COMMA_JOINER.join(this.components)));\n            return new StringBuilder(16 + value.length()).append(\"Predicates.and(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class OrPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final List<? extends Predicate<? super T>> components;\n        private static final long serialVersionUID = 0L;\n        \n        private OrPredicate(final List<? extends Predicate<? super T>> components) {\n            this.components = components;\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            for (int i = 0; i < this.components.size(); ++i) {\n                if (((Predicate)this.components.get(i)).apply(t)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.components.hashCode() + 87855567;\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof OrPredicate) {\n                final OrPredicate<?> that = (OrPredicate<?>)obj;\n                return this.components.equals(that.components);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(Predicates.COMMA_JOINER.join(this.components)));\n            return new StringBuilder(15 + value.length()).append(\"Predicates.or(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class IsEqualToPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final T target;\n        private static final long serialVersionUID = 0L;\n        \n        private IsEqualToPredicate(final T target) {\n            this.target = target;\n        }\n        \n        @Override\n        public boolean apply(final T t) {\n            return this.target.equals(t);\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.target.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof IsEqualToPredicate) {\n                final IsEqualToPredicate<?> that = (IsEqualToPredicate<?>)obj;\n                return this.target.equals(that.target);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.target));\n            return new StringBuilder(20 + value.length()).append(\"Predicates.equalTo(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Class.isInstance\")\n    private static class InstanceOfPredicate implements Predicate<Object>, Serializable\n    {\n        private final Class<?> clazz;\n        private static final long serialVersionUID = 0L;\n        \n        private InstanceOfPredicate(final Class<?> clazz) {\n            this.clazz = Preconditions.checkNotNull(clazz);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final Object o) {\n            return this.clazz.isInstance(o);\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.clazz.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof InstanceOfPredicate) {\n                final InstanceOfPredicate that = (InstanceOfPredicate)obj;\n                return this.clazz == that.clazz;\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.clazz.getName()));\n            return new StringBuilder(23 + value.length()).append(\"Predicates.instanceOf(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Class.isAssignableFrom\")\n    private static class AssignableFromPredicate implements Predicate<Class<?>>, Serializable\n    {\n        private final Class<?> clazz;\n        private static final long serialVersionUID = 0L;\n        \n        private AssignableFromPredicate(final Class<?> clazz) {\n            this.clazz = Preconditions.checkNotNull(clazz);\n        }\n        \n        @Override\n        public boolean apply(final Class<?> input) {\n            return this.clazz.isAssignableFrom(input);\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.clazz.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof AssignableFromPredicate) {\n                final AssignableFromPredicate that = (AssignableFromPredicate)obj;\n                return this.clazz == that.clazz;\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.clazz.getName()));\n            return new StringBuilder(27 + value.length()).append(\"Predicates.assignableFrom(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class InPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final Collection<?> target;\n        private static final long serialVersionUID = 0L;\n        \n        private InPredicate(final Collection<?> target) {\n            this.target = Preconditions.checkNotNull(target);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            try {\n                return this.target.contains(t);\n            }\n            catch (NullPointerException e) {\n                return false;\n            }\n            catch (ClassCastException e2) {\n                return false;\n            }\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof InPredicate) {\n                final InPredicate<?> that = (InPredicate<?>)obj;\n                return this.target.equals(that.target);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.target.hashCode();\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.target));\n            return new StringBuilder(15 + value.length()).append(\"Predicates.in(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class CompositionPredicate<A, B> implements Predicate<A>, Serializable\n    {\n        final Predicate<B> p;\n        final Function<A, ? extends B> f;\n        private static final long serialVersionUID = 0L;\n        \n        private CompositionPredicate(final Predicate<B> p, final Function<A, ? extends B> f) {\n            this.p = Preconditions.checkNotNull(p);\n            this.f = Preconditions.checkNotNull(f);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final A a) {\n            return this.p.apply((B)this.f.apply(a));\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof CompositionPredicate) {\n                final CompositionPredicate<?, ?> that = (CompositionPredicate<?, ?>)obj;\n                return this.f.equals(that.f) && this.p.equals(that.p);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.f.hashCode() ^ this.p.hashCode();\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.p.toString()));\n            final String value2 = String.valueOf(String.valueOf(this.f.toString()));\n            return new StringBuilder(2 + value.length() + value2.length()).append(value).append(\"(\").append(value2).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Only used by other GWT-incompatible code.\")\n    private static class ContainsPatternPredicate implements Predicate<CharSequence>, Serializable\n    {\n        final Pattern pattern;\n        private static final long serialVersionUID = 0L;\n        \n        ContainsPatternPredicate(final Pattern pattern) {\n            this.pattern = Preconditions.checkNotNull(pattern);\n        }\n        \n        @Override\n        public boolean apply(final CharSequence t) {\n            return this.pattern.matcher(t).find();\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hashCode(this.pattern.pattern(), this.pattern.flags());\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof ContainsPatternPredicate) {\n                final ContainsPatternPredicate that = (ContainsPatternPredicate)obj;\n                return Objects.equal(this.pattern.pattern(), that.pattern.pattern()) && Objects.equal(this.pattern.flags(), that.pattern.flags());\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String patternString = Objects.toStringHelper(this.pattern).add(\"pattern\", this.pattern.pattern()).add(\"pattern.flags\", this.pattern.flags()).toString();\n            final String value = String.valueOf(String.valueOf(patternString));\n            return new StringBuilder(21 + value.length()).append(\"Predicates.contains(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Only used by other GWT-incompatible code.\")\n    private static class ContainsPatternFromStringPredicate extends ContainsPatternPredicate\n    {\n        private static final long serialVersionUID = 0L;\n        \n        ContainsPatternFromStringPredicate(final String string) {\n            super(Pattern.compile(string));\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.pattern.pattern()));\n            return new StringBuilder(28 + value.length()).append(\"Predicates.containsPattern(\").append(value).append(\")\").toString();\n        }\n    }\n}\n",
        "token_number_zeroshot": 3513,
        "token_number_fewshot": 3911,
        "token_number_cot": 3624
    },
    {
        "project_name": "guava",
        "class": "Monitor",
        "source_code": "package com.google.common.util.concurrent;\n\nimport com.google.common.annotations.*;\nimport javax.annotation.concurrent.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\nimport com.google.common.base.*;\n\n@Beta\npublic final class Monitor\n{\n    private final boolean fair;\n    private final ReentrantLock lock;\n    @GuardedBy(\"lock\")\n    private Guard activeGuards;\n    \n    public Monitor() {\n        this(false);\n    }\n    \n    public Monitor(final boolean fair) {\n        this.activeGuards = null;\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n    \n    public void enter() {\n        this.lock.lock();\n    }\n    \n    public void enterInterruptibly() throws InterruptedException {\n        this.lock.lockInterruptibly();\n    }\n    \n    public boolean enter(final long time, final TimeUnit unit) {\n        long timeoutNanos = unit.toNanos(time);\n        final ReentrantLock lock = this.lock;\n        if (!this.fair && lock.tryLock()) {\n            return true;\n        }\n        final long deadline = System.nanoTime() + timeoutNanos;\n        boolean interrupted = Thread.interrupted();\n        try {\n            return lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n        }\n        catch (InterruptedException interrupt) {\n            interrupted = true;\n            timeoutNanos = deadline - System.nanoTime();\n            return lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n        }\n        finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    public boolean enterInterruptibly(final long time, final TimeUnit unit) throws InterruptedException {\n        return this.lock.tryLock(time, unit);\n    }\n    \n    public boolean tryEnter() {\n        return this.lock.tryLock();\n    }\n    \n    public void enterWhen(final Guard guard) throws InterruptedException {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n        boolean satisfied = false;\n        try {\n            if (!guard.isSatisfied()) {\n                this.await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally {\n            if (!satisfied) {\n                this.leave();\n            }\n        }\n    }\n    \n    public void enterWhenUninterruptibly(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n        boolean satisfied = false;\n        try {\n            if (!guard.isSatisfied()) {\n                this.awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally {\n            if (!satisfied) {\n                this.leave();\n            }\n        }\n    }\n    \n    public boolean enterWhen(final Guard guard, final long time, final TimeUnit unit) throws InterruptedException {\n        long timeoutNanos = unit.toNanos(time);\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final boolean reentrant = lock.isHeldByCurrentThread();\n        if (this.fair || !lock.tryLock()) {\n            final long deadline = System.nanoTime() + timeoutNanos;\n            if (!lock.tryLock(time, unit)) {\n                return false;\n            }\n            timeoutNanos = deadline - System.nanoTime();\n        }\n        boolean satisfied = false;\n        boolean threw = true;\n        try {\n            satisfied = (guard.isSatisfied() || this.awaitNanos(guard, timeoutNanos, reentrant));\n            threw = false;\n            return satisfied;\n        }\n        finally {\n            if (!satisfied) {\n                try {\n                    if (threw && !reentrant) {\n                        this.signalNextWaiter();\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n    \n    public boolean enterWhenUninterruptibly(final Guard guard, final long time, final TimeUnit unit) {\n        long timeoutNanos = unit.toNanos(time);\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final long deadline = System.nanoTime() + timeoutNanos;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try {\n            if (this.fair || !lock.tryLock()) {\n                boolean locked = false;\n                do {\n                    try {\n                        locked = lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n                        if (!locked) {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt) {\n                        interrupted = true;\n                    }\n                    timeoutNanos = deadline - System.nanoTime();\n                } while (!locked);\n            }\n            boolean satisfied = false;\n            try {\n                return satisfied = (guard.isSatisfied() || this.awaitNanos(guard, timeoutNanos, signalBeforeWaiting));\n            }\n            catch (InterruptedException interrupt) {\n                interrupted = true;\n                signalBeforeWaiting = false;\n                timeoutNanos = deadline - System.nanoTime();\n            }\n            finally {\n                if (!satisfied) {\n                    lock.unlock();\n                }\n            }\n        }\n        finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    public boolean enterIf(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public boolean enterIfInterruptibly(final Guard guard) throws InterruptedException {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public boolean enterIf(final Guard guard, final long time, final TimeUnit unit) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        if (!this.enter(time, unit)) {\n            return false;\n        }\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                this.lock.unlock();\n            }\n        }\n    }\n    \n    public boolean enterIfInterruptibly(final Guard guard, final long time, final TimeUnit unit) throws InterruptedException {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit)) {\n            return false;\n        }\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public boolean tryEnterIf(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock()) {\n            return false;\n        }\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public void waitFor(final Guard guard) throws InterruptedException {\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied()) {\n            this.await(guard, true);\n        }\n    }\n    \n    public void waitForUninterruptibly(final Guard guard) {\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied()) {\n            this.awaitUninterruptibly(guard, true);\n        }\n    }\n    \n    public boolean waitFor(final Guard guard, final long time, final TimeUnit unit) throws InterruptedException {\n        final long timeoutNanos = unit.toNanos(time);\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        return guard.isSatisfied() || this.awaitNanos(guard, timeoutNanos, true);\n    }\n    \n    public boolean waitForUninterruptibly(final Guard guard, final long time, final TimeUnit unit) {\n        long timeoutNanos = unit.toNanos(time);\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied()) {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long deadline = System.nanoTime() + timeoutNanos;\n        boolean interrupted = Thread.interrupted();\n        try {\n            return this.awaitNanos(guard, timeoutNanos, signalBeforeWaiting);\n        }\n        catch (InterruptedException interrupt) {\n            interrupted = true;\n            if (guard.isSatisfied()) {\n                return true;\n            }\n            signalBeforeWaiting = false;\n            timeoutNanos = deadline - System.nanoTime();\n            return this.awaitNanos(guard, timeoutNanos, signalBeforeWaiting);\n        }\n        finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    public void leave() {\n        final ReentrantLock lock = this.lock;\n        try {\n            if (lock.getHoldCount() == 1) {\n                this.signalNextWaiter();\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n    }\n    \n    public boolean isFair() {\n        return this.fair;\n    }\n    \n    public boolean isOccupied() {\n        return this.lock.isLocked();\n    }\n    \n    public boolean isOccupiedByCurrentThread() {\n        return this.lock.isHeldByCurrentThread();\n    }\n    \n    public int getOccupiedDepth() {\n        return this.lock.getHoldCount();\n    }\n    \n    public int getQueueLength() {\n        return this.lock.getQueueLength();\n    }\n    \n    public boolean hasQueuedThreads() {\n        return this.lock.hasQueuedThreads();\n    }\n    \n    public boolean hasQueuedThread(final Thread thread) {\n        return this.lock.hasQueuedThread(thread);\n    }\n    \n    public boolean hasWaiters(final Guard guard) {\n        return this.getWaitQueueLength(guard) > 0;\n    }\n    \n    public int getWaitQueueLength(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        this.lock.lock();\n        try {\n            return guard.waiterCount;\n        }\n        finally {\n            this.lock.unlock();\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void signalNextWaiter() {\n        for (Guard guard = this.activeGuards; guard != null; guard = guard.next) {\n            if (this.isSatisfied(guard)) {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(final Guard guard) {\n        try {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable) {\n            this.signalAllWaiters();\n            throw Throwables.propagate(throwable);\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void signalAllWaiters() {\n        for (Guard guard = this.activeGuards; guard != null; guard = guard.next) {\n            guard.condition.signalAll();\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(final Guard guard) {\n        final int waiters = guard.waiterCount++;\n        if (waiters == 0) {\n            guard.next = this.activeGuards;\n            this.activeGuards = guard;\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void endWaitingFor(final Guard guard) {\n        final int waiterCount = guard.waiterCount - 1;\n        guard.waiterCount = waiterCount;\n        final int waiters = waiterCount;\n        if (waiters == 0) {\n            Guard p = this.activeGuards;\n            Guard pred = null;\n            while (p != guard) {\n                pred = p;\n                p = p.next;\n            }\n            if (pred == null) {\n                this.activeGuards = p.next;\n            }\n            else {\n                pred.next = p.next;\n            }\n            p.next = null;\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void await(final Guard guard, final boolean signalBeforeWaiting) throws InterruptedException {\n        if (signalBeforeWaiting) {\n            this.signalNextWaiter();\n        }\n        this.beginWaitingFor(guard);\n        try {\n            do {\n                guard.condition.await();\n            } while (!guard.isSatisfied());\n        }\n        finally {\n            this.endWaitingFor(guard);\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(final Guard guard, final boolean signalBeforeWaiting) {\n        if (signalBeforeWaiting) {\n            this.signalNextWaiter();\n        }\n        this.beginWaitingFor(guard);\n        try {\n            do {\n                guard.condition.awaitUninterruptibly();\n            } while (!guard.isSatisfied());\n        }\n        finally {\n            this.endWaitingFor(guard);\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(final Guard guard, long nanos, final boolean signalBeforeWaiting) throws InterruptedException {\n        if (signalBeforeWaiting) {\n            this.signalNextWaiter();\n        }\n        this.beginWaitingFor(guard);\n        try {\n            while (nanos >= 0L) {\n                nanos = guard.condition.awaitNanos(nanos);\n                if (guard.isSatisfied()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        finally {\n            this.endWaitingFor(guard);\n        }\n    }\n    \n    @Beta\n    public abstract static class Guard\n    {\n        final Monitor monitor;\n        final Condition condition;\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount;\n        @GuardedBy(\"monitor.lock\")\n        Guard next;\n        \n        protected Guard(final Monitor monitor) {\n            this.waiterCount = 0;\n            this.monitor = Preconditions.checkNotNull(monitor, (Object)\"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n        \n        public abstract boolean isSatisfied();\n    }\n}\n",
        "token_number_zeroshot": 3101,
        "token_number_fewshot": 3499,
        "token_number_cot": 3211
    },
    {
        "project_name": "guava",
        "class": "SmallCharMatcher",
        "source_code": "package com.google.common.base;\n\nimport com.google.common.annotations.*;\nimport java.util.*;\n\n@GwtIncompatible(\"no precomputation is done in GWT\")\nfinal class SmallCharMatcher extends FastMatcher\n{\n    static final int MAX_SIZE = 1023;\n    private final char[] table;\n    private final boolean containsZero;\n    private final long filter;\n    private static final int C1 = -862048943;\n    private static final int C2 = 461845907;\n    private static final double DESIRED_LOAD_FACTOR = 0.5;\n    \n    private SmallCharMatcher(final char[] table, final long filter, final boolean containsZero, final String description) {\n        super(description);\n        this.table = table;\n        this.filter = filter;\n        this.containsZero = containsZero;\n    }\n    \n    static int smear(final int hashCode) {\n        return 461845907 * Integer.rotateLeft(hashCode * -862048943, 15);\n    }\n    \n    private boolean checkFilter(final int c) {\n        return 0x1L == (0x1L & this.filter >> c);\n    }\n    \n    @VisibleForTesting\n    static int chooseTableSize(final int setSize) {\n        if (setSize == 1) {\n            return 2;\n        }\n        int tableSize;\n        for (tableSize = Integer.highestOneBit(setSize - 1) << 1; tableSize * 0.5 < setSize; tableSize <<= 1) {}\n        return tableSize;\n    }\n    \n    static CharMatcher from(final BitSet chars, final String description) {\n        long filter = 0L;\n        final int size = chars.cardinality();\n        final boolean containsZero = chars.get(0);\n        final char[] table = new char[chooseTableSize(size)];\n        final int mask = table.length - 1;\n        for (int c = chars.nextSetBit(0); c != -1; c = chars.nextSetBit(c + 1)) {\n            filter |= 1L << c;\n            int index;\n            for (index = (smear(c) & mask); table[index] != '\\0'; index = (index + 1 & mask)) {}\n            table[index] = (char)c;\n        }\n        return new SmallCharMatcher(table, filter, containsZero, description);\n    }\n    \n    @Override\n    public boolean matches(final char c) {\n        if (c == '\\0') {\n            return this.containsZero;\n        }\n        if (!this.checkFilter(c)) {\n            return false;\n        }\n        final int mask = this.table.length - 1;\n        int index;\n        final int startingIndex = index = (smear(c) & mask);\n        while (this.table[index] != '\\0') {\n            if (this.table[index] == c) {\n                return true;\n            }\n            index = (index + 1 & mask);\n            if (index == startingIndex) {\n                return false;\n            }\n        }\n        return false;\n    }\n    \n    @Override\n    void setBits(final BitSet table) {\n        if (this.containsZero) {\n            table.set(0);\n        }\n        for (final char c : this.table) {\n            if (c != '\\0') {\n                table.set(c);\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 721,
        "token_number_fewshot": 1119,
        "token_number_cot": 833
    },
    {
        "project_name": "98_trans-locator",
        "class": "HuntDisplay",
        "source_code": "package Joshua.FoxHunt;\n\nimport javax.swing.*;\nimport java.util.*;\nimport java.awt.image.*;\nimport java.awt.*;\n\npublic class HuntDisplay extends JComponent\n{\n    Vector points;\n    Vector landmarks;\n    Dimension minSize;\n    Dimension prefSize;\n    \n    public HuntDisplay() {\n        this.points = new Vector();\n        this.landmarks = new Vector();\n        this.setBackground(Color.WHITE);\n        this.minSize = new Dimension(50, 50);\n        this.prefSize = new Dimension(200, 200);\n    }\n    \n    @Override\n    public Dimension getPreferredSize() {\n        return this.prefSize;\n    }\n    \n    @Override\n    public Dimension getMinimumSize() {\n        return this.minSize;\n    }\n    \n    public void addPoint(final TrigPoint point) {\n        this.points.add(new TrigPoint(point.getY() / 90.0, point.getX() / 180.0, point.getTheta(), point.isFox()));\n        this.repaint();\n    }\n    \n    public void addLandMark(final Landmark landmark) {\n        this.landmarks.add(new Landmark(landmark.getLat() / 90.0, landmark.getLon() / 180.0, landmark.getIcon()));\n        this.repaint();\n    }\n    \n    public void paintComponent(final Graphics g) {\n        super.paintComponent(g);\n        final Color point = Color.BLACK;\n        final Color fox = Color.GREEN;\n        final TrigPoint[] trigpoints = new TrigPoint[this.points.size()];\n        for (int a = 0; a < this.points.size(); ++a) {\n            trigpoints[a] = this.points.elementAt(a);\n        }\n        final Landmark[] landMarks = new Landmark[this.landmarks.size()];\n        if (this.landmarks.size() != 0) {\n            for (int z = 0; z < this.points.size(); ++z) {\n                landMarks[z] = this.landmarks.elementAt(z);\n            }\n        }\n        double trigPointAvgX = 0.0;\n        for (int b = 0; b < trigpoints.length; ++b) {\n            trigPointAvgX += trigpoints[b].getX();\n        }\n        trigPointAvgX /= trigpoints.length;\n        double trigPointAvgY = 0.0;\n        for (int b2 = 0; b2 < trigpoints.length; ++b2) {\n            trigPointAvgY += trigpoints[b2].getY();\n        }\n        trigPointAvgY /= trigpoints.length;\n        final double xAdd = 0.5 - trigPointAvgX;\n        final double yAdd = 0.5 - trigPointAvgY;\n        for (int t = 0; t < trigpoints.length; ++t) {\n            if (trigpoints[t].isFox()) {\n                g.setColor(fox);\n            }\n            else {\n                g.setColor(point);\n            }\n            final int X = (int)((trigpoints[t].getX() + xAdd) * this.getWidth());\n            final int Y = (int)((trigpoints[t].getY() + yAdd) * this.getHeight());\n            g.fillOval(X, Y, 5, 5);\n        }\n        g.setColor(this.getForeground());\n        if (this.landmarks.size() != 0) {\n            for (int l = 0; l < landMarks.length; ++l) {\n                final int X = (int)((landMarks[l].getLon() + xAdd) * this.getWidth());\n                final int Y = (int)((landMarks[l].getLat() + yAdd) * this.getHeight());\n                final Image image = landMarks[l].getIcon().getImage();\n                g.drawImage(image, X, Y, 10, 10, this.getBackground(), this);\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 817,
        "token_number_fewshot": 1215,
        "token_number_cot": 928
    },
    {
        "project_name": "98_trans-locator",
        "class": "FoxHuntFrame",
        "source_code": "package Joshua.FoxHunt;\n\nimport java.util.*;\nimport java.awt.event.*;\nimport java.awt.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.table.*;\nimport java.text.*;\n\npublic class FoxHuntFrame extends JFrame implements ActionListener\n{\n    JTextField theta;\n    JTextField lat;\n    JTextField lon;\n    JTextField zoom;\n    JButton add;\n    JTable pos;\n    FoxTableModel posModel;\n    HuntDisplay display;\n    JPanel panel1;\n    JPanel panel2;\n    JPanel panel3;\n    JPanel panel;\n    Vector points;\n    Vector fox;\n    \n    public FoxHuntFrame() {\n        super(\"Triangulation\");\n        JFrame.setDefaultLookAndFeelDecorated(true);\n        this.points = new Vector();\n        this.fox = new Vector();\n        this.textPrep();\n        this.tablePrep();\n        this.displayPrep();\n        this.finalPrep();\n        final ImageIcon icon = new ImageIcon(\"icon.gif\");\n        this.setIconImage(icon.getImage());\n        this.setDefaultCloseOperation(3);\n        this.getContentPane().add(this.panel, \"Center\");\n        this.pack();\n        this.setState(6);\n        this.setVisible(true);\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        this.addPoint();\n    }\n    \n    public void addPoint() {\n        final int angle = Integer.parseInt(this.theta.getText());\n        final double LAT = Double.parseDouble(this.lat.getText());\n        final double LON = Double.parseDouble(this.lon.getText());\n        final TrigPoint point = new TrigPoint(LAT, LON, angle);\n        this.points.add(point);\n        this.display.addPoint(point);\n        if (this.points.size() > 1) {\n            final TrigPoint C = this.points.elementAt(this.points.size() - 2);\n            final TrigPoint B = FoxCalc.calcFox(point, C);\n            this.fox.add(B);\n            this.posModel.fireTableDataChanged();\n            this.display.addPoint(B);\n        }\n    }\n    \n    private void finalPrep() {\n        (this.zoom = new JTextField(\"1\")).addActionListener(this);\n        final JLabel zoomL = new JLabel(\"Zoom\");\n        final JPanel zoomP = new JPanel(new GridLayout(1, 2));\n        zoomP.add(zoomL);\n        zoomP.add(this.zoom);\n        (this.panel3 = new JPanel(new BorderLayout())).add(this.zoom, \"North\");\n        this.panel3.add(this.display, \"Center\");\n        this.panel = new JPanel(new BorderLayout());\n        final JSplitPane controls = new JSplitPane(1, this.panel1, this.panel2);\n        final JSplitPane map = new JSplitPane(0, controls, this.panel3);\n        map.setDividerLocation(0.25);\n        (this.panel = new JPanel(new BorderLayout())).add(map, \"Center\");\n    }\n    \n    private void textPrep() {\n        this.theta = new JTextField(3);\n        this.lat = new JTextField(9);\n        this.lon = new JTextField(10);\n        (this.add = new JButton(\"Add It!!!\")).addActionListener(this);\n        final JLabel thetaL = new JLabel(\"Theta in Degrees\");\n        final JLabel latL = new JLabel(\"Lat. dd*mm.mmm\");\n        final JLabel lonL = new JLabel(\"lon. ddd*mm.mmm\");\n        (this.panel1 = new JPanel(new GridLayout(4, 2))).add(thetaL);\n        this.panel1.add(this.theta);\n        this.panel1.add(latL);\n        this.panel1.add(this.lat);\n        this.panel1.add(lonL);\n        this.panel1.add(this.lon);\n        this.panel1.add(this.add);\n    }\n    \n    private void tablePrep() {\n        this.posModel = new FoxTableModel();\n        this.pos = new JTable(this.posModel);\n        final JScrollPane scroll = new JScrollPane(this.pos);\n        this.pos.setPreferredScrollableViewportSize(new Dimension(500, 70));\n        (this.panel2 = new JPanel(new BorderLayout())).add(scroll, \"Center\");\n    }\n    \n    private void displayPrep() {\n        this.display = new HuntDisplay();\n        this.loadLandmarks();\n    }\n    \n    private void loadLandmarks() {\n        try {\n            final File file = new File(\"./landmarks.cfg\");\n            final FileInputStream inFile = new FileInputStream(file);\n            final BufferedReader in = new BufferedReader(new InputStreamReader(inFile));\n            String input = \"\";\n            int NUM = 0;\n            if ((input = in.readLine()) != null) {\n                final String num = input.substring(4);\n                NUM = Integer.parseInt(num);\n            }\n            int numAtFile = 0;\n            int numAtLat = 0;\n            int numAtLon = 0;\n            final String[] iconFile = new String[NUM];\n            final double[] lat = new double[NUM];\n            final double[] lon = new double[NUM];\n            while ((input = in.readLine()) != null) {\n                if (input.startsWith(\"FILE\")) {\n                    iconFile[numAtFile] = input.substring(4);\n                    ++numAtFile;\n                }\n                else if (input.startsWith(\"LAT\")) {\n                    lat[numAtLat] = Double.parseDouble(input.substring(4));\n                    ++numAtLat;\n                }\n                else {\n                    if (!input.startsWith(\"LON\")) {\n                        continue;\n                    }\n                    lon[numAtLon] = Double.parseDouble(input.substring(4));\n                    ++numAtLon;\n                }\n            }\n            for (int a = 0; a < NUM; ++a) {\n                this.display.addLandMark(new Landmark(lat[a], lon[a], new ImageIcon(iconFile[a])));\n            }\n            in.close();\n            inFile.close();\n        }\n        catch (FileNotFoundException e) {\n            this.error(\"Can't Find the file\");\n        }\n        catch (IOException e2) {\n            this.error(\"Error communicating with the file\");\n        }\n    }\n    \n    private void error(final String text) {\n        final Object[] options = { \"Abort\", \"Continue\" };\n        final int ans = JOptionPane.showOptionDialog(this, text, \"Error\", 0, 0, null, options, options[0]);\n        if (ans == 0 | ans == -1) {\n            System.exit(1);\n        }\n    }\n    \n    class FoxTableModel extends AbstractTableModel\n    {\n        String[] colNames;\n        \n        FoxTableModel() {\n            this.colNames = new String[] { \"Lattitude\", \"Longitude\" };\n        }\n        \n        @Override\n        public int getColumnCount() {\n            return this.colNames.length;\n        }\n        \n        @Override\n        public int getRowCount() {\n            return FoxHuntFrame.this.fox.size();\n        }\n        \n        @Override\n        public String getColumnName(final int col) {\n            return this.colNames[col];\n        }\n        \n        @Override\n        public Object getValueAt(final int row, final int col) {\n            final DecimalFormat formatter = new DecimalFormat(\"###.##############\");\n            final TrigPoint point = FoxHuntFrame.this.fox.elementAt(row);\n            if (col == 0) {\n                final String output = formatter.format(point.getY());\n                return output;\n            }\n            final String output = formatter.format(point.getX());\n            return output;\n        }\n        \n        @Override\n        public Class getColumnClass(final int col) {\n            return this.getValueAt(0, col).getClass();\n        }\n        \n        @Override\n        public boolean isCellEditable(final int row, final int col) {\n            return false;\n        }\n    }\n}\n",
        "token_number_zeroshot": 1564,
        "token_number_fewshot": 1962,
        "token_number_cot": 1677
    },
    {
        "project_name": "35_corina",
        "class": "TucsonSimple",
        "source_code": "package corina.formats;\n\nimport corina.ui.*;\nimport java.io.*;\nimport corina.util.*;\nimport corina.*;\n\npublic class TucsonSimple implements Filetype\n{\n    @Override\n    public String toString() {\n        return I18n.getText(\"format.tucsonsimple\");\n    }\n    \n    @Override\n    public String getDefaultExtension() {\n        return \".RWL\";\n    }\n    \n    @Override\n    public Sample load(final BufferedReader r) throws IOException {\n        throw new WrongFiletypeException();\n    }\n    \n    private String make6digitCode(final Sample s) {\n        String code;\n        if (s.meta.containsKey(\"id\")) {\n            code = s.meta.get(\"id\").toString();\n        }\n        else {\n            code = \"000000\";\n        }\n        if (code.length() > 6) {\n            code = code.substring(0, 6);\n        }\n        else {\n            while (code.length() < 6) {\n                code += \" \";\n            }\n        }\n        return code;\n    }\n    \n    private void saveRowHeader(final BufferedWriter w, final Sample s, final String code, final int yearWidth, final Year y) throws IOException {\n        String prefix;\n        if (y.compareTo(s.range.getStart()) < 0) {\n            prefix = s.range.getStart().toString();\n        }\n        else {\n            prefix = y.toString();\n        }\n        while (prefix.length() < yearWidth) {\n            prefix = \" \" + prefix;\n        }\n        w.write(code + prefix);\n    }\n    \n    protected void saveData(final Sample s, final BufferedWriter w) throws IOException {\n        final Range r = this.computeRange(s);\n        final Year start = r.getStart();\n        final Year end = r.getEnd();\n        final String code = this.make6digitCode(s);\n        final boolean isSummed = false;\n        final boolean isProcessed = false;\n        Year y = start;\n        if (isProcessed) {\n            y = y.add(-start.column());\n        }\n        while (true) {\n            if (y.column() == 0 || (y.equals(start) && !isProcessed)) {\n                this.saveRowHeader(w, s, code, isProcessed ? 4 : 6, y);\n            }\n            if (y.compareTo(end) > 0 || (isProcessed && y.compareTo(start) < 0)) {\n                if (!isProcessed) {\n                    w.write(\"   999\");\n                    break;\n                }\n                w.write(isSummed ? \"9990  0\" : \"9990   \");\n            }\n            else {\n                w.write(StringUtils.leftPad(s.data.get(y.diff(start)).toString(), isProcessed ? 4 : 6));\n                if (isSummed) {\n                    w.write(StringUtils.leftPad(s.count.get(y.diff(start)).toString(), 3));\n                }\n                else if (isProcessed) {\n                    w.write(\"   \");\n                }\n            }\n            if (isProcessed && y.compareTo(end) > 0 && y.column() == 9) {\n                break;\n            }\n            if (y.column() == 9) {\n                w.newLine();\n            }\n            y = y.add(1);\n        }\n        w.newLine();\n    }\n    \n    private Range computeRange(final Sample s) {\n        final Year start = s.range.getStart();\n        if (start.compareTo(new Year(1)) >= 0) {\n            return s.range;\n        }\n        if (start.add(8000).compareTo(new Year(1)) >= 0) {\n            return s.range.redateBy(8000);\n        }\n        return s.range.redateStartTo(new Year(1001));\n    }\n    \n    @Override\n    public void save(final Sample s, final BufferedWriter w) throws IOException {\n        this.saveData(s, w);\n    }\n}\n",
        "token_number_zeroshot": 809,
        "token_number_fewshot": 1207,
        "token_number_cot": 920
    },
    {
        "project_name": "commons-collections",
        "class": "SequencesComparator",
        "source_code": "package org.apache.commons.collections4.sequence;\n\nimport java.util.*;\nimport org.apache.commons.collections4.*;\nimport org.apache.commons.collections4.functors.*;\n\npublic class SequencesComparator<T>\n{\n    private final List<T> sequence1;\n    private final List<T> sequence2;\n    private final Equator<? super T> equator;\n    private final int[] vDown;\n    private final int[] vUp;\n    \n    public SequencesComparator(final List<T> sequence1, final List<T> sequence2) {\n        this(sequence1, sequence2, DefaultEquator.defaultEquator());\n    }\n    \n    public SequencesComparator(final List<T> sequence1, final List<T> sequence2, final Equator<? super T> equator) {\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.equator = equator;\n        final int size = sequence1.size() + sequence2.size() + 2;\n        this.vDown = new int[size];\n        this.vUp = new int[size];\n    }\n    \n    public EditScript<T> getScript() {\n        final EditScript<T> script = new EditScript<T>();\n        this.buildScript(0, this.sequence1.size(), 0, this.sequence2.size(), script);\n        return script;\n    }\n    \n    private Snake buildSnake(final int start, final int diag, final int end1, final int end2) {\n        int end3;\n        for (end3 = start; end3 - diag < end2 && end3 < end1 && this.equator.equate((Object)this.sequence1.get(end3), (Object)this.sequence2.get(end3 - diag)); ++end3) {}\n        return new Snake(start, end3, diag);\n    }\n    \n    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n        final int delta = m - n;\n        final int sum = n + m;\n        final int offset = ((sum % 2 == 0) ? sum : (sum + 1)) / 2;\n        this.vDown[1 + offset] = start1;\n        this.vUp[1 + offset] = end1 + 1;\n        for (int d = 0; d <= offset; ++d) {\n            for (int k = -d; k <= d; k += 2) {\n                final int i = k + offset;\n                if (k == -d || (k != d && this.vDown[i - 1] < this.vDown[i + 1])) {\n                    this.vDown[i] = this.vDown[i + 1];\n                }\n                else {\n                    this.vDown[i] = this.vDown[i - 1] + 1;\n                }\n                for (int x = this.vDown[i], y = x - start1 + start2 - k; x < end1 && y < end2 && this.equator.equate((Object)this.sequence1.get(x), (Object)this.sequence2.get(y)); this.vDown[i] = ++x, ++y) {}\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d && this.vUp[i - delta] <= this.vDown[i]) {\n                    return this.buildSnake(this.vUp[i - delta], k + start1 - start2, end1, end2);\n                }\n            }\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                final int i = k + offset - delta;\n                if (k == delta - d || (k != delta + d && this.vUp[i + 1] <= this.vUp[i - 1])) {\n                    this.vUp[i] = this.vUp[i + 1] - 1;\n                }\n                else {\n                    this.vUp[i] = this.vUp[i - 1];\n                }\n                for (int x = this.vUp[i] - 1, y = x - start1 + start2 - k; x >= start1 && y >= start2 && this.equator.equate((Object)this.sequence1.get(x), (Object)this.sequence2.get(y)); this.vUp[i] = x--, --y) {}\n                if (delta % 2 == 0 && -d <= k && k <= d && this.vUp[i] <= this.vDown[i + delta]) {\n                    return this.buildSnake(this.vUp[i], k + start1 - start2, end1, end2);\n                }\n            }\n        }\n        throw new RuntimeException(\"Internal Error\");\n    }\n    \n    private void buildScript(final int start1, final int end1, final int start2, final int end2, final EditScript<T> script) {\n        final Snake middle = this.getMiddleSnake(start1, end1, start2, end2);\n        if (middle == null || (middle.getStart() == end1 && middle.getDiag() == end1 - end2) || (middle.getEnd() == start1 && middle.getDiag() == start1 - start2)) {\n            int i = start1;\n            int j = start2;\n            while (i < end1 || j < end2) {\n                if (i < end1 && j < end2 && this.equator.equate((Object)this.sequence1.get(i), (Object)this.sequence2.get(j))) {\n                    script.append(new KeepCommand<T>(this.sequence1.get(i)));\n                    ++i;\n                    ++j;\n                }\n                else if (end1 - start1 > end2 - start2) {\n                    script.append(new DeleteCommand<T>(this.sequence1.get(i)));\n                    ++i;\n                }\n                else {\n                    script.append(new InsertCommand<T>(this.sequence2.get(j)));\n                    ++j;\n                }\n            }\n        }\n        else {\n            this.buildScript(start1, middle.getStart(), start2, middle.getStart() - middle.getDiag(), script);\n            for (int i = middle.getStart(); i < middle.getEnd(); ++i) {\n                script.append(new KeepCommand<T>(this.sequence1.get(i)));\n            }\n            this.buildScript(middle.getEnd(), end1, middle.getEnd() - middle.getDiag(), end2, script);\n        }\n    }\n    \n    private static class Snake\n    {\n        private final int start;\n        private final int end;\n        private final int diag;\n        \n        public Snake(final int start, final int end, final int diag) {\n            this.start = start;\n            this.end = end;\n            this.diag = diag;\n        }\n        \n        public int getStart() {\n            return this.start;\n        }\n        \n        public int getEnd() {\n            return this.end;\n        }\n        \n        public int getDiag() {\n            return this.diag;\n        }\n    }\n}\n",
        "token_number_zeroshot": 1498,
        "token_number_fewshot": 1896,
        "token_number_cot": 1610
    },
    {
        "project_name": "commons-collections",
        "class": "ArrayByteList",
        "source_code": "package org.apache.commons.collections.primitives;\n\nimport java.io.*;\n\npublic class ArrayByteList extends RandomAccessByteList implements ByteList, Serializable\n{\n    private transient byte[] _data;\n    private int _size;\n    \n    public ArrayByteList() {\n        this(8);\n    }\n    \n    public ArrayByteList(final int initialCapacity) {\n        this._data = null;\n        this._size = 0;\n        if (initialCapacity < 0) {\n            throw new IllegalArgumentException(\"capacity \" + initialCapacity);\n        }\n        this._data = new byte[initialCapacity];\n        this._size = 0;\n    }\n    \n    public ArrayByteList(final ByteCollection that) {\n        this(that.size());\n        this.addAll(that);\n    }\n    \n    public byte get(final int index) {\n        this.checkRange(index);\n        return this._data[index];\n    }\n    \n    public int size() {\n        return this._size;\n    }\n    \n    public byte removeElementAt(final int index) {\n        this.checkRange(index);\n        this.incrModCount();\n        final byte oldval = this._data[index];\n        final int numtomove = this._size - index - 1;\n        if (numtomove > 0) {\n            System.arraycopy(this._data, index + 1, this._data, index, numtomove);\n        }\n        --this._size;\n        return oldval;\n    }\n    \n    public byte set(final int index, final byte element) {\n        this.checkRange(index);\n        this.incrModCount();\n        final byte oldval = this._data[index];\n        this._data[index] = element;\n        return oldval;\n    }\n    \n    public void add(final int index, final byte element) {\n        this.checkRangeIncludingEndpoint(index);\n        this.incrModCount();\n        this.ensureCapacity(this._size + 1);\n        final int numtomove = this._size - index;\n        System.arraycopy(this._data, index, this._data, index + 1, numtomove);\n        this._data[index] = element;\n        ++this._size;\n    }\n    \n    public void ensureCapacity(final int mincap) {\n        this.incrModCount();\n        if (mincap > this._data.length) {\n            final int newcap = this._data.length * 3 / 2 + 1;\n            final byte[] olddata = this._data;\n            System.arraycopy(olddata, 0, this._data = new byte[(newcap < mincap) ? mincap : newcap], 0, this._size);\n        }\n    }\n    \n    public void trimToSize() {\n        this.incrModCount();\n        if (this._size < this._data.length) {\n            final byte[] olddata = this._data;\n            System.arraycopy(olddata, 0, this._data = new byte[this._size], 0, this._size);\n        }\n    }\n    \n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(this._data.length);\n        for (int i = 0; i < this._size; ++i) {\n            out.writeByte(this._data[i]);\n        }\n    }\n    \n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        this._data = new byte[in.readInt()];\n        for (int i = 0; i < this._size; ++i) {\n            this._data[i] = in.readByte();\n        }\n    }\n    \n    private final void checkRange(final int index) {\n        if (index < 0 || index >= this._size) {\n            throw new IndexOutOfBoundsException(\"Should be at least 0 and less than \" + this._size + \", found \" + index);\n        }\n    }\n    \n    private final void checkRangeIncludingEndpoint(final int index) {\n        if (index < 0 || index > this._size) {\n            throw new IndexOutOfBoundsException(\"Should be at least 0 and at most \" + this._size + \", found \" + index);\n        }\n    }\n}\n",
        "token_number_zeroshot": 892,
        "token_number_fewshot": 1290,
        "token_number_cot": 1004
    },
    {
        "project_name": "joda",
        "class": "MutablePeriod",
        "source_code": "package org.joda.time;\n\nimport org.joda.time.base.*;\nimport java.io.*;\nimport org.joda.convert.*;\nimport org.joda.time.format.*;\nimport org.joda.time.field.*;\n\npublic class MutablePeriod extends BasePeriod implements ReadWritablePeriod, Cloneable, Serializable\n{\n    private static final long serialVersionUID = 3436451121567212165L;\n    \n    @FromString\n    public static MutablePeriod parse(final String s) {\n        return parse(s, ISOPeriodFormat.standard());\n    }\n    \n    public static MutablePeriod parse(final String s, final PeriodFormatter periodFormatter) {\n        return periodFormatter.parsePeriod(s).toMutablePeriod();\n    }\n    \n    public MutablePeriod() {\n        super(0L, null, null);\n    }\n    \n    public MutablePeriod(final PeriodType periodType) {\n        super(0L, periodType, null);\n    }\n    \n    public MutablePeriod(final int n, final int n2, final int n3, final int n4) {\n        super(0, 0, 0, 0, n, n2, n3, n4, PeriodType.standard());\n    }\n    \n    public MutablePeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        super(n, n2, n3, n4, n5, n6, n7, n8, PeriodType.standard());\n    }\n    \n    public MutablePeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final PeriodType periodType) {\n        super(n, n2, n3, n4, n5, n6, n7, n8, periodType);\n    }\n    \n    public MutablePeriod(final long n) {\n        super(n);\n    }\n    \n    public MutablePeriod(final long n, final PeriodType periodType) {\n        super(n, periodType, null);\n    }\n    \n    public MutablePeriod(final long n, final Chronology chronology) {\n        super(n, null, chronology);\n    }\n    \n    public MutablePeriod(final long n, final PeriodType periodType, final Chronology chronology) {\n        super(n, periodType, chronology);\n    }\n    \n    public MutablePeriod(final long n, final long n2) {\n        super(n, n2, null, null);\n    }\n    \n    public MutablePeriod(final long n, final long n2, final PeriodType periodType) {\n        super(n, n2, periodType, null);\n    }\n    \n    public MutablePeriod(final long n, final long n2, final Chronology chronology) {\n        super(n, n2, null, chronology);\n    }\n    \n    public MutablePeriod(final long n, final long n2, final PeriodType periodType, final Chronology chronology) {\n        super(n, n2, periodType, chronology);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2) {\n        super(readableInstant, readableInstant2, null);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2, final PeriodType periodType) {\n        super(readableInstant, readableInstant2, periodType);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableDuration readableDuration) {\n        super(readableInstant, readableDuration, null);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableDuration readableDuration, final PeriodType periodType) {\n        super(readableInstant, readableDuration, periodType);\n    }\n    \n    public MutablePeriod(final ReadableDuration readableDuration, final ReadableInstant readableInstant) {\n        super(readableDuration, readableInstant, null);\n    }\n    \n    public MutablePeriod(final ReadableDuration readableDuration, final ReadableInstant readableInstant, final PeriodType periodType) {\n        super(readableDuration, readableInstant, periodType);\n    }\n    \n    public MutablePeriod(final Object o) {\n        super(o, null, null);\n    }\n    \n    public MutablePeriod(final Object o, final PeriodType periodType) {\n        super(o, periodType, null);\n    }\n    \n    public MutablePeriod(final Object o, final Chronology chronology) {\n        super(o, null, chronology);\n    }\n    \n    public MutablePeriod(final Object o, final PeriodType periodType, final Chronology chronology) {\n        super(o, periodType, chronology);\n    }\n    \n    public void clear() {\n        super.setValues(new int[this.size()]);\n    }\n    \n    public void setValue(final int n, final int n2) {\n        super.setValue(n, n2);\n    }\n    \n    public void set(final DurationFieldType durationFieldType, final int n) {\n        super.setField(durationFieldType, n);\n    }\n    \n    public void setPeriod(final ReadablePeriod period) {\n        super.setPeriod(period);\n    }\n    \n    public void setPeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        super.setPeriod(n, n2, n3, n4, n5, n6, n7, n8);\n    }\n    \n    public void setPeriod(final ReadableInterval readableInterval) {\n        if (readableInterval == null) {\n            this.setPeriod(0L);\n        }\n        else {\n            this.setPeriod(readableInterval.getStartMillis(), readableInterval.getEndMillis(), DateTimeUtils.getChronology(readableInterval.getChronology()));\n        }\n    }\n    \n    public void setPeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2) {\n        if (readableInstant == readableInstant2) {\n            this.setPeriod(0L);\n        }\n        else {\n            this.setPeriod(DateTimeUtils.getInstantMillis(readableInstant), DateTimeUtils.getInstantMillis(readableInstant2), DateTimeUtils.getIntervalChronology(readableInstant, readableInstant2));\n        }\n    }\n    \n    public void setPeriod(final long n, final long n2) {\n        this.setPeriod(n, n2, null);\n    }\n    \n    public void setPeriod(final long n, final long n2, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.setValues(chronology.get(this, n, n2));\n    }\n    \n    public void setPeriod(final ReadableDuration readableDuration) {\n        this.setPeriod(readableDuration, null);\n    }\n    \n    public void setPeriod(final ReadableDuration readableDuration, final Chronology chronology) {\n        this.setPeriod(DateTimeUtils.getDurationMillis(readableDuration), chronology);\n    }\n    \n    public void setPeriod(final long n) {\n        this.setPeriod(n, null);\n    }\n    \n    public void setPeriod(final long n, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.setValues(chronology.get(this, n));\n    }\n    \n    public void add(final DurationFieldType durationFieldType, final int n) {\n        super.addField(durationFieldType, n);\n    }\n    \n    public void add(final ReadablePeriod readablePeriod) {\n        super.addPeriod(readablePeriod);\n    }\n    \n    public void add(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        this.setPeriod(FieldUtils.safeAdd(this.getYears(), n), FieldUtils.safeAdd(this.getMonths(), n2), FieldUtils.safeAdd(this.getWeeks(), n3), FieldUtils.safeAdd(this.getDays(), n4), FieldUtils.safeAdd(this.getHours(), n5), FieldUtils.safeAdd(this.getMinutes(), n6), FieldUtils.safeAdd(this.getSeconds(), n7), FieldUtils.safeAdd(this.getMillis(), n8));\n    }\n    \n    public void add(final ReadableInterval readableInterval) {\n        if (readableInterval != null) {\n            this.add(readableInterval.toPeriod(this.getPeriodType()));\n        }\n    }\n    \n    public void add(final ReadableDuration readableDuration) {\n        if (readableDuration != null) {\n            this.add(new Period(readableDuration.getMillis(), this.getPeriodType()));\n        }\n    }\n    \n    public void add(final long n) {\n        this.add(new Period(n, this.getPeriodType()));\n    }\n    \n    public void add(final long n, final Chronology chronology) {\n        this.add(new Period(n, this.getPeriodType(), chronology));\n    }\n    \n    public void mergePeriod(final ReadablePeriod readablePeriod) {\n        super.mergePeriod(readablePeriod);\n    }\n    \n    public int getYears() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }\n    \n    public int getMonths() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }\n    \n    public int getWeeks() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }\n    \n    public int getDays() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }\n    \n    public int getHours() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n    }\n    \n    public int getMinutes() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n    }\n    \n    public int getSeconds() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n    }\n    \n    public int getMillis() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n    }\n    \n    public void setYears(final int n) {\n        super.setField(DurationFieldType.years(), n);\n    }\n    \n    public void addYears(final int n) {\n        super.addField(DurationFieldType.years(), n);\n    }\n    \n    public void setMonths(final int n) {\n        super.setField(DurationFieldType.months(), n);\n    }\n    \n    public void addMonths(final int n) {\n        super.addField(DurationFieldType.months(), n);\n    }\n    \n    public void setWeeks(final int n) {\n        super.setField(DurationFieldType.weeks(), n);\n    }\n    \n    public void addWeeks(final int n) {\n        super.addField(DurationFieldType.weeks(), n);\n    }\n    \n    public void setDays(final int n) {\n        super.setField(DurationFieldType.days(), n);\n    }\n    \n    public void addDays(final int n) {\n        super.addField(DurationFieldType.days(), n);\n    }\n    \n    public void setHours(final int n) {\n        super.setField(DurationFieldType.hours(), n);\n    }\n    \n    public void addHours(final int n) {\n        super.addField(DurationFieldType.hours(), n);\n    }\n    \n    public void setMinutes(final int n) {\n        super.setField(DurationFieldType.minutes(), n);\n    }\n    \n    public void addMinutes(final int n) {\n        super.addField(DurationFieldType.minutes(), n);\n    }\n    \n    public void setSeconds(final int n) {\n        super.setField(DurationFieldType.seconds(), n);\n    }\n    \n    public void addSeconds(final int n) {\n        super.addField(DurationFieldType.seconds(), n);\n    }\n    \n    public void setMillis(final int n) {\n        super.setField(DurationFieldType.millis(), n);\n    }\n    \n    public void addMillis(final int n) {\n        super.addField(DurationFieldType.millis(), n);\n    }\n    \n    public MutablePeriod copy() {\n        return (MutablePeriod)this.clone();\n    }\n    \n    public Object clone() {\n        try {\n            return super.clone();\n        }\n        catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"Clone error\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 2521,
        "token_number_fewshot": 2919,
        "token_number_cot": 2632
    },
    {
        "project_name": "joda",
        "class": "Partial",
        "source_code": "package org.joda.time;\n\nimport org.joda.time.base.*;\nimport java.io.*;\nimport org.joda.time.format.*;\nimport java.util.*;\nimport org.joda.time.field.*;\n\npublic final class Partial extends AbstractPartial implements ReadablePartial, Serializable\n{\n    private static final long serialVersionUID = 12324121189002L;\n    private final Chronology iChronology;\n    private final DateTimeFieldType[] iTypes;\n    private final int[] iValues;\n    private transient DateTimeFormatter[] iFormatter;\n    \n    public Partial() {\n        this((Chronology)null);\n    }\n    \n    public Partial(final Chronology chronology) {\n        this.iChronology = DateTimeUtils.getChronology(chronology).withUTC();\n        this.iTypes = new DateTimeFieldType[0];\n        this.iValues = new int[0];\n    }\n    \n    public Partial(final DateTimeFieldType dateTimeFieldType, final int n) {\n        this(dateTimeFieldType, n, null);\n    }\n    \n    public Partial(final DateTimeFieldType dateTimeFieldType, final int n, Chronology withUTC) {\n        withUTC = DateTimeUtils.getChronology(withUTC).withUTC();\n        this.iChronology = withUTC;\n        if (dateTimeFieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        this.iTypes = new DateTimeFieldType[] { dateTimeFieldType };\n        withUTC.validate(this, this.iValues = new int[] { n });\n    }\n    \n    public Partial(final DateTimeFieldType[] array, final int[] array2) {\n        this(array, array2, null);\n    }\n    \n    public Partial(final DateTimeFieldType[] iTypes, final int[] iValues, Chronology withUTC) {\n        withUTC = DateTimeUtils.getChronology(withUTC).withUTC();\n        this.iChronology = withUTC;\n        if (iTypes == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (iValues == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (iValues.length != iTypes.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (iTypes.length == 0) {\n            this.iTypes = iTypes;\n            this.iValues = iValues;\n            return;\n        }\n        for (int i = 0; i < iTypes.length; ++i) {\n            if (iTypes[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        Comparable<DurationField> comparable = null;\n        for (int j = 0; j < iTypes.length; ++j) {\n            final DateTimeFieldType dateTimeFieldType = iTypes[j];\n            final DurationField field = dateTimeFieldType.getDurationType().getField(this.iChronology);\n            if (j > 0) {\n                final int compareTo = comparable.compareTo(field);\n                if (compareTo < 0 || (compareTo != 0 && !field.isSupported())) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + iTypes[j - 1].getName() + \" < \" + dateTimeFieldType.getName());\n                }\n                if (compareTo == 0) {\n                    if (iTypes[j - 1].getRangeDurationType() == null) {\n                        if (dateTimeFieldType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + dateTimeFieldType.getName());\n                        }\n                    }\n                    else {\n                        if (dateTimeFieldType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + iTypes[j - 1].getName() + \" < \" + dateTimeFieldType.getName());\n                        }\n                        final DurationField field2 = iTypes[j - 1].getRangeDurationType().getField(this.iChronology);\n                        final DurationField field3 = dateTimeFieldType.getRangeDurationType().getField(this.iChronology);\n                        if (field2.compareTo(field3) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + iTypes[j - 1].getName() + \" < \" + dateTimeFieldType.getName());\n                        }\n                        if (field2.compareTo(field3) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + dateTimeFieldType.getName());\n                        }\n                    }\n                }\n            }\n            comparable = field;\n        }\n        this.iTypes = iTypes.clone();\n        withUTC.validate(this, iValues);\n        this.iValues = iValues.clone();\n    }\n    \n    public Partial(final ReadablePartial readablePartial) {\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        this.iChronology = DateTimeUtils.getChronology(readablePartial.getChronology()).withUTC();\n        this.iTypes = new DateTimeFieldType[readablePartial.size()];\n        this.iValues = new int[readablePartial.size()];\n        for (int i = 0; i < readablePartial.size(); ++i) {\n            this.iTypes[i] = readablePartial.getFieldType(i);\n            this.iValues[i] = readablePartial.getValue(i);\n        }\n    }\n    \n    Partial(final Partial partial, final int[] iValues) {\n        this.iChronology = partial.iChronology;\n        this.iTypes = partial.iTypes;\n        this.iValues = iValues;\n    }\n    \n    Partial(final Chronology iChronology, final DateTimeFieldType[] iTypes, final int[] iValues) {\n        this.iChronology = iChronology;\n        this.iTypes = iTypes;\n        this.iValues = iValues;\n    }\n    \n    public int size() {\n        return this.iTypes.length;\n    }\n    \n    public Chronology getChronology() {\n        return this.iChronology;\n    }\n    \n    protected DateTimeField getField(final int n, final Chronology chronology) {\n        return this.iTypes[n].getField(chronology);\n    }\n    \n    public DateTimeFieldType getFieldType(final int n) {\n        return this.iTypes[n];\n    }\n    \n    public DateTimeFieldType[] getFieldTypes() {\n        return this.iTypes.clone();\n    }\n    \n    public int getValue(final int n) {\n        return this.iValues[n];\n    }\n    \n    public int[] getValues() {\n        return this.iValues.clone();\n    }\n    \n    public Partial withChronologyRetainFields(Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        chronology = chronology.withUTC();\n        if (chronology == this.getChronology()) {\n            return this;\n        }\n        final Partial partial = new Partial(chronology, this.iTypes, this.iValues);\n        chronology.validate(partial, this.iValues);\n        return partial;\n    }\n    \n    public Partial with(final DateTimeFieldType dateTimeFieldType, final int n) {\n        if (dateTimeFieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        final int index = this.indexOf(dateTimeFieldType);\n        if (index == -1) {\n            final DateTimeFieldType[] array = new DateTimeFieldType[this.iTypes.length + 1];\n            final int[] array2 = new int[array.length];\n            int i = 0;\n            final DurationField field = dateTimeFieldType.getDurationType().getField(this.iChronology);\n            if (field.isSupported()) {\n                while (i < this.iTypes.length) {\n                    final DateTimeFieldType dateTimeFieldType2 = this.iTypes[i];\n                    final DurationField field2 = dateTimeFieldType2.getDurationType().getField(this.iChronology);\n                    if (field2.isSupported()) {\n                        final int compareTo = field.compareTo(field2);\n                        if (compareTo > 0) {\n                            break;\n                        }\n                        if (compareTo == 0 && dateTimeFieldType.getRangeDurationType().getField(this.iChronology).compareTo(dateTimeFieldType2.getRangeDurationType().getField(this.iChronology)) > 0) {\n                            break;\n                        }\n                    }\n                    ++i;\n                }\n            }\n            System.arraycopy(this.iTypes, 0, array, 0, i);\n            System.arraycopy(this.iValues, 0, array2, 0, i);\n            array[i] = dateTimeFieldType;\n            array2[i] = n;\n            System.arraycopy(this.iTypes, i, array, i + 1, array.length - i - 1);\n            System.arraycopy(this.iValues, i, array2, i + 1, array2.length - i - 1);\n            final Partial partial = new Partial(this.iChronology, array, array2);\n            this.iChronology.validate(partial, array2);\n            return partial;\n        }\n        if (n == this.getValue(index)) {\n            return this;\n        }\n        return new Partial(this, this.getField(index).set(this, index, this.getValues(), n));\n    }\n    \n    public Partial without(final DateTimeFieldType dateTimeFieldType) {\n        final int index = this.indexOf(dateTimeFieldType);\n        if (index != -1) {\n            final DateTimeFieldType[] array = new DateTimeFieldType[this.size() - 1];\n            final int[] array2 = new int[this.size() - 1];\n            System.arraycopy(this.iTypes, 0, array, 0, index);\n            System.arraycopy(this.iTypes, index + 1, array, index, array.length - index);\n            System.arraycopy(this.iValues, 0, array2, 0, index);\n            System.arraycopy(this.iValues, index + 1, array2, index, array2.length - index);\n            final Partial partial = new Partial(this.iChronology, array, array2);\n            this.iChronology.validate(partial, array2);\n            return partial;\n        }\n        return this;\n    }\n    \n    public Partial withField(final DateTimeFieldType dateTimeFieldType, final int n) {\n        final int indexOfSupported = this.indexOfSupported(dateTimeFieldType);\n        if (n == this.getValue(indexOfSupported)) {\n            return this;\n        }\n        return new Partial(this, this.getField(indexOfSupported).set(this, indexOfSupported, this.getValues(), n));\n    }\n    \n    public Partial withFieldAdded(final DurationFieldType durationFieldType, final int n) {\n        final int indexOfSupported = this.indexOfSupported(durationFieldType);\n        if (n == 0) {\n            return this;\n        }\n        return new Partial(this, this.getField(indexOfSupported).add(this, indexOfSupported, this.getValues(), n));\n    }\n    \n    public Partial withFieldAddWrapped(final DurationFieldType durationFieldType, final int n) {\n        final int indexOfSupported = this.indexOfSupported(durationFieldType);\n        if (n == 0) {\n            return this;\n        }\n        return new Partial(this, this.getField(indexOfSupported).addWrapPartial(this, indexOfSupported, this.getValues(), n));\n    }\n    \n    public Partial withPeriodAdded(final ReadablePeriod readablePeriod, final int n) {\n        if (readablePeriod == null || n == 0) {\n            return this;\n        }\n        int[] array = this.getValues();\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            final int index = this.indexOf(readablePeriod.getFieldType(i));\n            if (index >= 0) {\n                array = this.getField(index).add(this, index, array, FieldUtils.safeMultiply(readablePeriod.getValue(i), n));\n            }\n        }\n        return new Partial(this, array);\n    }\n    \n    public Partial plus(final ReadablePeriod readablePeriod) {\n        return this.withPeriodAdded(readablePeriod, 1);\n    }\n    \n    public Partial minus(final ReadablePeriod readablePeriod) {\n        return this.withPeriodAdded(readablePeriod, -1);\n    }\n    \n    public Property property(final DateTimeFieldType dateTimeFieldType) {\n        return new Property(this, this.indexOfSupported(dateTimeFieldType));\n    }\n    \n    public boolean isMatch(final ReadableInstant readableInstant) {\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        final Chronology instantChronology = DateTimeUtils.getInstantChronology(readableInstant);\n        for (int i = 0; i < this.iTypes.length; ++i) {\n            if (this.iTypes[i].getField(instantChronology).get(instantMillis) != this.iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public boolean isMatch(final ReadablePartial readablePartial) {\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < this.iTypes.length; ++i) {\n            if (readablePartial.get(this.iTypes[i]) != this.iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] iFormatter = this.iFormatter;\n        if (iFormatter == null) {\n            if (this.size() == 0) {\n                return null;\n            }\n            iFormatter = new DateTimeFormatter[2];\n            try {\n                final ArrayList<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(this.iTypes));\n                iFormatter[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    iFormatter[1] = iFormatter[0];\n                }\n            }\n            catch (IllegalArgumentException ex) {}\n            this.iFormatter = iFormatter;\n        }\n        return iFormatter[0];\n    }\n    \n    public String toString() {\n        DateTimeFormatter[] array = this.iFormatter;\n        if (array == null) {\n            this.getFormatter();\n            array = this.iFormatter;\n            if (array == null) {\n                return this.toStringList();\n            }\n        }\n        final DateTimeFormatter dateTimeFormatter = array[1];\n        if (dateTimeFormatter == null) {\n            return this.toStringList();\n        }\n        return dateTimeFormatter.print(this);\n    }\n    \n    public String toStringList() {\n        final int size = this.size();\n        final StringBuilder sb = new StringBuilder(20 * size);\n        sb.append('[');\n        for (int i = 0; i < size; ++i) {\n            if (i > 0) {\n                sb.append(',').append(' ');\n            }\n            sb.append(this.iTypes[i].getName());\n            sb.append('=');\n            sb.append(this.iValues[i]);\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n    \n    public String toString(final String s) {\n        if (s == null) {\n            return this.toString();\n        }\n        return DateTimeFormat.forPattern(s).print(this);\n    }\n    \n    public String toString(final String s, final Locale locale) {\n        if (s == null) {\n            return this.toString();\n        }\n        return DateTimeFormat.forPattern(s).withLocale(locale).print(this);\n    }\n    \n    public static class Property extends AbstractPartialFieldProperty implements Serializable\n    {\n        private static final long serialVersionUID = 53278362873888L;\n        private final Partial iPartial;\n        private final int iFieldIndex;\n        \n        Property(final Partial iPartial, final int iFieldIndex) {\n            this.iPartial = iPartial;\n            this.iFieldIndex = iFieldIndex;\n        }\n        \n        public DateTimeField getField() {\n            return this.iPartial.getField(this.iFieldIndex);\n        }\n        \n        protected ReadablePartial getReadablePartial() {\n            return this.iPartial;\n        }\n        \n        public Partial getPartial() {\n            return this.iPartial;\n        }\n        \n        public int get() {\n            return this.iPartial.getValue(this.iFieldIndex);\n        }\n        \n        public Partial addToCopy(final int n) {\n            return new Partial(this.iPartial, this.getField().add(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), n));\n        }\n        \n        public Partial addWrapFieldToCopy(final int n) {\n            return new Partial(this.iPartial, this.getField().addWrapField(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), n));\n        }\n        \n        public Partial setCopy(final int n) {\n            return new Partial(this.iPartial, this.getField().set(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), n));\n        }\n        \n        public Partial setCopy(final String s, final Locale locale) {\n            return new Partial(this.iPartial, this.getField().set(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), s, locale));\n        }\n        \n        public Partial setCopy(final String s) {\n            return this.setCopy(s, null);\n        }\n        \n        public Partial withMaximumValue() {\n            return this.setCopy(this.getMaximumValue());\n        }\n        \n        public Partial withMinimumValue() {\n            return this.setCopy(this.getMinimumValue());\n        }\n    }\n}\n",
        "token_number_zeroshot": 3519,
        "token_number_fewshot": 3917,
        "token_number_cot": 3629
    },
    {
        "project_name": "joda",
        "class": "BasicMonthOfYearDateTimeField",
        "source_code": "package org.joda.time.chrono;\n\nimport org.joda.time.field.*;\nimport org.joda.time.*;\n\nclass BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField\n{\n    private static final long serialVersionUID = -8258715387168736L;\n    private static final int MIN = 1;\n    private final BasicChronology iChronology;\n    private final int iMax;\n    private final int iLeapMonth;\n    \n    BasicMonthOfYearDateTimeField(final BasicChronology iChronology, final int iLeapMonth) {\n        super(DateTimeFieldType.monthOfYear(), iChronology.getAverageMillisPerMonth());\n        this.iChronology = iChronology;\n        this.iMax = this.iChronology.getMaxMonth();\n        this.iLeapMonth = iLeapMonth;\n    }\n    \n    public boolean isLenient() {\n        return false;\n    }\n    \n    public int get(final long n) {\n        return this.iChronology.getMonthOfYear(n);\n    }\n    \n    public long add(final long n, final int n2) {\n        if (n2 == 0) {\n            return n;\n        }\n        final long n3 = this.iChronology.getMillisOfDay(n);\n        final int year = this.iChronology.getYear(n);\n        final int monthOfYear = this.iChronology.getMonthOfYear(n, year);\n        final int n4 = monthOfYear - 1 + n2;\n        int n5;\n        int n6;\n        if (n4 >= 0) {\n            n5 = year + n4 / this.iMax;\n            n6 = n4 % this.iMax + 1;\n        }\n        else {\n            n5 = year + n4 / this.iMax - 1;\n            int iMax = Math.abs(n4) % this.iMax;\n            if (iMax == 0) {\n                iMax = this.iMax;\n            }\n            n6 = this.iMax - iMax + 1;\n            if (n6 == 1) {\n                ++n5;\n            }\n        }\n        int dayOfMonth = this.iChronology.getDayOfMonth(n, year, monthOfYear);\n        final int daysInYearMonth = this.iChronology.getDaysInYearMonth(n5, n6);\n        if (dayOfMonth > daysInYearMonth) {\n            dayOfMonth = daysInYearMonth;\n        }\n        return this.iChronology.getYearMonthDayMillis(n5, n6, dayOfMonth) + n3;\n    }\n    \n    public long add(final long n, final long n2) {\n        final int n3 = (int)n2;\n        if (n3 == n2) {\n            return this.add(n, n3);\n        }\n        final long n4 = this.iChronology.getMillisOfDay(n);\n        final int year = this.iChronology.getYear(n);\n        final int monthOfYear = this.iChronology.getMonthOfYear(n, year);\n        final long n5 = monthOfYear - 1 + n2;\n        long n6;\n        long n7;\n        if (n5 >= 0L) {\n            n6 = year + n5 / this.iMax;\n            n7 = n5 % this.iMax + 1L;\n        }\n        else {\n            n6 = year + n5 / this.iMax - 1L;\n            int iMax = (int)(Math.abs(n5) % this.iMax);\n            if (iMax == 0) {\n                iMax = this.iMax;\n            }\n            n7 = this.iMax - iMax + 1;\n            if (n7 == 1L) {\n                ++n6;\n            }\n        }\n        if (n6 < this.iChronology.getMinYear() || n6 > this.iChronology.getMaxYear()) {\n            throw new IllegalArgumentException(\"Magnitude of add amount is too large: \" + n2);\n        }\n        final int n8 = (int)n6;\n        final int n9 = (int)n7;\n        int dayOfMonth = this.iChronology.getDayOfMonth(n, year, monthOfYear);\n        final int daysInYearMonth = this.iChronology.getDaysInYearMonth(n8, n9);\n        if (dayOfMonth > daysInYearMonth) {\n            dayOfMonth = daysInYearMonth;\n        }\n        return this.iChronology.getYearMonthDayMillis(n8, n9, dayOfMonth) + n4;\n    }\n    \n    public int[] add(final ReadablePartial readablePartial, final int n, final int[] array, final int n2) {\n        if (n2 == 0) {\n            return array;\n        }\n        if (readablePartial.size() > 0 && readablePartial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && n == 0) {\n            return this.set(readablePartial, 0, array, (readablePartial.getValue(0) - 1 + n2 % 12 + 12) % 12 + 1);\n        }\n        if (DateTimeUtils.isContiguous(readablePartial)) {\n            long set = 0L;\n            for (int i = 0; i < readablePartial.size(); ++i) {\n                set = readablePartial.getFieldType(i).getField(this.iChronology).set(set, array[i]);\n            }\n            return this.iChronology.get(readablePartial, this.add(set, n2));\n        }\n        return super.add(readablePartial, n, array, n2);\n    }\n    \n    public long addWrapField(final long n, final int n2) {\n        return this.set(n, FieldUtils.getWrappedValue(this.get(n), n2, 1, this.iMax));\n    }\n    \n    public long getDifferenceAsLong(final long n, long set) {\n        if (n < set) {\n            return -this.getDifference(set, n);\n        }\n        final int year = this.iChronology.getYear(n);\n        final int monthOfYear = this.iChronology.getMonthOfYear(n, year);\n        final int year2 = this.iChronology.getYear(set);\n        final int monthOfYear2 = this.iChronology.getMonthOfYear(set, year2);\n        long n2 = (year - year2) * this.iMax + monthOfYear - monthOfYear2;\n        final int dayOfMonth = this.iChronology.getDayOfMonth(n, year, monthOfYear);\n        if (dayOfMonth == this.iChronology.getDaysInYearMonth(year, monthOfYear) && this.iChronology.getDayOfMonth(set, year2, monthOfYear2) > dayOfMonth) {\n            set = this.iChronology.dayOfMonth().set(set, dayOfMonth);\n        }\n        if (n - this.iChronology.getYearMonthMillis(year, monthOfYear) < set - this.iChronology.getYearMonthMillis(year2, monthOfYear2)) {\n            --n2;\n        }\n        return n2;\n    }\n    \n    public long set(final long n, final int n2) {\n        FieldUtils.verifyValueBounds(this, n2, 1, this.iMax);\n        final int year = this.iChronology.getYear(n);\n        int dayOfMonth = this.iChronology.getDayOfMonth(n, year);\n        final int daysInYearMonth = this.iChronology.getDaysInYearMonth(year, n2);\n        if (dayOfMonth > daysInYearMonth) {\n            dayOfMonth = daysInYearMonth;\n        }\n        return this.iChronology.getYearMonthDayMillis(year, n2, dayOfMonth) + this.iChronology.getMillisOfDay(n);\n    }\n    \n    public DurationField getRangeDurationField() {\n        return this.iChronology.years();\n    }\n    \n    public boolean isLeap(final long n) {\n        final int year = this.iChronology.getYear(n);\n        return this.iChronology.isLeapYear(year) && this.iChronology.getMonthOfYear(n, year) == this.iLeapMonth;\n    }\n    \n    public int getLeapAmount(final long n) {\n        return this.isLeap(n) ? 1 : 0;\n    }\n    \n    public DurationField getLeapDurationField() {\n        return this.iChronology.days();\n    }\n    \n    public int getMinimumValue() {\n        return 1;\n    }\n    \n    public int getMaximumValue() {\n        return this.iMax;\n    }\n    \n    public long roundFloor(final long n) {\n        final int year = this.iChronology.getYear(n);\n        return this.iChronology.getYearMonthMillis(year, this.iChronology.getMonthOfYear(n, year));\n    }\n    \n    public long remainder(final long n) {\n        return n - this.roundFloor(n);\n    }\n    \n    private Object readResolve() {\n        return this.iChronology.monthOfYear();\n    }\n}\n",
        "token_number_zeroshot": 1846,
        "token_number_fewshot": 2244,
        "token_number_cot": 1960
    },
    {
        "project_name": "joda",
        "class": "BasePeriod",
        "source_code": "package org.joda.time.base;\n\nimport java.io.*;\nimport org.joda.time.field.*;\nimport org.joda.time.chrono.*;\nimport org.joda.time.convert.*;\nimport org.joda.time.*;\n\npublic abstract class BasePeriod extends AbstractPeriod implements ReadablePeriod, Serializable\n{\n    private static final long serialVersionUID = -2110953284060001145L;\n    private static final ReadablePeriod DUMMY_PERIOD;\n    private final PeriodType iType;\n    private final int[] iValues;\n    \n    protected BasePeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        this.iType = checkPeriodType;\n        this.iValues = this.setPeriodInternal(n, n2, n3, n4, n5, n6, n7, n8);\n    }\n    \n    protected BasePeriod(final long n, final long n2, PeriodType checkPeriodType, Chronology chronology) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.iType = checkPeriodType;\n        this.iValues = chronology.get(this, n, n2);\n    }\n    \n    protected BasePeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        if (readableInstant == null && readableInstant2 == null) {\n            this.iType = checkPeriodType;\n            this.iValues = new int[this.size()];\n        }\n        else {\n            final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n            final long instantMillis2 = DateTimeUtils.getInstantMillis(readableInstant2);\n            final Chronology intervalChronology = DateTimeUtils.getIntervalChronology(readableInstant, readableInstant2);\n            this.iType = checkPeriodType;\n            this.iValues = intervalChronology.get(this, instantMillis, instantMillis2);\n        }\n    }\n    \n    protected BasePeriod(final ReadablePartial readablePartial, final ReadablePartial readablePartial2, PeriodType checkPeriodType) {\n        if (readablePartial == null || readablePartial2 == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (readablePartial instanceof BaseLocal && readablePartial2 instanceof BaseLocal && readablePartial.getClass() == readablePartial2.getClass()) {\n            checkPeriodType = this.checkPeriodType(checkPeriodType);\n            final long localMillis = ((BaseLocal)readablePartial).getLocalMillis();\n            final long localMillis2 = ((BaseLocal)readablePartial2).getLocalMillis();\n            final Chronology chronology = DateTimeUtils.getChronology(readablePartial.getChronology());\n            this.iType = checkPeriodType;\n            this.iValues = chronology.get(this, localMillis, localMillis2);\n        }\n        else {\n            if (readablePartial.size() != readablePartial2.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0; i < readablePartial.size(); ++i) {\n                if (readablePartial.getFieldType(i) != readablePartial2.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            if (!DateTimeUtils.isContiguous(readablePartial)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n            }\n            this.iType = this.checkPeriodType(checkPeriodType);\n            final Chronology withUTC = DateTimeUtils.getChronology(readablePartial.getChronology()).withUTC();\n            this.iValues = withUTC.get(this, withUTC.set(readablePartial, 0L), withUTC.set(readablePartial2, 0L));\n        }\n    }\n    \n    protected BasePeriod(final ReadableInstant readableInstant, final ReadableDuration readableDuration, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        final long safeAdd = FieldUtils.safeAdd(instantMillis, DateTimeUtils.getDurationMillis(readableDuration));\n        final Chronology instantChronology = DateTimeUtils.getInstantChronology(readableInstant);\n        this.iType = checkPeriodType;\n        this.iValues = instantChronology.get(this, instantMillis, safeAdd);\n    }\n    \n    protected BasePeriod(final ReadableDuration readableDuration, final ReadableInstant readableInstant, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        final long durationMillis = DateTimeUtils.getDurationMillis(readableDuration);\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        final long safeSubtract = FieldUtils.safeSubtract(instantMillis, durationMillis);\n        final Chronology instantChronology = DateTimeUtils.getInstantChronology(readableInstant);\n        this.iType = checkPeriodType;\n        this.iValues = instantChronology.get(this, safeSubtract, instantMillis);\n    }\n    \n    protected BasePeriod(final long n) {\n        this.iType = PeriodType.standard();\n        System.arraycopy(ISOChronology.getInstanceUTC().get(BasePeriod.DUMMY_PERIOD, n), 0, this.iValues = new int[8], 4, 4);\n    }\n    \n    protected BasePeriod(final long n, PeriodType checkPeriodType, Chronology chronology) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.iType = checkPeriodType;\n        this.iValues = chronology.get(this, n);\n    }\n    \n    protected BasePeriod(final Object o, PeriodType checkPeriodType, Chronology chronology) {\n        final PeriodConverter periodConverter = ConverterManager.getInstance().getPeriodConverter(o);\n        checkPeriodType = ((checkPeriodType == null) ? periodConverter.getPeriodType(o) : checkPeriodType);\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        this.iType = checkPeriodType;\n        if (this instanceof ReadWritablePeriod) {\n            this.iValues = new int[this.size()];\n            chronology = DateTimeUtils.getChronology(chronology);\n            periodConverter.setInto((ReadWritablePeriod)this, o, chronology);\n        }\n        else {\n            this.iValues = new MutablePeriod(o, checkPeriodType, chronology).getValues();\n        }\n    }\n    \n    protected BasePeriod(final int[] iValues, final PeriodType iType) {\n        this.iType = iType;\n        this.iValues = iValues;\n    }\n    \n    protected PeriodType checkPeriodType(final PeriodType periodType) {\n        return DateTimeUtils.getPeriodType(periodType);\n    }\n    \n    public PeriodType getPeriodType() {\n        return this.iType;\n    }\n    \n    public int getValue(final int n) {\n        return this.iValues[n];\n    }\n    \n    public Duration toDurationFrom(final ReadableInstant readableInstant) {\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        return new Duration(instantMillis, DateTimeUtils.getInstantChronology(readableInstant).add(this, instantMillis, 1));\n    }\n    \n    public Duration toDurationTo(final ReadableInstant readableInstant) {\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        return new Duration(DateTimeUtils.getInstantChronology(readableInstant).add(this, instantMillis, -1), instantMillis);\n    }\n    \n    private void checkAndUpdate(final DurationFieldType durationFieldType, final int[] array, final int n) {\n        final int index = this.indexOf(durationFieldType);\n        if (index == -1) {\n            if (n != 0) {\n                throw new IllegalArgumentException(\"Period does not support field '\" + durationFieldType.getName() + \"'\");\n            }\n        }\n        else {\n            array[index] = n;\n        }\n    }\n    \n    protected void setPeriod(final ReadablePeriod periodInternal) {\n        if (periodInternal == null) {\n            this.setValues(new int[this.size()]);\n        }\n        else {\n            this.setPeriodInternal(periodInternal);\n        }\n    }\n    \n    private void setPeriodInternal(final ReadablePeriod readablePeriod) {\n        final int[] values = new int[this.size()];\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            this.checkAndUpdate(readablePeriod.getFieldType(i), values, readablePeriod.getValue(i));\n        }\n        this.setValues(values);\n    }\n    \n    protected void setPeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        this.setValues(this.setPeriodInternal(n, n2, n3, n4, n5, n6, n7, n8));\n    }\n    \n    private int[] setPeriodInternal(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        final int[] array = new int[this.size()];\n        this.checkAndUpdate(DurationFieldType.years(), array, n);\n        this.checkAndUpdate(DurationFieldType.months(), array, n2);\n        this.checkAndUpdate(DurationFieldType.weeks(), array, n3);\n        this.checkAndUpdate(DurationFieldType.days(), array, n4);\n        this.checkAndUpdate(DurationFieldType.hours(), array, n5);\n        this.checkAndUpdate(DurationFieldType.minutes(), array, n6);\n        this.checkAndUpdate(DurationFieldType.seconds(), array, n7);\n        this.checkAndUpdate(DurationFieldType.millis(), array, n8);\n        return array;\n    }\n    \n    protected void setField(final DurationFieldType durationFieldType, final int n) {\n        this.setFieldInto(this.iValues, durationFieldType, n);\n    }\n    \n    protected void setFieldInto(final int[] array, final DurationFieldType durationFieldType, final int n) {\n        final int index = this.indexOf(durationFieldType);\n        if (index == -1) {\n            if (n != 0 || durationFieldType == null) {\n                throw new IllegalArgumentException(\"Period does not support field '\" + durationFieldType + \"'\");\n            }\n        }\n        else {\n            array[index] = n;\n        }\n    }\n    \n    protected void addField(final DurationFieldType durationFieldType, final int n) {\n        this.addFieldInto(this.iValues, durationFieldType, n);\n    }\n    \n    protected void addFieldInto(final int[] array, final DurationFieldType durationFieldType, final int n) {\n        final int index = this.indexOf(durationFieldType);\n        if (index == -1) {\n            if (n != 0 || durationFieldType == null) {\n                throw new IllegalArgumentException(\"Period does not support field '\" + durationFieldType + \"'\");\n            }\n        }\n        else {\n            array[index] = FieldUtils.safeAdd(array[index], n);\n        }\n    }\n    \n    protected void mergePeriod(final ReadablePeriod readablePeriod) {\n        if (readablePeriod != null) {\n            this.setValues(this.mergePeriodInto(this.getValues(), readablePeriod));\n        }\n    }\n    \n    protected int[] mergePeriodInto(final int[] array, final ReadablePeriod readablePeriod) {\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            this.checkAndUpdate(readablePeriod.getFieldType(i), array, readablePeriod.getValue(i));\n        }\n        return array;\n    }\n    \n    protected void addPeriod(final ReadablePeriod readablePeriod) {\n        if (readablePeriod != null) {\n            this.setValues(this.addPeriodInto(this.getValues(), readablePeriod));\n        }\n    }\n    \n    protected int[] addPeriodInto(final int[] array, final ReadablePeriod readablePeriod) {\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            final DurationFieldType fieldType = readablePeriod.getFieldType(i);\n            final int value = readablePeriod.getValue(i);\n            if (value != 0) {\n                final int index = this.indexOf(fieldType);\n                if (index == -1) {\n                    throw new IllegalArgumentException(\"Period does not support field '\" + fieldType.getName() + \"'\");\n                }\n                array[index] = FieldUtils.safeAdd(this.getValue(index), value);\n            }\n        }\n        return array;\n    }\n    \n    protected void setValue(final int n, final int n2) {\n        this.iValues[n] = n2;\n    }\n    \n    protected void setValues(final int[] array) {\n        System.arraycopy(array, 0, this.iValues, 0, this.iValues.length);\n    }\n    \n    static {\n        DUMMY_PERIOD = new AbstractPeriod() {\n            public int getValue(final int n) {\n                return 0;\n            }\n            \n            public PeriodType getPeriodType() {\n                return PeriodType.time();\n            }\n        };\n    }\n}\n",
        "token_number_zeroshot": 2730,
        "token_number_fewshot": 3128,
        "token_number_cot": 2841
    },
    {
        "project_name": "joda",
        "class": "DateTimeFormatter",
        "source_code": "package org.joda.time.format;\n\nimport java.util.*;\nimport java.io.*;\nimport org.joda.time.*;\n\npublic class DateTimeFormatter\n{\n    private final DateTimePrinter iPrinter;\n    private final DateTimeParser iParser;\n    private final Locale iLocale;\n    private final boolean iOffsetParsed;\n    private final Chronology iChrono;\n    private final DateTimeZone iZone;\n    private final Integer iPivotYear;\n    private final int iDefaultYear;\n    \n    public DateTimeFormatter(final DateTimePrinter iPrinter, final DateTimeParser iParser) {\n        this.iPrinter = iPrinter;\n        this.iParser = iParser;\n        this.iLocale = null;\n        this.iOffsetParsed = false;\n        this.iChrono = null;\n        this.iZone = null;\n        this.iPivotYear = null;\n        this.iDefaultYear = 2000;\n    }\n    \n    private DateTimeFormatter(final DateTimePrinter iPrinter, final DateTimeParser iParser, final Locale iLocale, final boolean iOffsetParsed, final Chronology iChrono, final DateTimeZone iZone, final Integer iPivotYear, final int iDefaultYear) {\n        this.iPrinter = iPrinter;\n        this.iParser = iParser;\n        this.iLocale = iLocale;\n        this.iOffsetParsed = iOffsetParsed;\n        this.iChrono = iChrono;\n        this.iZone = iZone;\n        this.iPivotYear = iPivotYear;\n        this.iDefaultYear = iDefaultYear;\n    }\n    \n    public boolean isPrinter() {\n        return this.iPrinter != null;\n    }\n    \n    public DateTimePrinter getPrinter() {\n        return this.iPrinter;\n    }\n    \n    public boolean isParser() {\n        return this.iParser != null;\n    }\n    \n    public DateTimeParser getParser() {\n        return this.iParser;\n    }\n    \n    public DateTimeFormatter withLocale(final Locale locale) {\n        if (locale == this.getLocale() || (locale != null && locale.equals(this.getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, locale, this.iOffsetParsed, this.iChrono, this.iZone, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public Locale getLocale() {\n        return this.iLocale;\n    }\n    \n    public DateTimeFormatter withOffsetParsed() {\n        if (this.iOffsetParsed) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, true, this.iChrono, null, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public boolean isOffsetParsed() {\n        return this.iOffsetParsed;\n    }\n    \n    public DateTimeFormatter withChronology(final Chronology chronology) {\n        if (this.iChrono == chronology) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, chronology, this.iZone, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public Chronology getChronology() {\n        return this.iChrono;\n    }\n    \n    @Deprecated\n    public Chronology getChronolgy() {\n        return this.iChrono;\n    }\n    \n    public DateTimeFormatter withZoneUTC() {\n        return this.withZone(DateTimeZone.UTC);\n    }\n    \n    public DateTimeFormatter withZone(final DateTimeZone dateTimeZone) {\n        if (this.iZone == dateTimeZone) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, false, this.iChrono, dateTimeZone, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public DateTimeZone getZone() {\n        return this.iZone;\n    }\n    \n    public DateTimeFormatter withPivotYear(final Integer n) {\n        if (this.iPivotYear == n || (this.iPivotYear != null && this.iPivotYear.equals(n))) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, this.iChrono, this.iZone, n, this.iDefaultYear);\n    }\n    \n    public DateTimeFormatter withPivotYear(final int n) {\n        return this.withPivotYear(Integer.valueOf(n));\n    }\n    \n    public Integer getPivotYear() {\n        return this.iPivotYear;\n    }\n    \n    public DateTimeFormatter withDefaultYear(final int n) {\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, this.iChrono, this.iZone, this.iPivotYear, n);\n    }\n    \n    public int getDefaultYear() {\n        return this.iDefaultYear;\n    }\n    \n    public void printTo(final StringBuffer sb, final ReadableInstant readableInstant) {\n        this.printTo(sb, DateTimeUtils.getInstantMillis(readableInstant), DateTimeUtils.getInstantChronology(readableInstant));\n    }\n    \n    public void printTo(final Writer writer, final ReadableInstant readableInstant) throws IOException {\n        this.printTo(writer, DateTimeUtils.getInstantMillis(readableInstant), DateTimeUtils.getInstantChronology(readableInstant));\n    }\n    \n    public void printTo(final Appendable appendable, final ReadableInstant readableInstant) throws IOException {\n        appendable.append(this.print(readableInstant));\n    }\n    \n    public void printTo(final StringBuffer sb, final long n) {\n        this.printTo(sb, n, null);\n    }\n    \n    public void printTo(final Writer writer, final long n) throws IOException {\n        this.printTo(writer, n, null);\n    }\n    \n    public void printTo(final Appendable appendable, final long n) throws IOException {\n        appendable.append(this.print(n));\n    }\n    \n    public void printTo(final StringBuffer sb, final ReadablePartial readablePartial) {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        requirePrinter.printTo(sb, readablePartial, this.iLocale);\n    }\n    \n    public void printTo(final Writer writer, final ReadablePartial readablePartial) throws IOException {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        requirePrinter.printTo(writer, readablePartial, this.iLocale);\n    }\n    \n    public void printTo(final Appendable appendable, final ReadablePartial readablePartial) throws IOException {\n        appendable.append(this.print(readablePartial));\n    }\n    \n    public String print(final ReadableInstant readableInstant) {\n        final StringBuffer sb = new StringBuffer(this.requirePrinter().estimatePrintedLength());\n        this.printTo(sb, readableInstant);\n        return sb.toString();\n    }\n    \n    public String print(final long n) {\n        final StringBuffer sb = new StringBuffer(this.requirePrinter().estimatePrintedLength());\n        this.printTo(sb, n);\n        return sb.toString();\n    }\n    \n    public String print(final ReadablePartial readablePartial) {\n        final StringBuffer sb = new StringBuffer(this.requirePrinter().estimatePrintedLength());\n        this.printTo(sb, readablePartial);\n        return sb.toString();\n    }\n    \n    private void printTo(final StringBuffer sb, final long n, Chronology selectChronology) {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        selectChronology = this.selectChronology(selectChronology);\n        DateTimeZone dateTimeZone = selectChronology.getZone();\n        int offset = dateTimeZone.getOffset(n);\n        long n2 = n + offset;\n        if ((n ^ n2) < 0L && (n ^ offset) >= 0L) {\n            dateTimeZone = DateTimeZone.UTC;\n            offset = 0;\n            n2 = n;\n        }\n        requirePrinter.printTo(sb, n2, selectChronology.withUTC(), offset, dateTimeZone, this.iLocale);\n    }\n    \n    private void printTo(final Writer writer, final long n, Chronology selectChronology) throws IOException {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        selectChronology = this.selectChronology(selectChronology);\n        DateTimeZone dateTimeZone = selectChronology.getZone();\n        int offset = dateTimeZone.getOffset(n);\n        long n2 = n + offset;\n        if ((n ^ n2) < 0L && (n ^ offset) >= 0L) {\n            dateTimeZone = DateTimeZone.UTC;\n            offset = 0;\n            n2 = n;\n        }\n        requirePrinter.printTo(writer, n2, selectChronology.withUTC(), offset, dateTimeZone, this.iLocale);\n    }\n    \n    private DateTimePrinter requirePrinter() {\n        final DateTimePrinter iPrinter = this.iPrinter;\n        if (iPrinter == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return iPrinter;\n    }\n    \n    public int parseInto(final ReadWritableInstant readWritableInstant, final String s, final int n) {\n        final DateTimeParser requireParser = this.requireParser();\n        if (readWritableInstant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        final long millis = readWritableInstant.getMillis();\n        final Chronology chronology = readWritableInstant.getChronology();\n        final int value = DateTimeUtils.getChronology(chronology).year().get(millis);\n        final long n2 = millis + chronology.getZone().getOffset(millis);\n        Chronology chronology2 = this.selectChronology(chronology);\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(n2, chronology2, this.iLocale, this.iPivotYear, value);\n        final int into = requireParser.parseInto(dateTimeParserBucket, s, n);\n        readWritableInstant.setMillis(dateTimeParserBucket.computeMillis(false, s));\n        if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {\n            chronology2 = chronology2.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n        }\n        else if (dateTimeParserBucket.getZone() != null) {\n            chronology2 = chronology2.withZone(dateTimeParserBucket.getZone());\n        }\n        readWritableInstant.setChronology(chronology2);\n        if (this.iZone != null) {\n            readWritableInstant.setZone(this.iZone);\n        }\n        return into;\n    }\n    \n    public long parseMillis(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, this.selectChronology(this.iChrono), this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                return dateTimeParserBucket.computeMillis(true, s);\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    public LocalDate parseLocalDate(final String s) {\n        return this.parseLocalDateTime(s).toLocalDate();\n    }\n    \n    public LocalTime parseLocalTime(final String s) {\n        return this.parseLocalDateTime(s).toLocalTime();\n    }\n    \n    public LocalDateTime parseLocalDateTime(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        Chronology chronology = this.selectChronology(null).withUTC();\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                final long computeMillis = dateTimeParserBucket.computeMillis(true, s);\n                if (dateTimeParserBucket.getOffsetInteger() != null) {\n                    chronology = chronology.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n                }\n                else if (dateTimeParserBucket.getZone() != null) {\n                    chronology = chronology.withZone(dateTimeParserBucket.getZone());\n                }\n                return new LocalDateTime(computeMillis, chronology);\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    public DateTime parseDateTime(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        Chronology chronology = this.selectChronology(null);\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                final long computeMillis = dateTimeParserBucket.computeMillis(true, s);\n                if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {\n                    chronology = chronology.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n                }\n                else if (dateTimeParserBucket.getZone() != null) {\n                    chronology = chronology.withZone(dateTimeParserBucket.getZone());\n                }\n                DateTime withZone = new DateTime(computeMillis, chronology);\n                if (this.iZone != null) {\n                    withZone = withZone.withZone(this.iZone);\n                }\n                return withZone;\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    public MutableDateTime parseMutableDateTime(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        Chronology chronology = this.selectChronology(null);\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                final long computeMillis = dateTimeParserBucket.computeMillis(true, s);\n                if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {\n                    chronology = chronology.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n                }\n                else if (dateTimeParserBucket.getZone() != null) {\n                    chronology = chronology.withZone(dateTimeParserBucket.getZone());\n                }\n                final MutableDateTime mutableDateTime = new MutableDateTime(computeMillis, chronology);\n                if (this.iZone != null) {\n                    mutableDateTime.setZone(this.iZone);\n                }\n                return mutableDateTime;\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    private DateTimeParser requireParser() {\n        final DateTimeParser iParser = this.iParser;\n        if (iParser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return iParser;\n    }\n    \n    private Chronology selectChronology(Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        if (this.iChrono != null) {\n            chronology = this.iChrono;\n        }\n        if (this.iZone != null) {\n            chronology = chronology.withZone(this.iZone);\n        }\n        return chronology;\n    }\n}\n",
        "token_number_zeroshot": 3274,
        "token_number_fewshot": 3672,
        "token_number_cot": 3385
    },
    {
        "project_name": "joda",
        "class": "BaseSingleFieldPeriod",
        "source_code": "package org.joda.time.base;\n\nimport java.io.*;\nimport org.joda.time.chrono.*;\nimport org.joda.time.field.*;\nimport org.joda.time.*;\n\npublic abstract class BaseSingleFieldPeriod implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable\n{\n    private static final long serialVersionUID = 9386874258972L;\n    private static final long START_1972 = 63072000000L;\n    private volatile int iPeriod;\n    \n    protected static int between(final ReadableInstant readableInstant, final ReadableInstant readableInstant2, final DurationFieldType durationFieldType) {\n        if (readableInstant == null || readableInstant2 == null) {\n            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n        }\n        return durationFieldType.getField(DateTimeUtils.getInstantChronology(readableInstant)).getDifference(readableInstant2.getMillis(), readableInstant.getMillis());\n    }\n    \n    protected static int between(final ReadablePartial readablePartial, final ReadablePartial readablePartial2, final ReadablePeriod readablePeriod) {\n        if (readablePartial == null || readablePartial2 == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (readablePartial.size() != readablePartial2.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0; i < readablePartial.size(); ++i) {\n            if (readablePartial.getFieldType(i) != readablePartial2.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (!DateTimeUtils.isContiguous(readablePartial)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        final Chronology withUTC = DateTimeUtils.getChronology(readablePartial.getChronology()).withUTC();\n        return withUTC.get(readablePeriod, withUTC.set(readablePartial, 63072000000L), withUTC.set(readablePartial2, 63072000000L))[0];\n    }\n    \n    protected static int standardPeriodIn(final ReadablePeriod readablePeriod, final long n) {\n        if (readablePeriod == null) {\n            return 0;\n        }\n        final ISOChronology instanceUTC = ISOChronology.getInstanceUTC();\n        long safeAdd = 0L;\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            final int value = readablePeriod.getValue(i);\n            if (value != 0) {\n                final DurationField field = readablePeriod.getFieldType(i).getField(instanceUTC);\n                if (!field.isPrecise()) {\n                    throw new IllegalArgumentException(\"Cannot convert period to duration as \" + field.getName() + \" is not precise in the period \" + readablePeriod);\n                }\n                safeAdd = FieldUtils.safeAdd(safeAdd, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n            }\n        }\n        return FieldUtils.safeToInt(safeAdd / n);\n    }\n    \n    protected BaseSingleFieldPeriod(final int iPeriod) {\n        this.iPeriod = iPeriod;\n    }\n    \n    protected int getValue() {\n        return this.iPeriod;\n    }\n    \n    protected void setValue(final int iPeriod) {\n        this.iPeriod = iPeriod;\n    }\n    \n    public abstract DurationFieldType getFieldType();\n    \n    public abstract PeriodType getPeriodType();\n    \n    public int size() {\n        return 1;\n    }\n    \n    public DurationFieldType getFieldType(final int n) {\n        if (n != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(n));\n        }\n        return this.getFieldType();\n    }\n    \n    public int getValue(final int n) {\n        if (n != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(n));\n        }\n        return this.getValue();\n    }\n    \n    public int get(final DurationFieldType durationFieldType) {\n        if (durationFieldType == this.getFieldType()) {\n            return this.getValue();\n        }\n        return 0;\n    }\n    \n    public boolean isSupported(final DurationFieldType durationFieldType) {\n        return durationFieldType == this.getFieldType();\n    }\n    \n    public Period toPeriod() {\n        return Period.ZERO.withFields(this);\n    }\n    \n    public MutablePeriod toMutablePeriod() {\n        final MutablePeriod mutablePeriod = new MutablePeriod();\n        mutablePeriod.add(this);\n        return mutablePeriod;\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof ReadablePeriod)) {\n            return false;\n        }\n        final ReadablePeriod readablePeriod = (ReadablePeriod)o;\n        return readablePeriod.getPeriodType() == this.getPeriodType() && readablePeriod.getValue(0) == this.getValue();\n    }\n    \n    public int hashCode() {\n        return 27 * (27 * 17 + this.getValue()) + this.getFieldType().hashCode();\n    }\n    \n    public int compareTo(final BaseSingleFieldPeriod baseSingleFieldPeriod) {\n        if (baseSingleFieldPeriod.getClass() != this.getClass()) {\n            throw new ClassCastException(this.getClass() + \" cannot be compared to \" + baseSingleFieldPeriod.getClass());\n        }\n        final int value = baseSingleFieldPeriod.getValue();\n        final int value2 = this.getValue();\n        if (value2 > value) {\n            return 1;\n        }\n        if (value2 < value) {\n            return -1;\n        }\n        return 0;\n    }\n}\n",
        "token_number_zeroshot": 1156,
        "token_number_fewshot": 1554,
        "token_number_cot": 1269
    },
    {
        "project_name": "1_tullibee",
        "class": "ComboLeg",
        "source_code": "package com.ib.client;\n\npublic class ComboLeg\n{\n    public static final int SAME = 0;\n    public static final int OPEN = 1;\n    public static final int CLOSE = 2;\n    public static final int UNKNOWN = 3;\n    public int m_conId;\n    public int m_ratio;\n    public String m_action;\n    public String m_exchange;\n    public int m_openClose;\n    public int m_shortSaleSlot;\n    public String m_designatedLocation;\n    \n    public ComboLeg() {\n        this(0, 0, null, null, 0, 0, null);\n    }\n    \n    public ComboLeg(final int p_conId, final int p_ratio, final String p_action, final String p_exchange, final int p_openClose) {\n        this(p_conId, p_ratio, p_action, p_exchange, p_openClose, 0, null);\n    }\n    \n    public ComboLeg(final int p_conId, final int p_ratio, final String p_action, final String p_exchange, final int p_openClose, final int p_shortSaleSlot, final String p_designatedLocation) {\n        this.m_conId = p_conId;\n        this.m_ratio = p_ratio;\n        this.m_action = p_action;\n        this.m_exchange = p_exchange;\n        this.m_openClose = p_openClose;\n        this.m_shortSaleSlot = p_shortSaleSlot;\n        this.m_designatedLocation = p_designatedLocation;\n    }\n    \n    @Override\n    public boolean equals(final Object p_other) {\n        if (this == p_other) {\n            return true;\n        }\n        if (p_other == null) {\n            return false;\n        }\n        final ComboLeg l_theOther = (ComboLeg)p_other;\n        return this.m_conId == l_theOther.m_conId && this.m_ratio == l_theOther.m_ratio && this.m_openClose == l_theOther.m_openClose && this.m_shortSaleSlot == l_theOther.m_shortSaleSlot && Util.StringCompareIgnCase(this.m_action, l_theOther.m_action) == 0 && Util.StringCompareIgnCase(this.m_exchange, l_theOther.m_exchange) == 0 && Util.StringCompareIgnCase(this.m_designatedLocation, l_theOther.m_designatedLocation) == 0;\n    }\n}\n",
        "token_number_zeroshot": 509,
        "token_number_fewshot": 907,
        "token_number_cot": 620
    },
    {
        "project_name": "1_tullibee",
        "class": "ExecutionFilter",
        "source_code": "package com.ib.client;\n\npublic class ExecutionFilter\n{\n    public int m_clientId;\n    public String m_acctCode;\n    public String m_time;\n    public String m_symbol;\n    public String m_secType;\n    public String m_exchange;\n    public String m_side;\n    \n    public ExecutionFilter() {\n        this.m_clientId = 0;\n    }\n    \n    public ExecutionFilter(final int p_clientId, final String p_acctCode, final String p_time, final String p_symbol, final String p_secType, final String p_exchange, final String p_side) {\n        this.m_clientId = p_clientId;\n        this.m_acctCode = p_acctCode;\n        this.m_time = p_time;\n        this.m_symbol = p_symbol;\n        this.m_secType = p_secType;\n        this.m_exchange = p_exchange;\n        this.m_side = p_side;\n    }\n    \n    @Override\n    public boolean equals(final Object p_other) {\n        boolean l_bRetVal = false;\n        if (p_other == null) {\n            l_bRetVal = false;\n        }\n        else if (this == p_other) {\n            l_bRetVal = true;\n        }\n        else {\n            final ExecutionFilter l_theOther = (ExecutionFilter)p_other;\n            l_bRetVal = (this.m_clientId == l_theOther.m_clientId && this.m_acctCode.equalsIgnoreCase(l_theOther.m_acctCode) && this.m_time.equalsIgnoreCase(l_theOther.m_time) && this.m_symbol.equalsIgnoreCase(l_theOther.m_symbol) && this.m_secType.equalsIgnoreCase(l_theOther.m_secType) && this.m_exchange.equalsIgnoreCase(l_theOther.m_exchange) && this.m_side.equalsIgnoreCase(l_theOther.m_side));\n        }\n        return l_bRetVal;\n    }\n}\n",
        "token_number_zeroshot": 395,
        "token_number_fewshot": 793,
        "token_number_cot": 506
    },
    {
        "project_name": "61_noen",
        "class": "ProbeInformation",
        "source_code": "package fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.*;\n\npublic class ProbeInformation\n{\n    private final String targetName;\n    private final String targetType;\n    private final String bmClass;\n    private final String bmName;\n    private final String bmDescription;\n    private final String probeName;\n    private final int precision;\n    private final String xmlRpcUrl;\n    \n    public ProbeInformation(final String targetName, final String targetType, final String bmClass, final String bmName, final String bmDescription, final String probeDescription, final int precision, final String xmlRpcUrl) {\n        this.targetName = targetName;\n        this.targetType = targetType;\n        this.bmClass = bmClass;\n        this.bmName = bmName;\n        this.bmDescription = bmDescription;\n        this.probeName = probeDescription;\n        this.precision = precision;\n        this.xmlRpcUrl = xmlRpcUrl;\n    }\n    \n    public String getTargetType() {\n        return this.targetType;\n    }\n    \n    public String getBmName() {\n        return this.bmName;\n    }\n    \n    public String getProbeName() {\n        return this.probeName;\n    }\n    \n    public String getTargetName() {\n        return this.targetName;\n    }\n    \n    public String getBmClass() {\n        return this.bmClass;\n    }\n    \n    public String getBmDescription() {\n        return this.bmDescription;\n    }\n    \n    public int getPrecision() {\n        return this.precision;\n    }\n    \n    public String getMeasureURI() {\n        return Const.createMeasureURI(this.targetType, this.targetName, this.bmClass, this.bmName);\n    }\n    \n    public String getXmlRpcUrl() {\n        return this.xmlRpcUrl;\n    }\n    \n    @Override\n    public String toString() {\n        return \"ProbeInformation{targetName='\" + this.targetName + '\\'' + \", targetType='\" + this.targetType + '\\'' + \", bmClass='\" + this.bmClass + '\\'' + \", bmName='\" + this.bmName + '\\'' + \", bmDescription='\" + this.bmDescription + '\\'' + \", probeDescription='\" + this.probeName + '\\'' + \", precision=\" + this.precision + '}';\n    }\n    \n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final ProbeInformation that = (ProbeInformation)o;\n        if (this.precision != that.precision) {\n            return false;\n        }\n        Label_0075: {\n            if (this.bmClass != null) {\n                if (this.bmClass.equals(that.bmClass)) {\n                    break Label_0075;\n                }\n            }\n            else if (that.bmClass == null) {\n                break Label_0075;\n            }\n            return false;\n        }\n        Label_0108: {\n            if (this.bmDescription != null) {\n                if (this.bmDescription.equals(that.bmDescription)) {\n                    break Label_0108;\n                }\n            }\n            else if (that.bmDescription == null) {\n                break Label_0108;\n            }\n            return false;\n        }\n        Label_0141: {\n            if (this.bmName != null) {\n                if (this.bmName.equals(that.bmName)) {\n                    break Label_0141;\n                }\n            }\n            else if (that.bmName == null) {\n                break Label_0141;\n            }\n            return false;\n        }\n        Label_0174: {\n            if (this.probeName != null) {\n                if (this.probeName.equals(that.probeName)) {\n                    break Label_0174;\n                }\n            }\n            else if (that.probeName == null) {\n                break Label_0174;\n            }\n            return false;\n        }\n        Label_0207: {\n            if (this.targetName != null) {\n                if (this.targetName.equals(that.targetName)) {\n                    break Label_0207;\n                }\n            }\n            else if (that.targetName == null) {\n                break Label_0207;\n            }\n            return false;\n        }\n        if (this.targetType != null) {\n            if (this.targetType.equals(that.targetType)) {\n                return true;\n            }\n        }\n        else if (that.targetType == null) {\n            return true;\n        }\n        return false;\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = (this.targetName != null) ? this.targetName.hashCode() : 0;\n        result = 31 * result + ((this.targetType != null) ? this.targetType.hashCode() : 0);\n        result = 31 * result + ((this.bmClass != null) ? this.bmClass.hashCode() : 0);\n        result = 31 * result + ((this.bmName != null) ? this.bmName.hashCode() : 0);\n        result = 31 * result + ((this.bmDescription != null) ? this.bmDescription.hashCode() : 0);\n        result = 31 * result + ((this.probeName != null) ? this.probeName.hashCode() : 0);\n        result = 31 * result + this.precision;\n        return result;\n    }\n}\n",
        "token_number_zeroshot": 1162,
        "token_number_fewshot": 1560,
        "token_number_cot": 1273
    },
    {
        "project_name": "61_noen",
        "class": "DaikonFormatter",
        "source_code": "package fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.parser.*;\nimport java.io.*;\nimport fi.vtt.noen.testgen.model.*;\nimport java.util.*;\nimport fi.vtt.noen.testgen.observations.data.*;\n\npublic class DaikonFormatter extends BasicFormatter\n{\n    private Set<String> declarations;\n    private boolean simple;\n    private final Collection<String> inputs;\n    \n    public DaikonFormatter(final String fileName, final boolean simple) throws IOException {\n        super(fileName);\n        this.declarations = new HashSet<String>();\n        this.simple = false;\n        this.simple = simple;\n        if (simple) {\n            this.inputs = null;\n            return;\n        }\n        try {\n            this.inputs = InterfaceParser.methodNames(inputs());\n            System.out.println(\"inputs:\" + this.inputs);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\n        }\n    }\n    \n    public DaikonFormatter(final String fileName, final Collection<String> inputs) throws IOException {\n        super(fileName);\n        this.declarations = new HashSet<String>();\n        this.simple = false;\n        this.inputs = inputs;\n        System.out.println(\"inputs:\" + inputs);\n    }\n    \n    private static Class classForProperty(final String property) throws Exception {\n        final Properties configuration = new Properties();\n        configuration.load(new FileInputStream(\"testgen.properties\"));\n        final String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n    \n    private static Collection<Class> classesForMultipleProperties(final String prefix) throws Exception {\n        final Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            final Class clazz = classForProperty(prefix + index);\n            ++index;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n    \n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n    \n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n    \n    @Override\n    public String header() {\n        final OutputBuffer out = new OutputBuffer();\n        out.append(\"decl-version 2.0\");\n        out.append(\"var-comparability implicit\");\n        return out.toString();\n    }\n    \n    @Override\n    public String footer() {\n        return \"\";\n    }\n    \n    @Override\n    public String fileNameExtension() {\n        return \"dtrace\";\n    }\n    \n    @Override\n    public String observations(final ProgramRun run) {\n        final OutputBuffer out = new OutputBuffer();\n        Event previousEvent = null;\n        Event event = Const.INITIAL_STATE;\n        final Iterator<Event> ei = run.iterator();\n        while (ei.hasNext()) {\n            previousEvent = event;\n            event = ei.next();\n            if (this.simple) {\n                this.simplePoint(event, \"10\", out);\n            }\n            else {\n                if ((this.inputs.contains(previousEvent.getName()) && this.inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\n                    this.point(previousEvent.getName(), previousEvent, \"11\", out);\n                }\n                if (previousEvent.isExit()) {\n                    this.point(previousEvent.getName(), previousEvent, \"22\", out);\n                }\n                else {\n                    if (!this.inputs.contains(previousEvent.getName()) || this.inputs.contains(event.getName()) || previousEvent.isExit() || event.isExit()) {\n                        continue;\n                    }\n                    final String name = previousEvent.getName() + \",\" + event.getName();\n                    this.point(name, previousEvent, \"22\", out);\n                }\n            }\n        }\n        if (!this.simple && (this.inputs.contains(event.getName()) || event.isExit())) {\n            this.point(event.getName(), event, \"11\", out);\n        }\n        return out.toString();\n    }\n    \n    private void simplePoint(final Event event, final String comparability, final OutputBuffer out) {\n        String name = event.getName();\n        name = name.replace(' ', '_');\n        if (!event.isExit()) {\n            name += \":::ENTER\";\n        }\n        else {\n            name += \":::EXIT1\";\n        }\n        this.declarations(event, name, out, comparability);\n        out.append(\"\");\n        out.append(name);\n        this.attributes(event, out);\n    }\n    \n    private void point(String name, final Event event, final String comparability, final OutputBuffer out) {\n        name = name.replace(' ', '_');\n        name += \":::ENTER\";\n        this.declarations(event, name, out, comparability);\n        out.append(\"\");\n        out.append(name);\n        this.attributes(event, out);\n    }\n    \n    private void declarations(final Event event, final String eventName, final OutputBuffer out, final String comparability) {\n        if (this.declarations.contains(eventName)) {\n            return;\n        }\n        this.declarations.add(eventName);\n        out.append(\"\");\n        out.append(\"ppt \" + eventName);\n        if (event.isExit()) {\n            out.append(\"ppt-type exit\");\n        }\n        else {\n            out.append(\"ppt-type enter\");\n        }\n        final Iterator<EventAttribute> ai = event.attributes();\n        while (ai.hasNext()) {\n            final EventAttribute attribute = ai.next();\n            if (attribute instanceof ArrayAttribute) {\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\n                out.append(\"    var-kind array\");\n            }\n            else {\n                out.append(\"  variable \" + attribute.getName());\n                out.append(\"    var-kind variable\");\n            }\n            out.append(\"    dec-type \" + attribute.getType());\n            out.append(\"    rep-type \" + attribute.getType());\n            out.append(\"    comparability \" + comparability);\n        }\n    }\n    \n    private void attributes(final Event event, final OutputBuffer out) {\n        final Iterator<EventAttribute> ai = event.attributes();\n        while (ai.hasNext()) {\n            final EventAttribute attribute = ai.next();\n            if (attribute instanceof ArrayAttribute) {\n                out.append(attribute.getName() + \"[]\");\n            }\n            else {\n                out.append(attribute.getName());\n            }\n            if (attribute.getType().equals(\"java.lang.String\")) {\n                out.append('\\\"' + attribute.getValue() + '\\\"');\n            }\n            else {\n                out.append(attribute.getValue());\n            }\n            out.append(\"1\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 1387,
        "token_number_fewshot": 1785,
        "token_number_cot": 1499
    },
    {
        "project_name": "8_gfarcegestionfa",
        "class": "OracleIdentiteDao",
        "source_code": "package fr.unice.gfarce.dao;\n\nimport javax.persistence.*;\nimport java.util.*;\nimport fr.unice.gfarce.identity.*;\n\npublic class OracleIdentiteDao implements IdentiteDao\n{\n    String persistUnitName;\n    @PersistenceContext\n    private EntityManager em;\n    \n    public OracleIdentiteDao() {\n        this.persistUnitName = \"Identite\";\n    }\n    \n    public static OracleIdentiteDao getDAO() {\n        return new OracleIdentiteDao();\n    }\n    \n    @Override\n    public void insert(final Identite identite, final String nomForm, final Calendar dateLimite) {\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            this.em.persist((Object)identite);\n            tx.commit();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n    }\n    \n    @Override\n    public void update(final Identite identite) {\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            final Identite i = (Identite)this.em.find((Class)identite.getClass(), (Object)identite.getId());\n            i.setEmail(identite.getEmail());\n            i.setNom(identite.getNom());\n            i.setPrenom(identite.getPrenom());\n            i.setSex(identite.getSex());\n            i.setType(identite.getType());\n            this.em.merge((Object)identite);\n            tx.commit();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n    }\n    \n    @Override\n    public void delete(final Identite identite) {\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            final Identite ident = (Identite)this.em.find((Class)identite.getClass(), (Object)identite.getId());\n            this.em.remove((Object)ident);\n            tx.commit();\n        }\n        catch (Exception e1) {\n            e1.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n    }\n    \n    public List<Identite> find(final String nom, final String prenom, final String sex, final String email, final Identite.TypeIdentite type) {\n        String a;\n        if (nom == null) {\n            a = \"ident.nom like '%'\";\n        }\n        else {\n            a = \"ident.nom='\" + nom + \"'\";\n        }\n        String b;\n        if (prenom == null) {\n            b = \"ident.prenom like '%'\";\n        }\n        else {\n            b = \"ident.prenom='\" + prenom + \"'\";\n        }\n        String c;\n        if (sex == null) {\n            c = \"ident.sex like '%'\";\n        }\n        else {\n            c = \"ident.sex='\" + sex + \"'\";\n        }\n        String e;\n        if (type == Identite.TypeIdentite.CANDIDAT) {\n            e = \"ident.type= :CANDIDAT\";\n        }\n        else if (type == Identite.TypeIdentite.FORMATEUR) {\n            e = \"ident.type= :FORMATEUR\";\n        }\n        else {\n            e = \"ident.type like '%'\";\n        }\n        final String s = \"select ident from Identite as ident where \" + a + \" and \" + b + \" and \" + c + \" and \" + e;\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        List<Identite> list = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            if (type == Identite.TypeIdentite.CANDIDAT) {\n                list = (List<Identite>)this.em.createQuery(s).setParameter(\"CANDIDAT\", (Object)Identite.TypeIdentite.CANDIDAT).getResultList();\n            }\n            else if (type == Identite.TypeIdentite.FORMATEUR) {\n                list = (List<Identite>)this.em.createQuery(s).setParameter(\"FORMATEUR\", (Object)Identite.TypeIdentite.FORMATEUR).getResultList();\n            }\n            else {\n                list = (List<Identite>)this.em.createQuery(s).getResultList();\n            }\n        }\n        catch (Exception e2) {\n            e2.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n        return list;\n    }\n    \n    @Override\n    public Candidat[] findCandidat(final String nom, final String prenom, final String sex, final String email) {\n        final List<Identite> resultList = this.find(nom, prenom, sex, email, Identite.TypeIdentite.CANDIDAT);\n        if (resultList != null) {\n            final Candidat[] result = resultList.toArray(new Candidat[resultList.size()]);\n            return result;\n        }\n        return null;\n    }\n    \n    @Override\n    public RespFormation[] findRespForm(final String nom, final String prenom, final String sex, final String email) {\n        final List<Identite> resultList = this.find(nom, prenom, sex, email, Identite.TypeIdentite.FORMATEUR);\n        if (resultList != null) {\n            final RespFormation[] result = resultList.toArray(new RespFormation[resultList.size()]);\n            return result;\n        }\n        return null;\n    }\n}\n",
        "token_number_zeroshot": 1446,
        "token_number_fewshot": 1844,
        "token_number_cot": 1559
    },
    {
        "project_name": "8_gfarcegestionfa",
        "class": "ModifTableStockage",
        "source_code": "package fr.unice.gfarce.interGraph;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class ModifTableStockage\n{\n    private int nbColonnes;\n    private int nbLignes;\n    private TableStockage ts;\n    \n    public ModifTableStockage(final TableStockage ts) {\n        this.nbColonnes = 0;\n        this.nbLignes = 0;\n        this.nbColonnes = ts.getColumnCount();\n        this.nbLignes = ts.getRowCount() + 1;\n        this.ts = ts;\n    }\n    \n    public TableStockage ajouterColonne(final String nomNouvelleColonne, final Class<?> type) {\n        ++this.nbColonnes;\n        final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        for (int j = 0; j < this.nbColonnes - 1; ++j) {\n            tableS.setColumnName(j, this.ts.getColumnName(j));\n        }\n        tableS.setColumnName(this.nbColonnes - 1, nomNouvelleColonne);\n        for (int i = 0; i < this.nbLignes - 1; ++i) {\n            for (int k = 0; k < this.nbColonnes - 1; ++k) {\n                tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n            }\n            tableS.setColumnClass(this.nbColonnes - 1, type);\n        }\n        return tableS;\n    }\n    \n    public TableStockage ajouterLigne() {\n        if (this.nbColonnes > 0) {\n            ++this.nbLignes;\n            final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n            for (int j = 0; j < this.nbColonnes; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j));\n            }\n            for (int i = 0; i < this.nbLignes - 2; ++i) {\n                for (int k = 0; k < this.nbColonnes; ++k) {\n                    tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n                }\n            }\n            for (int j = 0; j < this.nbColonnes; ++j) {\n                if (this.ts.getColumnClass(j).equals(String.class)) {\n                    tableS.setValueAt(\"\", this.nbLignes - 2, j);\n                }\n                else if (this.ts.getColumnClass(j).equals(Double.class)) {\n                    tableS.setValueAt(new Double(\"0\"), this.nbLignes - 2, j);\n                }\n                else {\n                    tableS.setValueAt(new Boolean(false), this.nbLignes - 2, j);\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"PAS DE COLONNE\", \"ERREUR\", 0);\n        return this.ts;\n    }\n    \n    public TableStockage supprimerColonne(final int indice) {\n        --this.nbColonnes;\n        final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        for (int j = 0; j < indice; ++j) {\n            tableS.setColumnName(j, this.ts.getColumnName(j));\n        }\n        for (int i = 0; i < this.nbLignes - 1; ++i) {\n            for (int k = 0; k < indice; ++k) {\n                tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n            }\n        }\n        if (indice != this.nbColonnes) {\n            for (int j = indice; j < this.nbColonnes; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j + 1));\n            }\n            for (int i = 0; i < this.nbLignes - 1; ++i) {\n                for (int k = indice; k < this.nbColonnes; ++k) {\n                    tableS.setValueAt(this.ts.getValueAt(i, k + 1), i, k);\n                }\n            }\n        }\n        return tableS;\n    }\n    \n    public TableStockage supprimerLigne(final int indice) {\n        --this.nbLignes;\n        final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        for (int j = 0; j < this.nbColonnes; ++j) {\n            tableS.setColumnName(j, this.ts.getColumnName(j));\n        }\n        for (int i = 0; i < indice; ++i) {\n            for (int k = 0; k < this.nbColonnes; ++k) {\n                tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n            }\n        }\n        if (indice != this.nbLignes - 1) {\n            for (int i = indice + 1; i < this.nbLignes; ++i) {\n                for (int k = 0; k < this.nbColonnes; ++k) {\n                    tableS.setValueAt(this.ts.getValueAt(i, k), i - 1, k);\n                }\n            }\n        }\n        return tableS;\n    }\n    \n    public TableStockage separerColonne(final int indice) {\n        if (!this.ts.getColumnClass(indice).equals(String.class)) {\n            JOptionPane.showMessageDialog(null, \"non separable: PAS DE TYPE STRING\", \"ERREUR\", 0);\n            return this.ts;\n        }\n        int k = 0;\n        String val = (String)this.ts.getValueAt(0, indice);\n        String val2 = new String();\n        while (val.charAt(k) != '\u00a0' && k != val.length() - 1) {\n            val2 = val2.concat(String.valueOf(val.charAt(k)));\n            ++k;\n        }\n        if (k == val.length() - 1) {\n            val2 = new String();\n            for (k = 0; val.charAt(k) != ' ' && k != val.length() - 1; ++k) {\n                val2 = val2.concat(String.valueOf(val.charAt(k)));\n            }\n        }\n        if (k != val.length() - 1) {\n            ++this.nbColonnes;\n            final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n            val2 = new String();\n            k = 0;\n            for (int j = 0; j < indice; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j));\n            }\n            for (int j = indice + 1; j < this.nbColonnes; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j - 1));\n            }\n            final String colonne = this.ts.getColumnName(indice);\n            final String[] resNP = colonne.split(\" \", 2);\n            final String val1Colonne = resNP[0];\n            String val2Colonne;\n            if (resNP.length > 1) {\n                val2Colonne = resNP[1];\n            }\n            else {\n                val2Colonne = \"\";\n            }\n            tableS.setColumnName(indice, val1Colonne);\n            tableS.setColumnName(indice + 1, val2Colonne);\n            for (int i = 0; i < this.nbLignes - 1; ++i) {\n                for (int l = 0; l < indice; ++l) {\n                    tableS.setValueAt(this.ts.getValueAt(i, l), i, l);\n                }\n                for (int l = indice + 2; l < this.nbColonnes; ++l) {\n                    tableS.setValueAt(this.ts.getValueAt(i, l - 1), i, l);\n                }\n            }\n            String val3 = null;\n            for (int m = 0; m < this.nbLignes - 1; ++m) {\n                val2 = new String();\n                val = (String)this.ts.getValueAt(m, indice);\n                k = 0;\n                if (val.equals(\"\")) {\n                    val2 = \"\";\n                    val3 = \"\";\n                }\n                else {\n                    while (val.charAt(k) != '\u00a0' && k != val.length() - 1) {\n                        val2 = val2.concat(String.valueOf(val.charAt(k)));\n                        ++k;\n                    }\n                    if (k == val.length() - 1) {\n                        val2 = new String();\n                        for (k = 0; val.charAt(k) != ' ' && k != val.length() - 1; ++k) {\n                            val2 = val2.concat(String.valueOf(val.charAt(k)));\n                        }\n                    }\n                    val3 = val.substring(k + 1, val.length());\n                }\n                double int1 = 0.0;\n                double int2 = 0.0;\n                try {\n                    int1 = Double.parseDouble(val2);\n                    tableS.setValueAt(int1, m, indice);\n                }\n                catch (NumberFormatException e) {\n                    tableS.setValueAt(val2, m, indice);\n                }\n                try {\n                    int2 = Double.parseDouble(val3);\n                    tableS.setValueAt(int2, m, indice + 1);\n                }\n                catch (NumberFormatException e) {\n                    tableS.setValueAt(val3, m, indice + 1);\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"PAS SEPARABLE\", \"ERREUR\", 0);\n        return this.ts;\n    }\n    \n    public TableStockage fusionnerColonnes(final int indice) {\n        if (this.nbColonnes <= 1) {\n            JOptionPane.showMessageDialog(null, \"UNE SEULE COLONNE\", \"ERREUR\", 0);\n            return this.ts;\n        }\n        if (!this.ts.getColumnClass(indice).equals(Boolean.class) && !this.ts.getColumnClass(indice + 1).equals(Boolean.class)) {\n            --this.nbColonnes;\n            final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n            for (int j = 0; j < indice; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j));\n            }\n            final String c1 = this.ts.getColumnName(indice);\n            final String c2 = this.ts.getColumnName(indice + 1);\n            for (int i = indice + 1; i < this.nbColonnes; ++i) {\n                tableS.setColumnName(i, this.ts.getColumnName(i + 1));\n            }\n            tableS.setColumnName(indice, c1.concat(\" \" + c2));\n            for (int k = 0; k < this.nbLignes - 1; ++k) {\n                for (int l = 0; l < indice; ++l) {\n                    tableS.setValueAt(this.ts.getValueAt(k, l), k, l);\n                }\n                final Object d1 = this.ts.getValueAt(k, indice);\n                final Object d2 = this.ts.getValueAt(k, indice + 1);\n                final String s1 = d1.toString();\n                final String s2 = d2.toString();\n                tableS.setValueAt(s1.concat(\" \" + s2), k, indice);\n                for (int m = indice + 1; m < this.nbColonnes; ++m) {\n                    tableS.setValueAt(this.ts.getValueAt(k, m + 1), k, m);\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"PAS DE TYPE STRING\", \"ERREUR\", 0);\n        return this.ts;\n    }\n    \n    public TableStockage colonneMail() {\n        ++this.nbColonnes;\n        final ModifTableStockage mt = new ModifTableStockage(this.ts);\n        TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        tableS = mt.ajouterColonne(\"Envoyer E-Mail a:\", Boolean.class);\n        for (int i = 0; i < this.nbLignes - 1; ++i) {\n            tableS.setValueAt(new Boolean(true), i, this.nbColonnes - 1);\n        }\n        return tableS;\n    }\n    \n    public TableStockage selectMail() {\n        int j;\n        for (j = 0; j < this.nbColonnes && !this.ts.getColumnName(j).equals(\"Envoyer E-Mail a:\"); ++j) {}\n        if (j != this.nbColonnes) {\n            int newNbLignes = 0;\n            for (int i = 0; i < this.nbLignes - 1; ++i) {\n                final Boolean bool = (Boolean)this.ts.getValueAt(i, j);\n                if (bool) {\n                    ++newNbLignes;\n                }\n            }\n            final TableStockage tableS = new TableStockage(newNbLignes + 1, this.nbColonnes);\n            int k = 0;\n            for (int ind = 0; ind < this.nbColonnes; ++ind) {\n                tableS.setColumnName(ind, this.ts.getColumnName(ind));\n            }\n            for (int row = 0; row < this.nbLignes - 1; ++row) {\n                Boolean bool = (Boolean)this.ts.getValueAt(row, j);\n                if (bool) {\n                    for (int column = 0; column < this.nbColonnes; ++column) {\n                        tableS.setValueAt(this.ts.getValueAt(row, column), k, column);\n                        bool = false;\n                    }\n                    ++k;\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"Le mail sera envoye a toute la liste\", \"Information\", 1);\n        return this.ts;\n    }\n}\n",
        "token_number_zeroshot": 2942,
        "token_number_fewshot": 3340,
        "token_number_cot": 3056
    },
    {
        "project_name": "51_jiprof",
        "class": "Profile",
        "source_code": "package com.mentorgen.tools.profile.runtime;\n\nimport com.mentorgen.tools.profile.*;\nimport java.util.*;\nimport com.mentorgen.tools.profile.output.*;\nimport java.io.*;\n\npublic final class Profile implements Runnable\n{\n    private static boolean _debugStart;\n    private static boolean _debugException;\n    private static ThreadDictionary _threadDictionary;\n    private static List<Frame> _frameList;\n    private static Map<Long, Frame> _threadActiveFrame;\n    private static Map<String, Method> _methodDictionary;\n    private static Object _lock;\n    private static Map<String, ClassAllocation> _allocList;\n    private static Controller _controller;\n    private static Thread _controllerThread;\n    \n    public static void initProfiler() {\n        System.err.println(\"Java Interactive Profiler: starting\");\n        init();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Profile()));\n        Profile._controller = new Controller();\n        if (Controller._remote) {\n            (Profile._controllerThread = new Thread(Profile._controller)).start();\n        }\n    }\n    \n    public static void init() {\n        Profile._threadActiveFrame = new HashMap<Long, Frame>(1001);\n        Profile._threadDictionary = new ThreadDictionary();\n        Profile._methodDictionary = new HashMap<String, Method>(2003);\n        Profile._frameList = new ArrayList<Frame>(1001);\n        Profile._lock = new Object();\n        Profile._allocList = new HashMap<String, ClassAllocation>();\n    }\n    \n    public static void clear() {\n        init();\n    }\n    \n    public static void start() {\n        Profile._controller.start();\n    }\n    \n    public static void stop() {\n        Profile._controller.stop();\n    }\n    \n    public static void setFileName(final String fileName) {\n        Profile._controller.setFileName(fileName);\n    }\n    \n    public static void shutdown() {\n        synchronized (Profile._lock) {\n            Controller._profile = false;\n            for (final Long threadId : ((HashMap<Long, V>)Profile._threadDictionary).keySet()) {\n                final Frame f = Profile._threadDictionary.getMostRecentFrame(threadId);\n                f.close();\n            }\n            for (final Frame frame : frameList()) {\n                frame.computeNetTime();\n            }\n        }\n    }\n    \n    public static Iterable<Long> threads() {\n        return Profile._threadDictionary.threads();\n    }\n    \n    public static Iterable<Frame> interactions(final long threadId) {\n        return Profile._threadDictionary.interactions(threadId);\n    }\n    \n    public static Iterable<Frame> frameList() {\n        return Profile._frameList;\n    }\n    \n    public static Iterable<ClassAllocation> allocations() {\n        return Profile._allocList.values();\n    }\n    \n    public static long getThreadTotalTime(final long threadId) {\n        return Profile._threadDictionary.getThreadTotalTime(threadId);\n    }\n    \n    public static void sortFrameList(final Comparator<Frame> comp) {\n        synchronized (Profile._lock) {\n            Collections.sort(Profile._frameList, comp);\n        }\n    }\n    \n    public static void start(final String className, final String methodName) {\n        final long start = System.nanoTime();\n        final long threadId = Thread.currentThread().getId();\n        synchronized (Profile._lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            final Method method = new Method(className, methodName);\n            if (Profile._methodDictionary.get(method.toString()) == null) {\n                Profile._methodDictionary.put(method.toString(), method);\n            }\n            final Frame parent = Profile._threadActiveFrame.get(threadId);\n            Frame target = null;\n            if (parent != null) {\n                target = parent.getChild(method);\n                if (target == null) {\n                    target = new Frame(parent, method, threadId);\n                    Profile._frameList.add(target);\n                }\n            }\n            else {\n                target = new Frame(null, method, threadId);\n                Profile._frameList.add(target);\n                Profile._threadDictionary.add(threadId, target);\n            }\n            if (Profile._debugStart) {\n                System.out.print(\"  (\");\n                System.out.print(className);\n                System.out.print(\" : \");\n                System.out.print(methodName);\n                System.out.println(')');\n                final Frame root = Profile._threadDictionary.getMostRecentFrame(threadId);\n                System.out.println(root);\n            }\n            Profile._threadActiveFrame.put(threadId, target);\n            target.overhead(System.nanoTime() - start);\n            target.setBeginTime(start);\n        }\n    }\n    \n    public static void end(final String className, final String method) {\n        final long start = System.nanoTime();\n        synchronized (Profile._lock) {\n            final long threadId = Thread.currentThread().getId();\n            final Frame target = findFrame(threadId, className, method);\n            if (target == null) {\n                return;\n            }\n            if (target.getParent() != null) {\n                Profile._threadActiveFrame.put(threadId, target.getParent());\n            }\n            else {\n                Profile._threadActiveFrame.put(threadId, null);\n            }\n            target.overhead(System.nanoTime() - start);\n            target.setEndTime(System.nanoTime());\n        }\n    }\n    \n    public static void beginWait(final String className, final String methodName) {\n        final long start = System.nanoTime();\n        synchronized (Profile._lock) {\n            final Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.beginWait(System.nanoTime());\n        }\n    }\n    \n    public static void endWait(final String className, final String methodName) {\n        final long start = System.nanoTime();\n        synchronized (Profile._lock) {\n            final Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.endWait(System.nanoTime());\n        }\n    }\n    \n    public static void unwind(final String className, final String methodName, final String exception) {\n        if (Profile._debugException || Controller._debug) {\n            System.out.println(\"Catch: \" + exception);\n        }\n        synchronized (Profile._lock) {\n            final long threadId = Thread.currentThread().getId();\n            final Frame target = findFrame(threadId, className, methodName);\n            if (target == null) {\n                return;\n            }\n            Profile._threadActiveFrame.put(threadId, target);\n        }\n    }\n    \n    private static final Frame findFrame(final long threadId, final String className, final String methodName) {\n        if (!Controller._profile) {\n            return null;\n        }\n        Frame target = Profile._threadActiveFrame.get(threadId);\n        if (target == null) {\n            return null;\n        }\n        boolean detectedException = false;\n        while (!target.getClassName().equals(className) || !target.getMethodName().equals(methodName)) {\n            if (!detectedException) {\n                detectedException = true;\n                if (Profile._debugException || Controller._debug) {\n                    System.err.print(\"Detected an exception at \");\n                    System.err.print(className);\n                    System.err.print('.');\n                    System.err.println(methodName);\n                }\n            }\n            else if (Profile._debugException) {\n                System.err.print(\"Unwinding \");\n                System.err.print(target.getClassName());\n                System.err.print('.');\n                System.err.println(target.getMethodName());\n            }\n            target.setEndTime(System.nanoTime());\n            target = target.getParent();\n            if (target == null) {\n                if (Profile._debugException) {\n                    System.err.println(\"Stack completely unwound.\");\n                }\n                return null;\n            }\n        }\n        return target;\n    }\n    \n    public static void alloc(final String className) {\n        synchronized (Profile._lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            final long threadId = Thread.currentThread().getId();\n            final Frame target = Profile._threadActiveFrame.get(threadId);\n            if (target != null && target.getClassName().equals(className) && target.getMethodName().equals(\"<init>\")) {\n                return;\n            }\n            ClassAllocation ca = Profile._allocList.get(className);\n            if (ca == null) {\n                ca = new ClassAllocation(className);\n                Profile._allocList.put(className, ca);\n            }\n            ca.incAllocCount();\n        }\n    }\n    \n    @Override\n    public void run() {\n        try {\n            if (Profile._threadDictionary.size() > 0) {\n                shutdown();\n                ProfileDump.dump();\n            }\n            Profile._controller.close();\n            if (Profile._controllerThread != null) {\n                Profile._controllerThread.interrupt();\n            }\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    static {\n        Profile._debugStart = false;\n        Profile._debugException = false;\n    }\n}\n",
        "token_number_zeroshot": 1831,
        "token_number_fewshot": 2229,
        "token_number_cot": 1941
    },
    {
        "project_name": "51_jiprof",
        "class": "LocalVariablesSorter",
        "source_code": "package org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.*;\n\npublic class LocalVariablesSorter extends MethodAdapter\n{\n    private static final Type OBJECT_TYPE;\n    private int[] mapping;\n    private Object[] newLocals;\n    protected final int firstLocal;\n    protected int nextLocal;\n    private boolean changed;\n    \n    public LocalVariablesSorter(final int access, final String desc, final MethodVisitor mv) {\n        super(mv);\n        this.mapping = new int[40];\n        this.newLocals = new Object[20];\n        final Type[] args = Type.getArgumentTypes(desc);\n        this.nextLocal = (((0x8 & access) == 0x0) ? 1 : 0);\n        for (int i = 0; i < args.length; ++i) {\n            this.nextLocal += args[i].getSize();\n        }\n        this.firstLocal = this.nextLocal;\n    }\n    \n    @Override\n    public void visitVarInsn(final int opcode, final int var) {\n        Type type = null;\n        switch (opcode) {\n            case 22:\n            case 55: {\n                type = Type.LONG_TYPE;\n                break;\n            }\n            case 24:\n            case 57: {\n                type = Type.DOUBLE_TYPE;\n                break;\n            }\n            case 23:\n            case 56: {\n                type = Type.FLOAT_TYPE;\n                break;\n            }\n            case 21:\n            case 54: {\n                type = Type.INT_TYPE;\n                break;\n            }\n            default: {\n                type = LocalVariablesSorter.OBJECT_TYPE;\n                break;\n            }\n        }\n        this.mv.visitVarInsn(opcode, this.remap(var, type));\n    }\n    \n    @Override\n    public void visitIincInsn(final int var, final int increment) {\n        this.mv.visitIincInsn(this.remap(var, Type.INT_TYPE), increment);\n    }\n    \n    @Override\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        this.mv.visitMaxs(maxStack, this.nextLocal);\n    }\n    \n    @Override\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        final int newIndex = this.remap(index, Type.getType(desc));\n        this.mv.visitLocalVariable(name, desc, signature, start, end, newIndex);\n    }\n    \n    @Override\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        if (type != -1) {\n            throw new IllegalStateException(\"ClassReader.accept() should be called with EXPAND_FRAMES flag\");\n        }\n        if (!this.changed) {\n            this.mv.visitFrame(type, nLocal, local, nStack, stack);\n            return;\n        }\n        final Object[] oldLocals = new Object[this.newLocals.length];\n        System.arraycopy(this.newLocals, 0, oldLocals, 0, oldLocals.length);\n        int index = 0;\n        for (final Object t : local) {\n            final int size = (t == Opcodes.LONG || t == Opcodes.DOUBLE) ? 2 : 1;\n            if (t != Opcodes.TOP) {\n                Type typ;\n                if (t == Opcodes.INTEGER) {\n                    typ = Type.INT_TYPE;\n                }\n                else if (t == Opcodes.FLOAT) {\n                    typ = Type.FLOAT_TYPE;\n                }\n                else if (t == Opcodes.LONG) {\n                    typ = Type.LONG_TYPE;\n                }\n                else if (t == Opcodes.DOUBLE) {\n                    typ = Type.DOUBLE_TYPE;\n                }\n                else {\n                    typ = Type.getObjectType((String)t);\n                }\n                this.setFrameLocal(this.remap(index, typ), t);\n            }\n            index += size;\n        }\n        index = 0;\n        int number = 0;\n        int i = 0;\n        while (index < this.newLocals.length) {\n            final Object t2 = this.newLocals[index++];\n            if (t2 != null && t2 != Opcodes.TOP) {\n                this.newLocals[i] = t2;\n                number = i + 1;\n                if (t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE) {\n                    ++index;\n                }\n            }\n            else {\n                this.newLocals[i] = Opcodes.TOP;\n            }\n            ++i;\n        }\n        this.mv.visitFrame(type, number, this.newLocals, nStack, stack);\n        this.newLocals = oldLocals;\n    }\n    \n    public int newLocal(final Type type) {\n        Object t = null;\n        switch (type.getSort()) {\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5: {\n                t = Opcodes.INTEGER;\n                break;\n            }\n            case 6: {\n                t = Opcodes.FLOAT;\n                break;\n            }\n            case 7: {\n                t = Opcodes.LONG;\n                break;\n            }\n            case 8: {\n                t = Opcodes.DOUBLE;\n                break;\n            }\n            case 9: {\n                t = type.getDescriptor();\n                break;\n            }\n            default: {\n                t = type.getInternalName();\n                break;\n            }\n        }\n        final int local = this.nextLocal;\n        this.nextLocal += type.getSize();\n        this.setLocalType(local, type);\n        this.setFrameLocal(local, t);\n        return local;\n    }\n    \n    protected void setLocalType(final int local, final Type type) {\n    }\n    \n    private void setFrameLocal(final int local, final Object type) {\n        final int l = this.newLocals.length;\n        if (local >= l) {\n            final Object[] a = new Object[Math.max(2 * l, local + 1)];\n            System.arraycopy(this.newLocals, 0, a, 0, l);\n            this.newLocals = a;\n        }\n        this.newLocals[local] = type;\n    }\n    \n    private int remap(final int var, final Type type) {\n        if (var < this.firstLocal) {\n            return var;\n        }\n        final int key = 2 * var + type.getSize() - 1;\n        final int size = this.mapping.length;\n        if (key >= size) {\n            final int[] newMapping = new int[Math.max(2 * size, key + 1)];\n            System.arraycopy(this.mapping, 0, newMapping, 0, size);\n            this.mapping = newMapping;\n        }\n        int value = this.mapping[key];\n        if (value == 0) {\n            value = this.newLocalMapping(type);\n            this.setLocalType(value, type);\n            this.mapping[key] = value + 1;\n        }\n        else {\n            --value;\n        }\n        if (value != var) {\n            this.changed = true;\n        }\n        return value;\n    }\n    \n    protected int newLocalMapping(final Type type) {\n        final int local = this.nextLocal;\n        this.nextLocal += type.getSize();\n        return local;\n    }\n    \n    static {\n        OBJECT_TYPE = Type.getObjectType(\"java/lang/Object\");\n    }\n}\n",
        "token_number_zeroshot": 1571,
        "token_number_fewshot": 1969,
        "token_number_cot": 1684
    },
    {
        "project_name": "43_lilith",
        "class": "AccessEvent",
        "source_code": "package de.huxhorn.lilith.data.access;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class AccessEvent implements Serializable\n{\n    private static final long serialVersionUID = -716078283933754505L;\n    private Long timeStamp;\n    private LoggerContext loggerContext;\n    private String requestURI;\n    private String requestURL;\n    private String remoteHost;\n    private String remoteUser;\n    private String protocol;\n    private String method;\n    private String serverName;\n    private String remoteAddress;\n    private Map<String, String> requestHeaders;\n    private Map<String, String> responseHeaders;\n    private Map<String, String[]> requestParameters;\n    private int localPort;\n    private int statusCode;\n    \n    public Long getTimeStamp() {\n        return this.timeStamp;\n    }\n    \n    public void setTimeStamp(final Long timeStamp) {\n        this.timeStamp = timeStamp;\n    }\n    \n    public LoggerContext getLoggerContext() {\n        return this.loggerContext;\n    }\n    \n    public void setLoggerContext(final LoggerContext loggerContext) {\n        this.loggerContext = loggerContext;\n    }\n    \n    public String getRequestURI() {\n        return this.requestURI;\n    }\n    \n    public void setRequestURI(final String requestURI) {\n        this.requestURI = requestURI;\n    }\n    \n    public String getRequestURL() {\n        return this.requestURL;\n    }\n    \n    public void setRequestURL(final String requestURL) {\n        this.requestURL = requestURL;\n    }\n    \n    public String getRemoteHost() {\n        return this.remoteHost;\n    }\n    \n    public void setRemoteHost(final String remoteHost) {\n        this.remoteHost = remoteHost;\n    }\n    \n    public String getRemoteUser() {\n        return this.remoteUser;\n    }\n    \n    public void setRemoteUser(final String remoteUser) {\n        this.remoteUser = remoteUser;\n    }\n    \n    public String getProtocol() {\n        return this.protocol;\n    }\n    \n    public void setProtocol(final String protocol) {\n        this.protocol = protocol;\n    }\n    \n    public String getMethod() {\n        return this.method;\n    }\n    \n    public void setMethod(final String method) {\n        this.method = method;\n    }\n    \n    public String getServerName() {\n        return this.serverName;\n    }\n    \n    public void setServerName(final String serverName) {\n        this.serverName = serverName;\n    }\n    \n    public String getRemoteAddress() {\n        return this.remoteAddress;\n    }\n    \n    public void setRemoteAddress(final String remoteAddress) {\n        this.remoteAddress = remoteAddress;\n    }\n    \n    public Map<String, String> getRequestHeaders() {\n        return this.requestHeaders;\n    }\n    \n    public void setRequestHeaders(final Map<String, String> requestHeaders) {\n        this.requestHeaders = requestHeaders;\n    }\n    \n    public Map<String, String> getResponseHeaders() {\n        return this.responseHeaders;\n    }\n    \n    public void setResponseHeaders(final Map<String, String> responseHeaders) {\n        this.responseHeaders = responseHeaders;\n    }\n    \n    public Map<String, String[]> getRequestParameters() {\n        return this.requestParameters;\n    }\n    \n    public void setRequestParameters(final Map<String, String[]> requestParameters) {\n        this.requestParameters = requestParameters;\n    }\n    \n    public int getLocalPort() {\n        return this.localPort;\n    }\n    \n    public void setLocalPort(final int localPort) {\n        this.localPort = localPort;\n    }\n    \n    public int getStatusCode() {\n        return this.statusCode;\n    }\n    \n    public void setStatusCode(final int statusCode) {\n        this.statusCode = statusCode;\n    }\n    \n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final AccessEvent event = (AccessEvent)o;\n        if (this.localPort != event.localPort) {\n            return false;\n        }\n        if (this.statusCode != event.statusCode) {\n            return false;\n        }\n        Label_0088: {\n            if (this.loggerContext != null) {\n                if (this.loggerContext.equals(event.loggerContext)) {\n                    break Label_0088;\n                }\n            }\n            else if (event.loggerContext == null) {\n                break Label_0088;\n            }\n            return false;\n        }\n        Label_0121: {\n            if (this.method != null) {\n                if (this.method.equals(event.method)) {\n                    break Label_0121;\n                }\n            }\n            else if (event.method == null) {\n                break Label_0121;\n            }\n            return false;\n        }\n        Label_0154: {\n            if (this.protocol != null) {\n                if (this.protocol.equals(event.protocol)) {\n                    break Label_0154;\n                }\n            }\n            else if (event.protocol == null) {\n                break Label_0154;\n            }\n            return false;\n        }\n        Label_0187: {\n            if (this.remoteAddress != null) {\n                if (this.remoteAddress.equals(event.remoteAddress)) {\n                    break Label_0187;\n                }\n            }\n            else if (event.remoteAddress == null) {\n                break Label_0187;\n            }\n            return false;\n        }\n        Label_0220: {\n            if (this.remoteHost != null) {\n                if (this.remoteHost.equals(event.remoteHost)) {\n                    break Label_0220;\n                }\n            }\n            else if (event.remoteHost == null) {\n                break Label_0220;\n            }\n            return false;\n        }\n        Label_0253: {\n            if (this.remoteUser != null) {\n                if (this.remoteUser.equals(event.remoteUser)) {\n                    break Label_0253;\n                }\n            }\n            else if (event.remoteUser == null) {\n                break Label_0253;\n            }\n            return false;\n        }\n        Label_0286: {\n            if (this.requestHeaders != null) {\n                if (this.requestHeaders.equals(event.requestHeaders)) {\n                    break Label_0286;\n                }\n            }\n            else if (event.requestHeaders == null) {\n                break Label_0286;\n            }\n            return false;\n        }\n        Label_0319: {\n            if (this.requestURI != null) {\n                if (this.requestURI.equals(event.requestURI)) {\n                    break Label_0319;\n                }\n            }\n            else if (event.requestURI == null) {\n                break Label_0319;\n            }\n            return false;\n        }\n        Label_0352: {\n            if (this.requestURL != null) {\n                if (this.requestURL.equals(event.requestURL)) {\n                    break Label_0352;\n                }\n            }\n            else if (event.requestURL == null) {\n                break Label_0352;\n            }\n            return false;\n        }\n        Label_0385: {\n            if (this.responseHeaders != null) {\n                if (this.responseHeaders.equals(event.responseHeaders)) {\n                    break Label_0385;\n                }\n            }\n            else if (event.responseHeaders == null) {\n                break Label_0385;\n            }\n            return false;\n        }\n        Label_0418: {\n            if (this.serverName != null) {\n                if (this.serverName.equals(event.serverName)) {\n                    break Label_0418;\n                }\n            }\n            else if (event.serverName == null) {\n                break Label_0418;\n            }\n            return false;\n        }\n        if (this.timeStamp != null) {\n            if (!this.timeStamp.equals(event.timeStamp)) {\n                return false;\n            }\n        }\n        else if (event.timeStamp != null) {\n            return false;\n        }\n        return true;\n        b = false;\n        return b;\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = (this.timeStamp != null) ? this.timeStamp.hashCode() : 0;\n        result = 31 * result + ((this.loggerContext != null) ? this.loggerContext.hashCode() : 0);\n        result = 31 * result + ((this.requestURI != null) ? this.requestURI.hashCode() : 0);\n        result = 31 * result + ((this.requestURL != null) ? this.requestURL.hashCode() : 0);\n        result = 31 * result + ((this.remoteHost != null) ? this.remoteHost.hashCode() : 0);\n        result = 31 * result + ((this.remoteUser != null) ? this.remoteUser.hashCode() : 0);\n        result = 31 * result + ((this.protocol != null) ? this.protocol.hashCode() : 0);\n        result = 31 * result + ((this.method != null) ? this.method.hashCode() : 0);\n        result = 31 * result + ((this.serverName != null) ? this.serverName.hashCode() : 0);\n        result = 31 * result + ((this.remoteAddress != null) ? this.remoteAddress.hashCode() : 0);\n        result = 31 * result + this.localPort;\n        result = 31 * result + this.statusCode;\n        return result;\n    }\n    \n    @Override\n    public String toString() {\n        final StringBuilder result = new StringBuilder();\n        result.append(\"AccessEvent[\");\n        result.append(\"loggerContext=\").append(this.loggerContext).append(\", \");\n        result.append(\"timeStamp=\").append(this.timeStamp);\n        result.append(\"]\");\n        return result.toString();\n    }\n}\n",
        "token_number_zeroshot": 1996,
        "token_number_fewshot": 2394,
        "token_number_cot": 2107
    },
    {
        "project_name": "80_wheelwebtool",
        "class": "DynamicSelectModel",
        "source_code": "package wheel.util;\n\nimport wheel.components.*;\nimport wheel.*;\nimport java.util.*;\n\npublic class DynamicSelectModel implements ISelectModel\n{\n    private Component component;\n    private StandaloneComponent topLevelComponent;\n    private ElExpression label;\n    private ElExpression value;\n    private ElExpression collection;\n    private ElExpression translator;\n    private Collection objects;\n    private Object emptyObject;\n    \n    public DynamicSelectModel(final ElExpression collection, final ElExpression label, final ElExpression value) {\n        this.validate();\n        this.label = label;\n        this.value = value;\n        this.collection = collection;\n    }\n    \n    public DynamicSelectModel() {\n    }\n    \n    public DynamicSelectModel collection(final String collection) {\n        this.collection = new ElExpression(collection);\n        return this;\n    }\n    \n    public DynamicSelectModel label(final String label) {\n        this.label = new ElExpression(label);\n        return this;\n    }\n    \n    public DynamicSelectModel value(final String value) {\n        this.value = new ElExpression(value);\n        return this;\n    }\n    \n    public DynamicSelectModel enumeration(final String enumeration) {\n        this.collection = new ElExpression(enumeration + \".values()\");\n        this.label = new ElExpression(\"toString()\");\n        this.value = new ElExpression(\"ordinal()\");\n        return this;\n    }\n    \n    public DynamicSelectModel translator(final String translator) {\n        this.translator = new ElExpression(translator);\n        return this;\n    }\n    \n    public DynamicSelectModel empty(final Object o) {\n        this.emptyObject = o;\n        return this;\n    }\n    \n    @Override\n    public int getOptionCount() {\n        return this.getObjects().size();\n    }\n    \n    @Override\n    public String getLabel(final int index) {\n        this.label.errorMessage(\"Could not evaluate expression \" + this.label.getExpression() + \" to create a label for dynamic ISelectModel. Index was \" + index);\n        final Object obj = this.label.eval(this.getObjects().toArray()[index], this.component);\n        return obj.toString();\n    }\n    \n    @Override\n    public String getValue(final int index) {\n        this.value.errorMessage(\"Could not evaluate expression \" + (Object)this.value + \" to create a value for dynamic ISelectModel. Index was \" + index);\n        final Object obj = this.value.eval(this.getObjects().toArray()[index], this.component);\n        return obj.toString();\n    }\n    \n    @Override\n    public Object translateValue(final String value) {\n        final Object[] array = this.getObjects().toArray();\n        int i = 0;\n        while (i < array.length) {\n            final String compareTo = this.getValue(i);\n            if (compareTo.equals(value)) {\n                if (this.translator != null) {\n                    this.translator.errorMessage(\"Could not evaluate expression \" + (Object)this.translator + \" to translate value ' \" + value + \"'\");\n                    return this.translator.eval(array[i], this.component);\n                }\n                return array[i];\n            }\n            else {\n                ++i;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public Collection getObjects() {\n        if (this.objects != null) {\n            return this.objects;\n        }\n        this.collection.errorMessage(\"Could not evaluate expression \" + (Object)this.collection + \" to create a dynamic ISelectModel.\");\n        final Object obj = this.collection.eval(this.topLevelComponent, this.component);\n        if (obj == null) {\n            throw new WheelException(\"Expression \" + (Object)this.collection + \" evaluated to null. Can't build a dynamic ISelectModel\", this.component);\n        }\n        if (obj instanceof Collection) {\n            this.objects = (Collection)obj;\n        }\n        else {\n            if (!(obj instanceof Object[])) {\n                throw new WheelException(\"Expression \" + (Object)this.collection + \" evaluated to an object that is not an instance of Collection or Object[]. Can't build a dynamic ISelectModel\", this.component);\n            }\n            final Object[] array = (Object[])obj;\n            final Collection col = new ArrayList();\n            for (int i = 0; i < array.length; ++i) {\n                col.add(array[i]);\n            }\n            this.objects = col;\n        }\n        if (this.emptyObject != null) {\n            final Collection newCollection = new LinkedList();\n            newCollection.add(this.emptyObject);\n            newCollection.addAll(this.objects);\n            this.objects = newCollection;\n        }\n        return this.objects;\n    }\n    \n    public Component getComponent() {\n        return this.component;\n    }\n    \n    public void setComponent(final Component component) {\n        this.component = component;\n    }\n    \n    public StandaloneComponent getTopLevelComponent() {\n        return this.topLevelComponent;\n    }\n    \n    public void setTopLevelComponent(final StandaloneComponent topLevelComponent) {\n        this.topLevelComponent = topLevelComponent;\n    }\n    \n    public void validate() {\n        if (this.collection == null) {\n            throw new WheelException(\"Could not create DynamicSelection model. Collection attribute was null or not an el-expression.\", (Component)null);\n        }\n        if (this.label == null) {\n            throw new WheelException(\"Could not create DynamicSelection model. Label attribute was null or not an el-expression.\", (Component)null);\n        }\n        if (this.value == null) {\n            throw new WheelException(\"Could not create DynamicSelection model. Value attribute was null or not an el-expression.\", (Component)null);\n        }\n    }\n    \n    public void reset() {\n        this.objects = null;\n    }\n}\n",
        "token_number_zeroshot": 1164,
        "token_number_fewshot": 1562,
        "token_number_cot": 1276
    },
    {
        "project_name": "99_newzgrabber",
        "class": "Newzgrabber",
        "source_code": "package Newzgrabber;\n\nimport javax.swing.*;\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\n\npublic class Newzgrabber extends JFrame implements WindowListener\n{\n    public static JTabbedPane jtp;\n    public static OptionsPanel optionspanel;\n    public static GroupsPanel groupspanel;\n    public static SearchPanel searchpanel;\n    public static boolean verbose;\n    public static boolean debug;\n    public static boolean batch;\n    public static TransferPanel transferpanel;\n    public static boolean IsBatch;\n    public static NewsFactory nf;\n    private Vector affiliates;\n    public static String Newzdirectory;\n    public static String JarFilename;\n    public static String BatchFilename;\n    public static String NewzInifilename;\n    \n    public Newzgrabber() {\n        Newzgrabber.IsBatch = true;\n        setupBasicSystem();\n        try {\n            final String batchfile = Newzgrabber.Newzdirectory + System.getProperty(\"file.separator\") + Newzgrabber.BatchFilename;\n            final String newzini = Newzgrabber.Newzdirectory + System.getProperty(\"file.separator\") + Newzgrabber.NewzInifilename;\n            if (Newzgrabber.verbose) {\n                System.out.println(\"Getting batch info from \" + batchfile);\n            }\n            final BatchDriver bd = new BatchDriver(newzini, batchfile);\n            final String[] BatchGroups = bd.getGroups();\n            final Vector GroupDownloadCount = new Vector();\n            for (int i = 0; i < BatchGroups.length; ++i) {\n                System.out.println(\"Starting batch job for \" + BatchGroups[i]);\n                final BatchJob bj = bd.getBatchJob(BatchGroups[i]);\n                if (bj == null) {\n                    System.out.println(\"Returned NULL batch job object for \" + BatchGroups[i]);\n                }\n                else {\n                    if (Newzgrabber.verbose) {\n                        System.out.println(\"Got batch job object\");\n                    }\n                    final String[] grouparray = { bj.getGroup() };\n                    if (Newzgrabber.verbose) {\n                        System.out.println(\"Getting the line data\");\n                    }\n                    final LineData ld = new LineData(bj.getServer(), grouparray);\n                    if (Newzgrabber.verbose) {\n                        System.out.println(\"Done getting line data\");\n                    }\n                    final String[] subjectlines = bd.getSubjectLines();\n                    final SongList sl = new SongList(subjectlines);\n                    final String[] complete = sl.getCompleteSongs();\n                    int nDownloads = 0;\n                    final Vector FullList = new Vector();\n                    if (Newzgrabber.verbose) {\n                        System.out.println(\"Found \" + complete.length + \" articles\");\n                    }\n                    for (int j = 0; j < complete.length; ++j) {\n                        try {\n                            final Object[] va = { bj.getGroup(), sl.getSongs().get(complete[j]) };\n                            final Hashtable tmp = (Hashtable)va[1];\n                            final long[] OrderedIds = SongInfo.getOrderedIds(tmp);\n                            if (OrderedIds != null) {\n                                final long TotalLines = ld.getTotalLines(BatchGroups[i], OrderedIds);\n                                if (tmp.get(\"UPPERLIMIT\") < 2) {\n                                    final SongInfo si = tmp.get(new Integer(1));\n                                    final long id = si.getId();\n                                    final long[] tmpids = { id };\n                                    if (ld.getTotalLines(BatchGroups[i], tmpids) < 100L) {\n                                        continue;\n                                    }\n                                }\n                                final Object[] rowinfo = { complete[j], BatchGroups[i], new Long(TotalLines), OrderedIds };\n                                FullList.add(rowinfo);\n                            }\n                        }\n                        catch (Exception completeE) {\n                            System.out.println(completeE.getMessage());\n                        }\n                    }\n                    for (int downindex = 0; downindex < FullList.size(); ++downindex) {\n                        try {\n                            final Object[] objarr = FullList.elementAt(downindex);\n                            final Downloader d = new Downloader();\n                            d.setDownloadDirectory(new File(bj.getDirectory()));\n                            d.setServer(bj.getServer());\n                            if (bj.getUsername() != null) {\n                                d.setUsername(bj.getUsername().trim());\n                            }\n                            if (bj.getPassword() != null) {\n                                d.setPassword(bj.getPassword().trim());\n                            }\n                            d.setGroup(BatchGroups[i]);\n                            d.setIds((long[])objarr[3]);\n                            d.setTotalLines((long)objarr[2]);\n                            final Object[] addrow = { (String)objarr[0], new String(), new String(), new String(), BatchGroups[i] };\n                            d.startDownload();\n                            ++nDownloads;\n                        }\n                        catch (Exception downloadE) {\n                            System.out.println(downloadE.getMessage());\n                        }\n                    }\n                    final Object[] DownloadData = { BatchGroups[i], new Integer(nDownloads) };\n                    GroupDownloadCount.add(DownloadData);\n                    this.updateIni(newzini, \"Messageids\", BatchGroups[i], String.valueOf(bj.getLastid()));\n                }\n            }\n            System.out.println(\"The following is the final download data:\");\n            System.out.println(\"GROUP\\tDOWNLOADS\");\n            for (int cnt = 0; cnt < GroupDownloadCount.size(); ++cnt) {\n                final Object[] downarr = GroupDownloadCount.elementAt(cnt);\n                final String tmpGroup = (String)downarr[0];\n                final int tmpDownloads = (int)downarr[1];\n                System.out.println(tmpGroup + \"\\t\" + tmpDownloads);\n            }\n        }\n        catch (Exception batchE) {\n            System.out.println(\"Caught exception\");\n            System.out.println(batchE.getMessage());\n            System.exit(1);\n        }\n    }\n    \n    public Newzgrabber(final String s) {\n        super(s);\n        Newzgrabber.IsBatch = false;\n        this.getContentPane().setLayout(new BorderLayout());\n        this.addWindowListener(this);\n        this.setSize(600, 500);\n        setupBasicSystem();\n        Newzgrabber.searchpanel = new SearchPanel(this);\n        Newzgrabber.optionspanel = new OptionsPanel(this);\n        Newzgrabber.groupspanel = new GroupsPanel(this);\n        Newzgrabber.transferpanel = new TransferPanel(this);\n        final AboutPanel p4 = new AboutPanel();\n        (Newzgrabber.jtp = new JTabbedPane()).addTab(\"Search\", Newzgrabber.searchpanel);\n        Newzgrabber.jtp.setSelectedIndex(0);\n        Newzgrabber.jtp.addTab(\"Options\", Newzgrabber.optionspanel);\n        Newzgrabber.jtp.setSelectedIndex(1);\n        Newzgrabber.jtp.addTab(\"Groups\", Newzgrabber.groupspanel);\n        Newzgrabber.jtp.setSelectedIndex(2);\n        Newzgrabber.jtp.addTab(\"Transfer\", Newzgrabber.transferpanel);\n        Newzgrabber.jtp.setSelectedIndex(3);\n        Newzgrabber.jtp.addTab(\"About\", p4);\n        Newzgrabber.jtp.setSelectedIndex(4);\n        Newzgrabber.jtp.setPreferredSize(new Dimension(this.getWidth() - 100, this.getHeight() - 100));\n        this.getContentPane().add(Newzgrabber.jtp, \"Center\");\n        this.setVisible(true);\n        Newzgrabber.jtp.setSelectedIndex(0);\n    }\n    \n    public static void setupBasicSystem() {\n        Newzgrabber.Newzdirectory = findDirectory(Newzgrabber.JarFilename);\n        if (System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1) {\n            try {\n                System.setProperty(\"java.library.path\", Newzgrabber.Newzdirectory + System.getProperty(\"path.separator\") + System.getProperty(\"java.library.path\"));\n            }\n            catch (Exception pathE) {\n                if (Newzgrabber.debug) {\n                    System.err.println(\"There was a problem setting the lib path!\");\n                    pathE.printStackTrace();\n                }\n            }\n            if (Newzgrabber.debug || Newzgrabber.verbose) {\n                System.out.println(\"The path variable is set to\\n\" + System.getProperty(\"java.library.path\"));\n            }\n        }\n        if (Newzgrabber.verbose) {\n            System.out.println(\"The newz dir is\\n\" + Newzgrabber.Newzdirectory);\n        }\n        Newzgrabber.nf = new NewsFactory();\n    }\n    \n    @Override\n    public void windowClosed(final WindowEvent we) {\n    }\n    \n    @Override\n    public void windowOpened(final WindowEvent we) {\n    }\n    \n    @Override\n    public void windowActivated(final WindowEvent we) {\n    }\n    \n    @Override\n    public void windowDeactivated(final WindowEvent we) {\n    }\n    \n    @Override\n    public void windowIconified(final WindowEvent we) {\n    }\n    \n    @Override\n    public void windowDeiconified(final WindowEvent we) {\n    }\n    \n    @Override\n    public void windowClosing(final WindowEvent we) {\n        try {\n            Newzgrabber.optionspanel.updateIni();\n            Newzgrabber.groupspanel.updateIni();\n            Newzgrabber.transferpanel.updateIni();\n        }\n        catch (Exception ce) {\n            System.err.println(ce.getMessage());\n            ce.printStackTrace();\n        }\n        System.exit(0);\n    }\n    \n    public static String findDirectory(final String classfile) {\n        try {\n            final String path = System.getProperty(\"java.class.path\");\n            final StringTokenizer st = new StringTokenizer(path, System.getProperty(\"path.separator\"));\n            while (st.hasMoreTokens()) {\n                final String nextpath = st.nextToken();\n                try {\n                    final File f = new File(nextpath);\n                    if (!f.isFile() || !f.getName().equals(classfile)) {\n                        continue;\n                    }\n                    final File parent = f.getParentFile();\n                    if (parent == null) {\n                        continue;\n                    }\n                    return parent.getAbsolutePath();\n                }\n                catch (Exception parseE) {\n                    System.err.println(\"There was a parse error!\\n\" + parseE.getMessage());\n                    parseE.printStackTrace();\n                }\n            }\n            return null;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n    \n    public void updateIni(final String inifile, final String prop, final String key, final String value) {\n        try {\n            final LinkedList ll = new LinkedList();\n            if (Newzgrabber.verbose) {\n                System.out.println(\"Updating the ini file from Newzgrabber\");\n            }\n            final Ini ini = new Ini(inifile, prop);\n            final Vector Newids = ini.getIniVector();\n            if (Newids.size() > 0) {\n                for (int i = 0; i < Newids.size(); ++i) {\n                    final String[] stringarr = Newids.elementAt(i);\n                    final String nextkey = stringarr[0];\n                    String thevalue = null;\n                    try {\n                        if (nextkey.toLowerCase().equals(key.toLowerCase())) {\n                            thevalue = value;\n                        }\n                        else {\n                            thevalue = stringarr[1];\n                        }\n                        final String[] listobj = { nextkey, thevalue };\n                        System.out.println(\"Adding \" + nextkey + \" to hash with \" + thevalue);\n                        ll.add(listobj);\n                    }\n                    catch (Exception lle) {\n                        System.out.println(\"Problem updating ini file!\\n\" + lle.getMessage());\n                    }\n                }\n            }\n            ini.writeIni(ll);\n        }\n        catch (Exception e) {\n            System.out.println(\"Problem updating ini file!\\n\" + e.getMessage());\n        }\n    }\n    \n    public static void main(final String[] args) {\n        try {\n            System.out.println(\"The user directory is:\\n\" + System.getProperty(\"user.dir\"));\n            if (args.length > 0) {\n                for (int i = 0; i < args.length; ++i) {\n                    if (args[i].toLowerCase().equals(\"-verbose\")) {\n                        Newzgrabber.verbose = true;\n                        System.out.println(\"Running Newzgrabber in verbose mode\");\n                    }\n                    else if (args[i].toLowerCase().equals(\"-batch\")) {\n                        Newzgrabber.IsBatch = true;\n                        System.out.println(\"Running Newzgrabber in batch mode\");\n                    }\n                    else if (args[i].toLowerCase().equals(\"-debug\")) {\n                        Newzgrabber.debug = true;\n                        System.out.println(\"Running Newzgrabber in debug mode\");\n                    }\n                    else if (args[i].toLowerCase().equals(\"-batch\")) {\n                        Newzgrabber.batch = true;\n                        System.out.println(\"Running Newzgrabber in batch mode\");\n                    }\n                }\n            }\n            Newzgrabber n = null;\n            Newzbatch nb = null;\n            if (Newzgrabber.IsBatch) {\n                nb = new Newzbatch();\n            }\n            else {\n                n = new Newzgrabber(\"Newzgrabber\");\n            }\n        }\n        catch (Exception e) {\n            System.err.println(e.getMessage());\n        }\n    }\n    \n    static {\n        Newzgrabber.verbose = false;\n        Newzgrabber.debug = false;\n        Newzgrabber.batch = false;\n        Newzgrabber.IsBatch = false;\n        Newzgrabber.JarFilename = \"Newz.jar\";\n        Newzgrabber.BatchFilename = \"batch.ini\";\n        Newzgrabber.NewzInifilename = \"Newzgrabber.ini\";\n    }\n}\n",
        "token_number_zeroshot": 2799,
        "token_number_fewshot": 3197,
        "token_number_cot": 2912
    },
    {
        "project_name": "99_newzgrabber",
        "class": "BatchDriver",
        "source_code": "package Newzgrabber;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class BatchDriver\n{\n    private Ini groupsini;\n    private Ini batchini;\n    private Hashtable NewsgroupsHash;\n    private Hashtable BatchgroupsHash;\n    private Hashtable BatchretrieveHash;\n    private Hashtable OptionsHash;\n    private Vector BatchgroupsVector;\n    private String[] subjectlines;\n    \n    public BatchDriver(final String newzini, final String batchfile) throws NullPointerException, IOException {\n        this.BatchgroupsVector = new Vector();\n        final Ini groupsini = new Ini(newzini, \"Messageids\");\n        final Ini batchgroups = new Ini(batchfile, \"\");\n        this.NewsgroupsHash = groupsini.readIni();\n        batchgroups.setProperty(\"Newsgroups\");\n        this.BatchgroupsHash = batchgroups.readIni();\n        this.BatchgroupsVector = batchgroups.getIniVector();\n        batchgroups.setProperty(\"Retrieve\");\n        this.BatchretrieveHash = batchgroups.readIni();\n        batchgroups.setProperty(\"Options\");\n        this.OptionsHash = batchgroups.readIni();\n    }\n    \n    public String[] getGroups() throws ArrayIndexOutOfBoundsException {\n        final String[] groups = new String[this.BatchgroupsVector.size()];\n        for (int i = 0; i < this.BatchgroupsVector.size(); ++i) {\n            final String[] groupstuff = this.BatchgroupsVector.elementAt(i);\n            groups[i] = groupstuff[0];\n        }\n        return groups;\n    }\n    \n    public BatchJob getBatchJob(final String group) {\n        try {\n            String server = null;\n            String directory = null;\n            try {\n                server = this.OptionsHash.get(\"server\");\n                directory = this.BatchgroupsHash.get(group).trim();\n            }\n            catch (Exception sdE) {\n                System.out.println(\"Could not get server and directory for \" + group);\n                return null;\n            }\n            String username = null;\n            String password = null;\n            if (this.OptionsHash.containsKey(\"username\")) {\n                username = this.OptionsHash.get(\"username\").trim();\n            }\n            if (this.OptionsHash.containsKey(\"password\")) {\n                password = this.OptionsHash.get(\"password\").trim();\n            }\n            int nThreads = 1;\n            int TIMEOUT = -1;\n            try {\n                nThreads = Integer.parseInt(this.OptionsHash.get(\"threads\").trim());\n            }\n            catch (Exception threadsE) {\n                nThreads = 1;\n            }\n            try {\n                TIMEOUT = Integer.parseInt(this.OptionsHash.get(\"timeout\").trim());\n                Newzbatch.TIMEOUT = true;\n                Newzbatch.TIMEOUTMAX = TIMEOUT;\n                System.out.println(\"Setting the max timeout value to \" + TIMEOUT);\n            }\n            catch (Exception threadsE) {\n                TIMEOUT = -1;\n            }\n            if (Newzgrabber.verbose) {\n                System.out.println(\"Getting NNTP object from BatchDriver with the server \" + server);\n            }\n            final NewsFactory nf = Newzgrabber.nf;\n            NewsFactory.setThreadLimit(nThreads);\n            final NNTP news = Newzgrabber.nf.getNewsSocket(server);\n            if (news == null) {\n                System.out.println(\"Could not get news socket in BatchDriver\");\n                return null;\n            }\n            if (username != null && password != null) {\n                news.authInfo(username, password);\n            }\n            final String[] groupinfo = news.genericCommand(\"group \" + group);\n            if (Newzgrabber.verbose) {\n                System.out.println(\"Got the following group line from BatchDriver\\n\" + groupinfo[0]);\n            }\n            final Status thestatus = new Status(groupinfo[0].trim());\n            if (!thestatus.statusOK()) {\n                return null;\n            }\n            final StringTokenizer st = new StringTokenizer(groupinfo[0].trim());\n            st.nextToken();\n            st.nextToken();\n            final int tmpFirst = Integer.parseInt(st.nextToken());\n            final int tmpLast = Integer.parseInt(st.nextToken());\n            if (Newzgrabber.IsBatch) {\n                System.out.println(\"The first id in group is \" + tmpFirst);\n                System.out.println(\"The last id in group is \" + tmpLast);\n            }\n            int firstid = 0;\n            final int lastid = tmpLast;\n            if (this.NewsgroupsHash.containsKey(group)) {\n                try {\n                    firstid = Integer.parseInt(this.NewsgroupsHash.get(group));\n                    ++firstid;\n                    if (Newzgrabber.IsBatch) {\n                        System.out.println(\"ini file shows \" + firstid + \" as being the id\");\n                    }\n                }\n                catch (Exception firstidE) {\n                    firstid = 0;\n                }\n            }\n            if (tmpFirst > firstid) {\n                firstid = tmpFirst;\n            }\n            final String cmd = \"xpat Subject \" + firstid + \"-\" + lastid + \" *\";\n            System.out.println(\"Getting ready to get subjects with\\n\" + cmd);\n            this.subjectlines = news.genericCommand(cmd);\n            news.quit();\n            final BatchJob bj = new BatchJob(server, group, directory, firstid, lastid);\n            if (username != null && password != null) {\n                bj.setUsername(username.trim());\n                bj.setPassword(password.trim());\n            }\n            return bj;\n        }\n        catch (Exception e) {\n            System.out.println(e.getMessage());\n            return null;\n        }\n    }\n    \n    public String[] getSubjectLines() {\n        return this.subjectlines;\n    }\n}\n",
        "token_number_zeroshot": 1151,
        "token_number_fewshot": 1549,
        "token_number_cot": 1262
    },
    {
        "project_name": "97_feudalismgame",
        "class": "Purchase",
        "source_code": "package src;\n\nimport java.util.*;\nimport java.lang.reflect.*;\n\npublic class Purchase extends Actions\n{\n    @Override\n    public void perform(final Collection args) {\n        try {\n            final Iterator argsIter = args.iterator();\n            this.getClass();\n            final Class aMethod = Class.forName(\"feudalism.Purchase\");\n            final Class[] argType = { String.class };\n            final Method methodObj = aMethod.getMethod(argsIter.next(), Iterator.class);\n            methodObj.invoke(this, argsIter);\n            GameAutoActions.saveAll();\n        }\n        catch (SecurityException e) {\n            e.printStackTrace();\n        }\n        catch (NoSuchMethodException e2) {\n            e2.printStackTrace();\n        }\n        catch (IllegalArgumentException e3) {\n            e3.printStackTrace();\n        }\n        catch (IllegalAccessException e4) {\n            e4.printStackTrace();\n        }\n        catch (InvocationTargetException e5) {\n            e5.printStackTrace();\n        }\n        catch (ClassNotFoundException e6) {\n            e6.printStackTrace();\n        }\n    }\n    \n    public void vassal(final Iterator arg) {\n        final int qty = Integer.parseInt(arg.next());\n        final String buyerName = arg.next();\n        final Fiefdoms fiefdom = Map.map.get(arg.next());\n        final Knight buyerObj = CurrentPlayers.currentPlayers.get(buyerName);\n        if (fiefdom.getOwner() != null) {\n            if (buyerObj.getRank().equalsIgnoreCase(\"king\") || buyerObj.isFiefdomMine(fiefdom.getName())) {\n                if (buyerObj.setTotalMoney(qty, false)) {\n                    fiefdom.setLoyalVassals(qty, true);\n                }\n                else {\n                    System.out.println(\"You cannot buy more vassals, you have insufficient funds\");\n                }\n            }\n            else if (CurrentPlayers.currentPlayers.get(fiefdom.getOwner()).getRank().equalsIgnoreCase(\"count\") || CurrentPlayers.currentPlayers.get(fiefdom.getOwner()).getRank().equalsIgnoreCase(\"duke\")) {\n                System.out.println(\"You can only buy a castle for a fiefdom that belongs to you\");\n            }\n        }\n        else {\n            System.out.println(\"Fiefdom doesn't belong to the kingdom\");\n        }\n    }\n    \n    public void castleFiefdom(final Iterator arg) {\n        final int qty = Integer.parseInt(arg.next());\n        final String buyerName = arg.next();\n        final Fiefdoms fiefdom = Map.map.get(arg.next());\n        final Knight buyerObj = CurrentPlayers.currentPlayers.get(buyerName);\n        if (fiefdom.getOwner() != null) {\n            if (buyerObj.getRank().equalsIgnoreCase(\"king\") || (buyerObj.isFiefdomMine(fiefdom.getName()) && fiefdom.getViking().size() + fiefdom.getMagyar().size() + fiefdom.getMuslim().size() == 0)) {\n                if (buyerObj.setTotalMoney(qty * 25, false)) {\n                    fiefdom.buyFiefdomCastles(qty);\n                }\n                else {\n                    System.out.println(\"You cannot buy more Fiefdom castles, you have insufficient funds\");\n                }\n            }\n            else if (CurrentPlayers.currentPlayers.get(fiefdom.getOwner()).getRank().equalsIgnoreCase(\"count\") || CurrentPlayers.currentPlayers.get(fiefdom.getOwner()).getRank().equalsIgnoreCase(\"duke\")) {\n                System.out.println(\"You can only buy a castle for a fiefdom that belongs to you\");\n            }\n        }\n        else {\n            System.out.println(\"Fiefdom doesn't belong to the kingdom\");\n        }\n    }\n    \n    public void castlePersonal(final Iterator arg) {\n        final int qty = Integer.parseInt(arg.next());\n        final String buyerName = arg.next();\n        final Fiefdoms fiefdom = Map.map.get(arg.next());\n        final Knight buyerObj = CurrentPlayers.currentPlayers.get(buyerName);\n        if (fiefdom.getOwner() != null) {\n            if ((buyerObj.getRank().equalsIgnoreCase(\"king\") && CurrentPlayers.currentPlayers.get(fiefdom.getOwner()).getRank().equalsIgnoreCase(\"knight\")) || (buyerObj.isFiefdomMine(fiefdom.getName()) && fiefdom.getViking().size() + fiefdom.getMagyar().size() + fiefdom.getMuslim().size() == 0)) {\n                if (buyerObj.setTotalMoney(qty * 10, false)) {\n                    fiefdom.buyPersonalCastles(qty);\n                }\n                else {\n                    System.out.println(\"You cannot buy more Personal castle, you have insufficient funds\");\n                }\n            }\n            else if (buyerObj.getRank().equalsIgnoreCase(\"king\")) {\n                System.out.println(\"You cannot buy a Personal Castle for Counts or Dukes\");\n            }\n            else if (CurrentPlayers.currentPlayers.get(fiefdom.getOwner()).getRank().equalsIgnoreCase(\"count\") || CurrentPlayers.currentPlayers.get(fiefdom.getOwner()).getRank().equalsIgnoreCase(\"duke\")) {\n                System.out.println(\"You can only buy a castle for a fiefdom that belongs to you\");\n            }\n        }\n        else {\n            System.out.println(\"Fiefdom doesn't belong to the kingdom: \" + fiefdom.getName() + \" owner: \" + Map.map.get(fiefdom.getName()).getOwner());\n        }\n    }\n    \n    public void mercenary(final Iterator arg) {\n        final int qty = Integer.parseInt(arg.next());\n        final String buyerName = arg.next();\n        final Knight knight = CurrentPlayers.currentPlayers.get(arg.next());\n        final Knight buyerObj = CurrentPlayers.currentPlayers.get(buyerName);\n        if (CurrentPlayers.currentPlayers.containsKey(buyerObj.getName()) && CurrentPlayers.currentPlayers.containsKey(knight.getName())) {\n            if (buyerObj.getName().equals(knight.getName()) || buyerObj.getRank().equals(\"king\")) {\n                if (buyerObj.setTotalMoney(qty, false)) {\n                    knight.addMercenaries(qty);\n                }\n                else {\n                    System.out.println(\"You cannot buy more mercenaries, you have insufficient funds\");\n                }\n            }\n        }\n        else {\n            System.out.println(\"Inexistent Knight\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 1297,
        "token_number_fewshot": 1695,
        "token_number_cot": 1407
    },
    {
        "project_name": "97_feudalismgame",
        "class": "VassalRebellion",
        "source_code": "package src;\n\nimport java.util.*;\n\npublic class VassalRebellion extends Actions\n{\n    private Fiefdoms fiefdomObj;\n    \n    @Override\n    public void perform(final Collection col) {\n        final Iterator colIter = col.iterator();\n        final String fiefdomName = colIter.next();\n        this.fiefdomObj = Map.map.get(fiefdomName);\n        final int personalCastles = this.fiefdomObj.getPersonalCastles();\n        final int fiefdomCastles = this.fiefdomObj.getFiefdomCastles();\n        if (Map.map.get(fiefdomName).getLoyalVassals().size() > 0) {\n            if (this.fiefdomObj.getLoyalVassals().size() - this.fiefdomObj.getValue() >= 0) {\n                this.fiefdomObj.setRebelliousVassals(this.fiefdomObj.getValue(), true);\n                this.fiefdomObj.setKingdom(false);\n            }\n            else {\n                this.fiefdomObj.setRebelliousVassals(this.fiefdomObj.getLoyalVassals().size(), true);\n            }\n            if ((personalCastles > 0 || fiefdomCastles > 0) && this.fiefdomObj.getLoyalVassals().size() - (personalCastles * 10 + fiefdomCastles * 25) > 0) {\n                this.fiefdomObj.setRebelliousVassals(this.fiefdomObj.getLoyalVassals().size() - (personalCastles * 10 + fiefdomCastles * 25), true);\n            }\n        }\n        else {\n            new RollEvent(this.fiefdomObj.getName());\n        }\n    }\n}\n",
        "token_number_zeroshot": 403,
        "token_number_fewshot": 801,
        "token_number_cot": 517
    },
    {
        "project_name": "78_caloriecount",
        "class": "SimpleComboBox",
        "source_code": "package com.lts.swing.combobox;\n\nimport javax.swing.*;\n\npublic class SimpleComboBox extends JComboBox\n{\n    private static final long serialVersionUID = 1L;\n    private SimpleComboBoxModel mySimpleModel;\n    \n    public SimpleComboBox(final SimpleComboBoxModel model) {\n        super(model);\n    }\n    \n    @Override\n    public void setModel(final ComboBoxModel model) {\n        if (model instanceof SimpleComboBoxModel) {\n            this.mySimpleModel = (SimpleComboBoxModel)model;\n        }\n        super.setModel(model);\n    }\n    \n    public Object getSelectedValue() {\n        if (null == this.mySimpleModel) {\n            return null;\n        }\n        return this.mySimpleModel.getSelectedValue();\n    }\n    \n    public void setSelectedValue(final Object value) {\n        this.mySimpleModel.setSelectedValue(value);\n    }\n    \n    public int getSelectedInt() {\n        final Object o = this.getSelectedValue();\n        if (null == o) {\n            return -1;\n        }\n        if (o instanceof Integer) {\n            final Integer ival = (Integer)o;\n            return ival;\n        }\n        if (o instanceof Long) {\n            final Long lval = (Long)o;\n            return (int)(Object)lval;\n        }\n        if (o instanceof Short) {\n            final Short sval = (Short)o;\n            return sval;\n        }\n        if (o instanceof Byte) {\n            final Byte bval = (Byte)o;\n            return bval;\n        }\n        throw new IllegalArgumentException();\n    }\n    \n    public long getSelectedLong() {\n        final Object o = this.getSelectedValue();\n        if (null == o) {\n            return -1L;\n        }\n        if (o instanceof Integer) {\n            final Integer ival = (Integer)o;\n            return ival;\n        }\n        if (o instanceof Long) {\n            final Long lval = (Long)o;\n            return lval;\n        }\n        if (o instanceof Short) {\n            final Short sval = (Short)o;\n            return sval;\n        }\n        if (o instanceof Byte) {\n            final Byte bval = (Byte)o;\n            return bval;\n        }\n        throw new IllegalArgumentException();\n    }\n}\n",
        "token_number_zeroshot": 485,
        "token_number_fewshot": 883,
        "token_number_cot": 596
    },
    {
        "project_name": "78_caloriecount",
        "class": "SimpleKeyListenerHelper",
        "source_code": "package com.lts.event;\n\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class SimpleKeyListenerHelper extends ListenerHelper implements KeyListener\n{\n    private Component component;\n    \n    public SimpleKeyListenerHelper(final Component component) {\n        component.addKeyListener(this);\n        this.component = component;\n    }\n    \n    public void detach() {\n        if (null != this.component) {\n            this.component.removeKeyListener(this);\n            this.component = null;\n        }\n    }\n    \n    @Override\n    public void notifyListener(final Object o, final int type, final Object data) {\n        final SimpleKeyListener listener = (SimpleKeyListener)o;\n        switch (type) {\n            case 10: {\n                listener.enter(this.component);\n                break;\n            }\n            case 155: {\n                listener.insert(this.component);\n                break;\n            }\n            case 127: {\n                listener.delete(this.component);\n                break;\n            }\n            case 9: {\n                listener.tab(this.component);\n                break;\n            }\n        }\n    }\n    \n    @Override\n    public void keyPressed(final KeyEvent event) {\n        switch (event.getKeyCode()) {\n            case 9:\n            case 10:\n            case 127:\n            case 155: {\n                this.fire(event.getKeyCode());\n                break;\n            }\n        }\n    }\n    \n    @Override\n    public void keyReleased(final KeyEvent arg0) {\n    }\n    \n    @Override\n    public void keyTyped(final KeyEvent event) {\n    }\n}\n",
        "token_number_zeroshot": 331,
        "token_number_fewshot": 729,
        "token_number_cot": 443
    },
    {
        "project_name": "trove",
        "class": "TShortByteMapDecorator",
        "source_code": "package gnu.trove.decorator;\n\nimport gnu.trove.map.*;\nimport gnu.trove.iterator.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class TShortByteMapDecorator extends AbstractMap<Short, Byte> implements Map<Short, Byte>, Externalizable, Cloneable\n{\n    static final long serialVersionUID = 1L;\n    protected TShortByteMap _map;\n    \n    public TShortByteMapDecorator() {\n    }\n    \n    public TShortByteMapDecorator(final TShortByteMap map) {\n        this._map = map;\n    }\n    \n    public TShortByteMap getMap() {\n        return this._map;\n    }\n    \n    public Byte put(final Short key, final Byte value) {\n        short k;\n        if (key == null) {\n            k = this._map.getNoEntryKey();\n        }\n        else {\n            k = this.unwrapKey(key);\n        }\n        byte v;\n        if (value == null) {\n            v = this._map.getNoEntryValue();\n        }\n        else {\n            v = this.unwrapValue(value);\n        }\n        final byte retval = this._map.put(k, v);\n        if (retval == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(retval);\n    }\n    \n    public Byte get(final Object key) {\n        short k;\n        if (key != null) {\n            if (!(key instanceof Short)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final byte v = this._map.get(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public void clear() {\n        this._map.clear();\n    }\n    \n    public Byte remove(final Object key) {\n        short k;\n        if (key != null) {\n            if (!(key instanceof Short)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final byte v = this._map.remove(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public Set<Entry<Short, Byte>> entrySet() {\n        return new AbstractSet<Entry<Short, Byte>>() {\n            public int size() {\n                return TShortByteMapDecorator.this._map.size();\n            }\n            \n            public boolean isEmpty() {\n                return TShortByteMapDecorator.this.isEmpty();\n            }\n            \n            public boolean contains(final Object o) {\n                if (o instanceof Entry) {\n                    final Object k = ((Entry)o).getKey();\n                    final Object v = ((Entry)o).getValue();\n                    return TShortByteMapDecorator.this.containsKey(k) && TShortByteMapDecorator.this.get(k).equals(v);\n                }\n                return false;\n            }\n            \n            public Iterator<Entry<Short, Byte>> iterator() {\n                return new Iterator<Entry<Short, Byte>>() {\n                    private final TShortByteIterator it = TShortByteMapDecorator.this._map.iterator();\n                    \n                    public Entry<Short, Byte> next() {\n                        this.it.advance();\n                        final short ik = this.it.key();\n                        final Short key = (ik == TShortByteMapDecorator.this._map.getNoEntryKey()) ? null : TShortByteMapDecorator.this.wrapKey(ik);\n                        final byte iv = this.it.value();\n                        final Byte v = (iv == TShortByteMapDecorator.this._map.getNoEntryValue()) ? null : TShortByteMapDecorator.this.wrapValue(iv);\n                        return new Entry<Short, Byte>() {\n                            private Byte val = v;\n                            \n                            public boolean equals(final Object o) {\n                                return o instanceof Entry && ((Entry)o).getKey().equals(key) && ((Entry)o).getValue().equals(this.val);\n                            }\n                            \n                            public Short getKey() {\n                                return key;\n                            }\n                            \n                            public Byte getValue() {\n                                return this.val;\n                            }\n                            \n                            public int hashCode() {\n                                return key.hashCode() + this.val.hashCode();\n                            }\n                            \n                            public Byte setValue(final Byte value) {\n                                this.val = value;\n                                return TShortByteMapDecorator.this.put(key, value);\n                            }\n                        };\n                    }\n                    \n                    public boolean hasNext() {\n                        return this.it.hasNext();\n                    }\n                    \n                    public void remove() {\n                        this.it.remove();\n                    }\n                };\n            }\n            \n            public boolean add(final Entry<Short, Byte> o) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public boolean remove(final Object o) {\n                boolean modified = false;\n                if (this.contains(o)) {\n                    final Short key = ((Entry)o).getKey();\n                    TShortByteMapDecorator.this._map.remove(TShortByteMapDecorator.this.unwrapKey(key));\n                    modified = true;\n                }\n                return modified;\n            }\n            \n            public boolean addAll(final Collection<? extends Entry<Short, Byte>> c) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public void clear() {\n                TShortByteMapDecorator.this.clear();\n            }\n        };\n    }\n    \n    public boolean containsValue(final Object val) {\n        return val instanceof Byte && this._map.containsValue(this.unwrapValue(val));\n    }\n    \n    public boolean containsKey(final Object key) {\n        if (key == null) {\n            return this._map.containsKey(this._map.getNoEntryKey());\n        }\n        return key instanceof Short && this._map.containsKey(this.unwrapKey(key));\n    }\n    \n    public int size() {\n        return this._map.size();\n    }\n    \n    public boolean isEmpty() {\n        return this.size() == 0;\n    }\n    \n    public void putAll(final Map<? extends Short, ? extends Byte> map) {\n        final Iterator<? extends Entry<? extends Short, ? extends Byte>> it = map.entrySet().iterator();\n        int i = map.size();\n        while (i-- > 0) {\n            final Entry<? extends Short, ? extends Byte> e = (Entry<? extends Short, ? extends Byte>)it.next();\n            this.put((Short)e.getKey(), (Byte)e.getValue());\n        }\n    }\n    \n    protected Short wrapKey(final short k) {\n        return k;\n    }\n    \n    protected short unwrapKey(final Object key) {\n        return (short)key;\n    }\n    \n    protected Byte wrapValue(final byte k) {\n        return k;\n    }\n    \n    protected byte unwrapValue(final Object value) {\n        return (byte)value;\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        this._map = (TShortByteMap)in.readObject();\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        out.writeObject(this._map);\n    }\n}\n",
        "token_number_zeroshot": 1468,
        "token_number_fewshot": 1866,
        "token_number_cot": 1582
    },
    {
        "project_name": "trove",
        "class": "TShortHash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport java.util.*;\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\n\npublic abstract class TShortHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient short[] _set;\n    protected short no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TShortHash() {\n        this.no_entry_value = Constants.DEFAULT_SHORT_NO_ENTRY_VALUE;\n        if (this.no_entry_value != 0) {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TShortHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_value = Constants.DEFAULT_SHORT_NO_ENTRY_VALUE;\n        if (this.no_entry_value != 0) {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TShortHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = Constants.DEFAULT_SHORT_NO_ENTRY_VALUE;\n        if (this.no_entry_value != 0) {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TShortHash(final int initialCapacity, final float loadFactor, final short no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = no_entry_value;\n        if (no_entry_value != 0) {\n            Arrays.fill(this._set, no_entry_value);\n        }\n    }\n    \n    public short getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new short[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final short val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TShortProcedure procedure) {\n        final byte[] states = this._states;\n        final short[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_value;\n        super.removeAt(index);\n    }\n    \n    protected int index(final short val) {\n        final byte[] states = this._states;\n        final short[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == val) {\n            return index;\n        }\n        return this.indexRehashed(val, index, hash, state);\n    }\n    \n    int indexRehashed(final short key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final short val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final short val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final short val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n}\n",
        "token_number_zeroshot": 1235,
        "token_number_fewshot": 1633,
        "token_number_cot": 1347
    },
    {
        "project_name": "trove",
        "class": "TDoubleShortMapDecorator",
        "source_code": "package gnu.trove.decorator;\n\nimport gnu.trove.map.*;\nimport gnu.trove.iterator.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class TDoubleShortMapDecorator extends AbstractMap<Double, Short> implements Map<Double, Short>, Externalizable, Cloneable\n{\n    static final long serialVersionUID = 1L;\n    protected TDoubleShortMap _map;\n    \n    public TDoubleShortMapDecorator() {\n    }\n    \n    public TDoubleShortMapDecorator(final TDoubleShortMap map) {\n        this._map = map;\n    }\n    \n    public TDoubleShortMap getMap() {\n        return this._map;\n    }\n    \n    public Short put(final Double key, final Short value) {\n        double k;\n        if (key == null) {\n            k = this._map.getNoEntryKey();\n        }\n        else {\n            k = this.unwrapKey(key);\n        }\n        short v;\n        if (value == null) {\n            v = this._map.getNoEntryValue();\n        }\n        else {\n            v = this.unwrapValue(value);\n        }\n        final short retval = this._map.put(k, v);\n        if (retval == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(retval);\n    }\n    \n    public Short get(final Object key) {\n        double k;\n        if (key != null) {\n            if (!(key instanceof Double)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final short v = this._map.get(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public void clear() {\n        this._map.clear();\n    }\n    \n    public Short remove(final Object key) {\n        double k;\n        if (key != null) {\n            if (!(key instanceof Double)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final short v = this._map.remove(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public Set<Entry<Double, Short>> entrySet() {\n        return new AbstractSet<Entry<Double, Short>>() {\n            public int size() {\n                return TDoubleShortMapDecorator.this._map.size();\n            }\n            \n            public boolean isEmpty() {\n                return TDoubleShortMapDecorator.this.isEmpty();\n            }\n            \n            public boolean contains(final Object o) {\n                if (o instanceof Entry) {\n                    final Object k = ((Entry)o).getKey();\n                    final Object v = ((Entry)o).getValue();\n                    return TDoubleShortMapDecorator.this.containsKey(k) && TDoubleShortMapDecorator.this.get(k).equals(v);\n                }\n                return false;\n            }\n            \n            public Iterator<Entry<Double, Short>> iterator() {\n                return new Iterator<Entry<Double, Short>>() {\n                    private final TDoubleShortIterator it = TDoubleShortMapDecorator.this._map.iterator();\n                    \n                    public Entry<Double, Short> next() {\n                        this.it.advance();\n                        final double ik = this.it.key();\n                        final Double key = (ik == TDoubleShortMapDecorator.this._map.getNoEntryKey()) ? null : TDoubleShortMapDecorator.this.wrapKey(ik);\n                        final short iv = this.it.value();\n                        final Short v = (iv == TDoubleShortMapDecorator.this._map.getNoEntryValue()) ? null : TDoubleShortMapDecorator.this.wrapValue(iv);\n                        return new Entry<Double, Short>() {\n                            private Short val = v;\n                            \n                            public boolean equals(final Object o) {\n                                return o instanceof Entry && ((Entry)o).getKey().equals(key) && ((Entry)o).getValue().equals(this.val);\n                            }\n                            \n                            public Double getKey() {\n                                return key;\n                            }\n                            \n                            public Short getValue() {\n                                return this.val;\n                            }\n                            \n                            public int hashCode() {\n                                return key.hashCode() + this.val.hashCode();\n                            }\n                            \n                            public Short setValue(final Short value) {\n                                this.val = value;\n                                return TDoubleShortMapDecorator.this.put(key, value);\n                            }\n                        };\n                    }\n                    \n                    public boolean hasNext() {\n                        return this.it.hasNext();\n                    }\n                    \n                    public void remove() {\n                        this.it.remove();\n                    }\n                };\n            }\n            \n            public boolean add(final Entry<Double, Short> o) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public boolean remove(final Object o) {\n                boolean modified = false;\n                if (this.contains(o)) {\n                    final Double key = ((Entry)o).getKey();\n                    TDoubleShortMapDecorator.this._map.remove(TDoubleShortMapDecorator.this.unwrapKey(key));\n                    modified = true;\n                }\n                return modified;\n            }\n            \n            public boolean addAll(final Collection<? extends Entry<Double, Short>> c) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public void clear() {\n                TDoubleShortMapDecorator.this.clear();\n            }\n        };\n    }\n    \n    public boolean containsValue(final Object val) {\n        return val instanceof Short && this._map.containsValue(this.unwrapValue(val));\n    }\n    \n    public boolean containsKey(final Object key) {\n        if (key == null) {\n            return this._map.containsKey(this._map.getNoEntryKey());\n        }\n        return key instanceof Double && this._map.containsKey(this.unwrapKey(key));\n    }\n    \n    public int size() {\n        return this._map.size();\n    }\n    \n    public boolean isEmpty() {\n        return this.size() == 0;\n    }\n    \n    public void putAll(final Map<? extends Double, ? extends Short> map) {\n        final Iterator<? extends Entry<? extends Double, ? extends Short>> it = map.entrySet().iterator();\n        int i = map.size();\n        while (i-- > 0) {\n            final Entry<? extends Double, ? extends Short> e = (Entry<? extends Double, ? extends Short>)it.next();\n            this.put((Double)e.getKey(), (Short)e.getValue());\n        }\n    }\n    \n    protected Double wrapKey(final double k) {\n        return k;\n    }\n    \n    protected double unwrapKey(final Object key) {\n        return (double)key;\n    }\n    \n    protected Short wrapValue(final short k) {\n        return k;\n    }\n    \n    protected short unwrapValue(final Object value) {\n        return (short)value;\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        this._map = (TDoubleShortMap)in.readObject();\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        out.writeObject(this._map);\n    }\n}\n",
        "token_number_zeroshot": 1458,
        "token_number_fewshot": 1856,
        "token_number_cot": 1572
    },
    {
        "project_name": "trove",
        "class": "TFloatDoubleHash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\nimport java.io.*;\n\npublic abstract class TFloatDoubleHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient float[] _set;\n    protected float no_entry_key;\n    protected double no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TFloatDoubleHash() {\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = 0.0;\n    }\n    \n    public TFloatDoubleHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = 0.0;\n    }\n    \n    public TFloatDoubleHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = 0.0;\n    }\n    \n    public TFloatDoubleHash(final int initialCapacity, final float loadFactor, final float no_entry_key, final double no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = no_entry_key;\n        this.no_entry_value = no_entry_value;\n    }\n    \n    public float getNoEntryKey() {\n        return this.no_entry_key;\n    }\n    \n    public double getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new float[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final float val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TFloatProcedure procedure) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_key;\n        super.removeAt(index);\n    }\n    \n    protected int index(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == key) {\n            return index;\n        }\n        return this.indexRehashed(key, index, hash, state);\n    }\n    \n    int indexRehashed(final float key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final float val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final float val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final float val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n    \n    protected int XinsertKey(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        int index = hash % length;\n        byte state = states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n        if (state == 1 && set[index] == key) {\n            return -index - 1;\n        }\n        final int probe = 1 + hash % (length - 2);\n        if (state != 2) {\n            do {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            } while (state == 1 && set[index] != key);\n        }\n        if (state == 2) {\n            final int firstRemoved = index;\n            while (state != 0 && (state == 2 || set[index] != key)) {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            }\n            if (state == 1) {\n                return -index - 1;\n            }\n            set[index] = key;\n            states[index] = 1;\n            return firstRemoved;\n        }\n        else {\n            if (state == 1) {\n                return -index - 1;\n            }\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        super.writeExternal(out);\n        out.writeFloat(this.no_entry_key);\n        out.writeDouble(this.no_entry_value);\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        super.readExternal(in);\n        this.no_entry_key = in.readFloat();\n        this.no_entry_value = in.readDouble();\n    }\n}\n",
        "token_number_zeroshot": 1681,
        "token_number_fewshot": 2079,
        "token_number_cot": 1794
    },
    {
        "project_name": "trove",
        "class": "TFloatCharHash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\nimport java.io.*;\n\npublic abstract class TFloatCharHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient float[] _set;\n    protected float no_entry_key;\n    protected char no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TFloatCharHash() {\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = '\\0';\n    }\n    \n    public TFloatCharHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = '\\0';\n    }\n    \n    public TFloatCharHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = '\\0';\n    }\n    \n    public TFloatCharHash(final int initialCapacity, final float loadFactor, final float no_entry_key, final char no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = no_entry_key;\n        this.no_entry_value = no_entry_value;\n    }\n    \n    public float getNoEntryKey() {\n        return this.no_entry_key;\n    }\n    \n    public char getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new float[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final float val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TFloatProcedure procedure) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_key;\n        super.removeAt(index);\n    }\n    \n    protected int index(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == key) {\n            return index;\n        }\n        return this.indexRehashed(key, index, hash, state);\n    }\n    \n    int indexRehashed(final float key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final float val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final float val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final float val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n    \n    protected int XinsertKey(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        int index = hash % length;\n        byte state = states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n        if (state == 1 && set[index] == key) {\n            return -index - 1;\n        }\n        final int probe = 1 + hash % (length - 2);\n        if (state != 2) {\n            do {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            } while (state == 1 && set[index] != key);\n        }\n        if (state == 2) {\n            final int firstRemoved = index;\n            while (state != 0 && (state == 2 || set[index] != key)) {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            }\n            if (state == 1) {\n                return -index - 1;\n            }\n            set[index] = key;\n            states[index] = 1;\n            return firstRemoved;\n        }\n        else {\n            if (state == 1) {\n                return -index - 1;\n            }\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        super.writeExternal(out);\n        out.writeFloat(this.no_entry_key);\n        out.writeChar(this.no_entry_value);\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        super.readExternal(in);\n        this.no_entry_key = in.readFloat();\n        this.no_entry_value = in.readChar();\n    }\n}\n",
        "token_number_zeroshot": 1675,
        "token_number_fewshot": 2073,
        "token_number_cot": 1788
    },
    {
        "project_name": "trove",
        "class": "TCharHash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport java.util.*;\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\n\npublic abstract class TCharHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient char[] _set;\n    protected char no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TCharHash() {\n        this.no_entry_value = Constants.DEFAULT_CHAR_NO_ENTRY_VALUE;\n        if (this.no_entry_value != '\\0') {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TCharHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_value = Constants.DEFAULT_CHAR_NO_ENTRY_VALUE;\n        if (this.no_entry_value != '\\0') {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TCharHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = Constants.DEFAULT_CHAR_NO_ENTRY_VALUE;\n        if (this.no_entry_value != '\\0') {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TCharHash(final int initialCapacity, final float loadFactor, final char no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = no_entry_value;\n        if (no_entry_value != '\\0') {\n            Arrays.fill(this._set, no_entry_value);\n        }\n    }\n    \n    public char getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new char[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final char val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TCharProcedure procedure) {\n        final byte[] states = this._states;\n        final char[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_value;\n        super.removeAt(index);\n    }\n    \n    protected int index(final char val) {\n        final byte[] states = this._states;\n        final char[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == val) {\n            return index;\n        }\n        return this.indexRehashed(val, index, hash, state);\n    }\n    \n    int indexRehashed(final char key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final char val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final char val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final char val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n}\n",
        "token_number_zeroshot": 1235,
        "token_number_fewshot": 1633,
        "token_number_cot": 1347
    },
    {
        "project_name": "commons-lang",
        "class": "LocaleUtils",
        "source_code": "package org.apache.commons.lang3;\n\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class LocaleUtils\n{\n    private static final ConcurrentMap<String, List<Locale>> cLanguagesByCountry;\n    private static final ConcurrentMap<String, List<Locale>> cCountriesByLanguage;\n    \n    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return new Locale(\"\", \"\");\n        }\n        if (str.contains(\"#\")) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n        if (ch0 != '_') {\n            final String[] split = str.split(\"_\", -1);\n            final int occurrences = split.length - 1;\n            switch (occurrences) {\n                case 0: {\n                    if (StringUtils.isAllLowerCase(str) && (len == 2 || len == 3)) {\n                        return new Locale(str);\n                    }\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                case 1: {\n                    if (StringUtils.isAllLowerCase(split[0]) && (split[0].length() == 2 || split[0].length() == 3) && split[1].length() == 2 && StringUtils.isAllUpperCase(split[1])) {\n                        return new Locale(split[0], split[1]);\n                    }\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                case 2: {\n                    if (StringUtils.isAllLowerCase(split[0]) && (split[0].length() == 2 || split[0].length() == 3) && (split[1].length() == 0 || (split[1].length() == 2 && StringUtils.isAllUpperCase(split[1]))) && split[2].length() > 0) {\n                        return new Locale(split[0], split[1], split[2]);\n                    }\n                    break;\n                }\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len < 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch2 = str.charAt(1);\n        final char ch3 = str.charAt(2);\n        if (!Character.isUpperCase(ch2) || !Character.isUpperCase(ch3)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len < 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    \n    public static List<Locale> localeLookupList(final Locale locale) {\n        return localeLookupList(locale, locale);\n    }\n    \n    public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) {\n        final List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList((List<? extends Locale>)list);\n    }\n    \n    public static List<Locale> availableLocaleList() {\n        return SyncAvoid.AVAILABLE_LOCALE_LIST;\n    }\n    \n    public static Set<Locale> availableLocaleSet() {\n        return SyncAvoid.AVAILABLE_LOCALE_SET;\n    }\n    \n    public static boolean isAvailableLocale(final Locale locale) {\n        return availableLocaleList().contains(locale);\n    }\n    \n    public static List<Locale> languagesByCountry(final String countryCode) {\n        if (countryCode == null) {\n            return Collections.emptyList();\n        }\n        List<Locale> langs = LocaleUtils.cLanguagesByCountry.get(countryCode);\n        if (langs == null) {\n            langs = new ArrayList<Locale>();\n            final List<Locale> locales = availableLocaleList();\n            for (int i = 0; i < locales.size(); ++i) {\n                final Locale locale = locales.get(i);\n                if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) {\n                    langs.add(locale);\n                }\n            }\n            langs = Collections.unmodifiableList((List<? extends Locale>)langs);\n            LocaleUtils.cLanguagesByCountry.putIfAbsent(countryCode, langs);\n            langs = LocaleUtils.cLanguagesByCountry.get(countryCode);\n        }\n        return langs;\n    }\n    \n    public static List<Locale> countriesByLanguage(final String languageCode) {\n        if (languageCode == null) {\n            return Collections.emptyList();\n        }\n        List<Locale> countries = LocaleUtils.cCountriesByLanguage.get(languageCode);\n        if (countries == null) {\n            countries = new ArrayList<Locale>();\n            final List<Locale> locales = availableLocaleList();\n            for (int i = 0; i < locales.size(); ++i) {\n                final Locale locale = locales.get(i);\n                if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) {\n                    countries.add(locale);\n                }\n            }\n            countries = Collections.unmodifiableList((List<? extends Locale>)countries);\n            LocaleUtils.cCountriesByLanguage.putIfAbsent(languageCode, countries);\n            countries = LocaleUtils.cCountriesByLanguage.get(languageCode);\n        }\n        return countries;\n    }\n    \n    static {\n        cLanguagesByCountry = new ConcurrentHashMap<String, List<Locale>>();\n        cCountriesByLanguage = new ConcurrentHashMap<String, List<Locale>>();\n    }\n    \n    static class SyncAvoid\n    {\n        private static final List<Locale> AVAILABLE_LOCALE_LIST;\n        private static final Set<Locale> AVAILABLE_LOCALE_SET;\n        \n        static {\n            final List<Locale> list = new ArrayList<Locale>(Arrays.asList(Locale.getAvailableLocales()));\n            AVAILABLE_LOCALE_LIST = Collections.unmodifiableList((List<? extends Locale>)list);\n            AVAILABLE_LOCALE_SET = Collections.unmodifiableSet((Set<? extends Locale>)new HashSet<Locale>(list));\n        }\n    }\n}\n",
        "token_number_zeroshot": 1427,
        "token_number_fewshot": 1825,
        "token_number_cot": 1538
    },
    {
        "project_name": "commons-lang",
        "class": "NumericEntityUnescaper",
        "source_code": "package org.apache.commons.lang3.text.translate;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class NumericEntityUnescaper extends CharSequenceTranslator\n{\n    private final EnumSet<OPTION> options;\n    \n    public NumericEntityUnescaper(final OPTION... options) {\n        if (options.length > 0) {\n            this.options = EnumSet.copyOf(Arrays.asList(options));\n        }\n        else {\n            this.options = EnumSet.copyOf(Arrays.asList(OPTION.semiColonRequired));\n        }\n    }\n    \n    public boolean isSet(final OPTION option) {\n        return this.options != null && this.options.contains(option);\n    }\n    \n    @Override\n    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n        final int seqEnd = input.length();\n        if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n            final char firstChar = input.charAt(start);\n            if (firstChar == 'x' || firstChar == 'X') {\n                ++start;\n                isHex = true;\n                if (start == seqEnd) {\n                    return 0;\n                }\n            }\n            int end;\n            for (end = start; end < seqEnd && ((input.charAt(end) >= '0' && input.charAt(end) <= '9') || (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || (input.charAt(end) >= 'A' && input.charAt(end) <= 'F')); ++end) {}\n            final boolean semiNext = end != seqEnd && input.charAt(end) == ';';\n            if (!semiNext) {\n                if (this.isSet(OPTION.semiColonRequired)) {\n                    return 0;\n                }\n                if (this.isSet(OPTION.errorIfNoSemiColon)) {\n                    throw new IllegalArgumentException(\"Semi-colon required at end of numeric entity\");\n                }\n            }\n            int entityValue;\n            try {\n                if (isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                }\n                else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            }\n            catch (NumberFormatException nfe) {\n                return 0;\n            }\n            if (entityValue > 65535) {\n                final char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            }\n            else {\n                out.write(entityValue);\n            }\n            return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n        }\n        return 0;\n    }\n    \n    public enum OPTION\n    {\n        semiColonRequired, \n        semiColonOptional, \n        errorIfNoSemiColon;\n    }\n}\n",
        "token_number_zeroshot": 648,
        "token_number_fewshot": 1046,
        "token_number_cot": 762
    },
    {
        "project_name": "commons-lang",
        "class": "FastDateFormat",
        "source_code": "package org.apache.commons.lang3.time;\n\nimport java.util.*;\nimport java.text.*;\n\npublic class FastDateFormat extends Format implements DateParser, DatePrinter\n{\n    private static final long serialVersionUID = 2L;\n    public static final int FULL = 0;\n    public static final int LONG = 1;\n    public static final int MEDIUM = 2;\n    public static final int SHORT = 3;\n    private static final FormatCache<FastDateFormat> cache;\n    private final FastDatePrinter printer;\n    private final FastDateParser parser;\n    \n    public static FastDateFormat getInstance() {\n        return FastDateFormat.cache.getInstance();\n    }\n    \n    public static FastDateFormat getInstance(final String pattern) {\n        return FastDateFormat.cache.getInstance(pattern, null, null);\n    }\n    \n    public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone) {\n        return FastDateFormat.cache.getInstance(pattern, timeZone, null);\n    }\n    \n    public static FastDateFormat getInstance(final String pattern, final Locale locale) {\n        return FastDateFormat.cache.getInstance(pattern, null, locale);\n    }\n    \n    public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getInstance(pattern, timeZone, locale);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style) {\n        return FastDateFormat.cache.getDateInstance(style, null, null);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style, final Locale locale) {\n        return FastDateFormat.cache.getDateInstance(style, null, locale);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone) {\n        return FastDateFormat.cache.getDateInstance(style, timeZone, null);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getDateInstance(style, timeZone, locale);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style) {\n        return FastDateFormat.cache.getTimeInstance(style, null, null);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style, final Locale locale) {\n        return FastDateFormat.cache.getTimeInstance(style, null, locale);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone) {\n        return FastDateFormat.cache.getTimeInstance(style, timeZone, null);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getTimeInstance(style, timeZone, locale);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle) {\n        return FastDateFormat.cache.getDateTimeInstance(dateStyle, timeStyle, null, null);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale) {\n        return FastDateFormat.cache.getDateTimeInstance(dateStyle, timeStyle, null, locale);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone) {\n        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);\n    }\n    \n    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) {\n        this(pattern, timeZone, locale, null);\n    }\n    \n    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale, final Date centuryStart) {\n        this.printer = new FastDatePrinter(pattern, timeZone, locale);\n        this.parser = new FastDateParser(pattern, timeZone, locale, centuryStart);\n    }\n    \n    @Override\n    public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n        return this.printer.format(obj, toAppendTo, pos);\n    }\n    \n    @Override\n    public String format(final long millis) {\n        return this.printer.format(millis);\n    }\n    \n    @Override\n    public String format(final Date date) {\n        return this.printer.format(date);\n    }\n    \n    @Override\n    public String format(final Calendar calendar) {\n        return this.printer.format(calendar);\n    }\n    \n    @Override\n    public StringBuffer format(final long millis, final StringBuffer buf) {\n        return this.printer.format(millis, buf);\n    }\n    \n    @Override\n    public StringBuffer format(final Date date, final StringBuffer buf) {\n        return this.printer.format(date, buf);\n    }\n    \n    @Override\n    public StringBuffer format(final Calendar calendar, final StringBuffer buf) {\n        return this.printer.format(calendar, buf);\n    }\n    \n    @Override\n    public Date parse(final String source) throws ParseException {\n        return this.parser.parse(source);\n    }\n    \n    @Override\n    public Date parse(final String source, final ParsePosition pos) {\n        return this.parser.parse(source, pos);\n    }\n    \n    @Override\n    public Object parseObject(final String source, final ParsePosition pos) {\n        return this.parser.parseObject(source, pos);\n    }\n    \n    @Override\n    public String getPattern() {\n        return this.printer.getPattern();\n    }\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return this.printer.getTimeZone();\n    }\n    \n    @Override\n    public Locale getLocale() {\n        return this.printer.getLocale();\n    }\n    \n    public int getMaxLengthEstimate() {\n        return this.printer.getMaxLengthEstimate();\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (!(obj instanceof FastDateFormat)) {\n            return false;\n        }\n        final FastDateFormat other = (FastDateFormat)obj;\n        return this.printer.equals(other.printer);\n    }\n    \n    @Override\n    public int hashCode() {\n        return this.printer.hashCode();\n    }\n    \n    @Override\n    public String toString() {\n        return \"FastDateFormat[\" + this.printer.getPattern() + \",\" + this.printer.getLocale() + \",\" + this.printer.getTimeZone().getID() + \"]\";\n    }\n    \n    protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {\n        return this.printer.applyRules(calendar, buf);\n    }\n    \n    static {\n        cache = new FormatCache<FastDateFormat>() {\n            @Override\n            protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {\n                return new FastDateFormat(pattern, timeZone, locale);\n            }\n        };\n    }\n}\n",
        "token_number_zeroshot": 1380,
        "token_number_fewshot": 1778,
        "token_number_cot": 1491
    },
    {
        "project_name": "commons-lang",
        "class": "HashCodeBuilder",
        "source_code": "package org.apache.commons.lang3.builder;\n\nimport org.apache.commons.lang3.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class HashCodeBuilder implements Builder<Integer>\n{\n    private static final ThreadLocal<Set<IDKey>> REGISTRY;\n    private final int iConstant;\n    private int iTotal;\n    \n    static Set<IDKey> getRegistry() {\n        return HashCodeBuilder.REGISTRY.get();\n    }\n    \n    static boolean isRegistered(final Object value) {\n        final Set<IDKey> registry = getRegistry();\n        return registry != null && registry.contains(new IDKey(value));\n    }\n    \n    private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            final Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (final Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName()) && field.getName().indexOf(36) == -1 && (useTransients || !Modifier.isTransient(field.getModifiers())) && !Modifier.isStatic(field.getModifiers())) {\n                    try {\n                        final Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    }\n                    catch (IllegalAccessException e) {\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        }\n        finally {\n            unregister(object);\n        }\n    }\n    \n    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, new String[0]);\n    }\n    \n    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object, final boolean testTransients) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null, new String[0]);\n    }\n    \n    public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) {\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }\n    \n    public static int reflectionHashCode(final Object object, final boolean testTransients) {\n        return reflectionHashCode(17, 37, object, testTransients, null, new String[0]);\n    }\n    \n    public static int reflectionHashCode(final Object object, final Collection<String> excludeFields) {\n        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n    \n    public static int reflectionHashCode(final Object object, final String... excludeFields) {\n        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n    }\n    \n    static void register(final Object value) {\n        synchronized (HashCodeBuilder.class) {\n            if (getRegistry() == null) {\n                HashCodeBuilder.REGISTRY.set(new HashSet<IDKey>());\n            }\n        }\n        getRegistry().add(new IDKey(value));\n    }\n    \n    static void unregister(final Object value) {\n        Set<IDKey> registry = getRegistry();\n        if (registry != null) {\n            registry.remove(new IDKey(value));\n            synchronized (HashCodeBuilder.class) {\n                registry = getRegistry();\n                if (registry != null && registry.isEmpty()) {\n                    HashCodeBuilder.REGISTRY.remove();\n                }\n            }\n        }\n    }\n    \n    public HashCodeBuilder() {\n        this.iTotal = 0;\n        this.iConstant = 37;\n        this.iTotal = 17;\n    }\n    \n    public HashCodeBuilder(final int initialOddNumber, final int multiplierOddNumber) {\n        this.iTotal = 0;\n        if (initialOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n        }\n        if (multiplierOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n        }\n        this.iConstant = multiplierOddNumber;\n        this.iTotal = initialOddNumber;\n    }\n    \n    public HashCodeBuilder append(final boolean value) {\n        this.iTotal = this.iTotal * this.iConstant + (value ? 0 : 1);\n        return this;\n    }\n    \n    public HashCodeBuilder append(final boolean[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final boolean element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final byte value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final byte[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final byte element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final char value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final char[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final char element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final double value) {\n        return this.append(Double.doubleToLongBits(value));\n    }\n    \n    public HashCodeBuilder append(final double[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final double element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final float value) {\n        this.iTotal = this.iTotal * this.iConstant + Float.floatToIntBits(value);\n        return this;\n    }\n    \n    public HashCodeBuilder append(final float[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final float element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final int value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final int[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final int element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final long value) {\n        this.iTotal = this.iTotal * this.iConstant + (int)(value ^ value >> 32);\n        return this;\n    }\n    \n    public HashCodeBuilder append(final long[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final long element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final Object object) {\n        if (object == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else if (object.getClass().isArray()) {\n            if (object instanceof long[]) {\n                this.append((long[])object);\n            }\n            else if (object instanceof int[]) {\n                this.append((int[])object);\n            }\n            else if (object instanceof short[]) {\n                this.append((short[])object);\n            }\n            else if (object instanceof char[]) {\n                this.append((char[])object);\n            }\n            else if (object instanceof byte[]) {\n                this.append((byte[])object);\n            }\n            else if (object instanceof double[]) {\n                this.append((double[])object);\n            }\n            else if (object instanceof float[]) {\n                this.append((float[])object);\n            }\n            else if (object instanceof boolean[]) {\n                this.append((boolean[])object);\n            }\n            else {\n                this.append((Object[])object);\n            }\n        }\n        else {\n            this.iTotal = this.iTotal * this.iConstant + object.hashCode();\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final Object[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final Object element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final short value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final short[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final short element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder appendSuper(final int superHashCode) {\n        this.iTotal = this.iTotal * this.iConstant + superHashCode;\n        return this;\n    }\n    \n    public int toHashCode() {\n        return this.iTotal;\n    }\n    \n    @Override\n    public Integer build() {\n        return this.toHashCode();\n    }\n    \n    @Override\n    public int hashCode() {\n        return this.toHashCode();\n    }\n    \n    static {\n        REGISTRY = new ThreadLocal<Set<IDKey>>();\n    }\n}\n",
        "token_number_zeroshot": 2196,
        "token_number_fewshot": 2594,
        "token_number_cot": 2308
    },
    {
        "project_name": "commons-lang",
        "class": "CompareToBuilder",
        "source_code": "package org.apache.commons.lang3.builder;\n\nimport org.apache.commons.lang3.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class CompareToBuilder implements Builder<Integer>\n{\n    private int comparison;\n    \n    public CompareToBuilder() {\n        this.comparison = 0;\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs) {\n        return reflectionCompare(lhs, rhs, false, null, new String[0]);\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) {\n        return reflectionCompare(lhs, rhs, compareTransients, null, new String[0]);\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields) {\n        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields) {\n        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {\n        if (lhs == rhs) {\n            return 0;\n        }\n        if (lhs == null || rhs == null) {\n            throw new NullPointerException();\n        }\n        Class<?> lhsClazz = lhs.getClass();\n        if (!lhsClazz.isInstance(rhs)) {\n            throw new ClassCastException();\n        }\n        final CompareToBuilder compareToBuilder = new CompareToBuilder();\n        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n            lhsClazz = lhsClazz.getSuperclass();\n            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        }\n        return compareToBuilder.toComparison();\n    }\n    \n    private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields) {\n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; ++i) {\n            final Field f = fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) && f.getName().indexOf(36) == -1 && (useTransients || !Modifier.isTransient(f.getModifiers())) && !Modifier.isStatic(f.getModifiers())) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                }\n                catch (IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }\n    \n    public CompareToBuilder appendSuper(final int superCompareTo) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = superCompareTo;\n        return this;\n    }\n    \n    public CompareToBuilder append(final Object lhs, final Object rhs) {\n        return this.append(lhs, rhs, null);\n    }\n    \n    public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.getClass().isArray()) {\n            if (lhs instanceof long[]) {\n                this.append((long[])lhs, (long[])rhs);\n            }\n            else if (lhs instanceof int[]) {\n                this.append((int[])lhs, (int[])rhs);\n            }\n            else if (lhs instanceof short[]) {\n                this.append((short[])lhs, (short[])rhs);\n            }\n            else if (lhs instanceof char[]) {\n                this.append((char[])lhs, (char[])rhs);\n            }\n            else if (lhs instanceof byte[]) {\n                this.append((byte[])lhs, (byte[])rhs);\n            }\n            else if (lhs instanceof double[]) {\n                this.append((double[])lhs, (double[])rhs);\n            }\n            else if (lhs instanceof float[]) {\n                this.append((float[])lhs, (float[])rhs);\n            }\n            else if (lhs instanceof boolean[]) {\n                this.append((boolean[])lhs, (boolean[])rhs);\n            }\n            else {\n                this.append((Object[])lhs, (Object[])rhs, comparator);\n            }\n        }\n        else if (comparator == null) {\n            final Comparable<Object> comparable = (Comparable<Object>)lhs;\n            this.comparison = comparable.compareTo(rhs);\n        }\n        else {\n            this.comparison = comparator.compare(lhs, rhs);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final long lhs, final long rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final int lhs, final int rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final short lhs, final short rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final char lhs, final char rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final byte lhs, final byte rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final double lhs, final double rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = Double.compare(lhs, rhs);\n        return this;\n    }\n    \n    public CompareToBuilder append(final float lhs, final float rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = Float.compare(lhs, rhs);\n        return this;\n    }\n    \n    public CompareToBuilder append(final boolean lhs, final boolean rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (!lhs) {\n            this.comparison = -1;\n        }\n        else {\n            this.comparison = 1;\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs) {\n        return this.append(lhs, rhs, null);\n    }\n    \n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i], comparator);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final long[] lhs, final long[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final int[] lhs, final int[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final short[] lhs, final short[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final char[] lhs, final char[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final double[] lhs, final double[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final float[] lhs, final float[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public int toComparison() {\n        return this.comparison;\n    }\n    \n    @Override\n    public Integer build() {\n        return this.toComparison();\n    }\n}\n",
        "token_number_zeroshot": 3183,
        "token_number_fewshot": 3581,
        "token_number_cot": 3295
    },
    {
        "project_name": "commons-lang",
        "class": "Validate",
        "source_code": "package org.apache.commons.lang3;\n\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class Validate\n{\n    private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE = \"The value %s is not in the specified exclusive range of %s to %s\";\n    private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE = \"The value %s is not in the specified inclusive range of %s to %s\";\n    private static final String DEFAULT_MATCHES_PATTERN_EX = \"The string %s does not match the pattern %s\";\n    private static final String DEFAULT_IS_NULL_EX_MESSAGE = \"The validated object is null\";\n    private static final String DEFAULT_IS_TRUE_EX_MESSAGE = \"The validated expression is false\";\n    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE = \"The validated array contains null element at index: %d\";\n    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE = \"The validated collection contains null element at index: %d\";\n    private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = \"The validated character sequence is blank\";\n    private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = \"The validated array is empty\";\n    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE = \"The validated character sequence is empty\";\n    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = \"The validated collection is empty\";\n    private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = \"The validated map is empty\";\n    private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = \"The validated array index is invalid: %d\";\n    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE = \"The validated character sequence index is invalid: %d\";\n    private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE = \"The validated collection index is invalid: %d\";\n    private static final String DEFAULT_VALID_STATE_EX_MESSAGE = \"The validated state is false\";\n    private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = \"Cannot assign a %s to a %s\";\n    private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = \"Expected type: %s, actual: %s\";\n    \n    public static void isTrue(final boolean expression, final String message, final long value) {\n        if (!expression) {\n            throw new IllegalArgumentException(String.format(message, value));\n        }\n    }\n    \n    public static void isTrue(final boolean expression, final String message, final double value) {\n        if (!expression) {\n            throw new IllegalArgumentException(String.format(message, value));\n        }\n    }\n    \n    public static void isTrue(final boolean expression, final String message, final Object... values) {\n        if (!expression) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void isTrue(final boolean expression) {\n        if (!expression) {\n            throw new IllegalArgumentException(\"The validated expression is false\");\n        }\n    }\n    \n    public static <T> T notNull(final T object) {\n        return notNull(object, \"The validated object is null\", new Object[0]);\n    }\n    \n    public static <T> T notNull(final T object, final String message, final Object... values) {\n        if (object == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        return object;\n    }\n    \n    public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) {\n        if (array == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return array;\n    }\n    \n    public static <T> T[] notEmpty(final T[] array) {\n        return notEmpty(array, \"The validated array is empty\", new Object[0]);\n    }\n    \n    public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) {\n        if (collection == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (collection.isEmpty()) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return collection;\n    }\n    \n    public static <T extends Collection<?>> T notEmpty(final T collection) {\n        return notEmpty(collection, \"The validated collection is empty\", new Object[0]);\n    }\n    \n    public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) {\n        if (map == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (map.isEmpty()) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return map;\n    }\n    \n    public static <T extends Map<?, ?>> T notEmpty(final T map) {\n        return notEmpty(map, \"The validated map is empty\", new Object[0]);\n    }\n    \n    public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) {\n        if (chars == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (chars.length() == 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return chars;\n    }\n    \n    public static <T extends CharSequence> T notEmpty(final T chars) {\n        return notEmpty(chars, \"The validated character sequence is empty\", new Object[0]);\n    }\n    \n    public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) {\n        if (chars == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (StringUtils.isBlank(chars)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return chars;\n    }\n    \n    public static <T extends CharSequence> T notBlank(final T chars) {\n        return notBlank(chars, \"The validated character sequence is blank\", new Object[0]);\n    }\n    \n    public static <T> T[] noNullElements(final T[] array, final String message, final Object... values) {\n        notNull(array);\n        for (int i = 0; i < array.length; ++i) {\n            if (array[i] == null) {\n                final Object[] values2 = ArrayUtils.add(values, i);\n                throw new IllegalArgumentException(String.format(message, values2));\n            }\n        }\n        return array;\n    }\n    \n    public static <T> T[] noNullElements(final T[] array) {\n        return noNullElements(array, \"The validated array contains null element at index: %d\", new Object[0]);\n    }\n    \n    public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) {\n        notNull(iterable);\n        int i = 0;\n        final Iterator<?> it = iterable.iterator();\n        while (it.hasNext()) {\n            if (it.next() == null) {\n                final Object[] values2 = ArrayUtils.addAll(values, i);\n                throw new IllegalArgumentException(String.format(message, values2));\n            }\n            ++i;\n        }\n        return iterable;\n    }\n    \n    public static <T extends Iterable<?>> T noNullElements(final T iterable) {\n        return noNullElements(iterable, \"The validated collection contains null element at index: %d\", new Object[0]);\n    }\n    \n    public static <T> T[] validIndex(final T[] array, final int index, final String message, final Object... values) {\n        notNull(array);\n        if (index < 0 || index >= array.length) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return array;\n    }\n    \n    public static <T> T[] validIndex(final T[] array, final int index) {\n        return validIndex(array, index, \"The validated array index is invalid: %d\", new Object[] { index });\n    }\n    \n    public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) {\n        notNull(collection);\n        if (index < 0 || index >= collection.size()) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return collection;\n    }\n    \n    public static <T extends Collection<?>> T validIndex(final T collection, final int index) {\n        return validIndex(collection, index, \"The validated collection index is invalid: %d\", new Object[] { index });\n    }\n    \n    public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) {\n        notNull(chars);\n        if (index < 0 || index >= chars.length()) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return chars;\n    }\n    \n    public static <T extends CharSequence> T validIndex(final T chars, final int index) {\n        return validIndex(chars, index, \"The validated character sequence index is invalid: %d\", new Object[] { index });\n    }\n    \n    public static void validState(final boolean expression) {\n        if (!expression) {\n            throw new IllegalStateException(\"The validated state is false\");\n        }\n    }\n    \n    public static void validState(final boolean expression, final String message, final Object... values) {\n        if (!expression) {\n            throw new IllegalStateException(String.format(message, values));\n        }\n    }\n    \n    public static void matchesPattern(final CharSequence input, final String pattern) {\n        if (!Pattern.matches(pattern, input)) {\n            throw new IllegalArgumentException(String.format(\"The string %s does not match the pattern %s\", input, pattern));\n        }\n    }\n    \n    public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {\n        if (!Pattern.matches(pattern, input)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) {\n        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void inclusiveBetween(final long start, final long end, final long value) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void inclusiveBetween(final long start, final long end, final long value, final String message) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static void inclusiveBetween(final double start, final double end, final double value) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void inclusiveBetween(final double start, final double end, final double value, final String message) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) {\n        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void exclusiveBetween(final long start, final long end, final long value) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void exclusiveBetween(final long start, final long end, final long value, final String message) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static void exclusiveBetween(final double start, final double end, final double value) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void exclusiveBetween(final double start, final double end, final double value, final String message) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static void isInstanceOf(final Class<?> type, final Object obj) {\n        if (!type.isInstance(obj)) {\n            throw new IllegalArgumentException(String.format(\"Expected type: %s, actual: %s\", type.getName(), (obj == null) ? \"null\" : obj.getClass().getName()));\n        }\n    }\n    \n    public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {\n        if (!type.isInstance(obj)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void isAssignableFrom(final Class<?> superType, final Class<?> type) {\n        if (!superType.isAssignableFrom(type)) {\n            throw new IllegalArgumentException(String.format(\"Cannot assign a %s to a %s\", (type == null) ? \"null\" : type.getName(), superType.getName()));\n        }\n    }\n    \n    public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {\n        if (!superType.isAssignableFrom(type)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n}\n",
        "token_number_zeroshot": 3082,
        "token_number_fewshot": 3480,
        "token_number_cot": 3192
    },
    {
        "project_name": "commons-lang",
        "class": "BooleanUtils",
        "source_code": "package org.apache.commons.lang3;\n\nimport org.apache.commons.lang3.math.*;\n\npublic class BooleanUtils\n{\n    public static Boolean negate(final Boolean bool) {\n        if (bool == null) {\n            return null;\n        }\n        return ((boolean)bool) ? Boolean.FALSE : Boolean.TRUE;\n    }\n    \n    public static boolean isTrue(final Boolean bool) {\n        return Boolean.TRUE.equals(bool);\n    }\n    \n    public static boolean isNotTrue(final Boolean bool) {\n        return !isTrue(bool);\n    }\n    \n    public static boolean isFalse(final Boolean bool) {\n        return Boolean.FALSE.equals(bool);\n    }\n    \n    public static boolean isNotFalse(final Boolean bool) {\n        return !isFalse(bool);\n    }\n    \n    public static boolean toBoolean(final Boolean bool) {\n        return bool != null && bool;\n    }\n    \n    public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) {\n        if (bool == null) {\n            return valueIfNull;\n        }\n        return bool;\n    }\n    \n    public static boolean toBoolean(final int value) {\n        return value != 0;\n    }\n    \n    public static Boolean toBooleanObject(final int value) {\n        return (value == 0) ? Boolean.FALSE : Boolean.TRUE;\n    }\n    \n    public static Boolean toBooleanObject(final Integer value) {\n        if (value == null) {\n            return null;\n        }\n        return (value == 0) ? Boolean.FALSE : Boolean.TRUE;\n    }\n    \n    public static boolean toBoolean(final int value, final int trueValue, final int falseValue) {\n        if (value == trueValue) {\n            return true;\n        }\n        if (value == falseValue) {\n            return false;\n        }\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n    \n    public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return true;\n            }\n            if (falseValue == null) {\n                return false;\n            }\n        }\n        else {\n            if (value.equals(trueValue)) {\n                return true;\n            }\n            if (value.equals(falseValue)) {\n                return false;\n            }\n        }\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n    \n    public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) {\n        if (value == trueValue) {\n            return Boolean.TRUE;\n        }\n        if (value == falseValue) {\n            return Boolean.FALSE;\n        }\n        if (value == nullValue) {\n            return null;\n        }\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n    \n    public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return Boolean.TRUE;\n            }\n            if (falseValue == null) {\n                return Boolean.FALSE;\n            }\n            if (nullValue == null) {\n                return null;\n            }\n        }\n        else {\n            if (value.equals(trueValue)) {\n                return Boolean.TRUE;\n            }\n            if (value.equals(falseValue)) {\n                return Boolean.FALSE;\n            }\n            if (value.equals(nullValue)) {\n                return null;\n            }\n        }\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n    \n    public static int toInteger(final boolean bool) {\n        return bool ? 1 : 0;\n    }\n    \n    public static Integer toIntegerObject(final boolean bool) {\n        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n    }\n    \n    public static Integer toIntegerObject(final Boolean bool) {\n        if (bool == null) {\n            return null;\n        }\n        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n    }\n    \n    public static int toInteger(final boolean bool, final int trueValue, final int falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static Integer toIntegerObject(final boolean bool, final Integer trueValue, final Integer falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static Boolean toBooleanObject(final String str) {\n        if (str == \"true\") {\n            return Boolean.TRUE;\n        }\n        if (str == null) {\n            return null;\n        }\n        switch (str.length()) {\n            case 1: {\n                final char ch0 = str.charAt(0);\n                if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') {\n                    return Boolean.TRUE;\n                }\n                if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n            case 2: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                if ((ch0 == 'o' || ch0 == 'O') && (ch2 == 'n' || ch2 == 'N')) {\n                    return Boolean.TRUE;\n                }\n                if ((ch0 == 'n' || ch0 == 'N') && (ch2 == 'o' || ch2 == 'O')) {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n            case 3: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                final char ch3 = str.charAt(2);\n                if ((ch0 == 'y' || ch0 == 'Y') && (ch2 == 'e' || ch2 == 'E') && (ch3 == 's' || ch3 == 'S')) {\n                    return Boolean.TRUE;\n                }\n                if ((ch0 == 'o' || ch0 == 'O') && (ch2 == 'f' || ch2 == 'F') && (ch3 == 'f' || ch3 == 'F')) {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n            case 4: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                final char ch3 = str.charAt(2);\n                final char ch4 = str.charAt(3);\n                if ((ch0 == 't' || ch0 == 'T') && (ch2 == 'r' || ch2 == 'R') && (ch3 == 'u' || ch3 == 'U') && (ch4 == 'e' || ch4 == 'E')) {\n                    return Boolean.TRUE;\n                }\n                break;\n            }\n            case 5: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                final char ch3 = str.charAt(2);\n                final char ch4 = str.charAt(3);\n                final char ch5 = str.charAt(4);\n                if ((ch0 == 'f' || ch0 == 'F') && (ch2 == 'a' || ch2 == 'A') && (ch3 == 'l' || ch3 == 'L') && (ch4 == 's' || ch4 == 'S') && (ch5 == 'e' || ch5 == 'E')) {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n        }\n        return null;\n    }\n    \n    public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {\n        if (str == null) {\n            if (trueString == null) {\n                return Boolean.TRUE;\n            }\n            if (falseString == null) {\n                return Boolean.FALSE;\n            }\n            if (nullString == null) {\n                return null;\n            }\n        }\n        else {\n            if (str.equals(trueString)) {\n                return Boolean.TRUE;\n            }\n            if (str.equals(falseString)) {\n                return Boolean.FALSE;\n            }\n            if (str.equals(nullString)) {\n                return null;\n            }\n        }\n        throw new IllegalArgumentException(\"The String did not match any specified value\");\n    }\n    \n    public static boolean toBoolean(final String str) {\n        return toBooleanObject(str) == Boolean.TRUE;\n    }\n    \n    public static boolean toBoolean(final String str, final String trueString, final String falseString) {\n        if (str == trueString) {\n            return true;\n        }\n        if (str == falseString) {\n            return false;\n        }\n        if (str != null) {\n            if (str.equals(trueString)) {\n                return true;\n            }\n            if (str.equals(falseString)) {\n                return false;\n            }\n        }\n        throw new IllegalArgumentException(\"The String did not match either specified value\");\n    }\n    \n    public static String toStringTrueFalse(final Boolean bool) {\n        return toString(bool, \"true\", \"false\", null);\n    }\n    \n    public static String toStringOnOff(final Boolean bool) {\n        return toString(bool, \"on\", \"off\", null);\n    }\n    \n    public static String toStringYesNo(final Boolean bool) {\n        return toString(bool, \"yes\", \"no\", null);\n    }\n    \n    public static String toString(final Boolean bool, final String trueString, final String falseString, final String nullString) {\n        if (bool == null) {\n            return nullString;\n        }\n        return bool ? trueString : falseString;\n    }\n    \n    public static String toStringTrueFalse(final boolean bool) {\n        return toString(bool, \"true\", \"false\");\n    }\n    \n    public static String toStringOnOff(final boolean bool) {\n        return toString(bool, \"on\", \"off\");\n    }\n    \n    public static String toStringYesNo(final boolean bool) {\n        return toString(bool, \"yes\", \"no\");\n    }\n    \n    public static String toString(final boolean bool, final String trueString, final String falseString) {\n        return bool ? trueString : falseString;\n    }\n    \n    public static boolean and(final boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (!element) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static Boolean and(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return and(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n    \n    public static boolean or(final boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (element) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public static Boolean or(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n    \n    public static boolean xor(final boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        boolean result = false;\n        for (final boolean element : array) {\n            result ^= element;\n        }\n        return result;\n    }\n    \n    public static Boolean xor(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n\n    @Test\n    public void testToBoolean() {\n        assertTrue(BooleanUtils.toBoolean(1, 1, 0));\n        assertFalse(BooleanUtils.toBoolean(0, 1, 0));\n        try {\n            BooleanUtils.toBoolean(2, 1, 0);\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match either specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToBooleanWithInteger() {\n        assertTrue(BooleanUtils.toBoolean(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0)));\n        assertFalse(BooleanUtils.toBoolean(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0)));\n        try {\n            BooleanUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(0));\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match either specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToBooleanObject() {\n        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(1, 1, 0, -1));\n        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(0, 1, 0, -1));\n        assertNull(BooleanUtils.toBooleanObject(-1, 1, 0, -1));\n        try {\n            BooleanUtils.toBooleanObject(2, 1, 0, -1);\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match any specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToBooleanObjectWithInteger() {\n        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0), null));\n        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0), null));\n        assertNull(BooleanUtils.toBooleanObject(null, Integer.valueOf(1), Integer.valueOf(0), null));\n        try {\n            BooleanUtils.toBooleanObject(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(0), null);\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match any specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToInteger() {\n        assertEquals(1, BooleanUtils.toInteger(true));\n        assertEquals(0, BooleanUtils.toInteger(false));\n    }\n    \n    @Test\n    public void testToIntegerObjectWithBoolean() {\n        assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(true));\n        assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(false));\n    }\n    \n    @Test\n    public void testToIntegerObjectWithNullableBoolean() {\n        assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(Boolean.TRUE));\n        assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(Boolean.FALSE));\n        assertNull(BooleanUtils.toIntegerObject(null));\n    }\n    \n    @Test\n    public void testToIntegerWithValue() {\n        assertEquals(1, BooleanUtils.toInteger(true, 1, 0));\n        assertEquals(0, BooleanUtils.toInteger(false, 1, 0));\n    }\n}\n",
        "token_number_zeroshot": 3539,
        "token_number_fewshot": 3937,
        "token_number_cot": 3650
    },
    {
        "project_name": "commons-lang",
        "class": "ExtendedMessageFormat",
        "source_code": "package org.apache.commons.lang3.text;\n\nimport java.text.*;\nimport java.util.*;\nimport org.apache.commons.lang3.*;\nimport java.io.*;\n\npublic class ExtendedMessageFormat extends MessageFormat\n{\n    private static final long serialVersionUID = -2362048321261811743L;\n    private static final int HASH_SEED = 31;\n    private static final String DUMMY_PATTERN = \"\";\n    private static final String ESCAPED_QUOTE = \"''\";\n    private static final char START_FMT = ',';\n    private static final char END_FE = '}';\n    private static final char START_FE = '{';\n    private static final char QUOTE = '\\'';\n    private String toPattern;\n    private final Map<String, ? extends FormatFactory> registry;\n    \n    public ExtendedMessageFormat(final String pattern) {\n        this(pattern, Locale.getDefault());\n    }\n    \n    public ExtendedMessageFormat(final String pattern, final Locale locale) {\n        this(pattern, locale, null);\n    }\n    \n    public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) {\n        this(pattern, Locale.getDefault(), registry);\n    }\n    \n    public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry) {\n        super(\"\");\n        this.setLocale(locale);\n        this.registry = registry;\n        this.applyPattern(pattern);\n    }\n    \n    @Override\n    public String toPattern() {\n        return this.toPattern;\n    }\n    \n    @Override\n    public final void applyPattern(final String pattern) {\n        if (this.registry == null) {\n            super.applyPattern(pattern);\n            this.toPattern = super.toPattern();\n            return;\n        }\n        final ArrayList<Format> foundFormats = new ArrayList<Format>();\n        final ArrayList<String> foundDescriptions = new ArrayList<String>();\n        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n        final ParsePosition pos = new ParsePosition(0);\n        final char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n                case '\\'': {\n                    this.appendQuotedString(pattern, pos, stripCustom, true);\n                    continue;\n                }\n                case '{': {\n                    ++fmtCount;\n                    this.seekNonWs(pattern, pos);\n                    final int start = pos.getIndex();\n                    final int index = this.readArgumentIndex(pattern, this.next(pos));\n                    stripCustom.append('{').append(index);\n                    this.seekNonWs(pattern, pos);\n                    Format format = null;\n                    String formatDescription = null;\n                    if (c[pos.getIndex()] == ',') {\n                        formatDescription = this.parseFormatDescription(pattern, this.next(pos));\n                        format = this.getFormat(formatDescription);\n                        if (format == null) {\n                            stripCustom.append(',').append(formatDescription);\n                        }\n                    }\n                    foundFormats.add(format);\n                    foundDescriptions.add((format == null) ? null : formatDescription);\n                    Validate.isTrue(foundFormats.size() == fmtCount);\n                    Validate.isTrue(foundDescriptions.size() == fmtCount);\n                    if (c[pos.getIndex()] != '}') {\n                        throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n                    }\n                    break;\n                }\n            }\n            stripCustom.append(c[pos.getIndex()]);\n            this.next(pos);\n        }\n        super.applyPattern(stripCustom.toString());\n        this.toPattern = this.insertFormats(super.toPattern(), foundDescriptions);\n        if (this.containsElements(foundFormats)) {\n            final Format[] origFormats = this.getFormats();\n            int i = 0;\n            for (final Format f : foundFormats) {\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n                ++i;\n            }\n            super.setFormats(origFormats);\n        }\n    }\n    \n    @Override\n    public void setFormat(final int formatElementIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void setFormats(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(this.getClass(), obj.getClass())) {\n            return false;\n        }\n        final ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n        return !ObjectUtils.notEqual(this.toPattern, rhs.toPattern) && !ObjectUtils.notEqual(this.registry, rhs.registry);\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + ObjectUtils.hashCode(this.registry);\n        result = 31 * result + ObjectUtils.hashCode(this.toPattern);\n        return result;\n    }\n    \n    private Format getFormat(final String desc) {\n        if (this.registry != null) {\n            String name = desc;\n            String args = null;\n            final int i = desc.indexOf(44);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            final FormatFactory factory = (FormatFactory)this.registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, this.getLocale());\n            }\n        }\n        return null;\n    }\n    \n    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        this.seekNonWs(pattern, pos);\n        final StringBuilder result = new StringBuilder();\n        boolean error = false;\n        while (!error && pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            Label_0149: {\n                if (Character.isWhitespace(c)) {\n                    this.seekNonWs(pattern, pos);\n                    c = pattern.charAt(pos.getIndex());\n                    if (c != ',' && c != '}') {\n                        error = true;\n                        break Label_0149;\n                    }\n                }\n                if ((c == ',' || c == '}') && result.length() > 0) {\n                    try {\n                        return Integer.parseInt(result.toString());\n                    }\n                    catch (NumberFormatException ex) {}\n                }\n                error = !Character.isDigit(c);\n                result.append(c);\n            }\n            this.next(pos);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\"Invalid format argument index at position \" + start + \": \" + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n    \n    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        this.seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        while (pos.getIndex() < pattern.length()) {\n            switch (pattern.charAt(pos.getIndex())) {\n                case '{': {\n                    ++depth;\n                    break;\n                }\n                case '}': {\n                    if (--depth == 0) {\n                        return pattern.substring(text, pos.getIndex());\n                    }\n                    break;\n                }\n                case '\\'': {\n                    this.getQuotedString(pattern, pos, false);\n                    break;\n                }\n            }\n            this.next(pos);\n        }\n        throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n    \n    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {\n        if (!this.containsElements(customPatterns)) {\n            return pattern;\n        }\n        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        final ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            final char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n                case '\\'': {\n                    this.appendQuotedString(pattern, pos, sb, false);\n                    continue;\n                }\n                case '{': {\n                    ++depth;\n                    sb.append('{').append(this.readArgumentIndex(pattern, this.next(pos)));\n                    if (depth == 1) {\n                        ++fe;\n                        final String customPattern = customPatterns.get(fe);\n                        if (customPattern == null) {\n                            continue;\n                        }\n                        sb.append(',').append(customPattern);\n                        continue;\n                    }\n                    continue;\n                }\n                case '}': {\n                    --depth;\n                    break;\n                }\n            }\n            sb.append(c);\n            this.next(pos);\n        }\n        return sb.toString();\n    }\n    \n    private void seekNonWs(final String pattern, final ParsePosition pos) {\n        int len = 0;\n        final char[] buffer = pattern.toCharArray();\n        do {\n            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n    \n    private ParsePosition next(final ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n    \n    private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) {\n        final int start = pos.getIndex();\n        final char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == '\\'') {\n            this.next(pos);\n            return (appendTo == null) ? null : appendTo.append('\\'');\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); ++i) {\n            if (escapingOn && pattern.substring(i).startsWith(\"''\")) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append('\\'');\n                pos.setIndex(i + \"''\".length());\n                lastHold = pos.getIndex();\n            }\n            else {\n                switch (c[pos.getIndex()]) {\n                    case '\\'': {\n                        this.next(pos);\n                        return (appendTo == null) ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    }\n                    default: {\n                        this.next(pos);\n                        break;\n                    }\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n    }\n    \n    private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn) {\n        this.appendQuotedString(pattern, pos, null, escapingOn);\n    }\n    \n    private boolean containsElements(final Collection<?> coll) {\n        if (coll == null || coll.isEmpty()) {\n            return false;\n        }\n        for (final Object name : coll) {\n            if (name != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
        "token_number_zeroshot": 2316,
        "token_number_fewshot": 2714,
        "token_number_cot": 2428
    },
    {
        "project_name": "commons-lang",
        "class": "DurationFormatUtils",
        "source_code": "package org.apache.commons.lang3.time;\n\nimport org.apache.commons.lang3.*;\nimport java.util.*;\n\npublic class DurationFormatUtils\n{\n    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\";\n    static final Object y;\n    static final Object M;\n    static final Object d;\n    static final Object H;\n    static final Object m;\n    static final Object s;\n    static final Object S;\n    \n    public static String formatDurationHMS(final long durationMillis) {\n        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n    }\n    \n    public static String formatDurationISO(final long durationMillis) {\n        return formatDuration(durationMillis, \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\", false);\n    }\n    \n    public static String formatDuration(final long durationMillis, final String format) {\n        return formatDuration(durationMillis, format, true);\n    }\n    \n    public static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros) {\n        final Token[] tokens = lexx(format);\n        long days = 0L;\n        long hours = 0L;\n        long minutes = 0L;\n        long seconds = 0L;\n        long milliseconds = durationMillis;\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.d)) {\n            days = milliseconds / 86400000L;\n            milliseconds -= days * 86400000L;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.H)) {\n            hours = milliseconds / 3600000L;\n            milliseconds -= hours * 3600000L;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.m)) {\n            minutes = milliseconds / 60000L;\n            milliseconds -= minutes * 60000L;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.s)) {\n            seconds = milliseconds / 1000L;\n            milliseconds -= seconds * 1000L;\n        }\n        return format(tokens, 0L, 0L, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n    \n    public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {\n        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n        if (suppressLeadingZeroElements) {\n            duration = \" \" + duration;\n            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = (duration = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\"));\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n                    }\n                }\n            }\n            if (duration.length() != 0) {\n                duration = duration.substring(1);\n            }\n        }\n        if (suppressTrailingZeroElements) {\n            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n                    }\n                }\n            }\n        }\n        duration = \" \" + duration;\n        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n        return duration.trim();\n    }\n    \n    public static String formatPeriodISO(final long startMillis, final long endMillis) {\n        return formatPeriod(startMillis, endMillis, \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\", false, TimeZone.getDefault());\n    }\n    \n    public static String formatPeriod(final long startMillis, final long endMillis, final String format) {\n        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n    }\n    \n    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {\n        final Token[] tokens = lexx(format);\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n        int milliseconds = end.get(14) - start.get(14);\n        int seconds = end.get(13) - start.get(13);\n        int minutes = end.get(12) - start.get(12);\n        int hours = end.get(11) - start.get(11);\n        int days = end.get(5) - start.get(5);\n        int months = end.get(2) - start.get(2);\n        int years = end.get(1) - start.get(1);\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            --seconds;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            --minutes;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            --hours;\n        }\n        while (hours < 0) {\n            hours += 24;\n            --days;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(5);\n                --months;\n                start.add(2, 1);\n            }\n            while (months < 0) {\n                months += 12;\n                --years;\n            }\n            if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        }\n        else {\n            if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.y)) {\n                int target = end.get(1);\n                if (months < 0) {\n                    --target;\n                }\n                while (start.get(1) != target) {\n                    days += start.getActualMaximum(6) - start.get(6);\n                    if (start instanceof GregorianCalendar && start.get(2) == 1 && start.get(5) == 29) {\n                        ++days;\n                    }\n                    start.add(1, 1);\n                    days += start.get(6);\n                }\n                years = 0;\n            }\n            while (start.get(2) != end.get(2)) {\n                days += start.getActualMaximum(5);\n                start.add(2, 1);\n            }\n            months = 0;\n            while (days < 0) {\n                days += start.getActualMaximum(5);\n                --months;\n                start.add(2, 1);\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n    \n    static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes, final long seconds, final long milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        for (final Token token : tokens) {\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            }\n            else if (value == DurationFormatUtils.y) {\n                buffer.append(paddedValue(years, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.M) {\n                buffer.append(paddedValue(months, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.d) {\n                buffer.append(paddedValue(days, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.H) {\n                buffer.append(paddedValue(hours, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.m) {\n                buffer.append(paddedValue(minutes, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.s) {\n                buffer.append(paddedValue(seconds, padWithZeros, count));\n                lastOutputSeconds = true;\n            }\n            else if (value == DurationFormatUtils.S) {\n                if (lastOutputSeconds) {\n                    final int width = padWithZeros ? Math.max(3, count) : 3;\n                    buffer.append(paddedValue(milliseconds, true, width));\n                }\n                else {\n                    buffer.append(paddedValue(milliseconds, padWithZeros, count));\n                }\n                lastOutputSeconds = false;\n            }\n        }\n        return buffer.toString();\n    }\n    \n    private static String paddedValue(final long value, final boolean padWithZeros, final int count) {\n        final String longString = Long.toString(value);\n        return padWithZeros ? StringUtils.leftPad(longString, count, '0') : longString;\n    }\n    \n    static Token[] lexx(final String format) {\n        final ArrayList<Token> list = new ArrayList<Token>(format.length());\n        boolean inLiteral = false;\n        StringBuilder buffer = null;\n        Token previous = null;\n        for (int i = 0; i < format.length(); ++i) {\n            final char ch = format.charAt(i);\n            if (inLiteral && ch != '\\'') {\n                buffer.append(ch);\n            }\n            else {\n                Object value = null;\n                switch (ch) {\n                    case '\\'': {\n                        if (inLiteral) {\n                            buffer = null;\n                            inLiteral = false;\n                            break;\n                        }\n                        buffer = new StringBuilder();\n                        list.add(new Token(buffer));\n                        inLiteral = true;\n                        break;\n                    }\n                    case 'y': {\n                        value = DurationFormatUtils.y;\n                        break;\n                    }\n                    case 'M': {\n                        value = DurationFormatUtils.M;\n                        break;\n                    }\n                    case 'd': {\n                        value = DurationFormatUtils.d;\n                        break;\n                    }\n                    case 'H': {\n                        value = DurationFormatUtils.H;\n                        break;\n                    }\n                    case 'm': {\n                        value = DurationFormatUtils.m;\n                        break;\n                    }\n                    case 's': {\n                        value = DurationFormatUtils.s;\n                        break;\n                    }\n                    case 'S': {\n                        value = DurationFormatUtils.S;\n                        break;\n                    }\n                    default: {\n                        if (buffer == null) {\n                            buffer = new StringBuilder();\n                            list.add(new Token(buffer));\n                        }\n                        buffer.append(ch);\n                        break;\n                    }\n                }\n                if (value != null) {\n                    if (previous != null && previous.getValue() == value) {\n                        previous.increment();\n                    }\n                    else {\n                        final Token token = new Token(value);\n                        list.add(token);\n                        previous = token;\n                    }\n                    buffer = null;\n                }\n            }\n        }\n        if (inLiteral) {\n            throw new IllegalArgumentException(\"Unmatched quote in format: \" + format);\n        }\n        return list.toArray(new Token[list.size()]);\n    }\n    \n    static {\n        y = \"y\";\n        M = \"M\";\n        d = \"d\";\n        H = \"H\";\n        m = \"m\";\n        s = \"s\";\n        S = \"S\";\n    }\n    \n    static class Token\n    {\n        private final Object value;\n        private int count;\n        \n        static boolean containsTokenWithValue(final Token[] tokens, final Object value) {\n            for (int sz = tokens.length, i = 0; i < sz; ++i) {\n                if (tokens[i].getValue() == value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        Token(final Object value) {\n            this.value = value;\n            this.count = 1;\n        }\n        \n        Token(final Object value, final int count) {\n            this.value = value;\n            this.count = count;\n        }\n        \n        void increment() {\n            ++this.count;\n        }\n        \n        int getCount() {\n            return this.count;\n        }\n        \n        Object getValue() {\n            return this.value;\n        }\n        \n        @Override\n        public boolean equals(final Object obj2) {\n            if (!(obj2 instanceof Token)) {\n                return false;\n            }\n            final Token tok2 = (Token)obj2;\n            if (this.value.getClass() != tok2.value.getClass()) {\n                return false;\n            }\n            if (this.count != tok2.count) {\n                return false;\n            }\n            if (this.value instanceof StringBuilder) {\n                return this.value.toString().equals(tok2.value.toString());\n            }\n            if (this.value instanceof Number) {\n                return this.value.equals(tok2.value);\n            }\n            return this.value == tok2.value;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.value.hashCode();\n        }\n        \n        @Override\n        public String toString() {\n            return StringUtils.repeat(this.value.toString(), this.count);\n        }\n    }\n}\n",
        "token_number_zeroshot": 3040,
        "token_number_fewshot": 3438,
        "token_number_cot": 3152
    },
    {
        "project_name": "89_jiggler",
        "class": "Shift",
        "source_code": "package jigl.image.ops;\n\nimport jigl.image.types.*;\nimport jigl.image.*;\nimport jigl.image.exceptions.*;\n\npublic class Shift extends SimpleOperator\n{\n    public static final int NOWRAP = 0;\n    public static final int WRAP = 1;\n    private int xoffset;\n    private int yoffset;\n    private boolean wrap;\n    \n    public Shift(final int x, final int y, final int wrap) {\n        this.xoffset = 0;\n        this.yoffset = 0;\n        this.wrap = false;\n        this.xoffset = x;\n        this.yoffset = y;\n        if (wrap == 1) {\n            this.wrap = true;\n        }\n    }\n    \n    @Override\n    protected GrayImage apply(final GrayImage image) {\n        final int X = image.X();\n        final int Y = image.Y();\n        final GrayImage temp = new GrayImage(X, Y);\n        if (this.wrap) {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (this.xoffset > 0 && this.yoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else if (this.xoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (Y + this.yoffset + y) % Y, image.get(x, y));\n                    }\n                    else if (this.yoffset > 0) {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset + Y) % Y, image.get(x, y));\n                    }\n                }\n            }\n        }\n        else {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (x + this.xoffset >= 0 && x + this.xoffset < X && y + this.yoffset >= 0 && y + this.yoffset < Y) {\n                        temp.set(x, y, image.get(x + this.xoffset, y + this.yoffset));\n                    }\n                    else {\n                        temp.set(x, y, Integer.valueOf(0));\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n    \n    @Override\n    protected RealGrayImage apply(final RealGrayImage image) {\n        final int X = image.X();\n        final int Y = image.Y();\n        final RealGrayImage temp = new RealGrayImage(X, Y);\n        if (this.wrap) {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (this.xoffset > 0 && this.yoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else if (this.xoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (Y + this.yoffset + y) % Y, image.get(x, y));\n                    }\n                    else if (this.yoffset > 0) {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset + Y) % Y, image.get(x, y));\n                    }\n                }\n            }\n        }\n        else {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (x + this.xoffset >= 0 && x + this.xoffset < X && y + this.yoffset >= 0 && y + this.yoffset < Y) {\n                        temp.set(x, y, image.get(x + this.xoffset, y + this.yoffset));\n                    }\n                    else {\n                        temp.set(x, y, Float.valueOf(0.0f));\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n    \n    @Override\n    protected ColorImage apply(final ColorImage image) {\n        final ColorImage temp = new ColorImage(image.X(), image.Y());\n        temp.setPlane(0, this.apply(image.plane(0)));\n        temp.setPlane(1, this.apply(image.plane(1)));\n        temp.setPlane(2, this.apply(image.plane(2)));\n        return temp;\n    }\n    \n    @Override\n    protected RealColorImage apply(final RealColorImage image) {\n        final RealColorImage temp = new RealColorImage(image.X(), image.Y());\n        temp.setPlane(0, this.apply(image.plane(0)));\n        temp.setPlane(1, this.apply(image.plane(1)));\n        temp.setPlane(2, this.apply(image.plane(2)));\n        return temp;\n    }\n}\n",
        "token_number_zeroshot": 1141,
        "token_number_fewshot": 1539,
        "token_number_cot": 1251
    },
    {
        "project_name": "89_jiggler",
        "class": "Clip",
        "source_code": "package jigl.image.ops.levelOps;\n\nimport jigl.image.ops.*;\nimport jigl.image.*;\nimport jigl.image.types.*;\nimport jigl.image.io.*;\n\npublic class Clip extends SimpleOperator\n{\n    private int int_min;\n    private int int_max;\n    private float float_min;\n    private float float_max;\n    \n    public Clip(final int min, final int max) {\n        this.int_min = min;\n        this.int_max = max;\n    }\n    \n    public Clip(final float min, final float max) {\n        this.float_min = min;\n        this.float_max = max;\n    }\n    \n    @Override\n    protected Image apply(final GrayImage image) {\n        return this.apply(image, new ROI(0, 0, image.X() - 1, image.Y() - 1));\n    }\n    \n    @Override\n    protected Image apply(final GrayImage image, final ROI roi) {\n        if (this.int_min == 0 && this.int_max == 0) {\n            this.int_min = (int)this.float_min;\n            this.int_max = (int)this.float_max;\n        }\n        int value = 0;\n        for (int y = roi.uy(); y <= roi.ly(); ++y) {\n            for (int x = roi.ux(); x <= roi.lx(); ++x) {\n                value = image.get(x, y);\n                value = ((value > this.int_max) ? this.int_max : value);\n                value = ((value < this.int_min) ? this.int_min : value);\n                image.set(x, y, Integer.valueOf(value));\n            }\n        }\n        return image;\n    }\n    \n    @Override\n    protected Image apply(final RealGrayImage image) {\n        return this.apply(image, new ROI(0, 0, image.X() - 1, image.Y() - 1));\n    }\n    \n    @Override\n    protected Image apply(final RealGrayImage image, final ROI roi) {\n        if (this.float_min == 0.0f && this.float_max == 0.0f) {\n            this.float_min = this.int_min;\n            this.float_max = this.int_max;\n        }\n        float value = 0.0f;\n        for (int y = roi.uy(); y <= roi.ly(); ++y) {\n            for (int x = roi.ux(); x <= roi.lx(); ++x) {\n                value = image.get(x, y);\n                value = ((value > this.float_max) ? this.float_max : value);\n                value = ((value < this.float_min) ? this.float_min : value);\n                image.set(x, y, Float.valueOf(value));\n            }\n        }\n        return image;\n    }\n    \n    @Override\n    protected Image apply(final ColorImage image) {\n        image.setPlane(0, (GrayImage)this.apply(image.plane(0), new ROI(0, 0, image.X() - 1, image.Y() - 1)));\n        image.setPlane(1, (GrayImage)this.apply(image.plane(1), new ROI(0, 0, image.X() - 1, image.Y() - 1)));\n        image.setPlane(2, (GrayImage)this.apply(image.plane(2), new ROI(0, 0, image.X() - 1, image.Y() - 1)));\n        return image;\n    }\n    \n    @Override\n    protected Image apply(final ColorImage image, final ROI roi) {\n        image.setPlane(0, (GrayImage)this.apply(image.plane(0), roi));\n        image.setPlane(1, (GrayImage)this.apply(image.plane(1), roi));\n        image.setPlane(2, (GrayImage)this.apply(image.plane(2), roi));\n        return image;\n    }\n    \n    @Override\n    protected Image apply(final RealColorImage image) {\n        image.setPlane(0, (RealGrayImage)this.apply(image.plane(0), new ROI(0, 0, image.X() - 1, image.Y() - 1)));\n        image.setPlane(1, (RealGrayImage)this.apply(image.plane(1), new ROI(0, 0, image.X() - 1, image.Y() - 1)));\n        image.setPlane(2, (RealGrayImage)this.apply(image.plane(2), new ROI(0, 0, image.X() - 1, image.Y() - 1)));\n        return image;\n    }\n    \n    @Override\n    protected Image apply(final RealColorImage image, final ROI roi) {\n        image.setPlane(0, (RealGrayImage)this.apply(image.plane(0), roi));\n        image.setPlane(1, (RealGrayImage)this.apply(image.plane(1), roi));\n        image.setPlane(2, (RealGrayImage)this.apply(image.plane(2), roi));\n        return image;\n    }\n    \n    public static void main(final String[] argv) {\n        try {\n            Image image = null;\n            final String inputfile = argv[2];\n            Image image2 = null;\n            final ImageInputStream is = new ImageInputStream(inputfile);\n            image = is.read();\n            is.close();\n            final Float f_val1 = Float.valueOf(argv[0]);\n            final Float f_val2 = Float.valueOf(argv[1]);\n            final float val1 = f_val1;\n            final float val2 = f_val2;\n            final Clip clip = new Clip(val1, val2);\n            image2 = clip.apply(image);\n            final ImageOutputStream os = new ImageOutputStream(argv[3]);\n            os.write(image2);\n            os.close();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "token_number_zeroshot": 1219,
        "token_number_fewshot": 1617,
        "token_number_cot": 1329
    },
    {
        "project_name": "89_jiggler",
        "class": "ConnectedComponents",
        "source_code": "package jigl.image.ops;\n\nimport jigl.image.types.*;\nimport jigl.image.*;\nimport jigl.image.exceptions.*;\n\npublic class ConnectedComponents extends SimpleOperator\n{\n    public static final int FOUR_CONNECTED = 0;\n    public static final int EIGHT_CONNECTED = 1;\n    private int neighbors;\n    private int background;\n    \n    public ConnectedComponents(final int numberNeighbors, final int backgroundColor) throws InvalidArgumentException {\n        this.neighbors = 0;\n        this.background = 0;\n        this.neighbors = numberNeighbors;\n        this.background = backgroundColor;\n        if ((this.neighbors != 0 && this.neighbors != 1) || (this.background != 1 && this.background != 0)) {\n            throw new InvalidArgumentException();\n        }\n    }\n    \n    @Override\n    protected GrayImage apply(final BinaryImage image) {\n        final int[] equiv = new int[100000];\n        int current = 1;\n        int min = 1000;\n        final int[] friends = new int[4];\n        final GrayImage gimage = new GrayImage(image.X(), image.Y());\n        for (int x = 0; x < 1000; ++x) {\n            equiv[x] = -1;\n        }\n        for (int x = 0; x < image.X(); ++x) {\n            for (int y = 0; y < image.Y(); ++y) {\n                if (image.get(x, y) == this.background) {\n                    gimage.set(x, y, Integer.valueOf(0));\n                }\n                else if (x == 0 && y == 0) {\n                    gimage.set(0, 0, Integer.valueOf(current));\n                    ++current;\n                }\n                else {\n                    if (x - 1 == -1) {\n                        friends[1] = (friends[0] = -1);\n                        friends[2] = gimage.get(x, y - 1);\n                        if (x + 1 >= image.X()) {\n                            friends[3] = -1;\n                        }\n                        else {\n                            friends[3] = gimage.get(x + 1, y - 1);\n                        }\n                    }\n                    else if (y - 1 == -1) {\n                        friends[0] = gimage.get(x - 1, y);\n                        friends[1] = -1;\n                        friends[3] = (friends[2] = -1);\n                    }\n                    else {\n                        friends[0] = gimage.get(x - 1, y);\n                        friends[1] = gimage.get(x - 1, y - 1);\n                        friends[2] = gimage.get(x, y - 1);\n                        if (x + 1 >= image.X()) {\n                            friends[3] = -1;\n                        }\n                        else {\n                            friends[3] = gimage.get(x + 1, y - 1);\n                        }\n                    }\n                    if (this.neighbors == 0) {\n                        if (friends[0] <= 0 && friends[2] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(current));\n                            ++current;\n                        }\n                        else if (friends[0] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(friends[2]));\n                        }\n                        else if (friends[2] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(friends[0]));\n                        }\n                        else if (friends[0] < friends[2]) {\n                            gimage.set(x, y, Integer.valueOf(friends[0]));\n                            equiv[friends[2]] = friends[0];\n                        }\n                        else {\n                            gimage.set(x, y, Integer.valueOf(friends[2]));\n                            if (friends[0] != friends[2]) {\n                                equiv[friends[0]] = friends[2];\n                            }\n                        }\n                    }\n                    else if (this.neighbors == 1) {\n                        if (friends[0] <= 0 && friends[1] <= 0 && friends[2] <= 0 && friends[3] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(current));\n                            ++current;\n                        }\n                        else {\n                            int minVal = 1000;\n                            for (int z = 0; z < 4; ++z) {\n                                if (friends[z] < minVal && friends[z] != 0 && friends[z] != -1) {\n                                    min = z;\n                                    minVal = friends[z];\n                                }\n                            }\n                            gimage.set(x, y, Integer.valueOf(friends[min]));\n                            for (int z = 0; z < 4; ++z) {\n                                if (friends[z] != friends[min] && friends[z] != 0 && friends[z] != -1) {\n                                    equiv[friends[z]] = friends[min];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int curVal = 0;\n        for (int x2 = 0; x2 < gimage.X(); ++x2) {\n            for (int y2 = 0; y2 < gimage.Y(); ++y2) {\n                for (curVal = gimage.get(x2, y2); equiv[curVal] != -1; curVal = equiv[curVal]) {}\n                gimage.set(x2, y2, Integer.valueOf(curVal));\n            }\n        }\n        return gimage;\n    }\n}\n",
        "token_number_zeroshot": 1160,
        "token_number_fewshot": 1558,
        "token_number_cot": 1271
    },
    {
        "project_name": "86_at-robots2-j",
        "class": "RobotRenderer",
        "source_code": "package net.virtualinfinity.atrobots.gui.renderers;\n\nimport java.util.*;\nimport java.awt.*;\nimport java.awt.geom.*;\nimport net.virtualinfinity.atrobots.measures.*;\nimport net.virtualinfinity.atrobots.snapshots.*;\n\npublic class RobotRenderer implements SnapshotRenderer<RobotSnapshot>\n{\n    private boolean showStatusBars;\n    private boolean renderDead;\n    private boolean showName;\n    private boolean fillShield;\n    private static final Color HEAT_COLOR1;\n    private static final Color HEAT_COLOR2;\n    \n    public RobotRenderer() {\n        this.showStatusBars = true;\n        this.renderDead = true;\n        this.showName = true;\n        this.fillShield = true;\n    }\n    \n    @Override\n    public void render(final Graphics2D g2d, final RobotSnapshot robotSnapshot, final Set<Integer> selectedRobotIds) {\n        if (!this.isRenderDead() && robotSnapshot.isDead()) {\n            return;\n        }\n        this.paintBody(g2d, robotSnapshot);\n        if (!robotSnapshot.isDead()) {\n            this.paintShield(g2d, robotSnapshot);\n            this.paintTurret(g2d, robotSnapshot);\n            if (this.isShowStatusBars()) {\n                this.paintArmor(g2d, robotSnapshot);\n                this.paintHeat(g2d, robotSnapshot);\n            }\n            if (this.isShowName()) {\n                this.paintName(g2d, robotSnapshot);\n            }\n        }\n        if (selectedRobotIds.contains(robotSnapshot.getId())) {\n            this.paintSelection(g2d, robotSnapshot);\n        }\n    }\n    \n    public boolean isRenderDead() {\n        return this.renderDead;\n    }\n    \n    public void setRenderDead(final boolean renderDead) {\n        this.renderDead = renderDead;\n    }\n    \n    public boolean isShowStatusBars() {\n        return this.showStatusBars;\n    }\n    \n    public void setShowStatusBars(final boolean showStatusBars) {\n        this.showStatusBars = showStatusBars;\n    }\n    \n    public boolean isShowName() {\n        return this.showName;\n    }\n    \n    public void setShowName(final boolean showName) {\n        this.showName = showName;\n    }\n    \n    public boolean isFillShield() {\n        return this.fillShield;\n    }\n    \n    public void setFillShield(final boolean fillShield) {\n        this.fillShield = fillShield;\n    }\n    \n    private void paintSelection(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(new Color(1.0f, 1.0f, 0.0f, 0.25f));\n        final Ellipse2D.Double s = new Ellipse2D.Double();\n        s.setFrameFromCenter(robotSnapshot.getX(), robotSnapshot.getY(), robotSnapshot.getX() + 30.0, robotSnapshot.getY() + 30.0);\n        g2d.fill(s);\n    }\n    \n    private void paintShield(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        if (robotSnapshot.isActiveShield()) {\n            final Ellipse2D.Double s = new Ellipse2D.Double();\n            s.setFrameFromCenter(robotSnapshot.getX(), robotSnapshot.getY(), robotSnapshot.getX() + 15.0, robotSnapshot.getY() + 15.0);\n            if (this.isFillShield()) {\n                g2d.setPaint(new RadialGradientPaint(robotSnapshot.getPositionVector().toPoint2D(), 15.0f, new float[] { 0.0f, 0.75f, 1.0f }, new Color[] { new Color(0.5f, 0.5f, 0.0f, 0.8f), new Color(0.0f, 0.0f, 0.5f, 0.1f), Color.white }));\n                g2d.fill(s);\n                g2d.fill(s);\n            }\n            else {\n                g2d.setPaint(new Color(0.8f, 0.6f, 1.0f));\n                g2d.draw(s);\n            }\n        }\n    }\n    \n    private void paintName(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(Color.yellow);\n        g2d.drawString(robotSnapshot.getName(), (float)(robotSnapshot.getX() - g2d.getFontMetrics().getStringBounds(robotSnapshot.getName(), g2d).getWidth() / 2.0), (float)(robotSnapshot.getY() - 10.0));\n    }\n    \n    private void paintHeat(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        final Rectangle2D.Double rect = new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 35.0, 100.0, 10.0);\n        g2d.setPaint(new GradientPaint((float)rect.getMinX(), (float)rect.getMinY(), RobotRenderer.HEAT_COLOR1, (float)rect.getMaxX(), (float)rect.getMinY(), RobotRenderer.HEAT_COLOR2));\n        if (!robotSnapshot.isDead()) {\n            g2d.fill(new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 35.0, robotSnapshot.getTemperature().getLogScale() * 0.2, 10.0));\n        }\n        g2d.draw(rect);\n    }\n    \n    private void paintArmor(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(new Color(0.0f, 0.0f, 1.0f, 0.6f));\n        g2d.fill(new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 20.0, robotSnapshot.getArmor(), 10.0));\n        g2d.setPaint(new Color(0.0f, 1.0f, 0.0f, 0.6f));\n        g2d.draw(new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 20.0, 100.0, 10.0));\n    }\n    \n    private void paintTurret(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(Color.white);\n        g2d.draw(new Line2D.Double(robotSnapshot.getX(), robotSnapshot.getY(), robotSnapshot.getX() + robotSnapshot.getTurretHeading().cosine() * 5.0, robotSnapshot.getY() + robotSnapshot.getTurretHeading().sine() * 5.0));\n    }\n    \n    private void paintBody(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        final Stroke stroke = g2d.getStroke();\n        if (robotSnapshot.isDead()) {\n            final BasicStroke basicStroke = new BasicStroke(1.0f, 1, 0, 10.0f, new float[] { 5.0f, 5.0f }, 0.0f);\n            g2d.setStroke(basicStroke);\n            g2d.setPaint(Color.orange.darker().darker());\n        }\n        else {\n            g2d.setPaint(Color.red);\n        }\n        final GeneralPath path = new GeneralPath();\n        path.moveTo(robotSnapshot.getX() + robotSnapshot.getHeading().cosine() * 15.0, robotSnapshot.getY() + robotSnapshot.getHeading().sine() * 15.0);\n        final AbsoluteAngle cc = robotSnapshot.getHeading().counterClockwise(RelativeAngle.fromBygrees(160));\n        final AbsoluteAngle c = robotSnapshot.getHeading().clockwise(RelativeAngle.fromBygrees(160));\n        path.lineTo(robotSnapshot.getX() + cc.cosine() * 9.0, robotSnapshot.getY() + cc.sine() * 9.0);\n        path.lineTo(robotSnapshot.getX(), robotSnapshot.getY());\n        path.lineTo(robotSnapshot.getX() + c.cosine() * 9.0, robotSnapshot.getY() + c.sine() * 9.0);\n        path.closePath();\n        if (robotSnapshot.isDead()) {\n            g2d.draw(path);\n        }\n        else {\n            g2d.fill(path);\n        }\n        g2d.setStroke(stroke);\n    }\n    \n    static {\n        HEAT_COLOR1 = new Color(1.0f, 0.0f, 0.0f, 0.1f);\n        HEAT_COLOR2 = Color.yellow;\n    }\n}\n",
        "token_number_zeroshot": 1809,
        "token_number_fewshot": 2207,
        "token_number_cot": 1920
    },
    {
        "project_name": "92_jcvi-javacommon",
        "class": "Distance",
        "source_code": "package org.jcvi.jillion.assembly.ca.frg;\n\npublic final class Distance\n{\n    private static final float SIX = 6.0f;\n    private static final int CA_GATEKEEPER_STDDEV_LIMIT = 3;\n    private static final float MAX_ROUNDING_ERROR = 1.015f;\n    private final int min;\n    private final int max;\n    private final float mean;\n    private final float stdDev;\n    \n    public static Distance buildDistance(final int min, final int max, final float mean, final float stdDev) {\n        return new Distance(min, max, mean, stdDev);\n    }\n    \n    public static Distance buildDistance(final float mean, final float stdDev) {\n        final float delta = calculateDelta(stdDev);\n        final int plusDelta = (int)(mean + delta);\n        final int minusDelta = (int)(mean - delta);\n        return new Distance(Math.min(plusDelta, minusDelta), Math.max(plusDelta, minusDelta), mean, stdDev);\n    }\n    \n    private static float calculateDelta(final float stdDev) {\n        return 3.0f * stdDev;\n    }\n    \n    public static Distance buildDistance(final int min, final int max) {\n        final float mean = computeMean(min, max);\n        final float stdDev = computeStandardDeviation(min, max);\n        return new Distance(min, max, mean, stdDev);\n    }\n    \n    private static float computeStandardDeviation(final int min, final int max) {\n        return (max - min) / 6.0f;\n    }\n    \n    private static float computeMean(final int min, final int max) {\n        return min / 2.0f + max / 2.0f;\n    }\n    \n    public static Distance transformIntoCeleraAssemblerDistance(final Distance distance) {\n        final float mean = distance.getMean();\n        final float stdDev = distance.getStdDev();\n        if (mean < calculateDelta(stdDev)) {\n            final float correctedStdDev = (mean - 1.015f) / 3.0f;\n            return new Distance(distance.getMin(), distance.getMax(), mean, correctedStdDev);\n        }\n        return distance;\n    }\n    \n    private Distance(final int min, final int max, final float mean, final float stdDev) {\n        this.min = min;\n        this.max = max;\n        this.mean = mean;\n        this.stdDev = stdDev;\n    }\n    \n    public float getMean() {\n        return this.mean;\n    }\n    \n    public float getStdDev() {\n        return this.stdDev;\n    }\n    \n    public int getMin() {\n        return this.min;\n    }\n    \n    public int getMax() {\n        return this.max;\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + this.max;\n        result = 31 * result + Float.floatToIntBits(this.mean);\n        result = 31 * result + this.min;\n        result = 31 * result + Float.floatToIntBits(this.stdDev);\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof Distance)) {\n            return false;\n        }\n        final Distance other = (Distance)obj;\n        return this.max == other.max && Float.floatToIntBits(this.mean) == Float.floatToIntBits(other.mean) && this.min == other.min && Float.floatToIntBits(this.stdDev) == Float.floatToIntBits(other.stdDev);\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"%.3f, std: %.3f\", this.mean, this.stdDev);\n    }\n}\n",
        "token_number_zeroshot": 833,
        "token_number_fewshot": 1231,
        "token_number_cot": 943
    },
    {
        "project_name": "92_jcvi-javacommon",
        "class": "DefaultPhdReadTag",
        "source_code": "package org.jcvi.jillion.assembly.consed.phd;\n\nimport org.jcvi.jillion.core.*;\nimport java.util.*;\n\nclass DefaultPhdReadTag implements PhdReadTag\n{\n    private final String type;\n    private final String source;\n    private final Range ungappedRange;\n    private final Date date;\n    private final String comment;\n    private final String freeFormData;\n    \n    public DefaultPhdReadTag(final String type, final String source, final Range ungappedRange, final Date date, final String comment, final String freeFormData) {\n        this.type = type;\n        this.source = source;\n        this.ungappedRange = ungappedRange;\n        this.date = date;\n        this.comment = comment;\n        this.freeFormData = freeFormData;\n    }\n    \n    @Override\n    public final String getType() {\n        return this.type;\n    }\n    \n    @Override\n    public final String getSource() {\n        return this.source;\n    }\n    \n    @Override\n    public final Range getUngappedRange() {\n        return this.ungappedRange;\n    }\n    \n    @Override\n    public final Date getDate() {\n        return this.date;\n    }\n    \n    @Override\n    public final String getComment() {\n        return this.comment;\n    }\n    \n    @Override\n    public final String getFreeFormData() {\n        return this.freeFormData;\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + ((this.comment == null) ? 0 : this.comment.hashCode());\n        result = 31 * result + ((this.date == null) ? 0 : this.date.hashCode());\n        result = 31 * result + ((this.freeFormData == null) ? 0 : this.freeFormData.hashCode());\n        result = 31 * result + ((this.source == null) ? 0 : this.source.hashCode());\n        result = 31 * result + ((this.type == null) ? 0 : this.type.hashCode());\n        result = 31 * result + ((this.ungappedRange == null) ? 0 : this.ungappedRange.hashCode());\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof DefaultPhdReadTag)) {\n            return false;\n        }\n        final DefaultPhdReadTag other = (DefaultPhdReadTag)obj;\n        if (this.comment == null) {\n            if (other.comment != null) {\n                return false;\n            }\n        }\n        else if (!this.comment.equals(other.comment)) {\n            return false;\n        }\n        if (this.date == null) {\n            if (other.date != null) {\n                return false;\n            }\n        }\n        else if (!this.date.equals(other.date)) {\n            return false;\n        }\n        if (this.freeFormData == null) {\n            if (other.freeFormData != null) {\n                return false;\n            }\n        }\n        else if (!this.freeFormData.equals(other.freeFormData)) {\n            return false;\n        }\n        if (this.source == null) {\n            if (other.source != null) {\n                return false;\n            }\n        }\n        else if (!this.source.equals(other.source)) {\n            return false;\n        }\n        if (this.type == null) {\n            if (other.type != null) {\n                return false;\n            }\n        }\n        else if (!this.type.equals(other.type)) {\n            return false;\n        }\n        if (this.ungappedRange == null) {\n            if (other.ungappedRange != null) {\n                return false;\n            }\n        }\n        else if (!this.ungappedRange.equals(other.ungappedRange)) {\n            return false;\n        }\n        return true;\n    }\n}\n",
        "token_number_zeroshot": 850,
        "token_number_fewshot": 1248,
        "token_number_cot": 964
    },
    {
        "project_name": "63_objectexplorer",
        "class": "AttributeModelComparator",
        "source_code": "package de.paragon.explorer.model;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class AttributeModelComparator implements Comparator<AttributeModel>, Serializable\n{\n    private static final String A_AS_STRING = \"a\";\n    private static final long serialVersionUID = -8846334934584145381L;\n    \n    @Override\n    public int compare(final AttributeModel o1, final AttributeModel o2) {\n        int value = -1;\n        if (o1 != null && o2 != null) {\n            value = o1.getName().compareToIgnoreCase(o2.getName());\n            if (value < 0 && o1.getName().compareToIgnoreCase(\"a\") < 0 && o2.getName().compareToIgnoreCase(\"a\") >= 0) {\n                return 1;\n            }\n            if (value > 0 && o2.getName().compareToIgnoreCase(\"a\") < 0 && o1.getName().compareToIgnoreCase(\"a\") >= 0) {\n                return -1;\n            }\n        }\n        return value;\n    }\n}\n",
        "token_number_zeroshot": 241,
        "token_number_fewshot": 639,
        "token_number_cot": 353
    },
    {
        "project_name": "41_follow",
        "class": "TabbedPane",
        "source_code": "package ghm.follow.gui;\n\nimport javax.swing.*;\nimport ghm.follow.config.*;\nimport java.awt.*;\nimport java.io.*;\n\npublic class TabbedPane extends JTabbedPane\n{\n    private FollowAppAttributes attributes;\n    \n    public TabbedPane(final FollowAppAttributes attributes) {\n        super(attributes.getTabPlacement());\n        this.attributes = null;\n        this.attributes = attributes;\n    }\n    \n    @Override\n    public Component findComponentAt(final int x, final int y) {\n        if (!this.contains(x, y)) {\n            return null;\n        }\n        for (int ncomponents = this.getComponentCount(), i = 0; i < ncomponents; ++i) {\n            Component comp = this.getComponentAt(i);\n            if (comp != null) {\n                if (comp instanceof Container) {\n                    if (comp.isVisible()) {\n                        comp = ((Container)comp).findComponentAt(x - comp.getX(), y - comp.getY());\n                    }\n                }\n                else {\n                    comp = comp.getComponentAt(x - comp.getX(), y - comp.getY());\n                }\n                if (comp != null && comp.isVisible()) {\n                    return comp;\n                }\n            }\n        }\n        return this;\n    }\n    \n    @Override\n    public void setSelectedIndex(final int index) {\n        super.setSelectedIndex(index);\n        this.handleSelectedFile();\n    }\n    \n    public void setSelectedComponent(final FileFollowingPane pane) {\n        super.setSelectedComponent(pane);\n        this.handleSelectedFile();\n    }\n    \n    @Override\n    public void removeTabAt(final int index) {\n        super.removeTabAt(index);\n        this.handleSelectedFile();\n    }\n    \n    private void handleSelectedFile() {\n        final FileFollowingPane pane = (FileFollowingPane)this.getSelectedComponent();\n        if (pane != null) {\n            final File parent = pane.getFollowedFile().getParentFile();\n            this.attributes.setLastFileChooserDirectory(parent);\n        }\n    }\n}\n",
        "token_number_zeroshot": 420,
        "token_number_fewshot": 818,
        "token_number_cot": 531
    },
    {
        "project_name": "41_follow",
        "class": "SearchableTextPane",
        "source_code": "package ghm.follow.search;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport javax.swing.plaf.*;\nimport java.util.logging.*;\nimport java.util.*;\nimport javax.swing.text.*;\n\npublic class SearchableTextPane extends JTextArea\n{\n    private Logger log;\n    private int lastSearchPos;\n    private String lastSearchTerm;\n    private final DefaultHighlighter.DefaultHighlightPainter wordPainter;\n    \n    public SearchableTextPane(final Font font, final int tabSize) {\n        this.log = Logger.getLogger(SearchableTextPane.class.getName());\n        this.lastSearchPos = -1;\n        this.wordPainter = new DefaultHighlighter.DefaultHighlightPainter(Color.YELLOW);\n        this.setFont(font);\n        this.setTabSize(tabSize);\n    }\n    \n    @Override\n    public boolean getScrollableTracksViewportWidth() {\n        final Component parent = this.getParent();\n        final ComponentUI ui = this.getUI();\n        return parent == null || ui.getPreferredSize(this).width <= parent.getSize().width;\n    }\n    \n    public List<LineResult> highlight(final String term, final int flags) {\n        List<LineResult> lineResults = new ArrayList<LineResult>();\n        this.removeHighlights();\n        if (term != null && term.length() > 0) {\n            try {\n                final Document doc = this.getDocument();\n                final String text = doc.getText(0, doc.getLength());\n                final List<WordResult> searchResults = new SearchEngine(flags).search(term, text);\n                lineResults = this.convertWords2Lines(searchResults);\n                for (final LineResult lineResult : lineResults) {\n                    final List<WordResult> wordResults = lineResult.getWordResults();\n                    for (final WordResult wordResult : wordResults) {\n                        final int wordStart = wordResult.start;\n                        final int wordEnd = wordResult.end;\n                        this.addHighlight(wordStart, wordEnd - wordStart);\n                        Thread.yield();\n                    }\n                }\n            }\n            catch (BadLocationException e) {\n                this.log.log(Level.SEVERE, \"BadLocationException in SearchableTextPane\", e);\n                lineResults = new ArrayList<LineResult>();\n            }\n        }\n        return lineResults;\n    }\n    \n    private void addHighlight(final int start, final int length) throws BadLocationException {\n        this.getHighlighter().addHighlight(start, start + length, this.wordPainter);\n    }\n    \n    public void removeHighlights() {\n        this.getHighlighter().removeAllHighlights();\n    }\n    \n    public int search(final String term) {\n        if (term != null && term.length() > 0) {\n            if (term.equals(this.lastSearchTerm)) {\n                int pos = 0;\n                if (this.lastSearchPos != -1) {\n                    pos = this.lastSearchPos + this.lastSearchTerm.length();\n                }\n                this.lastSearchPos = this.search(this.lastSearchTerm, pos);\n            }\n            else {\n                this.lastSearchPos = this.search(term, 0);\n            }\n        }\n        if (this.lastSearchPos == -1) {\n            this.lastSearchTerm = null;\n        }\n        else {\n            this.lastSearchTerm = term;\n        }\n        return this.lastSearchPos;\n    }\n    \n    public int search(final String term, final int startPos) {\n        int pos = 0;\n        try {\n            final Document doc = this.getDocument();\n            final String text = doc.getText(0, doc.getLength());\n            pos = text.indexOf(term, startPos);\n        }\n        catch (BadLocationException e) {\n            this.log.log(Level.WARNING, \"BadLocationException in SearchableTextPane\", e);\n            pos = -1;\n        }\n        return pos;\n    }\n    \n    private List<LineResult> convertWords2Lines(final List<WordResult> words) throws BadLocationException {\n        final ArrayList<LineResult> lines = new ArrayList<LineResult>();\n        LineResult tempLine = null;\n        int lastLine = -1;\n        for (final WordResult word : words) {\n            final int line = this.getLineOfOffset(word.start);\n            if (line != lastLine) {\n                if (tempLine != null) {\n                    lines.add(tempLine);\n                }\n                final Element elem = Utilities.getParagraphElement(this, word.start);\n                final int lineStart = elem.getStartOffset();\n                final int lineEnd = elem.getEndOffset();\n                tempLine = new LineResult(line, lineStart, lineEnd);\n            }\n            this.updateWordResult(word, tempLine);\n            lastLine = line;\n            Thread.yield();\n        }\n        if (tempLine != null) {\n            lines.add(tempLine);\n        }\n        return lines;\n    }\n    \n    private void updateWordResult(final WordResult wordResult, final LineResult lineResult) throws BadLocationException {\n        lineResult.addWord(wordResult);\n        final int line = this.getLineOfOffset(wordResult.start);\n        wordResult.parent.lineNumber = line + 1;\n        final int lineOffset = this.getLineStartOffset(line);\n        wordResult.setLineOffset(lineOffset);\n    }\n}\n",
        "token_number_zeroshot": 1069,
        "token_number_fewshot": 1467,
        "token_number_cot": 1182
    },
    {
        "project_name": "87_jaw-br",
        "class": "Salvar",
        "source_code": "package jaw.entrada;\n\nimport jaw.metamodelo.*;\nimport jaw.gui.*;\nimport java.util.*;\nimport jaw.*;\nimport javax.swing.filechooser.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport java.io.*;\n\npublic class Salvar\n{\n    private boolean vela;\n    private String arquivo;\n    public String xml;\n    public List<Entidade> entidade;\n    public static final int SALVAR_XML = 10;\n    public static final int SALVAR = 20;\n    public static final int SALVAR_COMO = 30;\n    \n    public Salvar(final ProcessarEntidades form, final int tipoSalvar) {\n        this.vela = false;\n        this.arquivo = \"\";\n        this.xml = \"\";\n        this.entidade = new Vector<Entidade>();\n        try {\n            this.entidade = form.getEntidades();\n        }\n        catch (Exception ex) {\n            Main.janelaPrincipal.log(ex.toString());\n            return;\n        }\n        final JFileChooser escolhedor = new JFileChooser();\n        escolhedor.setCurrentDirectory(new File(Main.configuracao.getCaminhoDosProjetos()));\n        if (tipoSalvar == 10) {\n            escolhedor.setFileFilter(new Filtro2());\n        }\n        if (tipoSalvar == 20 || tipoSalvar == 30) {\n            escolhedor.setFileFilter(new Filtro());\n        }\n        if (tipoSalvar == 10 || tipoSalvar == 30 || (tipoSalvar == 20 && form.getNomeArquivoSalvo().equals(\"Novo Projeto\"))) {\n            escolhedor.showSaveDialog(form);\n            this.vela = true;\n        }\n        if (escolhedor.getSelectedFile() == null && form.getName().equals(\"\")) {\n            return;\n        }\n        if (this.vela) {\n            if (escolhedor.getSelectedFile() == null) {\n                return;\n            }\n            this.arquivo = escolhedor.getSelectedFile().getAbsolutePath();\n        }\n        else {\n            this.arquivo = form.getNomeArquivoSalvo();\n        }\n        if (tipoSalvar == 20 || tipoSalvar == 30) {\n            if (!this.arquivo.endsWith(\".jaw\") && this.vela) {\n                form.setNomeArquivoSalvo(this.arquivo += \".jaw\");\n                this.vela = false;\n            }\n            else {\n                this.arquivo = form.getNomeArquivoSalvo();\n            }\n            System.out.println(form.getNomeArquivoSalvo());\n            final Serializacao salvar = new Serializacao();\n            try {\n                if (salvar.salvar(this.entidade, this.arquivo)) {\n                    JOptionPane.showMessageDialog(form, \"Arquivo salvo com sucesso!\", \"Jaw - Salvar\", 1);\n                }\n            }\n            catch (Exception ex2) {\n                JOptionPane.showMessageDialog(null, \"N\\u00c3\u00a3o foi poss\\u00c3\\u00advel salvar esse arquivo\\n Verifique o formato das entidades !\", \"Salvando Arquivo\", 0);\n                Main.janelaPrincipal.log(ex2.toString());\n            }\n        }\n        if (tipoSalvar == 10) {\n            if (!this.arquivo.endsWith(\".jaw.xml\")) {\n                this.arquivo += \".jaw.xml\";\n            }\n            final SerializacaoXML serializaXML = new SerializacaoXML();\n            this.xml = serializaXML.entidades2XML(this.entidade);\n            try {\n                final FileWriter escrevedor = new FileWriter(this.arquivo);\n                escrevedor.write(this.xml);\n                escrevedor.flush();\n                escrevedor.close();\n                JOptionPane.showMessageDialog(form, \"Arquivo Exportado com sucesso!\", \"Jaw - Salvar\", 1);\n            }\n            catch (Exception e) {\n                JOptionPane.showMessageDialog(form, \"N\\u00c3\u00a3o foi poss\\u00c3\\u00advel salvar esse arquivo\\n Verifique o formato das entidades !\", \"Salvando Arquivo\", 0);\n                Main.janelaPrincipal.log(e.toString());\n            }\n        }\n    }\n    \n    private class Filtro2 extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw.xml\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"XML JAW files\";\n        }\n    }\n    \n    private class Filtro extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"JAW files\";\n        }\n    }\n}\n",
        "token_number_zeroshot": 979,
        "token_number_fewshot": 1377,
        "token_number_cot": 1090
    },
    {
        "project_name": "87_jaw-br",
        "class": "Abrir",
        "source_code": "package jaw.entrada;\n\nimport jaw.gui.*;\nimport jaw.*;\nimport javax.swing.filechooser.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport java.io.*;\n\npublic class Abrir\n{\n    public String xml;\n    public ProcessarEntidades form;\n    public static final int ABRIR_XML = 10;\n    public static final int ABRIR = 20;\n    \n    public Abrir(final ProcessarEntidades form, final String arquivo) {\n        this.xml = \"\";\n        this.form = form;\n        if (arquivo.endsWith(\".jaw.xml\")) {\n            this.abrirXML(arquivo);\n        }\n        else {\n            this.abrirSerializado(arquivo);\n        }\n    }\n    \n    public Abrir(final ProcessarEntidades form, final int tipoAbrir) {\n        this.xml = \"\";\n        this.form = form;\n        final JFileChooser escolhedor = new JFileChooser();\n        escolhedor.setCurrentDirectory(new File(Main.configuracao.getCaminhoDosProjetos()));\n        if (tipoAbrir == 10) {\n            escolhedor.setFileFilter(new Filtro2());\n        }\n        if (tipoAbrir == 20) {\n            escolhedor.setFileFilter(new Filtro());\n        }\n        escolhedor.showOpenDialog(null);\n        if (escolhedor.getSelectedFile() == null) {\n            return;\n        }\n        final String arquivo = escolhedor.getSelectedFile().getAbsolutePath();\n        if (tipoAbrir == 20) {\n            this.abrirSerializado(arquivo);\n        }\n        if (tipoAbrir == 10) {\n            this.abrirXML(arquivo);\n        }\n    }\n    \n    private void abrirSerializado(final String arquivo) {\n        if (arquivo.endsWith(\".jaw\")) {\n            try {\n                this.form.setNomeArquivoSalvo(arquivo);\n                this.form.setEntidades(new Serializacao().abrir(arquivo));\n            }\n            catch (Exception e) {\n                JOptionPane.showMessageDialog(null, \"Arquivo jaw corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3\u00a7\\u00c3\u00a3o!\", \"Abrir Arquivo jaw\", 0);\n                Main.janelaPrincipal.log(e.toString());\n            }\n        }\n        else {\n            JOptionPane.showMessageDialog(null, \"Arquivo jaw corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3\u00a7\\u00c3\u00a3o!\", \"Abrir Arquivo jaw\", 0);\n        }\n    }\n    \n    private void abrirXML(final String arquivo) {\n        if (arquivo.endsWith(\".jaw.xml\")) {\n            try {\n                this.form.setNomeArquivoSalvo(arquivo);\n                final Reader leitor = new FileReader(arquivo);\n                this.form.setEntidades(new SerializacaoXML().xml2Entidades(leitor));\n            }\n            catch (Exception e) {\n                JOptionPane.showMessageDialog(null, \"Arquivo xml corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3\u00a7\\u00c3\u00a3o!\", \"Importa\\u00c3\u00a7\\u00c3\u00a3o XML\", 0);\n                Main.janelaPrincipal.log(e.toString());\n            }\n        }\n        else {\n            JOptionPane.showMessageDialog(null, \"Arquivo xml corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3\u00a7\\u00c3\u00a3o!\", \"Importa\\u00c3\u00a7\\u00c3\u00a3o XML\", 0);\n        }\n    }\n    \n    private class Filtro2 extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw.xml\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"XML JAW files\";\n        }\n    }\n    \n    private class Filtro extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"JAW files\";\n        }\n    }\n}\n",
        "token_number_zeroshot": 891,
        "token_number_fewshot": 1289,
        "token_number_cot": 1002
    },
    {
        "project_name": "95_celwars2009",
        "class": "MP3",
        "source_code": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class MP3 extends Thread\n{\n    AudioInputStream in;\n    AudioInputStream din;\n    String filename;\n    \n    public MP3(final String filename) {\n        this.in = null;\n        this.din = null;\n        this.filename = \"\";\n        this.filename = filename;\n        this.start();\n    }\n    \n    @Override\n    public void run() {\n        AudioInputStream din = null;\n        try {\n            final File file = new File(this.filename);\n            final AudioInputStream in = AudioSystem.getAudioInputStream(file);\n            final AudioFormat baseFormat = in.getFormat();\n            final AudioFormat decodedFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, baseFormat.getSampleRate(), 16, baseFormat.getChannels(), baseFormat.getChannels() * 2, baseFormat.getSampleRate(), false);\n            din = AudioSystem.getAudioInputStream(decodedFormat, in);\n            final DataLine.Info info = new DataLine.Info(SourceDataLine.class, decodedFormat);\n            final SourceDataLine line = (SourceDataLine)AudioSystem.getLine(info);\n            if (line != null) {\n                line.open(decodedFormat);\n                final byte[] data = new byte[4096];\n                line.start();\n                int nBytesRead;\n                while ((nBytesRead = din.read(data, 0, data.length)) != -1) {\n                    line.write(data, 0, nBytesRead);\n                }\n                line.drain();\n                line.stop();\n                line.close();\n                din.close();\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n            if (din != null) {\n                try {\n                    din.close();\n                }\n                catch (IOException ex) {}\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 397,
        "token_number_fewshot": 795,
        "token_number_cot": 508
    },
    {
        "project_name": "36_schemaspy",
        "class": "TableMeta",
        "source_code": "package net.sourceforge.schemaspy.model.xml;\n\nimport java.util.logging.*;\nimport java.util.*;\nimport org.w3c.dom.*;\n\npublic class TableMeta\n{\n    private final String name;\n    private final String comments;\n    private final List<TableColumnMeta> columns;\n    private final String remoteCatalog;\n    private final String remoteSchema;\n    private static final Logger logger;\n    \n    TableMeta(final Node tableNode) {\n        this.columns = new ArrayList<TableColumnMeta>();\n        final NamedNodeMap attribs = tableNode.getAttributes();\n        this.name = attribs.getNamedItem(\"name\").getNodeValue();\n        Node node = attribs.getNamedItem(\"comments\");\n        if (node == null) {\n            node = attribs.getNamedItem(\"remarks\");\n        }\n        if (node != null) {\n            final String tmp = node.getNodeValue().trim();\n            this.comments = ((tmp.length() == 0) ? null : tmp);\n        }\n        else {\n            this.comments = null;\n        }\n        node = attribs.getNamedItem(\"remoteSchema\");\n        this.remoteSchema = ((node == null) ? null : node.getNodeValue().trim());\n        node = attribs.getNamedItem(\"remoteCatalog\");\n        this.remoteCatalog = ((node == null) ? null : node.getNodeValue().trim());\n        TableMeta.logger.fine(\"Found XML table metadata for \" + this.name + \" remoteCatalog: \" + this.remoteCatalog + \" remoteSchema: \" + this.remoteSchema + \" comments: \" + this.comments);\n        final NodeList columnNodes = ((Element)tableNode.getChildNodes()).getElementsByTagName(\"column\");\n        for (int i = 0; i < columnNodes.getLength(); ++i) {\n            final Node colNode = columnNodes.item(i);\n            this.columns.add(new TableColumnMeta(colNode));\n        }\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n    \n    public String getComments() {\n        return this.comments;\n    }\n    \n    public List<TableColumnMeta> getColumns() {\n        return this.columns;\n    }\n    \n    public String getRemoteCatalog() {\n        return this.remoteCatalog;\n    }\n    \n    public String getRemoteSchema() {\n        return this.remoteSchema;\n    }\n    \n    static {\n        logger = Logger.getLogger(TableMeta.class.getName());\n    }\n}\n",
        "token_number_zeroshot": 507,
        "token_number_fewshot": 905,
        "token_number_cot": 618
    },
    {
        "project_name": "105_freemind",
        "class": "ExportHook",
        "source_code": "package freemind.extensions;\n\nimport freemind.view.mindmapview.*;\nimport javax.swing.filechooser.*;\nimport java.text.*;\nimport javax.swing.*;\nimport freemind.modes.*;\nimport java.awt.image.*;\nimport java.awt.*;\nimport freemind.main.*;\nimport java.net.*;\nimport java.io.*;\n\npublic class ExportHook extends ModeControllerHookAdapter\n{\n    private MapView view;\n    \n    protected File chooseFile(final String type, final String description, final String nameExtension) {\n        final ModeController controller = this.getController();\n        return chooseImageFile(type, description, nameExtension, controller);\n    }\n    \n    public static File chooseImageFile(final String type, final String description, final String nameExtension, final ModeController controller) {\n        final Container component = controller.getFrame().getContentPane();\n        final ImageFilter filter = new ImageFilter(type, description);\n        FreeMindFileDialog chooser = null;\n        chooser = controller.getFileChooser(filter);\n        final File mmFile = controller.getMap().getFile();\n        if (mmFile != null) {\n            final String proposedName = mmFile.getAbsolutePath().replaceFirst(\"\\\\.[^.]*?$\", \"\") + ((nameExtension != null) ? nameExtension : \"\") + \".\" + type;\n            chooser.setSelectedFile(new File(proposedName));\n        }\n        final int returnVal = chooser.showSaveDialog(component);\n        if (returnVal != 0) {\n            return null;\n        }\n        File chosenFile = chooser.getSelectedFile();\n        final String ext = Tools.getExtension(chosenFile.getName());\n        if (!Tools.safeEqualsIgnoreCase(ext, type)) {\n            chosenFile = new File(chosenFile.getParent(), chosenFile.getName() + \".\" + type);\n        }\n        if (chosenFile.exists()) {\n            final String overwriteText = MessageFormat.format(controller.getText(\"file_already_exists\"), chosenFile.toString());\n            final int overwriteMap = JOptionPane.showConfirmDialog(component, overwriteText, overwriteText, 0);\n            if (overwriteMap != 0) {\n                return null;\n            }\n        }\n        return chosenFile;\n    }\n    \n    protected String getTranslatableResourceString(final String resourceName) {\n        final String returnValue = this.getResourceString(resourceName);\n        if (returnValue != null && returnValue.startsWith(\"%\")) {\n            return this.getController().getText(returnValue.substring(1));\n        }\n        return returnValue;\n    }\n    \n    public BufferedImage createBufferedImage() {\n        this.view = this.getController().getView();\n        if (this.view == null) {\n            return null;\n        }\n        this.view.preparePrinting();\n        final Rectangle innerBounds = this.view.getInnerBounds();\n        BufferedImage myImage = (BufferedImage)this.view.createImage(this.view.getWidth(), this.view.getHeight());\n        final Graphics g = myImage.getGraphics();\n        g.clipRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height);\n        this.view.print(g);\n        myImage = myImage.getSubimage(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height);\n        this.view.endPrinting();\n        return myImage;\n    }\n    \n    protected void copyFromResource(final String prefix, final String fileName, final String destinationDirectory) {\n        try {\n            this.logger.finest(\"searching for \" + prefix + fileName);\n            final URL resource = this.getResource(prefix + fileName);\n            if (resource == null) {\n                this.logger.severe(\"Cannot find resource: \" + prefix + fileName);\n                return;\n            }\n            final InputStream in = resource.openStream();\n            final OutputStream out = new FileOutputStream(destinationDirectory + \"/\" + fileName);\n            Tools.copyStream(in, out, true);\n        }\n        catch (Exception e) {\n            this.logger.severe(\"File not found or could not be copied. Was earching for \" + prefix + fileName + \" and should go to \" + destinationDirectory);\n            Resources.getInstance().logException(e);\n        }\n    }\n    \n    protected void copyFromFile(final String dir, final String fileName, final String destinationDirectory) {\n        try {\n            this.logger.finest(\"searching for \" + dir + fileName);\n            final File resource = new File(dir, fileName);\n            if (resource == null) {\n                this.logger.severe(\"Cannot find resource: \" + dir + fileName);\n                return;\n            }\n            final InputStream in = new FileInputStream(resource);\n            final OutputStream out = new FileOutputStream(destinationDirectory + \"/\" + fileName);\n            Tools.copyStream(in, out, true);\n        }\n        catch (Exception e) {\n            this.logger.severe(\"File not found or could not be copied. Was earching for \" + dir + fileName + \" and should go to \" + destinationDirectory);\n            Resources.getInstance().logException(e);\n        }\n    }\n    \n    public static class ImageFilter extends FileFilter\n    {\n        private String type;\n        private final String description;\n        \n        public ImageFilter(final String type, final String description) {\n            this.type = type;\n            this.description = description;\n        }\n        \n        @Override\n        public boolean accept(final File f) {\n            if (f.isDirectory()) {\n                return true;\n            }\n            final String extension = Tools.getExtension(f.getName());\n            return Tools.safeEqualsIgnoreCase(extension, this.type);\n        }\n        \n        @Override\n        public String getDescription() {\n            return (this.description == null) ? this.type : this.description;\n        }\n    }\n}\n",
        "token_number_zeroshot": 1121,
        "token_number_fewshot": 1519,
        "token_number_cot": 1232
    },
    {
        "project_name": "xmlenc",
        "class": "XMLEncoder",
        "source_code": "package org.znerd.xmlenc;\n\nimport java.io.*;\n\npublic class XMLEncoder\n{\n    private static final char[] DECLARATION_START;\n    private static final int DECLARATION_START_LENGTH;\n    private static final char[] DECLARATION_END;\n    private static final int DECLARATION_END_LENGTH;\n    private static final char[] ESC_GREATER_THAN;\n    private static final char[] ESC_LESS_THAN;\n    private static final char[] ESC_AMPERSAND;\n    private static final char[] ESC_APOSTROPHE;\n    private static final char[] ESC_QUOTE;\n    private static final char[] AMPERSAND_HASH;\n    private static final char[] EQUALS_APOSTROPHE;\n    private static final char[] EQUALS_QUOTE;\n    private final String _encoding;\n    private final char[] _encodingCharArray;\n    private final boolean _sevenBitEncoding;\n    \n    public static final XMLEncoder getEncoder(final String encoding) throws IllegalArgumentException, UnsupportedEncodingException {\n        return new XMLEncoder(encoding);\n    }\n    \n    public XMLEncoder(final String encoding) throws IllegalArgumentException, UnsupportedEncodingException {\n        if (encoding == null) {\n            throw new IllegalArgumentException(\"encoding == null\");\n        }\n        final String ucEncoding = encoding.toUpperCase();\n        if (ucEncoding.equals(\"UTF-8\") || ucEncoding.equals(\"UTF-16\")) {\n            this._sevenBitEncoding = false;\n        }\n        else {\n            if (!ucEncoding.equals(\"US-ASCII\") && !ucEncoding.equals(\"ASCII\") && !ucEncoding.startsWith(\"ISO-8859-\")) {\n                throw new UnsupportedEncodingException(encoding);\n            }\n            this._sevenBitEncoding = true;\n        }\n        this._encoding = encoding;\n        this._encodingCharArray = encoding.toCharArray();\n    }\n    \n    public String getEncoding() {\n        return this._encoding;\n    }\n    \n    public void declaration(final Writer out) throws NullPointerException, IOException {\n        out.write(XMLEncoder.DECLARATION_START, 0, XMLEncoder.DECLARATION_START_LENGTH);\n        out.write(this._encodingCharArray);\n        out.write(XMLEncoder.DECLARATION_END, 0, XMLEncoder.DECLARATION_END_LENGTH);\n    }\n    \n    public void text(final Writer out, final String text, final boolean escapeAmpersands) throws NullPointerException, InvalidXMLException, IOException {\n        this.text(out, text.toCharArray(), 0, text.length(), escapeAmpersands);\n    }\n    \n    public void text(final Writer out, final char[] ch, final int start, final int length, final boolean escapeAmpersands) throws NullPointerException, IndexOutOfBoundsException, InvalidXMLException, IOException {\n        final int end = start + length;\n        int lastEscaped = start;\n        for (int i = start; i < end; ++i) {\n            final int c = ch[i];\n            if ((c < 63 || c > 127) && (c < 39 || c > 59) && (c < 32 || c > 37) && (c != 38 || escapeAmpersands) && (c <= 127 || this._sevenBitEncoding) && c != 10 && c != 13 && c != 61) {\n                if (c != 9) {\n                    out.write(ch, lastEscaped, i - lastEscaped);\n                    if (c == 60) {\n                        out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n                    }\n                    else if (c == 62) {\n                        out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n                    }\n                    else if (c == 38) {\n                        out.write(XMLEncoder.ESC_AMPERSAND, 0, 5);\n                    }\n                    else {\n                        if (c <= 127) {\n                            throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n                        }\n                        out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n                        out.write(Integer.toString(c));\n                        out.write(59);\n                    }\n                    lastEscaped = i + 1;\n                }\n            }\n        }\n        out.write(ch, lastEscaped, end - lastEscaped);\n    }\n    \n    public void text(final Writer out, final char c) throws InvalidXMLException, IOException {\n        if ((c >= '?' && c <= '\\u007f') || (c >= '\\'' && c <= ';') || (c >= ' ' && c <= '%') || c == '&' || (c > '\\u007f' && !this._sevenBitEncoding) || c == '\\n' || c == '\\r' || c == '=' || c == '\\t') {\n            out.write(c);\n        }\n        else if (c == '<') {\n            out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n        }\n        else if (c == '>') {\n            out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n        }\n        else {\n            if (c <= '\\u007f') {\n                throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n            }\n            out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n            out.write(Integer.toString(c));\n            out.write(59);\n        }\n    }\n    \n    public void text(final Writer out, final char c, final boolean escapeAmpersands) throws InvalidXMLException, IOException {\n        if ((c >= '?' && c <= '\\u007f') || (c >= '\\'' && c <= ';') || (c >= ' ' && c <= '%') || (c == '&' && escapeAmpersands) || (c > '\\u007f' && !this._sevenBitEncoding) || c == '\\n' || c == '\\r' || c == '=' || c == '\\t') {\n            out.write(c);\n        }\n        else if (c == '<') {\n            out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n        }\n        else if (c == '>') {\n            out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n        }\n        else if (c == '&') {\n            out.write(XMLEncoder.ESC_AMPERSAND, 0, 5);\n        }\n        else {\n            if (c <= '\\u007f') {\n                throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n            }\n            out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n            out.write(Integer.toString(c));\n            out.write(59);\n        }\n    }\n    \n    public void whitespace(final Writer out, final String s) throws NullPointerException, InvalidXMLException, IOException {\n        final char[] ch = s.toCharArray();\n        final int length = ch.length;\n        this.whitespace(out, ch, 0, length);\n    }\n    \n    public void whitespace(final Writer out, final char[] ch, final int start, final int length) throws NullPointerException, IndexOutOfBoundsException, InvalidXMLException, IOException {\n        XMLChecker.checkS(ch, start, length);\n        out.write(ch, start, length);\n    }\n    \n    public void attribute(final Writer out, final String name, final String value, final char quotationMark, final boolean escapeAmpersands) throws NullPointerException, IOException {\n        final char[] ch = value.toCharArray();\n        final int length = ch.length;\n        final int start = 0;\n        final int end = start + length;\n        int lastEscaped = 0;\n        boolean useQuote;\n        if (quotationMark == '\\\"') {\n            useQuote = true;\n        }\n        else {\n            if (quotationMark != '\\'') {\n                final String error = \"Character 0x\" + Integer.toHexString(quotationMark) + \" ('\" + quotationMark + \"') is not a valid quotation mark.\";\n                throw new IllegalArgumentException(error);\n            }\n            useQuote = false;\n        }\n        out.write(32);\n        out.write(name);\n        if (useQuote) {\n            out.write(XMLEncoder.EQUALS_QUOTE, 0, 2);\n        }\n        else {\n            out.write(XMLEncoder.EQUALS_APOSTROPHE, 0, 2);\n        }\n        for (int i = start; i < end; ++i) {\n            final int c = ch[i];\n            if ((c < 63 || c > 127) && (c < 40 || c > 59) && (c < 32 || c > 37 || c == 34) && (c != 38 || escapeAmpersands) && (c <= 127 || this._sevenBitEncoding) && (useQuote || c != 34) && (!useQuote || c != 39) && c != 10 && c != 13 && c != 61) {\n                if (c != 9) {\n                    out.write(ch, lastEscaped, i - lastEscaped);\n                    if (c == 60) {\n                        out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n                    }\n                    else if (c == 62) {\n                        out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n                    }\n                    else if (c == 34) {\n                        out.write(XMLEncoder.ESC_QUOTE, 0, 6);\n                    }\n                    else if (c == 39) {\n                        out.write(XMLEncoder.ESC_APOSTROPHE, 0, 6);\n                    }\n                    else if (c == 38) {\n                        out.write(XMLEncoder.ESC_AMPERSAND, 0, 5);\n                    }\n                    else {\n                        if (c <= 127) {\n                            throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n                        }\n                        out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n                        out.write(Integer.toString(c));\n                        out.write(59);\n                    }\n                    lastEscaped = i + 1;\n                }\n            }\n        }\n        out.write(ch, lastEscaped, length - lastEscaped);\n        out.write(quotationMark);\n    }\n    \n    static {\n        DECLARATION_START = \"<?xml version=\\\"1.0\\\" encoding=\\\"\".toCharArray();\n        DECLARATION_START_LENGTH = XMLEncoder.DECLARATION_START.length;\n        DECLARATION_END = \"\\\"?>\".toCharArray();\n        DECLARATION_END_LENGTH = XMLEncoder.DECLARATION_END.length;\n        ESC_GREATER_THAN = new char[] { '&', 'g', 't', ';' };\n        ESC_LESS_THAN = new char[] { '&', 'l', 't', ';' };\n        ESC_AMPERSAND = new char[] { '&', 'a', 'm', 'p', ';' };\n        ESC_APOSTROPHE = new char[] { '&', 'a', 'p', 'o', 's', ';' };\n        ESC_QUOTE = new char[] { '&', 'q', 'u', 'o', 't', ';' };\n        AMPERSAND_HASH = new char[] { '&', '#' };\n        EQUALS_APOSTROPHE = new char[] { '=', '\\'' };\n        EQUALS_QUOTE = new char[] { '=', '\\\"' };\n    }\n}\n",
        "token_number_zeroshot": 2401,
        "token_number_fewshot": 2799,
        "token_number_cot": 2513
    },
    {
        "project_name": "91_classviewer",
        "class": "SAXDirParser",
        "source_code": "package com.jstevh.viewer;\n\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\n\npublic class SAXDirParser extends DefaultHandler\n{\n    public String webData;\n    private static HashMap<String, String> directory;\n    private static StringList localPackages;\n    private static String localBrowser;\n    private static String file_editor;\n    private static boolean lineNumAccepted;\n    private static String lineNumParam;\n    private boolean check;\n    private boolean local;\n    private int level;\n    private String location;\n    \n    public String getWebData() {\n        return this.webData;\n    }\n    \n    public SAXDirParser() throws Exception {\n        this.webData = \"\";\n    }\n    \n    @Override\n    public void startElement(final String namespace, final String local, final String qname, final Attributes atts) throws SAXException {\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\n            this.check = true;\n            this.level = 0;\n        }\n        if (qname.compareTo(\"Editor\") == 0) {\n            this.check = true;\n            this.level = 10;\n        }\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\n            this.check = true;\n            this.level = 11;\n        }\n        if (qname.compareTo(\"parameter\") == 0) {\n            this.check = true;\n            this.level = 12;\n        }\n        if (qname.compareTo(\"Group\") == 0) {\n            this.level = 2;\n            this.check = false;\n        }\n        if (qname.compareTo(\"Web\") == 0) {\n            this.check = true;\n            this.level = 30;\n        }\n        if (qname.compareTo(\"Local\") == 0) {\n            this.check = true;\n            this.level = 31;\n        }\n        if (qname.compareTo(\"Names\") == 0) {\n            this.check = true;\n        }\n        if (qname.compareTo(\"pkg\") == 0) {\n            this.level = 4;\n        }\n    }\n    \n    @Override\n    public void characters(final char[] charArray, final int start, final int length) {\n        if (this.check && this.level >= 0) {\n            String tempStr = \"\";\n            for (int i = start; i < start + length; ++i) {\n                tempStr += charArray[i];\n            }\n            if (this.level == 0) {\n                SAXDirParser.localBrowser = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 10) {\n                SAXDirParser.file_editor = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 11) {\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\n                    SAXDirParser.lineNumAccepted = true;\n                }\n                else {\n                    SAXDirParser.lineNumAccepted = false;\n                }\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 12) {\n                SAXDirParser.lineNumParam = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 30) {\n                this.location = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 31) {\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\n                    this.local = true;\n                }\n                else {\n                    this.local = false;\n                }\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 4 && tempStr.trim().compareTo(\"\") != 0) {\n                if (tempStr.endsWith(\".\")) {\n                    tempStr = tempStr.substring(0, tempStr.length() - 1);\n                }\n                SAXDirParser.directory.put(tempStr, this.location);\n                if (this.local) {\n                    SAXDirParser.localPackages.add(tempStr);\n                }\n            }\n        }\n    }\n    \n    @Override\n    public void endElement(final String namespace, final String local, final String qname) throws SAXException {\n        if (qname.compareTo(\"Group\") == 0) {\n            this.check = false;\n        }\n    }\n    \n    public static HashMap getDirectory() {\n        return (HashMap)SAXDirParser.directory.clone();\n    }\n    \n    public static StringList getLocalPackages() {\n        if (SAXDirParser.localPackages.isEmpty()) {\n            return null;\n        }\n        return SAXDirParser.localPackages.clone();\n    }\n    \n    public static String getLocalBrowser() {\n        return SAXDirParser.localBrowser;\n    }\n    \n    public static String getEditor() {\n        return SAXDirParser.file_editor;\n    }\n    \n    public static boolean acceptsLineNumber() {\n        return SAXDirParser.lineNumAccepted;\n    }\n    \n    public static String lineNumberParameter() {\n        return SAXDirParser.lineNumParam;\n    }\n    \n    public static void main(final String[] args) throws Exception {\n        final SAXParserFactory saxFactory = SAXParserFactory.newInstance();\n        final SAXParser myParser = saxFactory.newSAXParser();\n        final XMLReader myReader = myParser.getXMLReader();\n        myReader.setContentHandler(new SAXDirParser());\n        myReader.parse(\"packagedirectory.xml\");\n        System.out.println(\"test directory, test gives \" + SAXDirParser.directory.get(\"java.lang\"));\n        System.out.println(\"test directory, test gives \" + SAXDirParser.directory.get(\"javax.swing.border\"));\n        System.out.println(\"test local browser, test gives \" + SAXDirParser.localBrowser);\n    }\n    \n    static {\n        SAXDirParser.directory = new HashMap<String, String>();\n        SAXDirParser.localPackages = new StringList();\n        SAXDirParser.localBrowser = \"\";\n        SAXDirParser.file_editor = \"\";\n        SAXDirParser.lineNumAccepted = false;\n        SAXDirParser.lineNumParam = \"\";\n    }\n}\n",
        "token_number_zeroshot": 1290,
        "token_number_fewshot": 1688,
        "token_number_cot": 1402
    },
    {
        "project_name": "91_classviewer",
        "class": "ClassInfo",
        "source_code": "package com.jstevh.viewer;\n\nimport javax.swing.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\n\npublic class ClassInfo\n{\n    public static boolean debug;\n    private boolean statusAbstract;\n    private Class c;\n    private DirManager dirMan;\n    private static int count;\n    private static int length;\n    public static final int NO_OBJECT_METHODS = 1;\n    public static final int NO_INHERITED_METHODS = 2;\n    private String[] cMethods;\n    private String[] fndMethods;\n    protected String[] knownPackages;\n    \n    public boolean isAbstract() {\n        return this.statusAbstract;\n    }\n    \n    public boolean isInterface() {\n        return this.c.isInterface();\n    }\n    \n    public String getClassName() {\n        return this.c.getName();\n    }\n    \n    public String getClassPackage() {\n        return (this.c.getPackage() != null) ? this.c.getPackage().getName() : null;\n    }\n    \n    public String getSuperClassName() {\n        if (this.c != Object.class && !this.c.isInterface()) {\n            return this.c.getSuperclass().getName();\n        }\n        return null;\n    }\n    \n    private ClassInfo() {\n        this.c = WindowConstants.class;\n        this.fndMethods = null;\n    }\n    \n    public ClassInfo(final String name) throws ClassNotFoundException {\n        this.c = WindowConstants.class;\n        this.fndMethods = null;\n        this.c = this.getClass(name);\n        if (this.c == null) {\n            throw new ClassNotFoundException();\n        }\n        final Method[] m = this.c.getMethods();\n        final Object[] obj = null;\n        this.cMethods = getData(m);\n        if (this.cMethods != null) {\n            if (this.c != Object.class) {\n                final StringList tempList = new StringList();\n                ClassInfo.count = 0;\n                while (ClassInfo.count < this.cMethods.length) {\n                    if (this.cMethods[ClassInfo.count].indexOf(\"Object.\") == -1) {\n                        tempList.add(this.cMethods[ClassInfo.count]);\n                    }\n                    ++ClassInfo.count;\n                }\n                this.cMethods = tempList.toArray();\n            }\n            ClassInfo.count = 0;\n            while (ClassInfo.count < this.cMethods.length) {\n                if (!this.statusAbstract && this.cMethods[ClassInfo.count].indexOf(\"abstract\") != -1) {\n                    this.statusAbstract = true;\n                }\n                ++ClassInfo.count;\n            }\n        }\n    }\n    \n    public ClassInfo(final String name, final DirManager locManager) throws ClassNotFoundException {\n        this.c = WindowConstants.class;\n        this.fndMethods = null;\n        this.dirMan = locManager;\n        this.knownPackages = this.dirMan.getPackageList();\n        this.c = this.getClass(name);\n        if (this.c == null) {\n            throw new ClassNotFoundException();\n        }\n        final Method[] m = this.c.getMethods();\n        final Object[] obj = null;\n        this.cMethods = getData(m);\n        if (this.cMethods != null) {\n            if (this.c != Object.class) {\n                final StringList tempList = new StringList();\n                ClassInfo.count = 0;\n                while (ClassInfo.count < this.cMethods.length) {\n                    if (this.cMethods[ClassInfo.count].indexOf(\"Object.\") == -1) {\n                        tempList.add(this.cMethods[ClassInfo.count]);\n                    }\n                    ++ClassInfo.count;\n                }\n                this.cMethods = tempList.toArray();\n            }\n            ClassInfo.count = 0;\n            while (ClassInfo.count < this.cMethods.length) {\n                if (!this.statusAbstract && this.cMethods[ClassInfo.count].indexOf(\"abstract\") != -1) {\n                    this.statusAbstract = true;\n                }\n                ++ClassInfo.count;\n            }\n        }\n    }\n    \n    public String[] printFields() {\n        final Field[] f = this.c.getFields();\n        ClassInfo.length = f.length;\n        String[] StringData = null;\n        if (ClassInfo.length > 0) {\n            StringData = new String[ClassInfo.length];\n            final Object obj = new Object();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            ClassInfo.count = 0;\n            while (ClassInfo.count < ClassInfo.length) {\n                try {\n                    final String tempStr = f[ClassInfo.count] + \"=\" + f[ClassInfo.count].get(obj);\n                    StringData[ClassInfo.count] = tempStr;\n                    if (ClassInfo.debug) {\n                        System.out.println(tempStr);\n                    }\n                }\n                catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                    final String tempStr = f[ClassInfo.count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\n                    StringData[ClassInfo.count] = tempStr;\n                }\n                catch (IllegalArgumentException j) {\n                    j.printStackTrace();\n                    final String tempStr = f[ClassInfo.count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\n                    StringData[ClassInfo.count] = tempStr;\n                }\n                ++ClassInfo.count;\n            }\n        }\n        else if (ClassInfo.debug) {\n            System.out.println(\"No public fields.\");\n        }\n        return StringData;\n    }\n    \n    public String[] printMethods() {\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        String[] tempArray = null;\n        if (this.cMethods != null) {\n            tempArray = new String[this.cMethods.length];\n            System.arraycopy(this.cMethods, 0, tempArray, 0, this.cMethods.length);\n        }\n        if (ClassInfo.debug && tempArray == null) {\n            System.out.println(\"No public methods.\");\n        }\n        else {\n            this.printArray(tempArray);\n        }\n        return tempArray;\n    }\n    \n    public String[] printMethods(final int param) {\n        if (this.cMethods == null) {\n            return null;\n        }\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        String[] data = this.cMethods;\n        final StringList tempList = new StringList();\n        for (int i = 0; i < this.cMethods.length; ++i) {\n            if (this.cMethods[i].indexOf(this.getClassName() + '.') != -1) {\n                tempList.add(this.cMethods[i]);\n            }\n        }\n        if (!tempList.isEmpty()) {\n            data = tempList.toArray();\n        }\n        else {\n            data = null;\n        }\n        if (ClassInfo.debug && data == null) {\n            System.out.println(\"No public methods.\");\n        }\n        else {\n            this.printArray(data);\n        }\n        return data;\n    }\n    \n    public String[] printConstructors() {\n        final Constructor[] constr = this.c.getConstructors();\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        final String[] data = getData(constr);\n        if (ClassInfo.debug && data == null) {\n            System.out.println(\"No public constructors.\");\n        }\n        else {\n            this.printArray(data);\n        }\n        return data;\n    }\n    \n    public String[] printInterfaces() {\n        Class[] inter = this.c.getInterfaces();\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        String[] data = getData(inter);\n        if (this.c != Object.class && !this.c.isInterface()) {\n            Class superC = this.c.getSuperclass();\n            final TreeSet<String> hInterfaces = new TreeSet<String>();\n            int i = 0;\n            if (data != null) {\n                for (i = 0; i < data.length; ++i) {\n                    hInterfaces.add(data[i]);\n                }\n            }\n            while (superC != null && superC != Object.class) {\n                inter = superC.getInterfaces();\n                if (ClassInfo.debug) {\n                    System.out.println(\"****************************************\");\n                }\n                data = getData(inter);\n                if (data != null) {\n                    for (i = 0; i < data.length; ++i) {\n                        hInterfaces.add(data[i]);\n                    }\n                }\n                superC = superC.getSuperclass();\n            }\n            if (hInterfaces.size() != 0) {\n                data = new String[hInterfaces.size()];\n                final Iterator it = hInterfaces.iterator();\n                i = 0;\n                while (it.hasNext()) {\n                    data[i] = it.next();\n                    ++i;\n                }\n            }\n        }\n        if (ClassInfo.debug && data == null) {\n            System.out.println(\"No interfaces.\");\n        }\n        else {\n            this.printArray(data);\n        }\n        return data;\n    }\n    \n    public static String[] getData(final Member[] m) {\n        ClassInfo.length = m.length;\n        if (ClassInfo.length == 0) {\n            return null;\n        }\n        final String[] StringData = new String[ClassInfo.length];\n        ClassInfo.count = 0;\n        while (ClassInfo.count < m.length) {\n            final String tempStr = m[ClassInfo.count].toString();\n            StringData[ClassInfo.count] = tempStr;\n            ++ClassInfo.count;\n        }\n        return StringData;\n    }\n    \n    public static String[] getData(final Class[] m) {\n        ClassInfo.length = m.length;\n        if (ClassInfo.length == 0) {\n            return null;\n        }\n        final String[] StringData = new String[ClassInfo.length];\n        ClassInfo.count = 0;\n        while (ClassInfo.count < m.length) {\n            final String tempStr = m[ClassInfo.count].getName();\n            StringData[ClassInfo.count] = tempStr;\n            ++ClassInfo.count;\n        }\n        return StringData;\n    }\n    \n    public String[] srchMethods(final String tempStr) {\n        if (tempStr == null) {\n            return null;\n        }\n        this.fndMethods = StringTools.searchStrings(this.cMethods, tempStr);\n        if (this.fndMethods != null) {\n            final String[] tempArray = new String[this.fndMethods.length];\n            System.arraycopy(this.fndMethods, 0, tempArray, 0, this.fndMethods.length);\n            return tempArray;\n        }\n        return null;\n    }\n    \n    public String[] srchMethods(final String tempStr, final String[] index) {\n        if (tempStr == null) {\n            return null;\n        }\n        this.fndMethods = StringTools.searchStrings(this.cMethods, index, tempStr);\n        if (this.fndMethods != null) {\n            final String[] tempArray = new String[this.fndMethods.length];\n            System.arraycopy(this.fndMethods, 0, tempArray, 0, this.fndMethods.length);\n            return tempArray;\n        }\n        return null;\n    }\n    \n    public MethodData getFoundMethod(final int pos) {\n        if (this.fndMethods == null || pos > this.fndMethods.length) {\n            return null;\n        }\n        return new MethodData() {\n            String tempStr = this.tempStr.substring(this.begin + 1, this.tempStr.length());\n            String tempStr2;\n            String className = this.tempStr.substring(0, this.end);\n            String methodName = this.tempStr.substring(this.end + 1, this.tempStr.length());\n            int begin = this.tempStr.indexOf(\"(\");\n            int end = this.tempStr.lastIndexOf(\".\", this.begin);\n            Class methClass;\n            \n            {\n                this.tempStr = ClassInfo.this.fndMethods[pos];\n                this.end = this.tempStr.indexOf(\")\");\n                this.tempStr = this.tempStr.substring(0, this.end + 1);\n                this.begin = this.tempStr.lastIndexOf(\" \");\n                if (ClassInfo.debug) {\n                    System.out.println(\"className=\" + this.className);\n                }\n                this.methClass = tryClass(this.className);\n                if (ClassInfo.debug) {\n                    System.out.println(\"methClass=\" + this.methClass);\n                }\n            }\n            \n            @Override\n            public String getMethPackage() {\n                if (this.methClass == null) {\n                    return null;\n                }\n                return (this.methClass.getPackage() != null) ? this.methClass.getPackage().getName() : null;\n            }\n            \n            @Override\n            public String getMethClass() {\n                if (this.methClass == null) {\n                    return null;\n                }\n                return this.methClass.getName();\n            }\n            \n            @Override\n            public String getMethName() {\n                return this.methodName;\n            }\n        };\n    }\n    \n    private void printArray(final Object[] array) {\n        if (!ClassInfo.debug) {\n            return;\n        }\n        ClassInfo.length = array.length;\n        if (ClassInfo.length == 0) {\n            return;\n        }\n        ClassInfo.count = 0;\n        while (ClassInfo.count < ClassInfo.length) {\n            System.out.println(array[ClassInfo.count]);\n            ++ClassInfo.count;\n        }\n    }\n    \n    private Class getClass(final String name) {\n        Class tempClass = null;\n        tempClass = tryClass(name);\n        if (tempClass == null) {\n            for (int i = 0; i < this.knownPackages.length; ++i) {\n                final String tempStr = this.knownPackages[i] + name;\n                tempClass = tryClass(tempStr);\n                if (tempClass != null) {\n                    break;\n                }\n            }\n        }\n        return tempClass;\n    }\n    \n    private static Class tryClass(final String name) {\n        Class tempClass = null;\n        try {\n            if (name != null) {\n                tempClass = Class.forName(name.trim());\n            }\n        }\n        catch (ClassNotFoundException e) {\n            return null;\n        }\n        catch (NoClassDefFoundError f) {\n            return null;\n        }\n        return tempClass;\n    }\n    \n    private void printClassInfo() {\n        this.printMethods();\n        if (!this.c.isInterface()) {\n            this.printConstructors();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            this.printInterfaces();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            if (this.statusAbstract) {\n                System.out.println(\"Abstract \" + this.c);\n            }\n            else {\n                System.out.println(this.c.getName());\n            }\n            if (this.c != Object.class) {\n                System.out.println(\"Superclass is \" + this.c.getSuperclass().getName() + \".\");\n            }\n        }\n        else {\n            this.printFields();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            System.out.println(this.c.getName() + \" is an interface.\");\n        }\n    }\n    \n    public static void main(final String[] args) throws Exception {\n        final long t1 = System.currentTimeMillis();\n        ClassInfo.debug = true;\n        String name = null;\n        if (args.length > 0) {\n            if (args[0].equals(\"new\")) {\n                name = args[1];\n            }\n            else {\n                name = args[0];\n                try {\n                    final ClassInfo myClassInfo = new ClassInfo(name);\n                    myClassInfo.printClassInfo();\n                }\n                catch (ClassNotFoundException e) {\n                    System.out.println(\"Class not found.\");\n                    System.exit(0);\n                }\n            }\n        }\n        else {\n            final ClassInfo myClassInfo = new ClassInfo();\n            myClassInfo.printClassInfo();\n        }\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\n    }\n}\n",
        "token_number_zeroshot": 3274,
        "token_number_fewshot": 3672,
        "token_number_cot": 3385
    },
    {
        "project_name": "11_imsmart",
        "class": "HTMLFilter",
        "source_code": "package com.imsmart.servlet;\n\npublic final class HTMLFilter\n{\n    public static String filter(final String message) {\n        if (message == null) {\n            return null;\n        }\n        final char[] content = new char[message.length()];\n        message.getChars(0, message.length(), content, 0);\n        final StringBuffer result = new StringBuffer(content.length + 50);\n        for (int i = 0; i < content.length; ++i) {\n            switch (content[i]) {\n                case '<': {\n                    result.append(\"&lt;\");\n                    break;\n                }\n                case '>': {\n                    result.append(\"&gt;\");\n                    break;\n                }\n                case '&': {\n                    result.append(\"&amp;\");\n                    break;\n                }\n                case '\\\"': {\n                    result.append(\"&quot;\");\n                    break;\n                }\n                default: {\n                    result.append(content[i]);\n                    break;\n                }\n            }\n        }\n        return result.toString();\n    }\n}\n",
        "token_number_zeroshot": 225,
        "token_number_fewshot": 623,
        "token_number_cot": 336
    },
    {
        "project_name": "commons-math",
        "class": "IntervalsSet",
        "source_code": "package org.apache.commons.math3.geometry.euclidean.oned;\n\nimport org.apache.commons.math3.geometry.*;\nimport org.apache.commons.math3.util.*;\nimport java.util.*;\nimport org.apache.commons.math3.geometry.partitioning.*;\n\npublic class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D>\n{\n    public IntervalsSet() {\n    }\n    \n    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n    \n    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }\n    \n    public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n        super(boundary);\n    }\n    \n    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && lower < 0.0) {\n            if (Double.isInfinite(upper) && upper > 0.0) {\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            final SubHyperplane<Euclidean1D> upperCut = new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null);\n        }\n        else {\n            final SubHyperplane<Euclidean1D> lowerCut = new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n            if (Double.isInfinite(upper) && upper > 0.0) {\n                return new BSPTree<Euclidean1D>(lowerCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null);\n            }\n            final SubHyperplane<Euclidean1D> upperCut2 = new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(lowerCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(upperCut2, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null), null);\n        }\n    }\n    \n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }\n    \n    protected void computeGeometricalProperties() {\n        if (((AbstractRegion<Euclidean1D, T>)this).getTree(false).getCut() == null) {\n            ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(Vector1D.NaN);\n            this.setSize(((boolean)((AbstractRegion<Euclidean1D, T>)this).getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0.0);\n        }\n        else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : this.asList()) {\n                size += interval.getSize();\n                sum += interval.getSize() * interval.getBarycenter();\n            }\n            this.setSize(size);\n            if (Double.isInfinite(size)) {\n                ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(Vector1D.NaN);\n            }\n            else if (size >= Precision.SAFE_MIN) {\n                ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(new Vector1D(sum / size));\n            }\n            else {\n                ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(((OrientedPoint)((AbstractRegion<Euclidean1D, T>)this).getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }\n    \n    public double getInf() {\n        BSPTree<Euclidean1D> node = ((AbstractRegion<Euclidean1D, T>)this).getTree(false);\n        double inf = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint)node.getCut().getHyperplane();\n            inf = op.getLocation().getX();\n            node = (op.isDirect() ? node.getMinus() : node.getPlus());\n        }\n        return node.getAttribute() ? Double.NEGATIVE_INFINITY : inf;\n    }\n    \n    public double getSup() {\n        BSPTree<Euclidean1D> node = ((AbstractRegion<Euclidean1D, T>)this).getTree(false);\n        double sup = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint)node.getCut().getHyperplane();\n            sup = op.getLocation().getX();\n            node = (op.isDirect() ? node.getPlus() : node.getMinus());\n        }\n        return node.getAttribute() ? Double.POSITIVE_INFINITY : sup;\n    }\n    \n    public List<Interval> asList() {\n        final List<Interval> list = new ArrayList<Interval>();\n        this.recurseList(((AbstractRegion<Euclidean1D, T>)this).getTree(false), list, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n        return list;\n    }\n    \n    private void recurseList(final BSPTree<Euclidean1D> node, final List<Interval> list, final double lower, final double upper) {\n        if (node.getCut() == null) {\n            if (node.getAttribute()) {\n                list.add(new Interval(lower, upper));\n            }\n        }\n        else {\n            final OrientedPoint op = (OrientedPoint)node.getCut().getHyperplane();\n            final Vector1D loc = op.getLocation();\n            double x = loc.getX();\n            final BSPTree<Euclidean1D> low = op.isDirect() ? node.getMinus() : node.getPlus();\n            final BSPTree<Euclidean1D> high = op.isDirect() ? node.getPlus() : node.getMinus();\n            this.recurseList(low, list, lower, x);\n            if (((AbstractRegion<Euclidean1D, T>)this).checkPoint(low, loc) == Region.Location.INSIDE && ((AbstractRegion<Euclidean1D, T>)this).checkPoint(high, loc) == Region.Location.INSIDE) {\n                x = list.remove(list.size() - 1).getInf();\n            }\n            this.recurseList(high, list, x, upper);\n        }\n    }\n}\n",
        "token_number_zeroshot": 1434,
        "token_number_fewshot": 1832,
        "token_number_cot": 1546
    },
    {
        "project_name": "commons-math",
        "class": "AbstractSimplex",
        "source_code": "package org.apache.commons.math3.optim.nonlinear.scalar.noderiv;\n\nimport org.apache.commons.math3.optim.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.analysis.*;\nimport java.util.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.util.*;\n\npublic abstract class AbstractSimplex implements OptimizationData\n{\n    private PointValuePair[] simplex;\n    private double[][] startConfiguration;\n    private final int dimension;\n    \n    protected AbstractSimplex(final int n) {\n        this(n, 1.0);\n    }\n    \n    protected AbstractSimplex(final int n, final double sideLength) {\n        this(createHypercubeSteps(n, sideLength));\n    }\n    \n    protected AbstractSimplex(final double[] steps) {\n        if (steps == null) {\n            throw new NullArgumentException();\n        }\n        if (steps.length == 0) {\n            throw new ZeroException();\n        }\n        this.dimension = steps.length;\n        this.startConfiguration = new double[this.dimension][this.dimension];\n        for (int i = 0; i < this.dimension; ++i) {\n            final double[] vertexI = this.startConfiguration[i];\n            for (int j = 0; j < i + 1; ++j) {\n                if (steps[j] == 0.0) {\n                    throw new ZeroException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX, new Object[0]);\n                }\n                System.arraycopy(steps, 0, vertexI, 0, j + 1);\n            }\n        }\n    }\n    \n    protected AbstractSimplex(final double[][] referenceSimplex) {\n        if (referenceSimplex.length <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SIMPLEX_NEED_ONE_POINT, referenceSimplex.length);\n        }\n        this.dimension = referenceSimplex.length - 1;\n        this.startConfiguration = new double[this.dimension][this.dimension];\n        final double[] ref0 = referenceSimplex[0];\n        for (int i = 0; i < referenceSimplex.length; ++i) {\n            final double[] refI = referenceSimplex[i];\n            if (refI.length != this.dimension) {\n                throw new DimensionMismatchException(refI.length, this.dimension);\n            }\n            for (int j = 0; j < i; ++j) {\n                final double[] refJ = referenceSimplex[j];\n                boolean allEquals = true;\n                for (int k = 0; k < this.dimension; ++k) {\n                    if (refI[k] != refJ[k]) {\n                        allEquals = false;\n                        break;\n                    }\n                }\n                if (allEquals) {\n                    throw new MathIllegalArgumentException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX, new Object[] { i, j });\n                }\n            }\n            if (i > 0) {\n                final double[] confI = this.startConfiguration[i - 1];\n                for (int l = 0; l < this.dimension; ++l) {\n                    confI[l] = refI[l] - ref0[l];\n                }\n            }\n        }\n    }\n    \n    public int getDimension() {\n        return this.dimension;\n    }\n    \n    public int getSize() {\n        return this.simplex.length;\n    }\n    \n    public abstract void iterate(final MultivariateFunction p0, final Comparator<PointValuePair> p1);\n    \n    public void build(final double[] startPoint) {\n        if (this.dimension != startPoint.length) {\n            throw new DimensionMismatchException(this.dimension, startPoint.length);\n        }\n        (this.simplex = new PointValuePair[this.dimension + 1])[0] = new PointValuePair(startPoint, Double.NaN);\n        for (int i = 0; i < this.dimension; ++i) {\n            final double[] confI = this.startConfiguration[i];\n            final double[] vertexI = new double[this.dimension];\n            for (int k = 0; k < this.dimension; ++k) {\n                vertexI[k] = startPoint[k] + confI[k];\n            }\n            this.simplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n        }\n    }\n    \n    public void evaluate(final MultivariateFunction evaluationFunction, final Comparator<PointValuePair> comparator) {\n        for (int i = 0; i < this.simplex.length; ++i) {\n            final PointValuePair vertex = this.simplex[i];\n            final double[] point = vertex.getPointRef();\n            if (Double.isNaN(((Pair<K, Double>)vertex).getValue())) {\n                this.simplex[i] = new PointValuePair(point, evaluationFunction.value(point), false);\n            }\n        }\n        Arrays.sort(this.simplex, comparator);\n    }\n    \n    protected void replaceWorstPoint(PointValuePair pointValuePair, final Comparator<PointValuePair> comparator) {\n        for (int i = 0; i < this.dimension; ++i) {\n            if (comparator.compare(this.simplex[i], pointValuePair) > 0) {\n                final PointValuePair tmp = this.simplex[i];\n                this.simplex[i] = pointValuePair;\n                pointValuePair = tmp;\n            }\n        }\n        this.simplex[this.dimension] = pointValuePair;\n    }\n    \n    public PointValuePair[] getPoints() {\n        final PointValuePair[] copy = new PointValuePair[this.simplex.length];\n        System.arraycopy(this.simplex, 0, copy, 0, this.simplex.length);\n        return copy;\n    }\n    \n    public PointValuePair getPoint(final int index) {\n        if (index < 0 || index >= this.simplex.length) {\n            throw new OutOfRangeException(index, 0, this.simplex.length - 1);\n        }\n        return this.simplex[index];\n    }\n    \n    protected void setPoint(final int index, final PointValuePair point) {\n        if (index < 0 || index >= this.simplex.length) {\n            throw new OutOfRangeException(index, 0, this.simplex.length - 1);\n        }\n        this.simplex[index] = point;\n    }\n    \n    protected void setPoints(final PointValuePair[] points) {\n        if (points.length != this.simplex.length) {\n            throw new DimensionMismatchException(points.length, this.simplex.length);\n        }\n        this.simplex = points;\n    }\n    \n    private static double[] createHypercubeSteps(final int n, final double sideLength) {\n        final double[] steps = new double[n];\n        for (int i = 0; i < n; ++i) {\n            steps[i] = sideLength;\n        }\n        return steps;\n    }\n}\n",
        "token_number_zeroshot": 1397,
        "token_number_fewshot": 1795,
        "token_number_cot": 1509
    },
    {
        "project_name": "commons-math",
        "class": "MultidimensionalCounter",
        "source_code": "package org.apache.commons.math3.util;\n\nimport org.apache.commons.math3.exception.*;\nimport java.util.*;\n\npublic class MultidimensionalCounter implements Iterable<Integer>\n{\n    private final int dimension;\n    private final int[] uniCounterOffset;\n    private final int[] size;\n    private final int totalSize;\n    private final int last;\n    \n    public MultidimensionalCounter(final int... size) throws NotStrictlyPositiveException {\n        this.dimension = size.length;\n        this.size = MathArrays.copyOf(size);\n        this.uniCounterOffset = new int[this.dimension];\n        this.last = this.dimension - 1;\n        int tS = size[this.last];\n        for (int i = 0; i < this.last; ++i) {\n            int count = 1;\n            for (int j = i + 1; j < this.dimension; ++j) {\n                count *= size[j];\n            }\n            this.uniCounterOffset[i] = count;\n            tS *= size[i];\n        }\n        this.uniCounterOffset[this.last] = 0;\n        if (tS <= 0) {\n            throw new NotStrictlyPositiveException(tS);\n        }\n        this.totalSize = tS;\n    }\n    \n    public Iterator iterator() {\n        return new Iterator();\n    }\n    \n    public int getDimension() {\n        return this.dimension;\n    }\n    \n    public int[] getCounts(final int index) throws OutOfRangeException {\n        if (index < 0 || index >= this.totalSize) {\n            throw new OutOfRangeException(index, 0, this.totalSize);\n        }\n        final int[] indices = new int[this.dimension];\n        int count = 0;\n        for (int i = 0; i < this.last; ++i) {\n            int idx;\n            int offset;\n            for (idx = 0, offset = this.uniCounterOffset[i]; count <= index; count += offset, ++idx) {}\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n        indices[this.last] = index - count;\n        return indices;\n    }\n    \n    public int getCount(final int... c) throws OutOfRangeException, DimensionMismatchException {\n        if (c.length != this.dimension) {\n            throw new DimensionMismatchException(c.length, this.dimension);\n        }\n        int count = 0;\n        for (int i = 0; i < this.dimension; ++i) {\n            final int index = c[i];\n            if (index < 0 || index >= this.size[i]) {\n                throw new OutOfRangeException(index, 0, this.size[i] - 1);\n            }\n            count += this.uniCounterOffset[i] * c[i];\n        }\n        return count + c[this.last];\n    }\n    \n    public int getSize() {\n        return this.totalSize;\n    }\n    \n    public int[] getSizes() {\n        return MathArrays.copyOf(this.size);\n    }\n    \n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < this.dimension; ++i) {\n            sb.append(\"[\").append(this.getCount(i)).append(\"]\");\n        }\n        return sb.toString();\n    }\n    \n    public class Iterator implements java.util.Iterator<Integer>\n    {\n        private final int[] counter;\n        private int count;\n        \n        Iterator() {\n            this.counter = new int[MultidimensionalCounter.this.dimension];\n            this.count = -1;\n            this.counter[MultidimensionalCounter.this.last] = -1;\n        }\n        \n        public boolean hasNext() {\n            for (int i = 0; i < MultidimensionalCounter.this.dimension; ++i) {\n                if (this.counter[i] != MultidimensionalCounter.this.size[i] - 1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        public Integer next() {\n            for (int i = MultidimensionalCounter.this.last; i >= 0; --i) {\n                if (this.counter[i] != MultidimensionalCounter.this.size[i] - 1) {\n                    final int[] counter = this.counter;\n                    final int n = i;\n                    ++counter[n];\n                    break;\n                }\n                this.counter[i] = 0;\n            }\n            return ++this.count;\n        }\n        \n        public int getCount() {\n            return this.count;\n        }\n        \n        public int[] getCounts() {\n            return MathArrays.copyOf(this.counter);\n        }\n        \n        public int getCount(final int dim) {\n            return this.counter[dim];\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n",
        "token_number_zeroshot": 991,
        "token_number_fewshot": 1389,
        "token_number_cot": 1104
    },
    {
        "project_name": "commons-math",
        "class": "Fraction",
        "source_code": "package org.apache.commons.math3.fraction;\n\nimport java.io.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.*;\nimport java.math.*;\nimport org.apache.commons.math3.*;\n\npublic class Fraction extends Number implements FieldElement<Fraction>, Comparable<Fraction>, Serializable\n{\n    public static final Fraction TWO;\n    public static final Fraction ONE;\n    public static final Fraction ZERO;\n    public static final Fraction FOUR_FIFTHS;\n    public static final Fraction ONE_FIFTH;\n    public static final Fraction ONE_HALF;\n    public static final Fraction ONE_QUARTER;\n    public static final Fraction ONE_THIRD;\n    public static final Fraction THREE_FIFTHS;\n    public static final Fraction THREE_QUARTERS;\n    public static final Fraction TWO_FIFTHS;\n    public static final Fraction TWO_QUARTERS;\n    public static final Fraction TWO_THIRDS;\n    public static final Fraction MINUS_ONE;\n    private static final long serialVersionUID = 3698073679419233275L;\n    private final int denominator;\n    private final int numerator;\n    \n    public Fraction(final double value) throws FractionConversionException {\n        this(value, 1.0E-5, 100);\n    }\n    \n    public Fraction(final double value, final double epsilon, final int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n    \n    public Fraction(final double value, final int maxDenominator) throws FractionConversionException {\n        this(value, 0.0, maxDenominator, 100);\n    }\n    \n    private Fraction(final double value, final double epsilon, final int maxDenominator, final int maxIterations) throws FractionConversionException {\n        final long overflow = 2147483647L;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1L);\n        }\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int)a0;\n            this.denominator = 1;\n            return;\n        }\n        long p0 = 1L;\n        long q0 = 0L;\n        long p2 = a0;\n        long q2 = 1L;\n        long p3 = 0L;\n        long q3 = 1L;\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            final double r2 = 1.0 / (r0 - a0);\n            final long a2 = (long)FastMath.floor(r2);\n            p3 = a2 * p2 + p0;\n            q3 = a2 * q2 + q0;\n            if (FastMath.abs(p3) > overflow || FastMath.abs(q3) > overflow) {\n                throw new FractionConversionException(value, p3, q3);\n            }\n            final double convergent = p3 / q3;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q3 < maxDenominator) {\n                p0 = p2;\n                p2 = p3;\n                q0 = q2;\n                q2 = q3;\n                a0 = a2;\n                r0 = r2;\n            }\n            else {\n                stop = true;\n            }\n        } while (!stop);\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n        if (q3 < maxDenominator) {\n            this.numerator = (int)p3;\n            this.denominator = (int)q3;\n        }\n        else {\n            this.numerator = (int)p2;\n            this.denominator = (int)q2;\n        }\n    }\n    \n    public Fraction(final int num) {\n        this(num, 1);\n    }\n    \n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, new Object[] { num, den });\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, new Object[] { num, den });\n            }\n            num = -num;\n            den = -den;\n        }\n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator = num;\n        this.denominator = den;\n    }\n    \n    public Fraction abs() {\n        Fraction ret;\n        if (this.numerator >= 0) {\n            ret = this;\n        }\n        else {\n            ret = this.negate();\n        }\n        return ret;\n    }\n    \n    public int compareTo(final Fraction object) {\n        final long nOd = this.numerator * object.denominator;\n        final long dOn = this.denominator * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? 1 : 0);\n    }\n    \n    public double doubleValue() {\n        return this.numerator / this.denominator;\n    }\n    \n    public boolean equals(final Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            final Fraction rhs = (Fraction)other;\n            return this.numerator == rhs.numerator && this.denominator == rhs.denominator;\n        }\n        return false;\n    }\n    \n    public float floatValue() {\n        return (float)this.doubleValue();\n    }\n    \n    public int getDenominator() {\n        return this.denominator;\n    }\n    \n    public int getNumerator() {\n        return this.numerator;\n    }\n    \n    public int hashCode() {\n        return 37 * (629 + this.numerator) + this.denominator;\n    }\n    \n    public int intValue() {\n        return (int)this.doubleValue();\n    }\n    \n    public long longValue() {\n        return (long)this.doubleValue();\n    }\n    \n    public Fraction negate() {\n        if (this.numerator == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, new Object[] { this.numerator, this.denominator });\n        }\n        return new Fraction(-this.numerator, this.denominator);\n    }\n    \n    public Fraction reciprocal() {\n        return new Fraction(this.denominator, this.numerator);\n    }\n    \n    public Fraction add(final Fraction fraction) {\n        return this.addSub(fraction, true);\n    }\n    \n    public Fraction add(final int i) {\n        return new Fraction(this.numerator + i * this.denominator, this.denominator);\n    }\n    \n    public Fraction subtract(final Fraction fraction) {\n        return this.addSub(fraction, false);\n    }\n    \n    public Fraction subtract(final int i) {\n        return new Fraction(this.numerator - i * this.denominator, this.denominator);\n    }\n    \n    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION, new Object[0]);\n        }\n        if (this.numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }\n        final int d1 = ArithmeticUtils.gcd(this.denominator, fraction.denominator);\n        if (d1 == 1) {\n            final int uvp = ArithmeticUtils.mulAndCheck(this.numerator, fraction.denominator);\n            final int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, this.denominator);\n            return new Fraction(isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) : ArithmeticUtils.subAndCheck(uvp, upv), ArithmeticUtils.mulAndCheck(this.denominator, fraction.denominator));\n        }\n        final BigInteger uvp2 = BigInteger.valueOf(this.numerator).multiply(BigInteger.valueOf(fraction.denominator / d1));\n        final BigInteger upv2 = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(this.denominator / d1));\n        final BigInteger t = isAdd ? uvp2.add(upv2) : uvp2.subtract(upv2);\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = (tmodd1 == 0) ? d1 : ArithmeticUtils.gcd(tmodd1, d1);\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY, new Object[] { w });\n        }\n        return new Fraction(w.intValue(), ArithmeticUtils.mulAndCheck(this.denominator / d1, fraction.denominator / d2));\n    }\n    \n    public Fraction multiply(final Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION, new Object[0]);\n        }\n        if (this.numerator == 0 || fraction.numerator == 0) {\n            return Fraction.ZERO;\n        }\n        final int d1 = ArithmeticUtils.gcd(this.numerator, fraction.denominator);\n        final int d2 = ArithmeticUtils.gcd(fraction.numerator, this.denominator);\n        return getReducedFraction(ArithmeticUtils.mulAndCheck(this.numerator / d1, fraction.numerator / d2), ArithmeticUtils.mulAndCheck(this.denominator / d2, fraction.denominator / d1));\n    }\n    \n    public Fraction multiply(final int i) {\n        return new Fraction(this.numerator * i, this.denominator);\n    }\n    \n    public Fraction divide(final Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION, new Object[0]);\n        }\n        if (fraction.numerator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY, new Object[] { fraction.numerator, fraction.denominator });\n        }\n        return this.multiply(fraction.reciprocal());\n    }\n    \n    public Fraction divide(final int i) {\n        return new Fraction(this.numerator, this.denominator * i);\n    }\n    \n    public double percentageValue() {\n        return 100.0 * this.doubleValue();\n    }\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, new Object[] { numerator, denominator });\n        }\n        if (numerator == 0) {\n            return Fraction.ZERO;\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 0x1) == 0x0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, new Object[] { numerator, denominator });\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        final int gcd = ArithmeticUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n    \n    public String toString() {\n        String str = null;\n        if (this.denominator == 1) {\n            str = Integer.toString(this.numerator);\n        }\n        else if (this.numerator == 0) {\n            str = \"0\";\n        }\n        else {\n            str = this.numerator + \" / \" + this.denominator;\n        }\n        return str;\n    }\n    \n    public FractionField getField() {\n        return FractionField.getInstance();\n    }\n    \n    static {\n        TWO = new Fraction(2, 1);\n        ONE = new Fraction(1, 1);\n        ZERO = new Fraction(0, 1);\n        FOUR_FIFTHS = new Fraction(4, 5);\n        ONE_FIFTH = new Fraction(1, 5);\n        ONE_HALF = new Fraction(1, 2);\n        ONE_QUARTER = new Fraction(1, 4);\n        ONE_THIRD = new Fraction(1, 3);\n        THREE_FIFTHS = new Fraction(3, 5);\n        THREE_QUARTERS = new Fraction(3, 4);\n        TWO_FIFTHS = new Fraction(2, 5);\n        TWO_QUARTERS = new Fraction(2, 4);\n        TWO_THIRDS = new Fraction(2, 3);\n        MINUS_ONE = new Fraction(-1, 1);\n    }\n}\n",
        "token_number_zeroshot": 2774,
        "token_number_fewshot": 3172,
        "token_number_cot": 2884
    },
    {
        "project_name": "commons-math",
        "class": "HypergeometricDistribution",
        "source_code": "package org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.random.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.util.*;\n\npublic class HypergeometricDistribution extends AbstractIntegerDistribution\n{\n    private static final long serialVersionUID = -436928820673516179L;\n    private final int numberOfSuccesses;\n    private final int populationSize;\n    private final int sampleSize;\n    private double numericalVariance;\n    private boolean numericalVarianceIsCalculated;\n    \n    public HypergeometricDistribution(final int populationSize, final int numberOfSuccesses, final int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        this(new Well19937c(), populationSize, numberOfSuccesses, sampleSize);\n    }\n    \n    public HypergeometricDistribution(final RandomGenerator rng, final int populationSize, final int numberOfSuccesses, final int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        super(rng);\n        this.numericalVariance = Double.NaN;\n        this.numericalVarianceIsCalculated = false;\n        if (populationSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE, populationSize);\n        }\n        if (numberOfSuccesses < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES, numberOfSuccesses);\n        }\n        if (sampleSize < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\n        }\n        if (numberOfSuccesses > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE, numberOfSuccesses, populationSize, true);\n        }\n        if (sampleSize > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE, sampleSize, populationSize, true);\n        }\n        this.numberOfSuccesses = numberOfSuccesses;\n        this.populationSize = populationSize;\n        this.sampleSize = sampleSize;\n    }\n    \n    public double cumulativeProbability(final int x) {\n        final int[] domain = this.getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);\n        double ret;\n        if (x < domain[0]) {\n            ret = 0.0;\n        }\n        else if (x >= domain[1]) {\n            ret = 1.0;\n        }\n        else {\n            ret = this.innerCumulativeProbability(domain[0], x, 1);\n        }\n        return ret;\n    }\n    \n    private int[] getDomain(final int n, final int m, final int k) {\n        return new int[] { this.getLowerDomain(n, m, k), this.getUpperDomain(m, k) };\n    }\n    \n    private int getLowerDomain(final int n, final int m, final int k) {\n        return FastMath.max(0, m - (n - k));\n    }\n    \n    public int getNumberOfSuccesses() {\n        return this.numberOfSuccesses;\n    }\n    \n    public int getPopulationSize() {\n        return this.populationSize;\n    }\n    \n    public int getSampleSize() {\n        return this.sampleSize;\n    }\n    \n    private int getUpperDomain(final int m, final int k) {\n        return FastMath.min(k, m);\n    }\n    \n    public double probability(final int x) {\n        final int[] domain = this.getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);\n        double ret;\n        if (x < domain[0] || x > domain[1]) {\n            ret = 0.0;\n        }\n        else {\n            final double p = this.sampleSize / this.populationSize;\n            final double q = (this.populationSize - this.sampleSize) / this.populationSize;\n            final double p2 = SaddlePointExpansion.logBinomialProbability(x, this.numberOfSuccesses, p, q);\n            final double p3 = SaddlePointExpansion.logBinomialProbability(this.sampleSize - x, this.populationSize - this.numberOfSuccesses, p, q);\n            final double p4 = SaddlePointExpansion.logBinomialProbability(this.sampleSize, this.populationSize, p, q);\n            ret = FastMath.exp(p2 + p3 - p4);\n        }\n        return ret;\n    }\n    \n    public double upperCumulativeProbability(final int x) {\n        final int[] domain = this.getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);\n        double ret;\n        if (x <= domain[0]) {\n            ret = 1.0;\n        }\n        else if (x > domain[1]) {\n            ret = 0.0;\n        }\n        else {\n            ret = this.innerCumulativeProbability(domain[1], x, -1);\n        }\n        return ret;\n    }\n    \n    private double innerCumulativeProbability(int x0, final int x1, final int dx) {\n        double ret;\n        for (ret = this.probability(x0); x0 != x1; x0 += dx, ret += this.probability(x0)) {}\n        return ret;\n    }\n    \n    public double getNumericalMean() {\n        return this.getSampleSize() * this.getNumberOfSuccesses() / this.getPopulationSize();\n    }\n    \n    public double getNumericalVariance() {\n        if (!this.numericalVarianceIsCalculated) {\n            this.numericalVariance = this.calculateNumericalVariance();\n            this.numericalVarianceIsCalculated = true;\n        }\n        return this.numericalVariance;\n    }\n    \n    protected double calculateNumericalVariance() {\n        final double N = this.getPopulationSize();\n        final double m = this.getNumberOfSuccesses();\n        final double n = this.getSampleSize();\n        return n * m * (N - n) * (N - m) / (N * N * (N - 1.0));\n    }\n    \n    public int getSupportLowerBound() {\n        return FastMath.max(0, this.getSampleSize() + this.getNumberOfSuccesses() - this.getPopulationSize());\n    }\n    \n    public int getSupportUpperBound() {\n        return FastMath.min(this.getNumberOfSuccesses(), this.getSampleSize());\n    }\n    \n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n",
        "token_number_zeroshot": 1384,
        "token_number_fewshot": 1782,
        "token_number_cot": 1497
    },
    {
        "project_name": "commons-math",
        "class": "EmbeddedRungeKuttaIntegrator",
        "source_code": "package org.apache.commons.math3.ode.nonstiff;\n\nimport org.apache.commons.math3.ode.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.ode.sampling.*;\nimport org.apache.commons.math3.exception.*;\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator\n{\n    private final boolean fsal;\n    private final double[] c;\n    private final double[][] a;\n    private final double[] b;\n    private final RungeKuttaStepInterpolator prototype;\n    private final double exp;\n    private double safety;\n    private double minReduction;\n    private double maxGrowth;\n    \n    protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n        super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n        this.fsal = fsal;\n        this.c = c;\n        this.a = a;\n        this.b = b;\n        this.prototype = prototype;\n        this.exp = -1.0 / this.getOrder();\n        this.setSafety(0.9);\n        this.setMinReduction(0.2);\n        this.setMaxGrowth(10.0);\n    }\n    \n    protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n        super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n        this.fsal = fsal;\n        this.c = c;\n        this.a = a;\n        this.b = b;\n        this.prototype = prototype;\n        this.exp = -1.0 / this.getOrder();\n        this.setSafety(0.9);\n        this.setMinReduction(0.2);\n        this.setMaxGrowth(10.0);\n    }\n    \n    public abstract int getOrder();\n    \n    public double getSafety() {\n        return this.safety;\n    }\n    \n    public void setSafety(final double safety) {\n        this.safety = safety;\n    }\n    \n    public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {\n        this.sanityChecks(equations, t);\n        this.setEquations(equations);\n        final boolean forward = t > equations.getTime();\n        final double[] y0 = equations.getCompleteState();\n        final double[] y2 = y0.clone();\n        final int stages = this.c.length + 1;\n        final double[][] yDotK = new double[stages][y2.length];\n        final double[] yTmp = y0.clone();\n        final double[] yDotTmp = new double[y2.length];\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator)this.prototype.copy();\n        interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n        interpolator.storeTime(equations.getTime());\n        this.stepStart = equations.getTime();\n        double hNew = 0.0;\n        boolean firstTime = true;\n        this.initIntegration(equations.getTime(), y0, t);\n        this.isLastStep = false;\n        do {\n            interpolator.shift();\n            double error = 10.0;\n            while (error >= 1.0) {\n                if (firstTime || !this.fsal) {\n                    this.computeDerivatives(this.stepStart, y2, yDotK[0]);\n                }\n                if (firstTime) {\n                    final double[] scale = new double[this.mainSetDimension];\n                    if (this.vecAbsoluteTolerance == null) {\n                        for (int i = 0; i < scale.length; ++i) {\n                            scale[i] = this.scalAbsoluteTolerance + this.scalRelativeTolerance * FastMath.abs(y2[i]);\n                        }\n                    }\n                    else {\n                        for (int i = 0; i < scale.length; ++i) {\n                            scale[i] = this.vecAbsoluteTolerance[i] + this.vecRelativeTolerance[i] * FastMath.abs(y2[i]);\n                        }\n                    }\n                    hNew = this.initializeStep(forward, this.getOrder(), scale, this.stepStart, y2, yDotK[0], yTmp, yDotK[1]);\n                    firstTime = false;\n                }\n                this.stepSize = hNew;\n                if (forward) {\n                    if (this.stepStart + this.stepSize >= t) {\n                        this.stepSize = t - this.stepStart;\n                    }\n                }\n                else if (this.stepStart + this.stepSize <= t) {\n                    this.stepSize = t - this.stepStart;\n                }\n                for (int k = 1; k < stages; ++k) {\n                    for (int j = 0; j < y0.length; ++j) {\n                        double sum = this.a[k - 1][0] * yDotK[0][j];\n                        for (int l = 1; l < k; ++l) {\n                            sum += this.a[k - 1][l] * yDotK[l][j];\n                        }\n                        yTmp[j] = y2[j] + this.stepSize * sum;\n                    }\n                    this.computeDerivatives(this.stepStart + this.c[k - 1] * this.stepSize, yTmp, yDotK[k]);\n                }\n                for (int m = 0; m < y0.length; ++m) {\n                    double sum2 = this.b[0] * yDotK[0][m];\n                    for (int l2 = 1; l2 < stages; ++l2) {\n                        sum2 += this.b[l2] * yDotK[l2][m];\n                    }\n                    yTmp[m] = y2[m] + this.stepSize * sum2;\n                }\n                error = this.estimateError(yDotK, y2, yTmp, this.stepSize);\n                if (error >= 1.0) {\n                    final double factor = FastMath.min(this.maxGrowth, FastMath.max(this.minReduction, this.safety * FastMath.pow(error, this.exp)));\n                    hNew = this.filterStep(this.stepSize * factor, forward, false);\n                }\n            }\n            interpolator.storeTime(this.stepStart + this.stepSize);\n            System.arraycopy(yTmp, 0, y2, 0, y0.length);\n            System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n            this.stepStart = this.acceptStep(interpolator, y2, yDotTmp, t);\n            System.arraycopy(y2, 0, yTmp, 0, y2.length);\n            if (!this.isLastStep) {\n                interpolator.storeTime(this.stepStart);\n                if (this.fsal) {\n                    System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n                }\n                final double factor = FastMath.min(this.maxGrowth, FastMath.max(this.minReduction, this.safety * FastMath.pow(error, this.exp)));\n                final double scaledH = this.stepSize * factor;\n                final double nextT = this.stepStart + scaledH;\n                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n                hNew = this.filterStep(scaledH, forward, nextIsLast);\n                final double filteredNextT = this.stepStart + hNew;\n                final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n                if (!filteredNextIsLast) {\n                    continue;\n                }\n                hNew = t - this.stepStart;\n            }\n        } while (!this.isLastStep);\n        equations.setTime(this.stepStart);\n        equations.setCompleteState(y2);\n        this.resetInternalState();\n    }\n    \n    public double getMinReduction() {\n        return this.minReduction;\n    }\n    \n    public void setMinReduction(final double minReduction) {\n        this.minReduction = minReduction;\n    }\n    \n    public double getMaxGrowth() {\n        return this.maxGrowth;\n    }\n    \n    public void setMaxGrowth(final double maxGrowth) {\n        this.maxGrowth = maxGrowth;\n    }\n    \n    protected abstract double estimateError(final double[][] p0, final double[] p1, final double[] p2, final double p3);\n}\n",
        "token_number_zeroshot": 1898,
        "token_number_fewshot": 2296,
        "token_number_cot": 2014
    },
    {
        "project_name": "commons-math",
        "class": "DfpDec",
        "source_code": "package org.apache.commons.math3.dfp;\n\npublic class DfpDec extends Dfp\n{\n    protected DfpDec(final DfpField factory) {\n        super(factory);\n    }\n    \n    protected DfpDec(final DfpField factory, final byte x) {\n        super(factory, x);\n    }\n    \n    protected DfpDec(final DfpField factory, final int x) {\n        super(factory, x);\n    }\n    \n    protected DfpDec(final DfpField factory, final long x) {\n        super(factory, x);\n    }\n    \n    protected DfpDec(final DfpField factory, final double x) {\n        super(factory, x);\n        this.round(0);\n    }\n    \n    public DfpDec(final Dfp d) {\n        super(d);\n        this.round(0);\n    }\n    \n    protected DfpDec(final DfpField factory, final String s) {\n        super(factory, s);\n        this.round(0);\n    }\n    \n    protected DfpDec(final DfpField factory, final byte sign, final byte nans) {\n        super(factory, sign, nans);\n    }\n    \n    public Dfp newInstance() {\n        return new DfpDec(this.getField());\n    }\n    \n    public Dfp newInstance(final byte x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final int x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final long x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final double x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final Dfp d) {\n        if (this.getField().getRadixDigits() != d.getField().getRadixDigits()) {\n            this.getField().setIEEEFlagsBits(1);\n            final Dfp result = this.newInstance(this.getZero());\n            result.nans = 3;\n            return this.dotrap(1, \"newInstance\", d, result);\n        }\n        return new DfpDec(d);\n    }\n    \n    public Dfp newInstance(final String s) {\n        return new DfpDec(this.getField(), s);\n    }\n    \n    public Dfp newInstance(final byte sign, final byte nans) {\n        return new DfpDec(this.getField(), sign, nans);\n    }\n    \n    protected int getDecimalDigits() {\n        return this.getRadixDigits() * 4 - 3;\n    }\n    \n    protected int round(final int in) {\n        final int msb = this.mant[this.mant.length - 1];\n        if (msb == 0) {\n            return 0;\n        }\n        int cmaxdigits = this.mant.length * 4;\n        for (int lsbthreshold = 1000; lsbthreshold > msb; lsbthreshold /= 10, --cmaxdigits) {}\n        final int digits = this.getDecimalDigits();\n        final int lsbshift = cmaxdigits - digits;\n        final int lsd = lsbshift / 4;\n        int lsbthreshold = 1;\n        for (int i = 0; i < lsbshift % 4; ++i) {\n            lsbthreshold *= 10;\n        }\n        final int lsb = this.mant[lsd];\n        if (lsbthreshold <= 1 && digits == 4 * this.mant.length - 3) {\n            return super.round(in);\n        }\n        int n;\n        int discarded;\n        if (lsbthreshold == 1) {\n            n = this.mant[lsd - 1] / 1000 % 10;\n            final int[] mant = this.mant;\n            final int n2 = lsd - 1;\n            mant[n2] %= 1000;\n            discarded = (in | this.mant[lsd - 1]);\n        }\n        else {\n            n = lsb * 10 / lsbthreshold % 10;\n            discarded = (in | lsb % (lsbthreshold / 10));\n        }\n        for (int j = 0; j < lsd; ++j) {\n            discarded |= this.mant[j];\n            this.mant[j] = 0;\n        }\n        this.mant[lsd] = lsb / lsbthreshold * lsbthreshold;\n        boolean inc = false;\n        switch (this.getField().getRoundingMode()) {\n            case ROUND_DOWN: {\n                inc = false;\n                break;\n            }\n            case ROUND_UP: {\n                inc = (n != 0 || discarded != 0);\n                break;\n            }\n            case ROUND_HALF_UP: {\n                inc = (n >= 5);\n                break;\n            }\n            case ROUND_HALF_DOWN: {\n                inc = (n > 5);\n                break;\n            }\n            case ROUND_HALF_EVEN: {\n                inc = (n > 5 || (n == 5 && discarded != 0) || (n == 5 && discarded == 0 && (lsb / lsbthreshold & 0x1) == 0x1));\n                break;\n            }\n            case ROUND_HALF_ODD: {\n                inc = (n > 5 || (n == 5 && discarded != 0) || (n == 5 && discarded == 0 && (lsb / lsbthreshold & 0x1) == 0x0));\n                break;\n            }\n            case ROUND_CEIL: {\n                inc = (this.sign == 1 && (n != 0 || discarded != 0));\n                break;\n            }\n            default: {\n                inc = (this.sign == -1 && (n != 0 || discarded != 0));\n                break;\n            }\n        }\n        if (inc) {\n            int rh = lsbthreshold;\n            for (int k = lsd; k < this.mant.length; ++k) {\n                final int r = this.mant[k] + rh;\n                rh = r / 10000;\n                this.mant[k] = r % 10000;\n            }\n            if (rh != 0) {\n                this.shiftRight();\n                this.mant[this.mant.length - 1] = rh;\n            }\n        }\n        if (this.exp < -32767) {\n            this.getField().setIEEEFlagsBits(8);\n            return 8;\n        }\n        if (this.exp > 32768) {\n            this.getField().setIEEEFlagsBits(4);\n            return 4;\n        }\n        if (n != 0 || discarded != 0) {\n            this.getField().setIEEEFlagsBits(16);\n            return 16;\n        }\n        return 0;\n    }\n    \n    public Dfp nextAfter(final Dfp x) {\n        final String trapName = \"nextAfter\";\n        if (this.getField().getRadixDigits() != x.getField().getRadixDigits()) {\n            this.getField().setIEEEFlagsBits(1);\n            final Dfp result = this.newInstance(this.getZero());\n            result.nans = 3;\n            return this.dotrap(1, \"nextAfter\", x, result);\n        }\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n        if (this.equals(x)) {\n            return this.newInstance(x);\n        }\n        if (this.lessThan(this.getZero())) {\n            up = !up;\n        }\n        Dfp result2;\n        if (up) {\n            Dfp inc = this.power10(this.intLog10() - this.getDecimalDigits() + 1);\n            inc = Dfp.copysign(inc, this);\n            if (this.equals(this.getZero())) {\n                inc = this.power10K(-32767 - this.mant.length - 1);\n            }\n            if (inc.equals(this.getZero())) {\n                result2 = Dfp.copysign(this.newInstance(this.getZero()), this);\n            }\n            else {\n                result2 = this.add(inc);\n            }\n        }\n        else {\n            Dfp inc = this.power10(this.intLog10());\n            inc = Dfp.copysign(inc, this);\n            if (this.equals(inc)) {\n                inc = inc.divide(this.power10(this.getDecimalDigits()));\n            }\n            else {\n                inc = inc.divide(this.power10(this.getDecimalDigits() - 1));\n            }\n            if (this.equals(this.getZero())) {\n                inc = this.power10K(-32767 - this.mant.length - 1);\n            }\n            if (inc.equals(this.getZero())) {\n                result2 = Dfp.copysign(this.newInstance(this.getZero()), this);\n            }\n            else {\n                result2 = this.subtract(inc);\n            }\n        }\n        if (result2.classify() == 1 && this.classify() != 1) {\n            this.getField().setIEEEFlagsBits(16);\n            result2 = this.dotrap(16, \"nextAfter\", x, result2);\n        }\n        if (result2.equals(this.getZero()) && !this.equals(this.getZero())) {\n            this.getField().setIEEEFlagsBits(16);\n            result2 = this.dotrap(16, \"nextAfter\", x, result2);\n        }\n        return result2;\n    }\n}\n",
        "token_number_zeroshot": 1986,
        "token_number_fewshot": 2384,
        "token_number_cot": 2098
    },
    {
        "project_name": "commons-math",
        "class": "BrentOptimizer",
        "source_code": "package org.apache.commons.math3.optim.univariate;\n\nimport org.apache.commons.math3.optim.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.optim.nonlinear.scalar.*;\nimport org.apache.commons.math3.util.*;\n\npublic class BrentOptimizer extends UnivariateOptimizer\n{\n    private static final double GOLDEN_SECTION;\n    private static final double MIN_RELATIVE_TOLERANCE;\n    private final double relativeThreshold;\n    private final double absoluteThreshold;\n    \n    public BrentOptimizer(final double rel, final double abs, final ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n        if (rel < BrentOptimizer.MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, BrentOptimizer.MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0.0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        this.relativeThreshold = rel;\n        this.absoluteThreshold = abs;\n    }\n    \n    public BrentOptimizer(final double rel, final double abs) {\n        this(rel, abs, null);\n    }\n    \n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = this.getGoalType() == GoalType.MINIMIZE;\n        final double lo = this.getMin();\n        final double mid = this.getStartValue();\n        final double hi = this.getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker = this.getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        }\n        else {\n            a = hi;\n            b = lo;\n        }\n        double v;\n        double w;\n        double x = w = (v = mid);\n        double d = 0.0;\n        double e = 0.0;\n        double fx = this.computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair best;\n        UnivariatePointValuePair current = best = new UnivariatePointValuePair(x, isMinim ? fx : (-fx));\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = this.relativeThreshold * FastMath.abs(x) + this.absoluteThreshold;\n            final double tol2 = 2.0 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                return this.best(best, this.best(previous, current, isMinim), isMinim);\n            }\n            double p = 0.0;\n            double q = 0.0;\n            double r = 0.0;\n            double u = 0.0;\n            if (FastMath.abs(e) > tol1) {\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2.0 * (q - r);\n                if (q > 0.0) {\n                    p = -p;\n                }\n                else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    d = p / q;\n                    u = x + d;\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        }\n                        else {\n                            d = -tol1;\n                        }\n                    }\n                }\n                else {\n                    if (x < m) {\n                        e = b - x;\n                    }\n                    else {\n                        e = a - x;\n                    }\n                    d = BrentOptimizer.GOLDEN_SECTION * e;\n                }\n            }\n            else {\n                if (x < m) {\n                    e = b - x;\n                }\n                else {\n                    e = a - x;\n                }\n                d = BrentOptimizer.GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0.0) {\n                    u = x + tol1;\n                }\n                else {\n                    u = x - tol1;\n                }\n            }\n            else {\n                u = x + d;\n            }\n            double fu = this.computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : (-fu));\n            best = this.best(best, this.best(previous, current, isMinim), isMinim);\n            if (checker != null && checker.converged(iter, previous, current)) {\n                return best;\n            }\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                }\n                else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            }\n            else {\n                if (u < x) {\n                    a = u;\n                }\n                else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                }\n                else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n            ++iter;\n        }\n    }\n    \n    private UnivariatePointValuePair best(final UnivariatePointValuePair a, final UnivariatePointValuePair b, final boolean isMinim) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n        if (isMinim) {\n            return (a.getValue() <= b.getValue()) ? a : b;\n        }\n        return (a.getValue() >= b.getValue()) ? a : b;\n    }\n    \n    static {\n        GOLDEN_SECTION = 0.5 * (3.0 - FastMath.sqrt(5.0));\n        MIN_RELATIVE_TOLERANCE = 2.0 * FastMath.ulp(1.0);\n    }\n}\n",
        "token_number_zeroshot": 1432,
        "token_number_fewshot": 1830,
        "token_number_cot": 1543
    },
    {
        "project_name": "commons-math",
        "class": "MathUtils",
        "source_code": "package org.apache.commons.math3.util;\n\nimport java.util.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.exception.*;\n\npublic final class MathUtils\n{\n    public static final double TWO_PI = 6.283185307179586;\n    \n    public static int hash(final double value) {\n        return new Double(value).hashCode();\n    }\n    \n    public static int hash(final double[] value) {\n        return Arrays.hashCode(value);\n    }\n    \n    public static double normalizeAngle(final double a, final double center) {\n        return a - 6.283185307179586 * FastMath.floor((a + 3.141592653589793 - center) / 6.283185307179586);\n    }\n    \n    public static double reduce(final double a, final double period, final double offset) {\n        final double p = FastMath.abs(period);\n        return a - p * FastMath.floor((a - offset) / p) - offset;\n    }\n    \n    public static byte copySign(final byte magnitude, final byte sign) throws MathArithmeticException {\n        if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n            return magnitude;\n        }\n        if (sign >= 0 && magnitude == -128) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return (byte)(-magnitude);\n    }\n    \n    public static short copySign(final short magnitude, final short sign) throws MathArithmeticException {\n        if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n            return magnitude;\n        }\n        if (sign >= 0 && magnitude == -32768) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return (short)(-magnitude);\n    }\n    \n    public static int copySign(final int magnitude, final int sign) throws MathArithmeticException {\n        if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n            return magnitude;\n        }\n        if (sign >= 0 && magnitude == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return -magnitude;\n    }\n    \n    public static long copySign(final long magnitude, final long sign) throws MathArithmeticException {\n        if ((magnitude >= 0L && sign >= 0L) || (magnitude < 0L && sign < 0L)) {\n            return magnitude;\n        }\n        if (sign >= 0L && magnitude == Long.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return -magnitude;\n    }\n    \n    public static void checkFinite(final double x) throws NotFiniteNumberException {\n        if (Double.isInfinite(x) || Double.isNaN(x)) {\n            throw new NotFiniteNumberException(x, new Object[0]);\n        }\n    }\n    \n    public static void checkFinite(final double[] val) throws NotFiniteNumberException {\n        for (int i = 0; i < val.length; ++i) {\n            final double x = val[i];\n            if (Double.isInfinite(x) || Double.isNaN(x)) {\n                throw new NotFiniteNumberException(LocalizedFormats.ARRAY_ELEMENT, x, new Object[] { i });\n            }\n        }\n    }\n    \n    public static void checkNotNull(final Object o, final Localizable pattern, final Object... args) throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException(pattern, args);\n        }\n    }\n    \n    public static void checkNotNull(final Object o) throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n}\n",
        "token_number_zeroshot": 848,
        "token_number_fewshot": 1246,
        "token_number_cot": 959
    },
    {
        "project_name": "commons-math",
        "class": "AbstractIntegrator",
        "source_code": "package org.apache.commons.math3.ode;\n\nimport org.apache.commons.math3.ode.events.*;\nimport org.apache.commons.math3.analysis.solvers.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.ode.sampling.*;\nimport java.util.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.util.*;\n\npublic abstract class AbstractIntegrator implements FirstOrderIntegrator\n{\n    protected Collection<StepHandler> stepHandlers;\n    protected double stepStart;\n    protected double stepSize;\n    protected boolean isLastStep;\n    protected boolean resetOccurred;\n    private Collection<EventState> eventsStates;\n    private boolean statesInitialized;\n    private final String name;\n    private Incrementor evaluations;\n    private transient ExpandableStatefulODE expandable;\n    \n    public AbstractIntegrator(final String name) {\n        this.name = name;\n        this.stepHandlers = new ArrayList<StepHandler>();\n        this.stepStart = Double.NaN;\n        this.stepSize = Double.NaN;\n        this.eventsStates = new ArrayList<EventState>();\n        this.statesInitialized = false;\n        this.evaluations = new Incrementor();\n        this.setMaxEvaluations(-1);\n        this.evaluations.resetCount();\n    }\n    \n    protected AbstractIntegrator() {\n        this(null);\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n    \n    public void addStepHandler(final StepHandler handler) {\n        this.stepHandlers.add(handler);\n    }\n    \n    public Collection<StepHandler> getStepHandlers() {\n        return Collections.unmodifiableCollection((Collection<? extends StepHandler>)this.stepHandlers);\n    }\n    \n    public void clearStepHandlers() {\n        this.stepHandlers.clear();\n    }\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        this.addEventHandler(handler, maxCheckInterval, convergence, maxIterationCount, new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateSolver solver) {\n        this.eventsStates.add(new EventState(handler, maxCheckInterval, convergence, maxIterationCount, solver));\n    }\n    \n    public Collection<EventHandler> getEventHandlers() {\n        final List<EventHandler> list = new ArrayList<EventHandler>();\n        for (final EventState state : this.eventsStates) {\n            list.add(state.getEventHandler());\n        }\n        return Collections.unmodifiableCollection((Collection<? extends EventHandler>)list);\n    }\n    \n    public void clearEventHandlers() {\n        this.eventsStates.clear();\n    }\n    \n    public double getCurrentStepStart() {\n        return this.stepStart;\n    }\n    \n    public double getCurrentSignedStepsize() {\n        return this.stepSize;\n    }\n    \n    public void setMaxEvaluations(final int maxEvaluations) {\n        this.evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n    \n    public int getMaxEvaluations() {\n        return this.evaluations.getMaximalCount();\n    }\n    \n    public int getEvaluations() {\n        return this.evaluations.getCount();\n    }\n    \n    protected void initIntegration(final double t0, final double[] y0, final double t) {\n        this.evaluations.resetCount();\n        for (final EventState state : this.eventsStates) {\n            state.getEventHandler().init(t0, y0, t);\n        }\n        for (final StepHandler handler : this.stepHandlers) {\n            handler.init(t0, y0, t);\n        }\n        this.setStateInitialized(false);\n    }\n    \n    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n    \n    protected ExpandableStatefulODE getExpandable() {\n        return this.expandable;\n    }\n    \n    protected Incrementor getEvaluationsCounter() {\n        return this.evaluations;\n    }\n    \n    public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n        this.integrate(expandableODE, t);\n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n    }\n    \n    public abstract void integrate(final ExpandableStatefulODE p0, final double p1) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException;\n    \n    public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException {\n        this.evaluations.incrementCount();\n        this.expandable.computeDerivatives(t, y, yDot);\n    }\n    \n    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n    \n    protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n        if (!this.statesInitialized) {\n            for (final EventState state : this.eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            this.statesInitialized = true;\n        }\n        final int orderingSign = interpolator.isForward() ? 1 : -1;\n        final SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n            public int compare(final EventState es0, final EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n        });\n        for (final EventState state2 : this.eventsStates) {\n            if (state2.evaluateStep(interpolator)) {\n                occuringEvents.add(state2);\n            }\n        }\n        while (!occuringEvents.isEmpty()) {\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventYPrimary = interpolator.getInterpolatedState().clone();\n            final double[] eventYComplete = new double[y.length];\n            this.expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(), eventYComplete);\n            int index = 0;\n            for (final EquationsMapper secondary : this.expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++), eventYComplete);\n            }\n            for (final EventState state3 : this.eventsStates) {\n                state3.stepAccepted(eventT, eventYPrimary);\n                this.isLastStep = (this.isLastStep || state3.stop());\n            }\n            for (final StepHandler handler : this.stepHandlers) {\n                handler.handleStep(interpolator, this.isLastStep);\n            }\n            if (this.isLastStep) {\n                System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                return eventT;\n            }\n            boolean needReset = false;\n            for (final EventState state4 : this.eventsStates) {\n                needReset = (needReset || state4.reset(eventT, eventYComplete));\n            }\n            if (needReset) {\n                interpolator.setInterpolatedTime(eventT);\n                System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                this.computeDerivatives(eventT, y, yDot);\n                this.resetOccurred = true;\n                return eventT;\n            }\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n            if (!currentEvent.evaluateStep(interpolator)) {\n                continue;\n            }\n            occuringEvents.add(currentEvent);\n        }\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state5 : this.eventsStates) {\n            state5.stepAccepted(currentT, currentY);\n            this.isLastStep = (this.isLastStep || state5.stop());\n        }\n        this.isLastStep = (this.isLastStep || Precision.equals(currentT, tEnd, 1));\n        for (final StepHandler handler2 : this.stepHandlers) {\n            handler2.handleStep(interpolator, this.isLastStep);\n        }\n        return currentT;\n    }\n    \n    protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException {\n        final double threshold = 1000.0 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()), FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL, dt, threshold, false);\n        }\n    }\n}\n",
        "token_number_zeroshot": 2087,
        "token_number_fewshot": 2485,
        "token_number_cot": 2199
    },
    {
        "project_name": "commons-math",
        "class": "SimplexTableau",
        "source_code": "package org.apache.commons.math3.optimization.linear;\n\nimport org.apache.commons.math3.optimization.*;\nimport java.util.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.linear.*;\nimport java.io.*;\n\nclass SimplexTableau implements Serializable\n{\n    private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\";\n    private static final int DEFAULT_ULPS = 10;\n    private static final double CUTOFF_THRESHOLD = 1.0E-12;\n    private static final long serialVersionUID = -1369660067587938365L;\n    private final LinearObjectiveFunction f;\n    private final List<LinearConstraint> constraints;\n    private final boolean restrictToNonNegative;\n    private final List<String> columnLabels;\n    private transient RealMatrix tableau;\n    private final int numDecisionVariables;\n    private final int numSlackVariables;\n    private int numArtificialVariables;\n    private final double epsilon;\n    private final int maxUlps;\n    \n    SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {\n        this(f, constraints, goalType, restrictToNonNegative, epsilon, 10);\n    }\n    \n    SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon, final int maxUlps) {\n        this.columnLabels = new ArrayList<String>();\n        this.f = f;\n        this.constraints = this.normalizeConstraints(constraints);\n        this.restrictToNonNegative = restrictToNonNegative;\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n        this.numDecisionVariables = f.getCoefficients().getDimension() + (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables = this.getConstraintTypeCounts(Relationship.LEQ) + this.getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = this.getConstraintTypeCounts(Relationship.EQ) + this.getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = this.createTableau(goalType == GoalType.MAXIMIZE);\n        this.initializeColumnLabels();\n    }\n    \n    protected void initializeColumnLabels() {\n        if (this.getNumObjectiveFunctions() == 2) {\n            this.columnLabels.add(\"W\");\n        }\n        this.columnLabels.add(\"Z\");\n        for (int i = 0; i < this.getOriginalNumDecisionVariables(); ++i) {\n            this.columnLabels.add(\"x\" + i);\n        }\n        if (!this.restrictToNonNegative) {\n            this.columnLabels.add(\"x-\");\n        }\n        for (int i = 0; i < this.getNumSlackVariables(); ++i) {\n            this.columnLabels.add(\"s\" + i);\n        }\n        for (int i = 0; i < this.getNumArtificialVariables(); ++i) {\n            this.columnLabels.add(\"a\" + i);\n        }\n        this.columnLabels.add(\"RHS\");\n    }\n    \n    protected RealMatrix createTableau(final boolean maximize) {\n        final int width = this.numDecisionVariables + this.numSlackVariables + this.numArtificialVariables + this.getNumObjectiveFunctions() + 1;\n        final int height = this.constraints.size() + this.getNumObjectiveFunctions();\n        final Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n        if (this.getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1.0);\n        }\n        final int zIndex = (this.getNumObjectiveFunctions() != 1) ? 1 : 0;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1.0 : -1.0);\n        final RealVector objectiveCoefficients = maximize ? this.f.getCoefficients().mapMultiply(-1.0) : this.f.getCoefficients();\n        this.copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1, maximize ? this.f.getConstantTerm() : (-1.0 * this.f.getConstantTerm()));\n        if (!this.restrictToNonNegative) {\n            matrix.setEntry(zIndex, this.getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients));\n        }\n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < this.constraints.size(); ++i) {\n            final LinearConstraint constraint = this.constraints.get(i);\n            final int row = this.getNumObjectiveFunctions() + i;\n            this.copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n            if (!this.restrictToNonNegative) {\n                matrix.setEntry(row, this.getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n            matrix.setEntry(row, width - 1, constraint.getValue());\n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, this.getSlackVariableOffset() + slackVar++, 1.0);\n            }\n            else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, this.getSlackVariableOffset() + slackVar++, -1.0);\n            }\n            if (constraint.getRelationship() == Relationship.EQ || constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(0, this.getArtificialVariableOffset() + artificialVar, 1.0);\n                matrix.setEntry(row, this.getArtificialVariableOffset() + artificialVar++, 1.0);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n        return matrix;\n    }\n    \n    public List<LinearConstraint> normalizeConstraints(final Collection<LinearConstraint> originalConstraints) {\n        final List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (final LinearConstraint constraint : originalConstraints) {\n            normalized.add(this.normalize(constraint));\n        }\n        return normalized;\n    }\n    \n    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0.0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1.0), constraint.getRelationship().oppositeRelationship(), -1.0 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());\n    }\n    \n    protected final int getNumObjectiveFunctions() {\n        return (this.numArtificialVariables > 0) ? 2 : 1;\n    }\n    \n    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : this.constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }\n    \n    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n        double sum = 0.0;\n        for (final double coefficient : coefficients.toArray()) {\n            sum -= coefficient;\n        }\n        return sum;\n    }\n    \n    protected Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = 0; i < this.getHeight(); ++i) {\n            final double entry = this.getEntry(i, col);\n            if (Precision.equals(entry, 1.0, this.maxUlps) && row == null) {\n                row = i;\n            }\n            else if (!Precision.equals(entry, 0.0, this.maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }\n    \n    protected void dropPhase1Objective() {\n        if (this.getNumObjectiveFunctions() == 1) {\n            return;\n        }\n        final Set<Integer> columnsToDrop = new TreeSet<Integer>();\n        columnsToDrop.add(0);\n        for (int i = this.getNumObjectiveFunctions(); i < this.getArtificialVariableOffset(); ++i) {\n            final double entry = this.tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0.0, this.epsilon) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n        for (int i = 0; i < this.getNumArtificialVariables(); ++i) {\n            final int col = i + this.getArtificialVariableOffset();\n            if (this.getBasicRow(col) == null) {\n                columnsToDrop.add(col);\n            }\n        }\n        final double[][] matrix = new double[this.getHeight() - 1][this.getWidth() - columnsToDrop.size()];\n        for (int j = 1; j < this.getHeight(); ++j) {\n            int col2 = 0;\n            for (int k = 0; k < this.getWidth(); ++k) {\n                if (!columnsToDrop.contains(k)) {\n                    matrix[j - 1][col2++] = this.tableau.getEntry(j, k);\n                }\n            }\n        }\n        final Integer[] drop = columnsToDrop.toArray(new Integer[columnsToDrop.size()]);\n        for (int l = drop.length - 1; l >= 0; --l) {\n            this.columnLabels.remove((int)drop[l]);\n        }\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n    \n    private void copyArray(final double[] src, final double[] dest) {\n        System.arraycopy(src, 0, dest, this.getNumObjectiveFunctions(), src.length);\n    }\n    \n    boolean isOptimal() {\n        for (int i = this.getNumObjectiveFunctions(); i < this.getWidth() - 1; ++i) {\n            final double entry = this.tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0.0, this.epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected PointValuePair getSolution() {\n        final int negativeVarColumn = this.columnLabels.indexOf(\"x-\");\n        final Integer negativeVarBasicRow = (negativeVarColumn > 0) ? this.getBasicRow(negativeVarColumn) : null;\n        final double mostNegative = (negativeVarBasicRow == null) ? 0.0 : this.getEntry(negativeVarBasicRow, this.getRhsOffset());\n        final Set<Integer> basicRows = new HashSet<Integer>();\n        final double[] coefficients = new double[this.getOriginalNumDecisionVariables()];\n        for (int i = 0; i < coefficients.length; ++i) {\n            final int colIndex = this.columnLabels.indexOf(\"x\" + i);\n            if (colIndex < 0) {\n                coefficients[i] = 0.0;\n            }\n            else {\n                final Integer basicRow = this.getBasicRow(colIndex);\n                if (basicRow != null && basicRow == 0) {\n                    coefficients[i] = 0.0;\n                }\n                else if (basicRows.contains(basicRow)) {\n                    coefficients[i] = 0.0 - (this.restrictToNonNegative ? 0.0 : mostNegative);\n                }\n                else {\n                    basicRows.add(basicRow);\n                    coefficients[i] = ((basicRow == null) ? 0.0 : this.getEntry(basicRow, this.getRhsOffset())) - (this.restrictToNonNegative ? 0.0 : mostNegative);\n                }\n            }\n        }\n        return new PointValuePair(coefficients, this.f.getValue(coefficients));\n    }\n    \n    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < this.getWidth(); ++j) {\n            this.tableau.setEntry(dividendRow, j, this.tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }\n    \n    protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {\n        for (int i = 0; i < this.getWidth(); ++i) {\n            double result = this.tableau.getEntry(minuendRow, i) - this.tableau.getEntry(subtrahendRow, i) * multiple;\n            if (FastMath.abs(result) < 1.0E-12) {\n                result = 0.0;\n            }\n            this.tableau.setEntry(minuendRow, i, result);\n        }\n    }\n    \n    protected final int getWidth() {\n        return this.tableau.getColumnDimension();\n    }\n    \n    protected final int getHeight() {\n        return this.tableau.getRowDimension();\n    }\n    \n    protected final double getEntry(final int row, final int column) {\n        return this.tableau.getEntry(row, column);\n    }\n    \n    protected final void setEntry(final int row, final int column, final double value) {\n        this.tableau.setEntry(row, column, value);\n    }\n    \n    protected final int getSlackVariableOffset() {\n        return this.getNumObjectiveFunctions() + this.numDecisionVariables;\n    }\n    \n    protected final int getArtificialVariableOffset() {\n        return this.getNumObjectiveFunctions() + this.numDecisionVariables + this.numSlackVariables;\n    }\n    \n    protected final int getRhsOffset() {\n        return this.getWidth() - 1;\n    }\n    \n    protected final int getNumDecisionVariables() {\n        return this.numDecisionVariables;\n    }\n    \n    protected final int getOriginalNumDecisionVariables() {\n        return this.f.getCoefficients().getDimension();\n    }\n    \n    protected final int getNumSlackVariables() {\n        return this.numSlackVariables;\n    }\n    \n    protected final int getNumArtificialVariables() {\n        return this.numArtificialVariables;\n    }\n    \n    protected final double[][] getData() {\n        return this.tableau.getData();\n    }\n    \n    public boolean equals(final Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof SimplexTableau) {\n            final SimplexTableau rhs = (SimplexTableau)other;\n            return this.restrictToNonNegative == rhs.restrictToNonNegative && this.numDecisionVariables == rhs.numDecisionVariables && this.numSlackVariables == rhs.numSlackVariables && this.numArtificialVariables == rhs.numArtificialVariables && this.epsilon == rhs.epsilon && this.maxUlps == rhs.maxUlps && this.f.equals(rhs.f) && this.constraints.equals(rhs.constraints) && this.tableau.equals(rhs.tableau);\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        return Boolean.valueOf(this.restrictToNonNegative).hashCode() ^ this.numDecisionVariables ^ this.numSlackVariables ^ this.numArtificialVariables ^ Double.valueOf(this.epsilon).hashCode() ^ this.maxUlps ^ this.f.hashCode() ^ this.constraints.hashCode() ^ this.tableau.hashCode();\n    }\n    \n    private void writeObject(final ObjectOutputStream oos) throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(this.tableau, oos);\n    }\n    \n    private void readObject(final ObjectInputStream ois) throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }\n}\n",
        "token_number_zeroshot": 3226,
        "token_number_fewshot": 3624,
        "token_number_cot": 3339
    },
    {
        "project_name": "commons-math",
        "class": "RectangularCholeskyDecomposition",
        "source_code": "package org.apache.commons.math3.linear;\n\nimport org.apache.commons.math3.util.*;\n\npublic class RectangularCholeskyDecomposition\n{\n    private final RealMatrix root;\n    private int rank;\n    \n    public RectangularCholeskyDecomposition(final RealMatrix matrix) throws NonPositiveDefiniteMatrixException {\n        this(matrix, 0.0);\n    }\n    \n    public RectangularCholeskyDecomposition(final RealMatrix matrix, final double small) throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n        final int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        boolean loop = true;\n        while (loop) {\n            int swapR = r;\n            for (int j = r + 1; j < order; ++j) {\n                final int ii = index[j];\n                final int isr = index[swapR];\n                if (c[ii][ii] > c[isr][isr]) {\n                    swapR = j;\n                }\n            }\n            if (swapR != r) {\n                final int tmpIndex = index[r];\n                index[r] = index[swapR];\n                index[swapR] = tmpIndex;\n                final double[] tmpRow = b[r];\n                b[r] = b[swapR];\n                b[swapR] = tmpRow;\n            }\n            final int ir = index[r];\n            if (c[ir][ir] <= small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n                for (int k = r; k < order; ++k) {\n                    if (c[index[k]][index[k]] < -small) {\n                        throw new NonPositiveDefiniteMatrixException(c[index[k]][index[k]], k, small);\n                    }\n                }\n                loop = false;\n            }\n            else {\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse = 1.0 / sqrt;\n                final double inverse2 = 1.0 / c[ir][ir];\n                for (int l = r + 1; l < order; ++l) {\n                    final int ii2 = index[l];\n                    final double e = inverse * c[ii2][ir];\n                    b[l][r] = e;\n                    final double[] array = c[ii2];\n                    final int n = ii2;\n                    array[n] -= c[ii2][ir] * c[ii2][ir] * inverse2;\n                    for (int m = r + 1; m < l; ++m) {\n                        final int ij = index[m];\n                        final double f = c[ii2][ij] - e * b[m][r];\n                        c[ii2][ij] = f;\n                        c[ij][ii2] = f;\n                    }\n                }\n                loop = (++r < order);\n            }\n        }\n        this.rank = r;\n        this.root = MatrixUtils.createRealMatrix(order, r);\n        for (int i2 = 0; i2 < order; ++i2) {\n            for (int j2 = 0; j2 < r; ++j2) {\n                this.root.setEntry(index[i2], j2, b[i2][j2]);\n            }\n        }\n    }\n    \n    public RealMatrix getRootMatrix() {\n        return this.root;\n    }\n    \n    public int getRank() {\n        return this.rank;\n    }\n}\n",
        "token_number_zeroshot": 828,
        "token_number_fewshot": 1226,
        "token_number_cot": 945
    },
    {
        "project_name": "commons-math",
        "class": "ProperFractionFormat",
        "source_code": "package org.apache.commons.math3.fraction;\n\nimport java.text.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.exception.util.*;\n\npublic class ProperFractionFormat extends FractionFormat\n{\n    private static final long serialVersionUID = 760934726031766749L;\n    private NumberFormat wholeFormat;\n    \n    public ProperFractionFormat() {\n        this(FractionFormat.getDefaultNumberFormat());\n    }\n    \n    public ProperFractionFormat(final NumberFormat format) {\n        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n    }\n    \n    public ProperFractionFormat(final NumberFormat wholeFormat, final NumberFormat numeratorFormat, final NumberFormat denominatorFormat) {\n        super(numeratorFormat, denominatorFormat);\n        this.setWholeFormat(wholeFormat);\n    }\n    \n    public StringBuffer format(final Fraction fraction, final StringBuffer toAppendTo, final FieldPosition pos) {\n        pos.setBeginIndex(0);\n        pos.setEndIndex(0);\n        int num = fraction.getNumerator();\n        final int den = fraction.getDenominator();\n        final int whole = num / den;\n        num %= den;\n        if (whole != 0) {\n            this.getWholeFormat().format(whole, toAppendTo, pos);\n            toAppendTo.append(' ');\n            num = Math.abs(num);\n        }\n        this.getNumeratorFormat().format(num, toAppendTo, pos);\n        toAppendTo.append(\" / \");\n        this.getDenominatorFormat().format(den, toAppendTo, pos);\n        return toAppendTo;\n    }\n    \n    public NumberFormat getWholeFormat() {\n        return this.wholeFormat;\n    }\n    \n    public Fraction parse(final String source, final ParsePosition pos) {\n        final Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        final int initialIndex = pos.getIndex();\n        AbstractFormat.parseAndIgnoreWhitespace(source, pos);\n        final Number whole = this.getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        AbstractFormat.parseAndIgnoreWhitespace(source, pos);\n        final Number num = this.getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        if (num.intValue() < 0) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        final int startIndex = pos.getIndex();\n        final char c = AbstractFormat.parseNextCharacter(source, pos);\n        switch (c) {\n            case '\\0': {\n                return new Fraction(num.intValue(), 1);\n            }\n            case '/': {\n                AbstractFormat.parseAndIgnoreWhitespace(source, pos);\n                final Number den = this.getDenominatorFormat().parse(source, pos);\n                if (den == null) {\n                    pos.setIndex(initialIndex);\n                    return null;\n                }\n                if (den.intValue() < 0) {\n                    pos.setIndex(initialIndex);\n                    return null;\n                }\n                final int w = whole.intValue();\n                final int n = num.intValue();\n                final int d = den.intValue();\n                return new Fraction((Math.abs(w) * d + n) * MathUtils.copySign(1, w), d);\n            }\n            default: {\n                pos.setIndex(initialIndex);\n                pos.setErrorIndex(startIndex);\n                return null;\n            }\n        }\n    }\n    \n    public void setWholeFormat(final NumberFormat format) {\n        if (format == null) {\n            throw new NullArgumentException(LocalizedFormats.WHOLE_FORMAT, new Object[0]);\n        }\n        this.wholeFormat = format;\n    }\n}\n",
        "token_number_zeroshot": 802,
        "token_number_fewshot": 1200,
        "token_number_cot": 914
    },
    {
        "project_name": "commons-math",
        "class": "SchurTransformer",
        "source_code": "package org.apache.commons.math3.linear;\n\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.exception.util.*;\n\nclass SchurTransformer\n{\n    private static final int MAX_ITERATIONS = 100;\n    private final double[][] matrixP;\n    private final double[][] matrixT;\n    private RealMatrix cachedP;\n    private RealMatrix cachedT;\n    private RealMatrix cachedPt;\n    private final double epsilon;\n    \n    public SchurTransformer(final RealMatrix matrix) {\n        this.epsilon = Precision.EPSILON;\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n        final HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n        this.matrixT = transformer.getH().getData();\n        this.matrixP = transformer.getP().getData();\n        this.cachedT = null;\n        this.cachedP = null;\n        this.cachedPt = null;\n        this.transform();\n    }\n    \n    public RealMatrix getP() {\n        if (this.cachedP == null) {\n            this.cachedP = MatrixUtils.createRealMatrix(this.matrixP);\n        }\n        return this.cachedP;\n    }\n    \n    public RealMatrix getPT() {\n        if (this.cachedPt == null) {\n            this.cachedPt = this.getP().transpose();\n        }\n        return this.cachedPt;\n    }\n    \n    public RealMatrix getT() {\n        if (this.cachedT == null) {\n            this.cachedT = MatrixUtils.createRealMatrix(this.matrixT);\n        }\n        return this.cachedT;\n    }\n    \n    private void transform() {\n        final int n = this.matrixT.length;\n        final double norm = this.getNorm();\n        final ShiftInfo shift = new ShiftInfo();\n        int iteration = 0;\n        int iu = n - 1;\n        while (iu >= 0) {\n            final int il = this.findSmallSubDiagonalElement(iu, norm);\n            if (il == iu) {\n                this.matrixT[iu][iu] += shift.exShift;\n                --iu;\n                iteration = 0;\n            }\n            else if (il == iu - 1) {\n                double p = (this.matrixT[iu - 1][iu - 1] - this.matrixT[iu][iu]) / 2.0;\n                double q = p * p + this.matrixT[iu][iu - 1] * this.matrixT[iu - 1][iu];\n                final double[] array = this.matrixT[iu];\n                final int n2 = iu;\n                array[n2] += shift.exShift;\n                final double[] array2 = this.matrixT[iu - 1];\n                final int n3 = iu - 1;\n                array2[n3] += shift.exShift;\n                if (q >= 0.0) {\n                    double z = FastMath.sqrt(FastMath.abs(q));\n                    if (p >= 0.0) {\n                        z += p;\n                    }\n                    else {\n                        z = p - z;\n                    }\n                    final double x = this.matrixT[iu][iu - 1];\n                    final double s = FastMath.abs(x) + FastMath.abs(z);\n                    p = x / s;\n                    q = z / s;\n                    final double r = FastMath.sqrt(p * p + q * q);\n                    p /= r;\n                    q /= r;\n                    for (int j = iu - 1; j < n; ++j) {\n                        z = this.matrixT[iu - 1][j];\n                        this.matrixT[iu - 1][j] = q * z + p * this.matrixT[iu][j];\n                        this.matrixT[iu][j] = q * this.matrixT[iu][j] - p * z;\n                    }\n                    for (int i = 0; i <= iu; ++i) {\n                        z = this.matrixT[i][iu - 1];\n                        this.matrixT[i][iu - 1] = q * z + p * this.matrixT[i][iu];\n                        this.matrixT[i][iu] = q * this.matrixT[i][iu] - p * z;\n                    }\n                    for (int i = 0; i <= n - 1; ++i) {\n                        z = this.matrixP[i][iu - 1];\n                        this.matrixP[i][iu - 1] = q * z + p * this.matrixP[i][iu];\n                        this.matrixP[i][iu] = q * this.matrixP[i][iu] - p * z;\n                    }\n                }\n                iu -= 2;\n                iteration = 0;\n            }\n            else {\n                this.computeShift(il, iu, iteration, shift);\n                if (++iteration > 100) {\n                    throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED, 100, new Object[0]);\n                }\n                final double[] hVec = new double[3];\n                final int im = this.initQRStep(il, iu, shift, hVec);\n                this.performDoubleQRStep(il, im, iu, shift, hVec);\n            }\n        }\n    }\n    \n    private double getNorm() {\n        double norm = 0.0;\n        for (int i = 0; i < this.matrixT.length; ++i) {\n            for (int j = FastMath.max(i - 1, 0); j < this.matrixT.length; ++j) {\n                norm += FastMath.abs(this.matrixT[i][j]);\n            }\n        }\n        return norm;\n    }\n    \n    private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n        int l;\n        for (l = startIdx; l > 0; --l) {\n            double s = FastMath.abs(this.matrixT[l - 1][l - 1]) + FastMath.abs(this.matrixT[l][l]);\n            if (s == 0.0) {\n                s = norm;\n            }\n            if (FastMath.abs(this.matrixT[l][l - 1]) < this.epsilon * s) {\n                break;\n            }\n        }\n        return l;\n    }\n    \n    private void computeShift(final int l, final int idx, final int iteration, final ShiftInfo shift) {\n        shift.x = this.matrixT[idx][idx];\n        final double n = 0.0;\n        shift.w = n;\n        shift.y = n;\n        if (l < idx) {\n            shift.y = this.matrixT[idx - 1][idx - 1];\n            shift.w = this.matrixT[idx][idx - 1] * this.matrixT[idx - 1][idx];\n        }\n        if (iteration == 10) {\n            shift.exShift += shift.x;\n            for (int i = 0; i <= idx; ++i) {\n                final double[] array = this.matrixT[i];\n                final int n2 = i;\n                array[n2] -= shift.x;\n            }\n            final double s = FastMath.abs(this.matrixT[idx][idx - 1]) + FastMath.abs(this.matrixT[idx - 1][idx - 2]);\n            shift.x = 0.75 * s;\n            shift.y = 0.75 * s;\n            shift.w = -0.4375 * s * s;\n        }\n        if (iteration == 30) {\n            double s = (shift.y - shift.x) / 2.0;\n            s = s * s + shift.w;\n            if (s > 0.0) {\n                s = FastMath.sqrt(s);\n                if (shift.y < shift.x) {\n                    s = -s;\n                }\n                s = shift.x - shift.w / ((shift.y - shift.x) / 2.0 + s);\n                for (int j = 0; j <= idx; ++j) {\n                    final double[] array2 = this.matrixT[j];\n                    final int n3 = j;\n                    array2[n3] -= s;\n                }\n                shift.exShift += s;\n                final double x = 0.964;\n                shift.w = x;\n                shift.y = x;\n                shift.x = x;\n            }\n        }\n    }\n    \n    private int initQRStep(final int il, final int iu, final ShiftInfo shift, final double[] hVec) {\n        int im;\n        for (im = iu - 2; im >= il; --im) {\n            final double z = this.matrixT[im][im];\n            final double r = shift.x - z;\n            final double s = shift.y - z;\n            hVec[0] = (r * s - shift.w) / this.matrixT[im + 1][im] + this.matrixT[im][im + 1];\n            hVec[1] = this.matrixT[im + 1][im + 1] - z - r - s;\n            hVec[2] = this.matrixT[im + 2][im + 1];\n            if (im == il) {\n                break;\n            }\n            final double lhs = FastMath.abs(this.matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(this.matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(this.matrixT[im + 1][im + 1]));\n            if (lhs < this.epsilon * rhs) {\n                break;\n            }\n        }\n        return im;\n    }\n    \n    private void performDoubleQRStep(final int il, final int im, final int iu, final ShiftInfo shift, final double[] hVec) {\n        final int n = this.matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n        for (int k = im; k <= iu - 1; ++k) {\n            final boolean notlast = k != iu - 1;\n            if (k != im) {\n                p = this.matrixT[k][k - 1];\n                q = this.matrixT[k + 1][k - 1];\n                r = (notlast ? this.matrixT[k + 2][k - 1] : 0.0);\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, this.epsilon)) {\n                    p /= shift.x;\n                    q /= shift.x;\n                    r /= shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    this.matrixT[k][k - 1] = -s * shift.x;\n                }\n                else if (il != im) {\n                    this.matrixT[k][k - 1] = -this.matrixT[k][k - 1];\n                }\n                p += s;\n                shift.x = p / s;\n                shift.y = q / s;\n                final double z = r / s;\n                q /= p;\n                r /= p;\n                for (int j = k; j < n; ++j) {\n                    p = this.matrixT[k][j] + q * this.matrixT[k + 1][j];\n                    if (notlast) {\n                        p += r * this.matrixT[k + 2][j];\n                        this.matrixT[k + 2][j] -= p * z;\n                    }\n                    this.matrixT[k][j] -= p * shift.x;\n                    this.matrixT[k + 1][j] -= p * shift.y;\n                }\n                for (int i = 0; i <= FastMath.min(iu, k + 3); ++i) {\n                    p = shift.x * this.matrixT[i][k] + shift.y * this.matrixT[i][k + 1];\n                    if (notlast) {\n                        p += z * this.matrixT[i][k + 2];\n                        this.matrixT[i][k + 2] -= p * r;\n                    }\n                    this.matrixT[i][k] -= p;\n                    this.matrixT[i][k + 1] -= p * q;\n                }\n                for (int high = this.matrixT.length - 1, l = 0; l <= high; ++l) {\n                    p = shift.x * this.matrixP[l][k] + shift.y * this.matrixP[l][k + 1];\n                    if (notlast) {\n                        p += z * this.matrixP[l][k + 2];\n                        this.matrixP[l][k + 2] -= p * r;\n                    }\n                    this.matrixP[l][k] -= p;\n                    this.matrixP[l][k + 1] -= p * q;\n                }\n            }\n        }\n        for (int m = im + 2; m <= iu; ++m) {\n            this.matrixT[m][m - 2] = 0.0;\n            if (m > im + 2) {\n                this.matrixT[m][m - 3] = 0.0;\n            }\n        }\n    }\n    \n    private static class ShiftInfo\n    {\n        double x;\n        double y;\n        double w;\n        double exShift;\n    }\n}\n",
        "token_number_zeroshot": 2942,
        "token_number_fewshot": 3340,
        "token_number_cot": 3054
    },
    {
        "project_name": "commons-math",
        "class": "MultivariateNormalMixtureExpectationMaximization",
        "source_code": "package org.apache.commons.math3.distribution.fitting;\n\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.distribution.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.linear.*;\nimport org.apache.commons.math3.exception.*;\nimport java.util.*;\nimport org.apache.commons.math3.stat.correlation.*;\n\npublic class MultivariateNormalMixtureExpectationMaximization\n{\n    private static final int DEFAULT_MAX_ITERATIONS = 1000;\n    private static final double DEFAULT_THRESHOLD = 1.0E-5;\n    private final double[][] data;\n    private MixtureMultivariateNormalDistribution fittedModel;\n    private double logLikelihood;\n    \n    public MultivariateNormalMixtureExpectationMaximization(final double[][] data) throws NotStrictlyPositiveException, DimensionMismatchException, NumberIsTooSmallException {\n        this.logLikelihood = 0.0;\n        if (data.length < 1) {\n            throw new NotStrictlyPositiveException(data.length);\n        }\n        this.data = new double[data.length][data[0].length];\n        for (int i = 0; i < data.length; ++i) {\n            if (data[i].length != data[0].length) {\n                throw new DimensionMismatchException(data[i].length, data[0].length);\n            }\n            if (data[i].length < 2) {\n                throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_TOO_SMALL, data[i].length, 2, true);\n            }\n            this.data[i] = MathArrays.copyOf(data[i], data[i].length);\n        }\n    }\n    \n    public void fit(final MixtureMultivariateNormalDistribution initialMixture, final int maxIterations, final double threshold) throws SingularMatrixException, NotStrictlyPositiveException, DimensionMismatchException {\n        if (maxIterations < 1) {\n            throw new NotStrictlyPositiveException(maxIterations);\n        }\n        if (threshold < Double.MIN_VALUE) {\n            throw new NotStrictlyPositiveException(threshold);\n        }\n        final int n = this.data.length;\n        final int numCols = this.data[0].length;\n        final int k = initialMixture.getComponents().size();\n        final int numMeanColumns = initialMixture.getComponents().get(0).getSecond().getMeans().length;\n        if (numMeanColumns != numCols) {\n            throw new DimensionMismatchException(numMeanColumns, numCols);\n        }\n        int numIterations = 0;\n        double previousLogLikelihood = 0.0;\n        this.logLikelihood = Double.NEGATIVE_INFINITY;\n        this.fittedModel = new MixtureMultivariateNormalDistribution(initialMixture.getComponents());\n        while (numIterations++ <= maxIterations && Math.abs(previousLogLikelihood - this.logLikelihood) > threshold) {\n            previousLogLikelihood = this.logLikelihood;\n            double sumLogLikelihood = 0.0;\n            final List<Pair<Double, MultivariateNormalDistribution>> components = this.fittedModel.getComponents();\n            final double[] weights = new double[k];\n            final MultivariateNormalDistribution[] mvns = new MultivariateNormalDistribution[k];\n            for (int j = 0; j < k; ++j) {\n                weights[j] = components.get(j).getFirst();\n                mvns[j] = components.get(j).getSecond();\n            }\n            final double[][] gamma = new double[n][k];\n            final double[] gammaSums = new double[k];\n            final double[][] gammaDataProdSums = new double[k][numCols];\n            for (int i = 0; i < n; ++i) {\n                final double rowDensity = this.fittedModel.density(this.data[i]);\n                sumLogLikelihood += Math.log(rowDensity);\n                for (int l = 0; l < k; ++l) {\n                    gamma[i][l] = weights[l] * mvns[l].density(this.data[i]) / rowDensity;\n                    final double[] array = gammaSums;\n                    final int n2 = l;\n                    array[n2] += gamma[i][l];\n                    for (int col = 0; col < numCols; ++col) {\n                        final double[] array2 = gammaDataProdSums[l];\n                        final int n3 = col;\n                        array2[n3] += gamma[i][l] * this.data[i][col];\n                    }\n                }\n            }\n            this.logLikelihood = sumLogLikelihood / n;\n            final double[] newWeights = new double[k];\n            final double[][] newMeans = new double[k][numCols];\n            for (int m = 0; m < k; ++m) {\n                newWeights[m] = gammaSums[m] / n;\n                for (int col2 = 0; col2 < numCols; ++col2) {\n                    newMeans[m][col2] = gammaDataProdSums[m][col2] / gammaSums[m];\n                }\n            }\n            final RealMatrix[] newCovMats = new RealMatrix[k];\n            for (int l = 0; l < k; ++l) {\n                newCovMats[l] = new Array2DRowRealMatrix(numCols, numCols);\n            }\n            for (int i2 = 0; i2 < n; ++i2) {\n                for (int j2 = 0; j2 < k; ++j2) {\n                    final RealMatrix vec = new Array2DRowRealMatrix(MathArrays.ebeSubtract(this.data[i2], newMeans[j2]));\n                    final RealMatrix dataCov = vec.multiply(vec.transpose()).scalarMultiply(gamma[i2][j2]);\n                    newCovMats[j2] = newCovMats[j2].add(dataCov);\n                }\n            }\n            final double[][][] newCovMatArrays = new double[k][numCols][numCols];\n            for (int j2 = 0; j2 < k; ++j2) {\n                newCovMats[j2] = newCovMats[j2].scalarMultiply(1.0 / gammaSums[j2]);\n                newCovMatArrays[j2] = newCovMats[j2].getData();\n            }\n            this.fittedModel = new MixtureMultivariateNormalDistribution(newWeights, newMeans, newCovMatArrays);\n        }\n        if (Math.abs(previousLogLikelihood - this.logLikelihood) > threshold) {\n            throw new ConvergenceException();\n        }\n    }\n    \n    public void fit(final MixtureMultivariateNormalDistribution initialMixture) throws SingularMatrixException, NotStrictlyPositiveException {\n        this.fit(initialMixture, 1000, 1.0E-5);\n    }\n    \n    public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {\n        if (data.length < 2) {\n            throw new NotStrictlyPositiveException(data.length);\n        }\n        if (numComponents < 2) {\n            throw new NumberIsTooSmallException(numComponents, 2, true);\n        }\n        if (numComponents > data.length) {\n            throw new NumberIsTooLargeException(numComponents, data.length, true);\n        }\n        final int numRows = data.length;\n        final int numCols = data[0].length;\n        final DataRow[] sortedData = new DataRow[numRows];\n        for (int i = 0; i < numRows; ++i) {\n            sortedData[i] = new DataRow(data[i]);\n        }\n        Arrays.sort(sortedData);\n        final double weight = 1.0 / numComponents;\n        final List<Pair<Double, MultivariateNormalDistribution>> components = new ArrayList<Pair<Double, MultivariateNormalDistribution>>();\n        for (int binIndex = 0; binIndex < numComponents; ++binIndex) {\n            final int minIndex = binIndex * numRows / numComponents;\n            final int maxIndex = (binIndex + 1) * numRows / numComponents;\n            final int numBinRows = maxIndex - minIndex;\n            final double[][] binData = new double[numBinRows][numCols];\n            final double[] columnMeans = new double[numCols];\n            for (int j = minIndex, iBin = 0; j < maxIndex; ++j, ++iBin) {\n                for (int k = 0; k < numCols; ++k) {\n                    final double val = sortedData[j].getRow()[k];\n                    final double[] array = columnMeans;\n                    final int n = k;\n                    array[n] += val;\n                    binData[iBin][k] = val;\n                }\n            }\n            MathArrays.scaleInPlace(1.0 / numBinRows, columnMeans);\n            final double[][] covMat = new Covariance(binData).getCovarianceMatrix().getData();\n            final MultivariateNormalDistribution mvn = new MultivariateNormalDistribution(columnMeans, covMat);\n            components.add(new Pair<Double, MultivariateNormalDistribution>(weight, mvn));\n        }\n        return new MixtureMultivariateNormalDistribution(components);\n    }\n    \n    public double getLogLikelihood() {\n        return this.logLikelihood;\n    }\n    \n    public MixtureMultivariateNormalDistribution getFittedModel() {\n        return new MixtureMultivariateNormalDistribution(this.fittedModel.getComponents());\n    }\n    \n    private static class DataRow implements Comparable<DataRow>\n    {\n        private final double[] row;\n        private Double mean;\n        \n        DataRow(final double[] data) {\n            this.row = data;\n            this.mean = 0.0;\n            for (int i = 0; i < data.length; ++i) {\n                this.mean += data[i];\n            }\n            this.mean /= (Double)data.length;\n        }\n        \n        public int compareTo(final DataRow other) {\n            return this.mean.compareTo(other.mean);\n        }\n        \n        public boolean equals(final Object other) {\n            return this == other || (other instanceof DataRow && MathArrays.equals(this.row, ((DataRow)other).row));\n        }\n        \n        public int hashCode() {\n            return Arrays.hashCode(this.row);\n        }\n        \n        public double[] getRow() {\n            return this.row;\n        }\n    }\n}\n",
        "token_number_zeroshot": 2174,
        "token_number_fewshot": 2572,
        "token_number_cot": 2292
    },
    {
        "project_name": "twitter4j",
        "class": "ExceptionDiagnosis",
        "source_code": "package twitter4j;\n\nimport java.io.*;\n\nfinal class ExceptionDiagnosis implements Serializable\n{\n    int stackLineHash;\n    int lineNumberHash;\n    String hexString;\n    Throwable th;\n    private static final long serialVersionUID = 453958937114285988L;\n    \n    ExceptionDiagnosis(final Throwable th) {\n        this(th, new String[0]);\n    }\n    \n    ExceptionDiagnosis(final Throwable th, final String[] inclusionFilter) {\n        this.hexString = \"\";\n        this.th = th;\n        final StackTraceElement[] stackTrace = th.getStackTrace();\n        this.stackLineHash = 0;\n        this.lineNumberHash = 0;\n        for (int i = stackTrace.length - 1; i >= 0; --i) {\n            final StackTraceElement line = stackTrace[i];\n            for (final String filter : inclusionFilter) {\n                if (line.getClassName().startsWith(filter)) {\n                    final int hash = line.getClassName().hashCode() + line.getMethodName().hashCode();\n                    this.stackLineHash = 31 * this.stackLineHash + hash;\n                    this.lineNumberHash = 31 * this.lineNumberHash + line.getLineNumber();\n                    break;\n                }\n            }\n        }\n        this.hexString = this.hexString + this.toHexString(this.stackLineHash) + \"-\" + this.toHexString(this.lineNumberHash);\n        if (null != th.getCause()) {\n            this.hexString = this.hexString + \" \" + new ExceptionDiagnosis(th.getCause(), inclusionFilter).asHexString();\n        }\n    }\n    \n    int getStackLineHash() {\n        return this.stackLineHash;\n    }\n    \n    int getLineNumberHash() {\n        return this.lineNumberHash;\n    }\n    \n    String asHexString() {\n        return this.hexString;\n    }\n    \n    private String toHexString(final int value) {\n        final String str = \"0000000\" + Integer.toHexString(value);\n        return str.substring(str.length() - 8, str.length());\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final ExceptionDiagnosis that = (ExceptionDiagnosis)o;\n        return this.lineNumberHash == that.lineNumberHash && this.stackLineHash == that.stackLineHash;\n    }\n    \n    public int hashCode() {\n        int result = this.stackLineHash;\n        result = 31 * result + this.lineNumberHash;\n        return result;\n    }\n    \n    public String toString() {\n        return \"ExceptionDiagnosis{stackLineHash=\" + this.stackLineHash + \", lineNumberHash=\" + this.lineNumberHash + '}';\n    }\n}\n",
        "token_number_zeroshot": 594,
        "token_number_fewshot": 992,
        "token_number_cot": 706
    },
    {
        "project_name": "twitter4j",
        "class": "TwitterException",
        "source_code": "package twitter4j;\n\nimport twitter4j.internal.http.*;\nimport java.io.*;\n\npublic class TwitterException extends Exception implements TwitterResponse, HttpResponseCode\n{\n    private int statusCode;\n    private int retryAfter;\n    private RateLimitStatus rateLimitStatus;\n    private RateLimitStatus featureSpecificRateLimitStatus;\n    private static final long serialVersionUID = -2623309261327598087L;\n    private static final String[] FILTER;\n    boolean nested;\n    \n    public TwitterException(final String msg) {\n        super(msg);\n        this.statusCode = -1;\n        this.featureSpecificRateLimitStatus = null;\n        this.nested = false;\n        this.rateLimitStatus = null;\n    }\n    \n    public TwitterException(final Exception cause) {\n        super(cause);\n        this.statusCode = -1;\n        this.featureSpecificRateLimitStatus = null;\n        this.nested = false;\n        if (cause instanceof TwitterException) {\n            ((TwitterException)cause).setNested();\n        }\n        this.rateLimitStatus = null;\n    }\n    \n    public TwitterException(final String msg, final HttpResponse res) {\n        super(getCause(res) + \"\\n\" + msg);\n        this.statusCode = -1;\n        this.featureSpecificRateLimitStatus = null;\n        this.nested = false;\n        if (res.getStatusCode() == 420) {\n            try {\n                final String retryAfterStr = res.getResponseHeader(\"Retry-After\");\n                if (null != retryAfterStr) {\n                    this.retryAfter = Integer.valueOf(retryAfterStr);\n                }\n            }\n            catch (NumberFormatException ignore) {\n                this.retryAfter = -1;\n            }\n        }\n        this.statusCode = res.getStatusCode();\n        this.rateLimitStatus = RateLimitStatusJSONImpl.createFromResponseHeader(res);\n        this.featureSpecificRateLimitStatus = RateLimitStatusJSONImpl.createFeatureSpecificRateLimitStatusFromResponseHeader(res);\n    }\n    \n    public TwitterException(final String msg, final Exception cause) {\n        super(msg, cause);\n        this.statusCode = -1;\n        this.featureSpecificRateLimitStatus = null;\n        this.nested = false;\n    }\n    \n    public TwitterException(final String msg, final Exception cause, final int statusCode) {\n        super(msg, cause);\n        this.statusCode = -1;\n        this.featureSpecificRateLimitStatus = null;\n        this.nested = false;\n        this.statusCode = statusCode;\n    }\n    \n    public int getStatusCode() {\n        return this.statusCode;\n    }\n    \n    public RateLimitStatus getRateLimitStatus() {\n        return this.rateLimitStatus;\n    }\n    \n    public RateLimitStatus getFeatureSpecificRateLimitStatus() {\n        return this.featureSpecificRateLimitStatus;\n    }\n    \n    public int getRetryAfter() {\n        if (this.statusCode != 420) {\n            throw new IllegalStateException(\"Rate limitation is not exceeded\");\n        }\n        return this.retryAfter;\n    }\n    \n    public boolean isCausedByNetworkIssue() {\n        return this.getCause() instanceof IOException;\n    }\n    \n    public boolean exceededRateLimitation() {\n        return (this.statusCode == 400 && null != this.rateLimitStatus) || this.statusCode == 420;\n    }\n    \n    public boolean resourceNotFound() {\n        return this.statusCode == 404;\n    }\n    \n    public String getExceptionCode() {\n        return new ExceptionDiagnosis(this, TwitterException.FILTER).asHexString();\n    }\n    \n    void setNested() {\n        this.nested = true;\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final TwitterException that = (TwitterException)o;\n        if (this.retryAfter != that.retryAfter) {\n            return false;\n        }\n        if (this.statusCode != that.statusCode) {\n            return false;\n        }\n        if (this.rateLimitStatus != null) {\n            if (this.rateLimitStatus.equals(that.rateLimitStatus)) {\n                return true;\n            }\n        }\n        else if (that.rateLimitStatus == null) {\n            return true;\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        int result = this.statusCode;\n        result = 31 * result + this.retryAfter;\n        result = 31 * result + ((this.rateLimitStatus != null) ? this.rateLimitStatus.hashCode() : 0);\n        return result;\n    }\n    \n    public String toString() {\n        return \"TwitterException{\" + (this.nested ? \"\" : (\"exceptionCode=[\" + this.getExceptionCode() + \"], \")) + \"statusCode=\" + this.statusCode + \", retryAfter=\" + this.retryAfter + \", rateLimitStatus=\" + this.rateLimitStatus + \", version=\" + Version.getVersion() + '}';\n    }\n    \n    private static String getCause(final HttpResponse res) {\n        final int statusCode = res.getStatusCode();\n        String cause = null;\n        switch (statusCode) {\n            case 304: {\n                cause = \"There was no new data to return.\";\n                break;\n            }\n            case 400: {\n                cause = \"The request was invalid.  An accompanying error message will explain why. This is the status code will be returned during rate limiting.\";\n                break;\n            }\n            case 401: {\n                cause = \"Authentication credentials were missing or incorrect.\";\n                break;\n            }\n            case 403: {\n                cause = \"The request is understood, but it has been refused.  An accompanying error message will explain why.\";\n                break;\n            }\n            case 404: {\n                cause = \"The URI requested is invalid or the resource requested, such as a user, does not exists.\";\n                break;\n            }\n            case 406: {\n                cause = \"Returned by the Search API when an invalid format is specified in the request.\";\n                break;\n            }\n            case 420: {\n                cause = \"The number of requests you have made exceeds the quota afforded by your assigned rate limit.\";\n                break;\n            }\n            case 500: {\n                cause = \"Something is broken.  Please post to the group so the Twitter team can investigate.\";\n                break;\n            }\n            case 502: {\n                cause = \"Twitter is down or being upgraded.\";\n                break;\n            }\n            case 503: {\n                cause = \"Service Unavailable: The Twitter servers are up, but overloaded with requests. Try again later. The search and trend methods use this to indicate when you are being rate limited.\";\n                break;\n            }\n            default: {\n                cause = \"\";\n                break;\n            }\n        }\n        return statusCode + \":\" + cause;\n    }\n    \n    static {\n        FILTER = new String[] { \"twitter4j\" };\n    }\n}\n",
        "token_number_zeroshot": 1414,
        "token_number_fewshot": 1812,
        "token_number_cot": 1525
    },
    {
        "project_name": "twitter4j",
        "class": "GeoQuery",
        "source_code": "package twitter4j;\n\nimport java.io.*;\nimport twitter4j.internal.http.*;\nimport java.util.*;\n\npublic final class GeoQuery implements Serializable\n{\n    private GeoLocation location;\n    private String ip;\n    private String accuracy;\n    private String granularity;\n    private int maxResults;\n    public static final String NEIGHBORHOOD = \"neighborhood\";\n    public static final String CITY = \"city\";\n    private static final long serialVersionUID = 927081526936169802L;\n    \n    public GeoQuery(final GeoLocation location) {\n        this.location = location;\n        this.ip = null;\n    }\n    \n    public GeoQuery(final String ip) {\n        this.ip = ip;\n        this.location = null;\n    }\n    \n    public GeoLocation getLocation() {\n        return this.location;\n    }\n    \n    public String getIp() {\n        return this.ip;\n    }\n    \n    public String getAccuracy() {\n        return this.accuracy;\n    }\n    \n    public void setAccuracy(final String accuracy) {\n        this.accuracy = accuracy;\n    }\n    \n    public GeoQuery accuracy(final String accuracy) {\n        this.setAccuracy(accuracy);\n        return this;\n    }\n    \n    public String getGranularity() {\n        return this.granularity;\n    }\n    \n    public void setGranularity(final String granularity) {\n        this.granularity = granularity;\n    }\n    \n    public GeoQuery granularity(final String granularity) {\n        this.setGranularity(granularity);\n        return this;\n    }\n    \n    public int getMaxResults() {\n        return this.maxResults;\n    }\n    \n    public void setMaxResults(final int maxResults) {\n        this.maxResults = maxResults;\n    }\n    \n    public GeoQuery maxResults(final int maxResults) {\n        this.setMaxResults(maxResults);\n        return this;\n    }\n    \n    HttpParameter[] asHttpParameterArray() {\n        final ArrayList<HttpParameter> params = new ArrayList<HttpParameter>();\n        if (null != this.location) {\n            this.appendParameter(\"lat\", this.location.getLatitude(), params);\n            this.appendParameter(\"long\", this.location.getLongitude(), params);\n        }\n        if (null != this.ip) {\n            this.appendParameter(\"ip\", this.ip, params);\n        }\n        this.appendParameter(\"accuracy\", this.accuracy, params);\n        this.appendParameter(\"granularity\", this.granularity, params);\n        this.appendParameter(\"max_results\", this.maxResults, params);\n        final HttpParameter[] paramArray = new HttpParameter[params.size()];\n        return params.toArray(paramArray);\n    }\n    \n    private void appendParameter(final String name, final String value, final List<HttpParameter> params) {\n        if (null != value) {\n            params.add(new HttpParameter(name, value));\n        }\n    }\n    \n    private void appendParameter(final String name, final int value, final List<HttpParameter> params) {\n        if (0 < value) {\n            params.add(new HttpParameter(name, String.valueOf(value)));\n        }\n    }\n    \n    private void appendParameter(final String name, final double value, final List<HttpParameter> params) {\n        params.add(new HttpParameter(name, String.valueOf(value)));\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final GeoQuery geoQuery = (GeoQuery)o;\n        if (this.maxResults != geoQuery.maxResults) {\n            return false;\n        }\n        Label_0075: {\n            if (this.accuracy != null) {\n                if (this.accuracy.equals(geoQuery.accuracy)) {\n                    break Label_0075;\n                }\n            }\n            else if (geoQuery.accuracy == null) {\n                break Label_0075;\n            }\n            return false;\n        }\n        Label_0108: {\n            if (this.granularity != null) {\n                if (this.granularity.equals(geoQuery.granularity)) {\n                    break Label_0108;\n                }\n            }\n            else if (geoQuery.granularity == null) {\n                break Label_0108;\n            }\n            return false;\n        }\n        Label_0141: {\n            if (this.ip != null) {\n                if (this.ip.equals(geoQuery.ip)) {\n                    break Label_0141;\n                }\n            }\n            else if (geoQuery.ip == null) {\n                break Label_0141;\n            }\n            return false;\n        }\n        if (this.location != null) {\n            if (this.location.equals(geoQuery.location)) {\n                return true;\n            }\n        }\n        else if (geoQuery.location == null) {\n            return true;\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        int result = (this.location != null) ? this.location.hashCode() : 0;\n        result = 31 * result + ((this.ip != null) ? this.ip.hashCode() : 0);\n        result = 31 * result + ((this.accuracy != null) ? this.accuracy.hashCode() : 0);\n        result = 31 * result + ((this.granularity != null) ? this.granularity.hashCode() : 0);\n        result = 31 * result + this.maxResults;\n        return result;\n    }\n    \n    public String toString() {\n        return \"GeoQuery{location=\" + this.location + \", ip='\" + this.ip + '\\'' + \", accuracy='\" + this.accuracy + '\\'' + \", granularity='\" + this.granularity + '\\'' + \", maxResults=\" + this.maxResults + '}';\n    }\n}\n",
        "token_number_zeroshot": 1186,
        "token_number_fewshot": 1584,
        "token_number_cot": 1297
    },
    {
        "project_name": "twitter4j",
        "class": "OEmbedRequest",
        "source_code": "package twitter4j;\n\nimport java.io.*;\nimport java.util.*;\n\npublic final class OEmbedRequest implements Serializable\n{\n    private static final long serialVersionUID = 7454130135274547901L;\n    private final long statusId;\n    private final String url;\n    private int maxWidth;\n    private boolean hideMedia;\n    private boolean hideThread;\n    private boolean omitScript;\n    private Align align;\n    private String[] related;\n    private String lang;\n    \n    public OEmbedRequest(final long statusId, final String url) {\n        this.hideMedia = true;\n        this.hideThread = true;\n        this.omitScript = false;\n        this.align = Align.NONE;\n        this.related = new String[0];\n        this.statusId = statusId;\n        this.url = url;\n    }\n    \n    public void setMaxWidth(final int maxWidth) {\n        this.maxWidth = maxWidth;\n    }\n    \n    public OEmbedRequest MaxWidth(final int maxWidth) {\n        this.maxWidth = maxWidth;\n        return this;\n    }\n    \n    public void setHideMedia(final boolean hideMedia) {\n        this.hideMedia = hideMedia;\n    }\n    \n    public OEmbedRequest HideMedia(final boolean hideMedia) {\n        this.hideMedia = hideMedia;\n        return this;\n    }\n    \n    public void setHideThread(final boolean hideThread) {\n        this.hideThread = hideThread;\n    }\n    \n    public OEmbedRequest HideThread(final boolean hideThread) {\n        this.hideThread = hideThread;\n        return this;\n    }\n    \n    public void setOmitScript(final boolean omitScript) {\n        this.omitScript = omitScript;\n    }\n    \n    public OEmbedRequest omitScript(final boolean omitScript) {\n        this.omitScript = omitScript;\n        return this;\n    }\n    \n    public void setAlign(final Align align) {\n        this.align = align;\n    }\n    \n    public OEmbedRequest align(final Align align) {\n        this.align = align;\n        return this;\n    }\n    \n    public void setRelated(final String[] related) {\n        this.related = related;\n    }\n    \n    public OEmbedRequest related(final String[] related) {\n        this.related = related;\n        return this;\n    }\n    \n    public void setLang(final String lang) {\n        this.lang = lang;\n    }\n    \n    public OEmbedRequest lang(final String lang) {\n        this.lang = lang;\n        return this;\n    }\n    \n    HttpParameter[] asHttpParameterArray() {\n        final ArrayList<HttpParameter> params = new ArrayList<HttpParameter>(12);\n        this.appendParameter(\"id\", this.statusId, params);\n        this.appendParameter(\"url\", this.url, params);\n        this.appendParameter(\"maxwidth\", this.maxWidth, params);\n        params.add(new HttpParameter(\"hide_media\", this.hideMedia));\n        params.add(new HttpParameter(\"hide_thread\", this.hideThread));\n        params.add(new HttpParameter(\"omit_script\", this.omitScript));\n        params.add(new HttpParameter(\"align\", this.align.name().toLowerCase()));\n        if (this.related.length > 0) {\n            this.appendParameter(\"related\", StringUtil.join(this.related), params);\n        }\n        this.appendParameter(\"lang\", this.lang, params);\n        final HttpParameter[] paramArray = new HttpParameter[params.size()];\n        return params.toArray(paramArray);\n    }\n    \n    private void appendParameter(final String name, final String value, final List<HttpParameter> params) {\n        if (value != null) {\n            params.add(new HttpParameter(name, value));\n        }\n    }\n    \n    private void appendParameter(final String name, final long value, final List<HttpParameter> params) {\n        if (0L <= value) {\n            params.add(new HttpParameter(name, String.valueOf(value)));\n        }\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final OEmbedRequest that = (OEmbedRequest)o;\n        if (this.hideMedia != that.hideMedia) {\n            return false;\n        }\n        if (this.hideThread != that.hideThread) {\n            return false;\n        }\n        if (this.maxWidth != that.maxWidth) {\n            return false;\n        }\n        if (this.omitScript != that.omitScript) {\n            return false;\n        }\n        if (this.statusId != that.statusId) {\n            return false;\n        }\n        if (this.align != that.align) {\n            return false;\n        }\n        Label_0141: {\n            if (this.lang != null) {\n                if (this.lang.equals(that.lang)) {\n                    break Label_0141;\n                }\n            }\n            else if (that.lang == null) {\n                break Label_0141;\n            }\n            return false;\n        }\n        if (!Arrays.equals(this.related, that.related)) {\n            return false;\n        }\n        if (this.url != null) {\n            if (this.url.equals(that.url)) {\n                return true;\n            }\n        }\n        else if (that.url == null) {\n            return true;\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        int result = (int)(this.statusId ^ this.statusId >>> 32);\n        result = 31 * result + ((this.url != null) ? this.url.hashCode() : 0);\n        result = 31 * result + this.maxWidth;\n        result = 31 * result + (this.hideMedia ? 1 : 0);\n        result = 31 * result + (this.hideThread ? 1 : 0);\n        result = 31 * result + (this.omitScript ? 1 : 0);\n        result = 31 * result + ((this.align != null) ? this.align.hashCode() : 0);\n        result = 31 * result + ((this.related != null) ? Arrays.hashCode(this.related) : 0);\n        result = 31 * result + ((this.lang != null) ? this.lang.hashCode() : 0);\n        return result;\n    }\n    \n    public String toString() {\n        return \"OEmbedRequest{statusId=\" + this.statusId + \", url='\" + this.url + '\\'' + \", maxWidth=\" + this.maxWidth + \", hideMedia=\" + this.hideMedia + \", hideThread=\" + this.hideThread + \", omitScript=\" + this.omitScript + \", align=\" + this.align + \", related=\" + ((this.related == null) ? null : Arrays.asList(this.related)) + \", lang='\" + this.lang + '\\'' + '}';\n    }\n    \n    public enum Align\n    {\n        LEFT, \n        CENTER, \n        RIGHT, \n        NONE;\n    }\n}\n",
        "token_number_zeroshot": 1430,
        "token_number_fewshot": 1828,
        "token_number_cot": 1542
    },
    {
        "project_name": "twitter4j",
        "class": "Paging",
        "source_code": "package twitter4j;\n\nimport java.io.*;\nimport twitter4j.internal.http.*;\nimport java.util.*;\n\npublic final class Paging implements Serializable\n{\n    private int page;\n    private int count;\n    private long sinceId;\n    private long maxId;\n    private static final long serialVersionUID = -3285857427993796670L;\n    static char[] S;\n    static char[] SMCP;\n    static final String COUNT = \"count\";\n    static final String PER_PAGE = \"per_page\";\n    private static HttpParameter[] NULL_PARAMETER_ARRAY;\n    private static List<HttpParameter> NULL_PARAMETER_LIST;\n    \n    List<HttpParameter> asPostParameterList() {\n        return this.asPostParameterList(Paging.SMCP, \"count\");\n    }\n    \n    HttpParameter[] asPostParameterArray() {\n        final List<HttpParameter> list = this.asPostParameterList(Paging.SMCP, \"count\");\n        if (list.size() == 0) {\n            return Paging.NULL_PARAMETER_ARRAY;\n        }\n        return list.toArray(new HttpParameter[list.size()]);\n    }\n    \n    List<HttpParameter> asPostParameterList(final char[] supportedParams) {\n        return this.asPostParameterList(supportedParams, \"count\");\n    }\n    \n    List<HttpParameter> asPostParameterList(final char[] supportedParams, final String perPageParamName) {\n        final List<HttpParameter> pagingParams = new ArrayList<HttpParameter>(supportedParams.length);\n        this.addPostParameter(supportedParams, 's', pagingParams, \"since_id\", this.getSinceId());\n        this.addPostParameter(supportedParams, 'm', pagingParams, \"max_id\", this.getMaxId());\n        this.addPostParameter(supportedParams, 'c', pagingParams, perPageParamName, this.getCount());\n        this.addPostParameter(supportedParams, 'p', pagingParams, \"page\", this.getPage());\n        if (pagingParams.size() == 0) {\n            return Paging.NULL_PARAMETER_LIST;\n        }\n        return pagingParams;\n    }\n    \n    HttpParameter[] asPostParameterArray(final char[] supportedParams, final String perPageParamName) {\n        final List<HttpParameter> pagingParams = new ArrayList<HttpParameter>(supportedParams.length);\n        this.addPostParameter(supportedParams, 's', pagingParams, \"since_id\", this.getSinceId());\n        this.addPostParameter(supportedParams, 'm', pagingParams, \"max_id\", this.getMaxId());\n        this.addPostParameter(supportedParams, 'c', pagingParams, perPageParamName, this.getCount());\n        this.addPostParameter(supportedParams, 'p', pagingParams, \"page\", this.getPage());\n        if (pagingParams.size() == 0) {\n            return Paging.NULL_PARAMETER_ARRAY;\n        }\n        return pagingParams.toArray(new HttpParameter[pagingParams.size()]);\n    }\n    \n    private void addPostParameter(final char[] supportedParams, final char paramKey, final List<HttpParameter> pagingParams, final String paramName, final long paramValue) {\n        boolean supported = false;\n        for (final char supportedParam : supportedParams) {\n            if (supportedParam == paramKey) {\n                supported = true;\n                break;\n            }\n        }\n        if (!supported && -1L != paramValue) {\n            throw new IllegalStateException(\"Paging parameter [\" + paramName + \"] is not supported with this operation.\");\n        }\n        if (-1L != paramValue) {\n            pagingParams.add(new HttpParameter(paramName, String.valueOf(paramValue)));\n        }\n    }\n    \n    public Paging() {\n        this.page = -1;\n        this.count = -1;\n        this.sinceId = -1L;\n        this.maxId = -1L;\n    }\n    \n    public Paging(final int page) {\n        this.page = -1;\n        this.count = -1;\n        this.sinceId = -1L;\n        this.maxId = -1L;\n        this.setPage(page);\n    }\n    \n    public Paging(final long sinceId) {\n        this.page = -1;\n        this.count = -1;\n        this.sinceId = -1L;\n        this.maxId = -1L;\n        this.setSinceId(sinceId);\n    }\n    \n    public Paging(final int page, final int count) {\n        this(page);\n        this.setCount(count);\n    }\n    \n    public Paging(final int page, final long sinceId) {\n        this(page);\n        this.setSinceId(sinceId);\n    }\n    \n    public Paging(final int page, final int count, final long sinceId) {\n        this(page, count);\n        this.setSinceId(sinceId);\n    }\n    \n    public Paging(final int page, final int count, final long sinceId, final long maxId) {\n        this(page, count, sinceId);\n        this.setMaxId(maxId);\n    }\n    \n    public int getPage() {\n        return this.page;\n    }\n    \n    public void setPage(final int page) {\n        if (page < 1) {\n            throw new IllegalArgumentException(\"page should be positive integer. passed:\" + page);\n        }\n        this.page = page;\n    }\n    \n    public int getCount() {\n        return this.count;\n    }\n    \n    public void setCount(final int count) {\n        if (count < 1) {\n            throw new IllegalArgumentException(\"count should be positive integer. passed:\" + count);\n        }\n        this.count = count;\n    }\n    \n    public Paging count(final int count) {\n        this.setCount(count);\n        return this;\n    }\n    \n    public long getSinceId() {\n        return this.sinceId;\n    }\n    \n    public void setSinceId(final long sinceId) {\n        if (sinceId < 1L) {\n            throw new IllegalArgumentException(\"since_id should be positive integer. passed:\" + sinceId);\n        }\n        this.sinceId = sinceId;\n    }\n    \n    public Paging sinceId(final long sinceId) {\n        this.setSinceId(sinceId);\n        return this;\n    }\n    \n    public long getMaxId() {\n        return this.maxId;\n    }\n    \n    public void setMaxId(final long maxId) {\n        if (maxId < 1L) {\n            throw new IllegalArgumentException(\"max_id should be positive integer. passed:\" + maxId);\n        }\n        this.maxId = maxId;\n    }\n    \n    public Paging maxId(final long maxId) {\n        this.setMaxId(maxId);\n        return this;\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Paging)) {\n            return false;\n        }\n        final Paging paging = (Paging)o;\n        return this.count == paging.count && this.maxId == paging.maxId && this.page == paging.page && this.sinceId == paging.sinceId;\n    }\n    \n    public int hashCode() {\n        int result = this.page;\n        result = 31 * result + this.count;\n        result = 31 * result + (int)(this.sinceId ^ this.sinceId >>> 32);\n        result = 31 * result + (int)(this.maxId ^ this.maxId >>> 32);\n        return result;\n    }\n    \n    public String toString() {\n        return \"Paging{page=\" + this.page + \", count=\" + this.count + \", sinceId=\" + this.sinceId + \", maxId=\" + this.maxId + '}';\n    }\n    \n    static {\n        Paging.S = new char[] { 's' };\n        Paging.SMCP = new char[] { 's', 'm', 'c', 'p' };\n        Paging.NULL_PARAMETER_ARRAY = new HttpParameter[0];\n        Paging.NULL_PARAMETER_LIST = new ArrayList<HttpParameter>(0);\n    }\n}\n",
        "token_number_zeroshot": 1642,
        "token_number_fewshot": 2040,
        "token_number_cot": 1752
    },
    {
        "project_name": "twitter4j",
        "class": "TwitterBaseImpl",
        "source_code": "package twitter4j;\n\nimport twitter4j.conf.*;\nimport twitter4j.util.function.*;\nimport java.util.*;\nimport java.io.*;\nimport twitter4j.auth.*;\n\nabstract class TwitterBaseImpl implements TwitterBase, Serializable, OAuthSupport, OAuth2Support, HttpResponseListener\n{\n    private static final String WWW_DETAILS = \"See http://twitter4j.org/en/configuration.html for details. See and register at http://apps.twitter.com/\";\n    private static final long serialVersionUID = -7824361938865528554L;\n    Configuration conf;\n    private transient String screenName;\n    private transient long id;\n    transient HttpClient http;\n    private List<RateLimitStatusListener> rateLimitStatusListeners;\n    ObjectFactory factory;\n    Authorization auth;\n    \n    TwitterBaseImpl(final Configuration conf, final Authorization auth) {\n        this.screenName = null;\n        this.id = 0L;\n        this.rateLimitStatusListeners = new ArrayList<RateLimitStatusListener>(0);\n        this.conf = conf;\n        this.auth = auth;\n        this.init();\n    }\n    \n    private void init() {\n        if (null == this.auth) {\n            final String consumerKey = this.conf.getOAuthConsumerKey();\n            final String consumerSecret = this.conf.getOAuthConsumerSecret();\n            if (consumerKey != null && consumerSecret != null) {\n                if (this.conf.isApplicationOnlyAuthEnabled()) {\n                    final OAuth2Authorization oauth2 = new OAuth2Authorization(this.conf);\n                    final String tokenType = this.conf.getOAuth2TokenType();\n                    final String accessToken = this.conf.getOAuth2AccessToken();\n                    if (tokenType != null && accessToken != null) {\n                        oauth2.setOAuth2Token(new OAuth2Token(tokenType, accessToken));\n                    }\n                    this.auth = oauth2;\n                }\n                else {\n                    final OAuthAuthorization oauth3 = new OAuthAuthorization(this.conf);\n                    final String accessToken2 = this.conf.getOAuthAccessToken();\n                    final String accessTokenSecret = this.conf.getOAuthAccessTokenSecret();\n                    if (accessToken2 != null && accessTokenSecret != null) {\n                        oauth3.setOAuthAccessToken(new AccessToken(accessToken2, accessTokenSecret));\n                    }\n                    this.auth = oauth3;\n                }\n            }\n            else {\n                this.auth = NullAuthorization.getInstance();\n            }\n        }\n        this.http = HttpClientFactory.getInstance(this.conf.getHttpClientConfiguration());\n        this.setFactory();\n    }\n    \n    void setFactory() {\n        this.factory = new JSONImplFactory(this.conf);\n    }\n    \n    public String getScreenName() throws TwitterException, IllegalStateException {\n        if (!this.auth.isEnabled()) {\n            throw new IllegalStateException(\"Neither user ID/password combination nor OAuth consumer key/secret combination supplied\");\n        }\n        if (null == this.screenName) {\n            if (this.auth instanceof BasicAuthorization) {\n                this.screenName = ((BasicAuthorization)this.auth).getUserId();\n                if (this.screenName.contains(\"@\")) {\n                    this.screenName = null;\n                }\n            }\n            if (null == this.screenName) {\n                this.fillInIDAndScreenName();\n            }\n        }\n        return this.screenName;\n    }\n    \n    public long getId() throws TwitterException, IllegalStateException {\n        if (!this.auth.isEnabled()) {\n            throw new IllegalStateException(\"Neither user ID/password combination nor OAuth consumer key/secret combination supplied\");\n        }\n        if (0L == this.id) {\n            this.fillInIDAndScreenName();\n        }\n        return this.id;\n    }\n    \n    User fillInIDAndScreenName() throws TwitterException {\n        return this.fillInIDAndScreenName(null);\n    }\n    \n    User fillInIDAndScreenName(final HttpParameter[] parameters) throws TwitterException {\n        this.ensureAuthorizationEnabled();\n        final User user = new UserJSONImpl(this.http.get(this.conf.getRestBaseURL() + \"account/verify_credentials.json\", parameters, this.auth, this), this.conf);\n        this.screenName = user.getScreenName();\n        this.id = user.getId();\n        return user;\n    }\n    \n    public void addRateLimitStatusListener(final RateLimitStatusListener listener) {\n        this.rateLimitStatusListeners.add(listener);\n    }\n    \n    public void onRateLimitStatus(final Consumer<RateLimitStatusEvent> action) {\n        this.rateLimitStatusListeners.add(new RateLimitStatusListener() {\n            public void onRateLimitStatus(final RateLimitStatusEvent event) {\n                action.accept(event);\n            }\n            \n            public void onRateLimitReached(final RateLimitStatusEvent event) {\n            }\n        });\n    }\n    \n    public void onRateLimitReached(final Consumer<RateLimitStatusEvent> action) {\n        this.rateLimitStatusListeners.add(new RateLimitStatusListener() {\n            public void onRateLimitStatus(final RateLimitStatusEvent event) {\n            }\n            \n            public void onRateLimitReached(final RateLimitStatusEvent event) {\n                action.accept(event);\n            }\n        });\n    }\n    \n    public void httpResponseReceived(final HttpResponseEvent event) {\n        if (this.rateLimitStatusListeners.size() != 0) {\n            final HttpResponse res = event.getResponse();\n            final TwitterException te = event.getTwitterException();\n            RateLimitStatus rateLimitStatus;\n            int statusCode;\n            if (te != null) {\n                rateLimitStatus = te.getRateLimitStatus();\n                statusCode = te.getStatusCode();\n            }\n            else {\n                rateLimitStatus = JSONImplFactory.createRateLimitStatusFromResponseHeader(res);\n                statusCode = res.getStatusCode();\n            }\n            if (rateLimitStatus != null) {\n                final RateLimitStatusEvent statusEvent = new RateLimitStatusEvent(this, rateLimitStatus, event.isAuthenticated());\n                if (statusCode == 420 || statusCode == 503 || statusCode == 429) {\n                    for (final RateLimitStatusListener listener : this.rateLimitStatusListeners) {\n                        listener.onRateLimitStatus(statusEvent);\n                        listener.onRateLimitReached(statusEvent);\n                    }\n                }\n                else {\n                    for (final RateLimitStatusListener listener : this.rateLimitStatusListeners) {\n                        listener.onRateLimitStatus(statusEvent);\n                    }\n                }\n            }\n        }\n    }\n    \n    public final Authorization getAuthorization() {\n        return this.auth;\n    }\n    \n    public Configuration getConfiguration() {\n        return this.conf;\n    }\n    \n    final void ensureAuthorizationEnabled() {\n        if (!this.auth.isEnabled()) {\n            throw new IllegalStateException(\"Authentication credentials are missing. See http://twitter4j.org/en/configuration.html for details. See and register at http://apps.twitter.com/\");\n        }\n    }\n    \n    final void ensureOAuthEnabled() {\n        if (!(this.auth instanceof OAuthAuthorization)) {\n            throw new IllegalStateException(\"OAuth required. Authentication credentials are missing. See http://twitter4j.org/en/configuration.html for details. See and register at http://apps.twitter.com/\");\n        }\n    }\n    \n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.putFields();\n        out.writeFields();\n        out.writeObject(this.conf);\n        out.writeObject(this.auth);\n        final List<RateLimitStatusListener> serializableRateLimitStatusListeners = new ArrayList<RateLimitStatusListener>(0);\n        for (final RateLimitStatusListener listener : this.rateLimitStatusListeners) {\n            if (listener instanceof Serializable) {\n                serializableRateLimitStatusListeners.add(listener);\n            }\n        }\n        out.writeObject(serializableRateLimitStatusListeners);\n    }\n    \n    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.readFields();\n        this.conf = (Configuration)stream.readObject();\n        this.auth = (Authorization)stream.readObject();\n        this.rateLimitStatusListeners = (List<RateLimitStatusListener>)stream.readObject();\n        this.http = HttpClientFactory.getInstance(this.conf.getHttpClientConfiguration());\n        this.setFactory();\n    }\n    \n    public synchronized void setOAuthConsumer(final String consumerKey, final String consumerSecret) {\n        if (null == consumerKey) {\n            throw new NullPointerException(\"consumer key is null\");\n        }\n        if (null == consumerSecret) {\n            throw new NullPointerException(\"consumer secret is null\");\n        }\n        if (this.auth instanceof NullAuthorization) {\n            if (this.conf.isApplicationOnlyAuthEnabled()) {\n                final OAuth2Authorization oauth2 = new OAuth2Authorization(this.conf);\n                oauth2.setOAuthConsumer(consumerKey, consumerSecret);\n                this.auth = oauth2;\n            }\n            else {\n                final OAuthAuthorization oauth3 = new OAuthAuthorization(this.conf);\n                oauth3.setOAuthConsumer(consumerKey, consumerSecret);\n                this.auth = oauth3;\n            }\n        }\n        else if (this.auth instanceof BasicAuthorization) {\n            final XAuthAuthorization xauth = new XAuthAuthorization((BasicAuthorization)this.auth);\n            xauth.setOAuthConsumer(consumerKey, consumerSecret);\n            this.auth = xauth;\n        }\n        else if (this.auth instanceof OAuthAuthorization || this.auth instanceof OAuth2Authorization) {\n            throw new IllegalStateException(\"consumer key/secret pair already set.\");\n        }\n    }\n    \n    public RequestToken getOAuthRequestToken() throws TwitterException {\n        return this.getOAuthRequestToken(null);\n    }\n    \n    public RequestToken getOAuthRequestToken(final String callbackUrl) throws TwitterException {\n        return this.getOAuth().getOAuthRequestToken(callbackUrl);\n    }\n    \n    public RequestToken getOAuthRequestToken(final String callbackUrl, final String xAuthAccessType) throws TwitterException {\n        return this.getOAuth().getOAuthRequestToken(callbackUrl, xAuthAccessType);\n    }\n    \n    public RequestToken getOAuthRequestToken(final String callbackUrl, final String xAuthAccessType, final String xAuthMode) throws TwitterException {\n        return this.getOAuth().getOAuthRequestToken(callbackUrl, xAuthAccessType, xAuthMode);\n    }\n    \n    public synchronized AccessToken getOAuthAccessToken() throws TwitterException {\n        Authorization auth = this.getAuthorization();\n        AccessToken oauthAccessToken;\n        if (auth instanceof BasicAuthorization) {\n            final BasicAuthorization basicAuth = (BasicAuthorization)auth;\n            auth = AuthorizationFactory.getInstance(this.conf);\n            if (!(auth instanceof OAuthAuthorization)) {\n                throw new IllegalStateException(\"consumer key / secret combination not supplied.\");\n            }\n            this.auth = auth;\n            final OAuthAuthorization oauthAuth = (OAuthAuthorization)auth;\n            oauthAccessToken = oauthAuth.getOAuthAccessToken(basicAuth.getUserId(), basicAuth.getPassword());\n        }\n        else if (auth instanceof XAuthAuthorization) {\n            final XAuthAuthorization xauth = (XAuthAuthorization)auth;\n            this.auth = xauth;\n            final OAuthAuthorization oauthAuth = new OAuthAuthorization(this.conf);\n            oauthAuth.setOAuthConsumer(xauth.getConsumerKey(), xauth.getConsumerSecret());\n            oauthAccessToken = oauthAuth.getOAuthAccessToken(xauth.getUserId(), xauth.getPassword());\n        }\n        else {\n            oauthAccessToken = this.getOAuth().getOAuthAccessToken();\n        }\n        this.screenName = oauthAccessToken.getScreenName();\n        this.id = oauthAccessToken.getUserId();\n        return oauthAccessToken;\n    }\n    \n    public synchronized AccessToken getOAuthAccessToken(final String oauthVerifier) throws TwitterException {\n        final AccessToken oauthAccessToken = this.getOAuth().getOAuthAccessToken(oauthVerifier);\n        this.screenName = oauthAccessToken.getScreenName();\n        return oauthAccessToken;\n    }\n    \n    public synchronized AccessToken getOAuthAccessToken(final RequestToken requestToken) throws TwitterException {\n        final OAuthSupport oauth = this.getOAuth();\n        final AccessToken oauthAccessToken = oauth.getOAuthAccessToken(requestToken);\n        this.screenName = oauthAccessToken.getScreenName();\n        return oauthAccessToken;\n    }\n    \n    public synchronized AccessToken getOAuthAccessToken(final RequestToken requestToken, final String oauthVerifier) throws TwitterException {\n        return this.getOAuth().getOAuthAccessToken(requestToken, oauthVerifier);\n    }\n    \n    public synchronized void setOAuthAccessToken(final AccessToken accessToken) {\n        this.getOAuth().setOAuthAccessToken(accessToken);\n    }\n    \n    public synchronized AccessToken getOAuthAccessToken(final String screenName, final String password) throws TwitterException {\n        return this.getOAuth().getOAuthAccessToken(screenName, password);\n    }\n    \n    private OAuthSupport getOAuth() {\n        if (!(this.auth instanceof OAuthSupport)) {\n            throw new IllegalStateException(\"OAuth consumer key/secret combination not supplied\");\n        }\n        return (OAuthSupport)this.auth;\n    }\n    \n    public synchronized OAuth2Token getOAuth2Token() throws TwitterException {\n        return this.getOAuth2().getOAuth2Token();\n    }\n    \n    public void setOAuth2Token(final OAuth2Token oauth2Token) {\n        this.getOAuth2().setOAuth2Token(oauth2Token);\n    }\n    \n    public synchronized void invalidateOAuth2Token() throws TwitterException {\n        this.getOAuth2().invalidateOAuth2Token();\n    }\n    \n    private OAuth2Support getOAuth2() {\n        if (!(this.auth instanceof OAuth2Support)) {\n            throw new IllegalStateException(\"OAuth consumer key/secret combination not supplied\");\n        }\n        return (OAuth2Support)this.auth;\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof TwitterBaseImpl)) {\n            return false;\n        }\n        final TwitterBaseImpl that = (TwitterBaseImpl)o;\n        Label_0054: {\n            if (this.auth != null) {\n                if (this.auth.equals(that.auth)) {\n                    break Label_0054;\n                }\n            }\n            else if (that.auth == null) {\n                break Label_0054;\n            }\n            return false;\n        }\n        if (!this.conf.equals(that.conf)) {\n            return false;\n        }\n        if (this.http != null) {\n            if (this.http.equals(that.http)) {\n                return this.rateLimitStatusListeners.equals(that.rateLimitStatusListeners);\n            }\n        }\n        else if (that.http == null) {\n            return this.rateLimitStatusListeners.equals(that.rateLimitStatusListeners);\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        int result = this.conf.hashCode();\n        result = 31 * result + ((this.http != null) ? this.http.hashCode() : 0);\n        result = 31 * result + this.rateLimitStatusListeners.hashCode();\n        result = 31 * result + ((this.auth != null) ? this.auth.hashCode() : 0);\n        return result;\n    }\n    \n    public String toString() {\n        return \"TwitterBase{conf=\" + this.conf + \", http=\" + this.http + \", rateLimitStatusListeners=\" + this.rateLimitStatusListeners + \", auth=\" + this.auth + '}';\n    }\n}\n",
        "token_number_zeroshot": 2981,
        "token_number_fewshot": 3379,
        "token_number_cot": 3093
    },
    {
        "project_name": "107_weka",
        "class": "Memory",
        "source_code": "package weka.core;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class Memory implements RevisionHandler\n{\n    protected static boolean m_Enabled;\n    protected boolean m_UseGUI;\n    protected static long m_Initial;\n    protected long m_Total;\n    protected long m_Max;\n    protected Runtime m_Runtime;\n    \n    public Memory() {\n        this(false);\n    }\n    \n    public Memory(final boolean useGUI) {\n        this.m_UseGUI = false;\n        this.m_UseGUI = useGUI;\n        this.m_Runtime = Runtime.getRuntime();\n        this.m_Max = this.m_Runtime.maxMemory();\n        this.m_Total = this.m_Runtime.totalMemory();\n    }\n    \n    public boolean isEnabled() {\n        return Memory.m_Enabled;\n    }\n    \n    public void setEnabled(final boolean value) {\n        Memory.m_Enabled = value;\n    }\n    \n    public boolean getUseGUI() {\n        return this.m_UseGUI;\n    }\n    \n    public long getInitial() {\n        return Memory.m_Initial;\n    }\n    \n    public long getCurrent() {\n        this.m_Runtime = Runtime.getRuntime();\n        return this.m_Total = this.m_Runtime.totalMemory();\n    }\n    \n    public long getMax() {\n        return this.m_Max;\n    }\n    \n    public boolean isOutOfMemory() {\n        return this.isEnabled() && this.getMax() - this.getCurrent() < this.getInitial() + 200000L;\n    }\n    \n    public static double toMegaByte(final long bytes) {\n        return bytes / 1048576.0;\n    }\n    \n    public void showOutOfMemory() {\n        if (!this.isEnabled()) {\n            return;\n        }\n        System.gc();\n        final String msg = \"Not enough memory. Please load a smaller dataset or use larger heap size.\\n- initial JVM size:   \" + Utils.doubleToString(toMegaByte(Memory.m_Initial), 1) + \"MB\\n\" + \"- total memory used:  \" + Utils.doubleToString(toMegaByte(this.m_Total), 1) + \"MB\\n\" + \"- max. memory avail.: \" + Utils.doubleToString(toMegaByte(this.m_Max), 1) + \"MB\\n\" + \"\\n\" + \"Note:\\n\" + \"The Java heap size can be specified with the -Xmx option.\\n\" + \"E.g., to use 128MB as heap size, the command line looks like this:\\n\" + \"   java -Xmx128m -classpath ...\\n\" + \"This does NOT work in the SimpleCLI, the java command refers\\n\" + \"to the one with which Weka is started.\";\n        System.err.println(msg);\n        if (this.getUseGUI()) {\n            JOptionPane.showMessageDialog(null, msg, \"OutOfMemory\", 2);\n        }\n    }\n    \n    public void stopThreads() {\n        Thread[] thGroup = new Thread[Thread.activeCount()];\n        Thread.enumerate(thGroup);\n        for (int i = 0; i < thGroup.length; ++i) {\n            final Thread t = thGroup[i];\n            if (t != null && t != Thread.currentThread()) {\n                if (t.getName().startsWith(\"Thread\")) {\n                    t.stop();\n                }\n                else if (t.getName().startsWith(\"AWT-EventQueue\")) {\n                    t.stop();\n                }\n            }\n        }\n        thGroup = null;\n        System.gc();\n    }\n    \n    @Override\n    public String getRevision() {\n        return RevisionUtils.extract(\"$Revision: 8034 $\");\n    }\n    \n    public static void main(final String[] args) {\n        final Memory mem = new Memory();\n        System.out.println(\"Initial memory: \" + Utils.doubleToString(toMegaByte(mem.getInitial()), 1) + \"MB\" + \" (\" + mem.getInitial() + \")\");\n        System.out.println(\"Max memory: \" + Utils.doubleToString(toMegaByte(mem.getMax()), 1) + \"MB\" + \" (\" + mem.getMax() + \")\");\n    }\n    \n    static {\n        Memory.m_Enabled = true;\n        Memory.m_Initial = Runtime.getRuntime().totalMemory();\n    }\n}\n",
        "token_number_zeroshot": 879,
        "token_number_fewshot": 1277,
        "token_number_cot": 989
    },
    {
        "project_name": "107_weka",
        "class": "ICSSearchAlgorithm",
        "source_code": "package weka.classifiers.bayes.net.search.ci;\n\nimport weka.classifiers.bayes.*;\nimport weka.classifiers.bayes.net.*;\nimport java.util.*;\nimport weka.classifiers.bayes.net.search.*;\nimport java.io.*;\nimport weka.core.*;\n\npublic class ICSSearchAlgorithm extends CISearchAlgorithm\n{\n    static final long serialVersionUID = -2510985917284798576L;\n    private int m_nMaxCardinality;\n    \n    public ICSSearchAlgorithm() {\n        this.m_nMaxCardinality = 2;\n    }\n    \n    String name(final int iAttribute) {\n        return this.m_instances.attribute(iAttribute).name();\n    }\n    \n    int maxn() {\n        return this.m_instances.numAttributes();\n    }\n    \n    public void setMaxCardinality(final int nMaxCardinality) {\n        this.m_nMaxCardinality = nMaxCardinality;\n    }\n    \n    public int getMaxCardinality() {\n        return this.m_nMaxCardinality;\n    }\n    \n    @Override\n    protected void search(final BayesNet bayesNet, final Instances instances) throws Exception {\n        this.m_BayesNet = bayesNet;\n        this.m_instances = instances;\n        final boolean[][] edges = new boolean[this.maxn() + 1][];\n        final boolean[][] arrows = new boolean[this.maxn() + 1][];\n        final SeparationSet[][] sepsets = new SeparationSet[this.maxn() + 1][];\n        for (int iNode = 0; iNode < this.maxn() + 1; ++iNode) {\n            edges[iNode] = new boolean[this.maxn()];\n            arrows[iNode] = new boolean[this.maxn()];\n            sepsets[iNode] = new SeparationSet[this.maxn()];\n        }\n        this.calcDependencyGraph(edges, sepsets);\n        this.calcVeeNodes(edges, arrows, sepsets);\n        this.calcArcDirections(edges, arrows);\n        for (int iNode = 0; iNode < this.maxn(); ++iNode) {\n            final ParentSet oParentSet = this.m_BayesNet.getParentSet(iNode);\n            while (oParentSet.getNrOfParents() > 0) {\n                oParentSet.deleteLastParent(this.m_instances);\n            }\n            for (int iParent = 0; iParent < this.maxn(); ++iParent) {\n                if (arrows[iParent][iNode]) {\n                    oParentSet.addParent(iParent, this.m_instances);\n                }\n            }\n        }\n    }\n    \n    void calcDependencyGraph(final boolean[][] edges, final SeparationSet[][] sepsets) {\n        for (int iNode1 = 0; iNode1 < this.maxn(); ++iNode1) {\n            for (int iNode2 = 0; iNode2 < this.maxn(); ++iNode2) {\n                edges[iNode1][iNode2] = true;\n            }\n        }\n        for (int iNode1 = 0; iNode1 < this.maxn(); ++iNode1) {\n            edges[iNode1][iNode1] = false;\n        }\n        for (int iCardinality = 0; iCardinality <= this.getMaxCardinality(); ++iCardinality) {\n            for (int iNode3 = 0; iNode3 <= this.maxn() - 2; ++iNode3) {\n                for (int iNode4 = iNode3 + 1; iNode4 < this.maxn(); ++iNode4) {\n                    if (edges[iNode3][iNode4]) {\n                        final SeparationSet oSepSet = this.existsSepSet(iNode3, iNode4, iCardinality, edges);\n                        if (oSepSet != null) {\n                            edges[iNode3][iNode4] = false;\n                            edges[iNode4][iNode3] = false;\n                            sepsets[iNode3][iNode4] = oSepSet;\n                            sepsets[iNode4][iNode3] = oSepSet;\n                            System.err.print(\"I(\" + this.name(iNode3) + \", {\");\n                            for (int iNode5 = 0; iNode5 < iCardinality; ++iNode5) {\n                                System.err.print(this.name(oSepSet.m_set[iNode5]) + \" \");\n                            }\n                            System.err.print(\"} ,\" + this.name(iNode4) + \")\\n\");\n                        }\n                    }\n                }\n            }\n            System.err.print(iCardinality + \" \");\n            for (int iNode3 = 0; iNode3 < this.maxn(); ++iNode3) {\n                System.err.print(this.name(iNode3) + \" \");\n            }\n            System.err.print('\\n');\n            for (int iNode3 = 0; iNode3 < this.maxn(); ++iNode3) {\n                for (int iNode4 = 0; iNode4 < this.maxn(); ++iNode4) {\n                    if (edges[iNode3][iNode4]) {\n                        System.err.print(\"X \");\n                    }\n                    else {\n                        System.err.print(\". \");\n                    }\n                }\n                System.err.print(this.name(iNode3) + \" \");\n                System.err.print('\\n');\n            }\n        }\n    }\n    \n    SeparationSet existsSepSet(final int iNode1, final int iNode2, final int nCardinality, final boolean[][] edges) {\n        final SeparationSet Z = new SeparationSet();\n        Z.m_set[nCardinality] = -1;\n        if (nCardinality > 0) {\n            Z.m_set[0] = this.next(-1, iNode1, iNode2, edges);\n            for (int iNode3 = 1; iNode3 < nCardinality; ++iNode3) {\n                Z.m_set[iNode3] = this.next(Z.m_set[iNode3 - 1], iNode1, iNode2, edges);\n            }\n        }\n        int iZ;\n        if (nCardinality > 0) {\n            iZ = this.maxn() - Z.m_set[nCardinality - 1] - 1;\n        }\n        else {\n            iZ = 0;\n        }\n        while (iZ >= 0) {\n            if (this.isConditionalIndependent(iNode2, iNode1, Z.m_set, nCardinality)) {\n                return Z;\n            }\n            if (nCardinality > 0) {\n                Z.m_set[nCardinality - 1] = this.next(Z.m_set[nCardinality - 1], iNode1, iNode2, edges);\n            }\n            for (iZ = nCardinality - 1; iZ >= 0 && Z.m_set[iZ] >= this.maxn(); iZ = nCardinality - 1) {\n                for (iZ = nCardinality - 1; iZ >= 0 && Z.m_set[iZ] >= this.maxn(); --iZ) {}\n                if (iZ < 0) {\n                    break;\n                }\n                Z.m_set[iZ] = this.next(Z.m_set[iZ], iNode1, iNode2, edges);\n                for (int iNode3 = iZ + 1; iNode3 < nCardinality; ++iNode3) {\n                    Z.m_set[iNode3] = this.next(Z.m_set[iNode3 - 1], iNode1, iNode2, edges);\n                }\n            }\n        }\n        return null;\n    }\n    \n    int next(int x, final int iNode1, final int iNode2, final boolean[][] edges) {\n        ++x;\n        while (x < this.maxn() && (!edges[iNode1][x] || !edges[iNode2][x] || x == iNode2)) {\n            ++x;\n        }\n        return x;\n    }\n    \n    void calcVeeNodes(final boolean[][] edges, final boolean[][] arrows, final SeparationSet[][] sepsets) {\n        for (int iNode1 = 0; iNode1 < this.maxn(); ++iNode1) {\n            for (int iNode2 = 0; iNode2 < this.maxn(); ++iNode2) {\n                arrows[iNode1][iNode2] = false;\n            }\n        }\n        for (int iNode1 = 0; iNode1 < this.maxn() - 1; ++iNode1) {\n            for (int iNode2 = iNode1 + 1; iNode2 < this.maxn(); ++iNode2) {\n                if (!edges[iNode1][iNode2]) {\n                    for (int iNode3 = 0; iNode3 < this.maxn(); ++iNode3) {\n                        if ((iNode3 != iNode1 && iNode3 != iNode2 && edges[iNode1][iNode3] && edges[iNode2][iNode3]) & !sepsets[iNode1][iNode2].contains(iNode3)) {\n                            arrows[iNode1][iNode3] = true;\n                            arrows[iNode2][iNode3] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    void calcArcDirections(final boolean[][] edges, final boolean[][] arrows) {\n        boolean bFound;\n        do {\n            bFound = false;\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[i][j]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (i != k && j != k && edges[j][k] && !edges[i][k] && !arrows[j][k] && !arrows[k][j]) {\n                                arrows[j][k] = true;\n                                bFound = true;\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[i][j]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (i != k && j != k && edges[i][k] && arrows[j][k] && !arrows[i][k] && !arrows[k][i]) {\n                                arrows[i][k] = true;\n                                bFound = true;\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[i][j]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (k != i && k != j && arrows[k][j] && !edges[k][i]) {\n                                for (int m = 0; m < this.maxn(); ++m) {\n                                    if (m != i && m != j && m != k && edges[m][i] && !arrows[m][i] && !arrows[i][m] && edges[m][j] && !arrows[m][j] && !arrows[j][m] && edges[m][k] && !arrows[m][k] && !arrows[k][m]) {\n                                        arrows[m][j] = true;\n                                        bFound = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[j][i]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (k != i && k != j && edges[k][j] && !arrows[k][j] && !arrows[j][k] && edges[k][i] && !arrows[k][i] && !arrows[i][k]) {\n                                for (int m = 0; m < this.maxn(); ++m) {\n                                    if (m != i && m != j && m != k && edges[m][i] && !arrows[m][i] && !arrows[i][m] && edges[m][k] && !arrows[m][k] && !arrows[k][m]) {\n                                        arrows[i][m] = true;\n                                        arrows[k][m] = true;\n                                        bFound = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (!bFound) {\n                for (int i = 0; !bFound && i < this.maxn(); ++i) {\n                    for (int j = 0; !bFound && j < this.maxn(); ++j) {\n                        if (edges[i][j] && !arrows[i][j] && !arrows[j][i]) {\n                            arrows[i][j] = true;\n                            bFound = true;\n                        }\n                    }\n                }\n            }\n        } while (bFound);\n    }\n    \n    @Override\n    public Enumeration listOptions() {\n        final Vector result = new Vector();\n        result.addElement(new Option(\"\\tWhen determining whether an edge exists a search is performed \\n\\tfor a set Z that separates the nodes. MaxCardinality determines \\n\\tthe maximum size of the set Z. This greatly influences the \\n\\tlength of the search. (default 2)\", \"cardinality\", 1, \"-cardinality <num>\"));\n        final Enumeration en = super.listOptions();\n        while (en.hasMoreElements()) {\n            result.addElement(en.nextElement());\n        }\n        return result.elements();\n    }\n    \n    @Override\n    public void setOptions(final String[] options) throws Exception {\n        final String tmpStr = Utils.getOption(\"cardinality\", options);\n        if (tmpStr.length() != 0) {\n            this.setMaxCardinality(Integer.parseInt(tmpStr));\n        }\n        else {\n            this.setMaxCardinality(2);\n        }\n        super.setOptions(options);\n    }\n    \n    @Override\n    public String[] getOptions() {\n        final Vector result = new Vector();\n        final String[] options = super.getOptions();\n        for (int i = 0; i < options.length; ++i) {\n            result.add(options[i]);\n        }\n        result.add(\"-cardinality\");\n        result.add(\"\" + this.getMaxCardinality());\n        return result.toArray(new String[result.size()]);\n    }\n    \n    public String maxCardinalityTipText() {\n        return \"When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.\";\n    }\n    \n    @Override\n    public String globalInfo() {\n        return \"This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.\";\n    }\n    \n    @Override\n    public String getRevision() {\n        return RevisionUtils.extract(\"$Revision: 8034 $\");\n    }\n    \n    public static void main(final String[] argv) {\n        try {\n            final BayesNet b = new BayesNet();\n            b.setSearchAlgorithm(new ICSSearchAlgorithm());\n            final Instances instances = new Instances(new FileReader(\"C:\\\\eclipse\\\\workspace\\\\weka\\\\data\\\\contact-lenses.arff\"));\n            instances.setClassIndex(instances.numAttributes() - 1);\n            b.buildClassifier(instances);\n            System.out.println(b.toString());\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    class SeparationSet implements RevisionHandler\n    {\n        public int[] m_set;\n        \n        public SeparationSet() {\n            this.m_set = new int[ICSSearchAlgorithm.this.getMaxCardinality() + 1];\n        }\n        \n        public boolean contains(final int nItem) {\n            for (int iItem = 0; iItem < ICSSearchAlgorithm.this.getMaxCardinality() && this.m_set[iItem] != -1; ++iItem) {\n                if (this.m_set[iItem] == nItem) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        @Override\n        public String getRevision() {\n            return RevisionUtils.extract(\"$Revision: 8034 $\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 3548,
        "token_number_fewshot": 3946,
        "token_number_cot": 3661
    },
    {
        "project_name": "47_dvd-homevideo",
        "class": "Menu",
        "source_code": "import java.util.*;\nimport java.io.*;\n\npublic class Menu implements Runnable\n{\n    private String strTitle;\n    private String strPicPath;\n    private String strAudioPath;\n    private String strTextFilePath;\n    private String dvd_menu;\n    private String[] titles;\n    private boolean pal_menu;\n    private String baseErr;\n    private String[] video_files;\n    private GUI m_GUI;\n    private Thread m_Thread;\n    private boolean m_Error;\n    \n    public Menu() {\n        this.dvd_menu = \"dvd-menu\";\n        this.titles = new String[50];\n        this.baseErr = \"Menu Error - \";\n    }\n    \n    public Menu(final String title, final String TextFilePath, final boolean isPAL, final GUI DVD_GUI) {\n        this.dvd_menu = \"dvd-menu\";\n        this.titles = new String[50];\n        this.baseErr = \"Menu Error - \";\n        this.strTitle = title;\n        this.strTextFilePath = TextFilePath;\n        this.pal_menu = isPAL;\n        this.m_GUI = DVD_GUI;\n    }\n    \n    public Menu(final String title, final String picPath, final String audioPath, final String TextFilePath, final boolean isPAL, final GUI DVD_GUI) {\n        this.dvd_menu = \"dvd-menu\";\n        this.titles = new String[50];\n        this.baseErr = \"Menu Error - \";\n        this.strTitle = title;\n        this.strPicPath = picPath;\n        this.strAudioPath = audioPath;\n        this.strTextFilePath = TextFilePath;\n        this.pal_menu = isPAL;\n        this.m_GUI = DVD_GUI;\n    }\n    \n    public boolean init() {\n        (this.m_Thread = new Thread(this)).start();\n        try {\n            this.m_Thread.join();\n        }\n        catch (InterruptedException ex) {\n            ex.printStackTrace();\n        }\n        return this.m_Error || this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/dvd-menu.log\");\n    }\n    \n    @Override\n    public void run() {\n        this.DVDMainMenu();\n    }\n    \n    public void DVDMainMenu() {\n        final File ListDir = new File(this.m_GUI.strOutputDir);\n        final FilenameFilter filter = new FilenameFilter() {\n            boolean ret_val = true;\n            \n            @Override\n            public boolean accept(final File dir, final String name) {\n                if (name.endsWith(\"vob\")) {\n                    if (!name.equals(\"menu.vob\")) {\n                        this.ret_val = true;\n                    }\n                    else {\n                        this.ret_val = false;\n                    }\n                }\n                else {\n                    this.ret_val = false;\n                }\n                return this.ret_val;\n            }\n        };\n        this.video_files = ListDir.list(filter);\n        this.m_GUI.lblAuthor.setEnabled(true);\n        this.m_GUI.lblAuthorProg.setEnabled(true);\n        this.m_GUI.prgAuthor.setEnabled(true);\n        this.m_GUI.prgAuthor.setIndeterminate(true);\n        String menu_options;\n        if (this.strPicPath == null && this.strAudioPath == null) {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir;\n        }\n        else if (this.strPicPath.equals(\"\") && this.strAudioPath != null) {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir + \" -a \" + this.strAudioPath;\n        }\n        else if (this.strPicPath != null && this.strAudioPath.equals(\"\")) {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir + \" -b \" + this.strPicPath;\n        }\n        else {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir + \" -a \" + this.strAudioPath + \" -b \" + this.strPicPath;\n        }\n        int i = 0;\n        if (this.strTextFilePath.equals(\"\") || this.strTextFilePath == null) {\n            while (i < this.video_files.length) {\n                menu_options = menu_options + \" -f \" + this.m_GUI.strOutputDir + \"/\" + this.video_files[i].substring(0, 11) + \".vob -t \" + this.strTitle + \"_\" + (i + 1);\n                ++i;\n            }\n        }\n        else {\n            try {\n                final BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(this.m_GUI.txtTextFile.getText())));\n                i = 0;\n                String line;\n                while ((line = in.readLine()) != null) {\n                    this.titles[i] = line;\n                    ++i;\n                }\n                int num_blanks = 0;\n                for (i = 0; i < this.titles.length; ++i) {\n                    if (this.titles[i].equals(\"BLANK\")) {\n                        ++num_blanks;\n                    }\n                    if (this.titles[i].equals(\"DONE\")) {\n                        break;\n                    }\n                }\n                final int num_lines = i;\n                if (num_lines - num_blanks > 10) {\n                    this.m_GUI.MessageBox(\"Your text file can only have a maximumof 10 titles!  Please edit your text file and rerundvd-homevideo.\", 1);\n                    this.m_Error = true;\n                }\n                else if (num_lines == this.video_files.length) {\n                    for (i = 0; i < this.video_files.length; ++i) {\n                        if (!this.titles[i].equals(\"BLANK\") && !this.titles[i].equals(\"DONE\")) {\n                            menu_options = menu_options + \" -t \" + this.titles[i] + \" -f \" + this.m_GUI.strOutputDir + \"/\" + this.video_files[i].substring(0, 11) + \".vob\";\n                        }\n                        else {\n                            if (this.titles[i].equals(\"DONE\")) {\n                                break;\n                            }\n                            menu_options = menu_options + \" -f \" + this.m_GUI.strOutputDir + \"/\" + this.video_files[i].substring(0, 11) + \".vob\";\n                        }\n                    }\n                }\n                else {\n                    this.m_GUI.MessageBox(\"It appears that your text file is not\\nformatted correctly.  You currently have\\n\" + (this.video_files.length + 1) + \" vob files, \\n\" + \"however your text file is showing\\n\" + num_lines + \" lines.\", 1);\n                    this.m_Error = true;\n                }\n            }\n            catch (FileNotFoundException ex) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                this.m_GUI.MessageBox(\"Can not find \" + this.m_GUI.txtTextFile + \"\\n\" + ex.toString(), 0);\n                ex.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (IOException ex2) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                this.m_GUI.MessageBox(this.baseErr + \"IO Error\\n\" + ex2.toString(), 0);\n                ex2.printStackTrace();\n                this.m_Error = true;\n            }\n        }\n        if (this.pal_menu) {\n            menu_options += \" -p\";\n        }\n        this.dvd_menu = this.dvd_menu + menu_options + \" 2>&1\";\n        this.m_GUI.txtAreaOutput.append(this.dvd_menu + \"\\n\");\n        try {\n            final String[] dvd_menu_cmd = { \"/bin/sh\", \"-c\", this.dvd_menu };\n            Process p = Runtime.getRuntime().exec(dvd_menu_cmd, null, new File(this.m_GUI.strOutputDir));\n            final BufferedReader in2 = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            final BufferedReader err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n            String line2;\n            while ((line2 = in2.readLine()) != null) {\n                if (line2.equals(\"/bin/sh: dvd-menu: command not found\")) {\n                    this.m_GUI.MessageBox(\"Could not locate dvd-menu in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                    in2.close();\n                    err_in.close();\n                    this.m_Error = true;\n                }\n                final StringTokenizer st = new StringTokenizer(line2);\n                if (st.hasMoreTokens() && !st.nextToken().equals(\"Frame#\")) {\n                    this.m_GUI.txtAreaOutput.append(line2 + \"\\n\");\n                    this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                }\n            }\n            p.waitFor();\n            p = Runtime.getRuntime().exec(\"mv dvd-menu.log log/\", null, new File(this.m_GUI.strOutputDir));\n            final File CreateOutDir = new File(this.m_GUI.strOutputDir + \"/dvd_fs\");\n            if (CreateOutDir.exists() && CreateOutDir.isDirectory()) {\n                CreateOutDir.delete();\n            }\n            Thread.sleep(2000L);\n        }\n        catch (IOException ex2) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n            this.m_GUI.MessageBox(this.baseErr + \"IO Error\\n\" + ex2.toString(), 0);\n            ex2.printStackTrace();\n            this.m_Error = true;\n        }\n        catch (InterruptedException ex3) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex3);\n            this.m_GUI.MessageBox(this.baseErr + \"dvd-homevideo thread was interrupted\\n\" + ex3.toString(), 0);\n            ex3.printStackTrace();\n            this.m_Error = true;\n        }\n    }\n    \n    public boolean createXML() {\n        final File xmlFile = new File(this.m_GUI.strOutputDir + \"/vmgm.xml\");\n        final File ListDir = new File(this.m_GUI.strOutputDir);\n        final FilenameFilter filter = new FilenameFilter() {\n            boolean ret_val = true;\n            \n            @Override\n            public boolean accept(final File dir, final String name) {\n                if (name.endsWith(\"vob\")) {\n                    if (!name.equals(\"menu.vob\")) {\n                        this.ret_val = true;\n                    }\n                    else {\n                        this.ret_val = false;\n                    }\n                }\n                else {\n                    this.ret_val = false;\n                }\n                return this.ret_val;\n            }\n        };\n        this.video_files = ListDir.list(filter);\n        try {\n            final BufferedWriter writer = new BufferedWriter(new FileWriter(xmlFile));\n            writer.write(\"<dvdauthor dest=\\\"\" + this.m_GUI.strOutputDir + \"/DVD/\\\" jumppad=\\\"0\\\">\");\n            writer.newLine();\n            writer.write(\"\\t<vmgm>\");\n            writer.newLine();\n            writer.write(\"\\t\\t<menus>\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t<pgc entry=\\\"title\\\" >\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t\\t<vob file=\\\"\" + this.m_GUI.strOutputDir + \"/menu.vob\\\" pause=\\\"inf\\\" />\");\n            writer.newLine();\n            if (this.titles[0] == null) {\n                for (int i = 1; i <= this.video_files.length; ++i) {\n                    writer.write(\"\\t\\t\\t\\t<button>jump title \" + i + \";</button>\");\n                    writer.newLine();\n                }\n            }\n            else {\n                for (int i = 1; i < this.titles.length; ++i) {\n                    if (!this.titles[i - 1].equals(\"BLANK\") && !this.titles[i - 1].equals(\"DONE\")) {\n                        writer.write(\"\\t\\t\\t\\t<button>jump title \" + i + \";</button>\");\n                        writer.newLine();\n                    }\n                    else if (this.titles[i - 1].equals(\"DONE\")) {\n                        break;\n                    }\n                }\n            }\n            writer.write(\"\\t\\t\\t\\t<post> jump vmgm menu 1; </post>\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t</pgc>\");\n            writer.newLine();\n            writer.write(\"\\t\\t</menus>\");\n            writer.newLine();\n            writer.write(\"\\t</vmgm>\");\n            writer.newLine();\n            writer.write(\"\\t<titleset>\");\n            writer.newLine();\n            writer.write(\"\\t<titles>\");\n            writer.newLine();\n            int i;\n            for (i = 1; i < this.video_files.length; ++i) {\n                writer.write(\"\\t\\t<pgc>\");\n                writer.newLine();\n                writer.write(\"\\t\\t\\t<vob file=\\\"\" + this.video_files[i - 1] + \"\\\" />\");\n                writer.newLine();\n                writer.write(\"\\t\\t\\t<post>jump title \" + (i + 1) + \";</post>\");\n                writer.newLine();\n                writer.write(\"\\t\\t</pgc>\");\n                writer.newLine();\n            }\n            writer.write(\"\\t\\t<pgc>\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t<vob file=\\\"\" + this.video_files[i - 1] + \"\\\" />\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t<post>call vmgm menu 1;</post>\");\n            writer.newLine();\n            writer.write(\"\\t\\t</pgc>\");\n            writer.newLine();\n            writer.write(\"\\t</titles>\");\n            writer.newLine();\n            writer.write(\"\\t</titleset>\");\n            writer.newLine();\n            writer.write(\"</dvdauthor>\");\n            writer.newLine();\n            writer.close();\n        }\n        catch (IOException ex) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n            this.m_GUI.MessageBox(this.baseErr + \"IO Error\\n\" + ex.toString(), 0);\n            ex.printStackTrace();\n            return true;\n        }\n        return false;\n    }\n}\n",
        "token_number_zeroshot": 2856,
        "token_number_fewshot": 3254,
        "token_number_cot": 2966
    },
    {
        "project_name": "47_dvd-homevideo",
        "class": "Capture",
        "source_code": "import java.io.*;\n\npublic class Capture implements Runnable\n{\n    private int m_Minutes;\n    private int m_Seconds;\n    private GUI m_GUI;\n    private Thread m_Thread;\n    private boolean m_Error;\n    private String m_BaseErr;\n    private String m_dvgrab;\n    \n    public Capture() {\n        this.m_BaseErr = \"Capture Error - \";\n        this.m_dvgrab = \"dvgrab --autosplit --size 0 --format raw --opendml --buffers 200 dv/dv_file-\";\n    }\n    \n    public Capture(final int min, final int sec, final GUI DVD_GUI) {\n        this.m_BaseErr = \"Capture Error - \";\n        this.m_dvgrab = \"dvgrab --autosplit --size 0 --format raw --opendml --buffers 200 dv/dv_file-\";\n        this.m_Minutes = min;\n        this.m_Seconds = sec;\n        this.m_GUI = DVD_GUI;\n    }\n    \n    public boolean init() {\n        if (this.m_GUI.menuChkThread.isSelected()) {\n            (this.m_Thread = new Thread(this)).setPriority(10);\n            this.m_Thread.start();\n            return false;\n        }\n        this.DV_Capture();\n        return this.m_Error | this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/dvgrab.log\");\n    }\n    \n    @Override\n    public void run() {\n        this.DV_Capture();\n    }\n    \n    public void DV_Capture() {\n        File CreateOutDir = new File(this.m_GUI.strOutputDir);\n        if (CreateOutDir.exists() && CreateOutDir.isDirectory()) {\n            final int response = this.m_GUI.MessageBox(\"The Output Directory \" + this.m_GUI.strOutputDir + \" already exists!\" + \"\\nWould you like to delete it?\");\n            if (response == 0) {\n                try {\n                    final String rm = \"rm -fr \" + this.m_GUI.strOutputDir;\n                    final String[] rm_cmd = { \"/bin/sh\", \"-c\", rm };\n                    final Process remove_dir = Runtime.getRuntime().exec(rm_cmd, null);\n                    remove_dir.waitFor();\n                }\n                catch (IOException ex) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex.toString(), 0);\n                    ex.printStackTrace();\n                }\n                catch (InterruptedException ex2) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"dvd-homevideo thread was interrupted\\n\" + ex2.toString(), 0);\n                    ex2.printStackTrace();\n                }\n            }\n            else {\n                this.m_GUI.MessageBox(\"Please choose a different name for your\\ntitle or move the directory to another location.\", 2);\n                this.m_GUI.blnBegin = false;\n                this.m_Error = true;\n            }\n        }\n        else if (CreateOutDir.exists() && !CreateOutDir.isDirectory()) {\n            final int response = this.m_GUI.MessageBox(\"There exists a file with the Output directory name\\nat this location!  Would you like to delete it?\");\n            if (response == 0) {\n                try {\n                    final String rm = \"rm -fr \" + this.m_GUI.strOutputDir;\n                    final String[] rm_cmd = { \"/bin/sh\", \"-c\", rm };\n                    final Process remove_dir = Runtime.getRuntime().exec(rm_cmd, null);\n                    remove_dir.waitFor();\n                }\n                catch (IOException ex) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex.toString(), 0);\n                    ex.printStackTrace();\n                }\n                catch (InterruptedException ex2) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"dvd-homevideo thread was interrupted\\n\" + ex2.toString(), 0);\n                    ex2.printStackTrace();\n                }\n            }\n            else {\n                this.m_GUI.MessageBox(\"Please choose a different name for your\\ntitle or move the file to another location.\", 2);\n                this.m_GUI.blnBegin = false;\n            }\n        }\n        if (this.m_GUI.blnBegin) {\n            CreateOutDir.mkdir();\n            CreateOutDir = new File(this.m_GUI.strOutputDir + \"/DVD\");\n            CreateOutDir.mkdir();\n            CreateOutDir = new File(this.m_GUI.strOutputDir + \"/log\");\n            CreateOutDir.mkdir();\n            CreateOutDir = new File(this.m_GUI.strOutputDir + \"/dv\");\n            CreateOutDir.mkdir();\n            try {\n                final String[] dvgrab_cmd = { \"/bin/sh\", \"-c\", this.m_dvgrab };\n                final Process p = Runtime.getRuntime().exec(dvgrab_cmd, null, new File(this.m_GUI.strOutputDir));\n                final BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                final BufferedReader err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                final BufferedWriter out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/dvgrab.log\"));\n                final BufferedWriter err_out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/dvgrab.err\"));\n                if (err_in.ready()) {\n                    final String line = err_in.readLine();\n                    if (line.equals(\"/bin/sh: dvgrab: command not found\")) {\n                        this.m_GUI.MessageBox(\"Could not locate dvgrab in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                        in.close();\n                        out.close();\n                        err_in.close();\n                        err_out.close();\n                        this.m_Error = true;\n                    }\n                    else {\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                this.m_GUI.lblCapture.setEnabled(true);\n                this.m_GUI.prgCapture.setEnabled(true);\n                this.m_GUI.lblCaptureProg.setEnabled(true);\n                final long start = System.currentTimeMillis();\n                final int total = this.m_Minutes * 60 * 1000 + this.m_Seconds * 1000 + 5000;\n                final long end = start + total;\n                long current = System.currentTimeMillis();\n                int diff = (int)(current - start);\n                final int track = 0;\n                while (diff / total < 1) {\n                    this.m_GUI.prgCapture.setValue((int)(diff / total * 100.0));\n                    this.m_GUI.lblCaptureProg.setText(Integer.toString((int)(diff / total * 100.0)) + \"%\");\n                    current = System.currentTimeMillis();\n                    diff = (int)(current - start);\n                    String line = in.readLine();\n                    if (err_in.ready()) {\n                        line = err_in.readLine();\n                        if (line.equals(\"Error: no camera exists\")) {\n                            this.m_GUI.MessageBox(\"It appears that your camcorder is not connected to your computer!\", 0);\n                            final String rm2 = \"rm -fr \" + this.m_GUI.strOutputDir;\n                            final String[] rm_cmd2 = { \"/bin/sh\", \"-c\", rm2 };\n                            final Process remove_dir2 = Runtime.getRuntime().exec(rm_cmd2, null);\n                            remove_dir2.waitFor();\n                            in.close();\n                            out.close();\n                            err_in.close();\n                            err_out.close();\n                            this.m_Error = true;\n                        }\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                in.close();\n                out.close();\n                err_in.close();\n                err_out.close();\n                p.destroy();\n                this.m_GUI.prgCapture.setValue(100);\n                this.m_GUI.prgCapture.setValue(100);\n                this.m_GUI.lblCaptureProg.setText(\"100%\");\n                this.m_GUI.prgCapture.setEnabled(false);\n                this.m_GUI.lblCapture.setEnabled(false);\n                this.m_GUI.lblCaptureProg.setEnabled(false);\n                Thread.sleep(2000L);\n            }\n            catch (IOException ex3) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex3);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex3.toString(), 0);\n                ex3.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (NullPointerException ex4) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex4);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Error executing Runtime.getRuntime().exec()\\n\" + ex4.toString(), 0);\n                ex4.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (IllegalArgumentException ex5) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex5);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Illegal argument sent to Runtime.getRuntime().exec()\\n\" + ex5.toString(), 0);\n                ex5.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (Exception ex6) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex6);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Unknown Error occurred\\n\" + ex6.toString(), 0);\n                ex6.printStackTrace();\n                this.m_Error = true;\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 1961,
        "token_number_fewshot": 2359,
        "token_number_cot": 2071
    },
    {
        "project_name": "47_dvd-homevideo",
        "class": "Convert",
        "source_code": "import java.util.*;\nimport java.io.*;\n\npublic class Convert implements Runnable\n{\n    private int m_Quality;\n    private double m_fps;\n    private String m_Format;\n    private String m_AspectRatio;\n    private String m_flags;\n    private String m_bitrate;\n    protected String[] video_files;\n    private GUI m_GUI;\n    private Thread m_Thread;\n    private boolean m_Error;\n    private int thread_track;\n    private String m_BaseErr;\n    private String m_transcode;\n    private String mplex;\n    \n    public Convert(final String format, final String aspectRatio, final GUI DVD_GUI) {\n        this.m_bitrate = \"8500\";\n        this.m_BaseErr = \"Transcoding Error - \";\n        this.m_transcode = \"transcode -i dv/inp -m test1.ac3 -o test1 -w bitr -x dv,dv -F flags -y mpeg2enc,raw -N 0x2000 -b 256 --encode_fields b -E 48000,16,2 -J resample --export_prof format --export_fps frames/s --export_asr aspectRatio -j 0,8,0,8 --print_status 30\";\n        this.mplex = \"mplex -f 8 -V -o inp.vob inp.m2v inp.ac3\";\n        if (format.equals(\"dvd-ntsc\")) {\n            this.m_fps = 29.97;\n        }\n        else {\n            this.m_fps = 25.0;\n        }\n        this.m_GUI = DVD_GUI;\n        this.m_Format = format;\n        this.m_AspectRatio = aspectRatio;\n        this.thread_track = 0;\n    }\n    \n    public Convert(final int quality, final String format, final String aspectRatio, final GUI DVD_GUI) {\n        this.m_bitrate = \"8500\";\n        this.m_BaseErr = \"Transcoding Error - \";\n        this.m_transcode = \"transcode -i dv/inp -m test1.ac3 -o test1 -w bitr -x dv,dv -F flags -y mpeg2enc,raw -N 0x2000 -b 256 --encode_fields b -E 48000,16,2 -J resample --export_prof format --export_fps frames/s --export_asr aspectRatio -j 0,8,0,8 --print_status 30\";\n        this.mplex = \"mplex -f 8 -V -o inp.vob inp.m2v inp.ac3\";\n        if (format.equals(\"dvd-ntsc\")) {\n            this.m_fps = 29.97;\n        }\n        else {\n            this.m_fps = 25.0;\n        }\n        this.m_GUI = DVD_GUI;\n        this.m_Quality = quality;\n        this.m_Format = format;\n        this.m_AspectRatio = aspectRatio;\n        this.thread_track = 0;\n    }\n    \n    public boolean init() {\n        if (this.m_GUI.menuChkThread.isSelected()) {\n            (this.m_Thread = new Thread(this)).start();\n            try {\n                this.m_Thread.join();\n            }\n            catch (InterruptedException ex) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Could not join Convert.java thread\\n\" + ex.toString(), 0);\n                ex.printStackTrace();\n                this.m_Error = true;\n            }\n        }\n        else {\n            this.Transcode();\n        }\n        return this.m_Error || this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/transcode.log\") || this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/mplex.log\");\n    }\n    \n    @Override\n    public void run() {\n        this.Transcode();\n    }\n    \n    public void Transcode() {\n        final File ListDir = new File(this.m_GUI.strOutputDir + \"/dv/\");\n        if (this.m_Quality == 0) {\n            this.m_flags = \"'8, -c -q 2 -4 1 -2 1 -H -K file=matrix.txt -R 2'\";\n        }\n        else if (this.m_Quality == 1) {\n            this.m_flags = \"'8, -c -q 4 -4 2 -2 2 -K file=matrix.txt -R 1'\";\n        }\n        else {\n            this.m_flags = \"'8, -c -q 6 -4 3 -2 3 -N 0.5 -E -10 -K tmpgenc -R 0'\";\n        }\n        this.m_transcode = this.m_transcode.replaceAll(\"flags\", this.m_flags);\n        this.m_transcode = this.m_transcode.replaceAll(\"bitr\", this.m_bitrate);\n        this.m_transcode = this.m_transcode.replaceAll(\"format\", this.m_Format);\n        this.m_transcode = this.m_transcode.replaceAll(\"aspectRatio\", this.m_AspectRatio);\n        this.m_transcode = this.m_transcode.replaceAll(\"frames/s\", String.valueOf(this.m_fps));\n        this.matrix();\n        this.m_GUI.lblConvert.setEnabled(true);\n        this.m_GUI.prgConvert.setEnabled(true);\n        this.m_GUI.lblConvertProg.setEnabled(true);\n        double cummulative_time = 0.0;\n        double current_time = 0.0;\n        final double[] average_fps = { 0.0, 0.0, 0.0, 0.0, -1.0 };\n        final int total_time = (int)this.m_GUI.spnMinutes.getValue() * 60 + (int)this.m_GUI.spnSeconds.getValue();\n        while (this.thread_track < ListDir.list().length) {\n            this.video_files = ListDir.list();\n            try {\n                if (this.thread_track == 0) {\n                    this.m_transcode = this.m_transcode.replaceAll(\"inp\", this.video_files[this.thread_track]);\n                    this.m_transcode = this.m_transcode.replaceAll(\"test1\", this.video_files[this.thread_track].substring(0, 11));\n                    this.mplex = this.mplex.replaceAll(\"inp\", this.video_files[this.thread_track].substring(0, 11));\n                }\n                else {\n                    this.m_transcode = this.m_transcode.replaceAll(this.video_files[this.thread_track - 1], this.video_files[this.thread_track]);\n                    this.m_transcode = this.m_transcode.replaceAll(this.video_files[this.thread_track - 1].substring(0, 11), this.video_files[this.thread_track].substring(0, 11));\n                    this.mplex = this.mplex.replaceAll(this.video_files[this.thread_track - 1].substring(0, 11), this.video_files[this.thread_track].substring(0, 11));\n                }\n            }\n            catch (StringIndexOutOfBoundsException ex) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Are there non-standard (not .dv)\" + \"\\nfiles in the dv directory?\\n\" + ex.toString(), 0);\n                ex.printStackTrace();\n                this.m_Error = true;\n            }\n            try {\n                final String[] transcode_cmd = { \"/bin/sh\", \"-c\", this.m_transcode };\n                Process p = Runtime.getRuntime().exec(transcode_cmd, null, new File(this.m_GUI.strOutputDir));\n                BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                BufferedReader err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                BufferedWriter out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/transcode.log\"));\n                BufferedWriter err_out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/transcode.err\"));\n                out.write(this.m_transcode);\n                out.newLine();\n                if (err_in.ready()) {\n                    final String line = err_in.readLine();\n                    if (line.equals(\"/bin/sh: transcode: command not found\")) {\n                        this.m_GUI.MessageBox(\"Could not locate transcode in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                        in.close();\n                        out.close();\n                        err_in.close();\n                        err_out.close();\n                        this.m_Error = true;\n                    }\n                    else {\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                int k = 0;\n                String line;\n                while ((line = in.readLine()) != null) {\n                    final StringTokenizer st = new StringTokenizer(line);\n                    if (st.hasMoreTokens() && st.nextToken().equals(\"encoding\")) {\n                        st.nextToken();\n                        st.nextToken();\n                        average_fps[k % 5] = Double.valueOf(st.nextToken());\n                        st.nextToken();\n                        st.nextToken();\n                        final StringTokenizer time = new StringTokenizer(st.nextToken(), \":,\");\n                        if (time.hasMoreTokens()) {\n                            final int hour = Integer.valueOf(time.nextToken());\n                            final int min = Integer.valueOf(time.nextToken());\n                            final int sec = Integer.valueOf(time.nextToken());\n                            current_time = hour * 3600 + min * 60 + sec + cummulative_time;\n                            this.m_GUI.prgConvert.setValue((int)(current_time / total_time * 100.0));\n                            this.m_GUI.lblConvertProg.setText(String.valueOf((int)(current_time / total_time * 100.0)) + \"%\");\n                            double fps_sum = 0.0;\n                            if (average_fps[4] != -1.0) {\n                                for (int j = 0; j < 5; ++j) {\n                                    fps_sum += average_fps[j];\n                                }\n                                fps_sum /= 5.0;\n                                final int time_remaining = (int)((total_time - current_time) * (int)this.m_fps / fps_sum);\n                                final int captureTipHour = time_remaining / 3600;\n                                final int captureTipMinute = (time_remaining - 3600 * captureTipHour) / 60;\n                                if (captureTipHour == 0 && captureTipMinute < 5) {\n                                    this.m_GUI.prgConvert.setToolTipText(\"Less than 5 minutes remaining\");\n                                }\n                                else if (captureTipMinute < 10) {\n                                    this.m_GUI.prgConvert.setToolTipText(captureTipHour + \":0\" + captureTipMinute + \" Remaining\");\n                                }\n                                else {\n                                    this.m_GUI.prgConvert.setToolTipText(captureTipHour + \":\" + captureTipMinute + \" Remaining\");\n                                }\n                            }\n                            this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                            this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                            out.write(line);\n                            out.newLine();\n                        }\n                        else {\n                            this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                            this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                            out.write(line);\n                            out.newLine();\n                        }\n                        ++k;\n                    }\n                }\n                while ((line = err_in.readLine()) != null) {\n                    this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                    this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                    out.write(line);\n                    out.newLine();\n                }\n                in.close();\n                out.close();\n                err_in.close();\n                err_out.close();\n                cummulative_time = current_time;\n                final String[] mplex_cmd = { \"/bin/sh\", \"-c\", this.mplex };\n                p = Runtime.getRuntime().exec(mplex_cmd, null, new File(this.m_GUI.strOutputDir));\n                in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/mplex.log\"));\n                err_out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/mplex.err\"));\n                if (err_in.ready()) {\n                    line = err_in.readLine();\n                    if (line.equals(\"/bin/sh: mplex: command not found\")) {\n                        this.m_GUI.MessageBox(\"Could not locate mplex in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                        in.close();\n                        out.close();\n                        err_in.close();\n                        err_out.close();\n                        this.m_Error = true;\n                    }\n                    else {\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                while ((line = err_in.readLine()) != null) {\n                    this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                    this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                    out.write(line);\n                    out.newLine();\n                }\n                in.close();\n                out.close();\n                err_in.close();\n                err_out.close();\n                Thread.sleep(2000L);\n            }\n            catch (IOException ex2) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex2.toString(), 0);\n                ex2.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (NullPointerException ex3) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex3);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Error executing Runtime.getRuntime().exec()\\n\" + ex3.toString(), 0);\n                ex3.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (IllegalArgumentException ex4) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex4);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Illegal argument sent to Runtime.getRuntime().exec()\\n\" + ex4.toString(), 0);\n                ex4.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (Exception ex5) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex5);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Unknown Error occurred\\n\" + ex5.toString(), 0);\n                ex5.printStackTrace();\n                this.m_Error = true;\n            }\n            ++this.thread_track;\n        }\n        this.m_GUI.prgConvert.setValue(100);\n        this.m_GUI.lblConvertProg.setText(\"100%\");\n        this.m_GUI.prgConvert.setEnabled(false);\n        this.m_GUI.lblConvert.setEnabled(false);\n        this.m_GUI.lblConvertProg.setEnabled(false);\n    }\n    \n    public void matrix() {\n        try {\n            final FileWriter fw = new FileWriter(this.m_GUI.strOutputDir + \"/\" + \"matrix.txt\");\n            final BufferedWriter wr = new BufferedWriter(fw);\n            wr.write(\"# High resolution INTRA table\\n\");\n            wr.write(\"8,16,18,20,24,25,26,30\\n\");\n            wr.write(\"16,16,20,23,25,26,30,30\\n\");\n            wr.write(\"18,20,22,24,26,28,29,31\\n\");\n            wr.write(\"20,21,23,24,26,28,31,31\\n\");\n            wr.write(\"21,23,24,25,28,30,30,33\\n\");\n            wr.write(\"23,24,25,28,30,30,33,36\\n\");\n            wr.write(\"24,25,26,29,29,31,34,38\\n\");\n            wr.write(\"25,26,28,29,31,34,38,42\\n\");\n            wr.write(\"# TMPEGEnc NON-INTRA table\\n\");\n            wr.write(\"16,17,18,19,20,21,22,23\\n\");\n            wr.write(\"17,18,19,20,21,22,23,24\\n\");\n            wr.write(\"18,19,20,21,22,23,24,25\\n\");\n            wr.write(\"19,20,21,22,23,24,26,27\\n\");\n            wr.write(\"20,21,22,23,25,26,27,28\\n\");\n            wr.write(\"21,22,23,24,26,27,28,30\\n\");\n            wr.write(\"22,23,24,26,27,28,30,31\\n\");\n            wr.write(\"23,24,25,27,28,30,31,33\\n\");\n            wr.close();\n            fw.close();\n        }\n        catch (IOException ex) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n            this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex.toString(), 0);\n            ex.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n",
        "token_number_zeroshot": 3468,
        "token_number_fewshot": 3866,
        "token_number_cot": 3578
    },
    {
        "project_name": "83_xbus",
        "class": "MessageHandler",
        "source_code": "package net.sf.xbus.base.core;\n\nimport net.sf.xbus.base.core.trace.*;\nimport net.sf.xbus.base.core.strings.*;\nimport java.io.*;\nimport java.util.*;\nimport net.sf.xbus.base.core.config.*;\n\npublic class MessageHandler\n{\n    private static Hashtable mInstances;\n    private static final Object classLock;\n    private Hashtable mMessages;\n    \n    public String getMessage(final String key, final List params) {\n        String messageText = null;\n        messageText = this.getMessageOptional(key, params);\n        if (messageText == null) {\n            messageText = \"Key: \" + key + \" not found in message file\";\n            Trace.error(messageText);\n        }\n        return messageText;\n    }\n    \n    public String getMessageOptional(final String key, final List params) {\n        String messageText = null;\n        if (this.mMessages == null) {\n            return null;\n        }\n        messageText = this.mMessages.get(key);\n        if (messageText == null) {\n            return null;\n        }\n        int counter = 1;\n        if (params != null) {\n            String paramText = null;\n            Object paramObject = null;\n            final Iterator it = params.iterator();\n            while (it.hasNext()) {\n                paramObject = it.next();\n                if (paramObject != null) {\n                    paramText = paramObject.toString();\n                }\n                else {\n                    paramText = \"<null>\";\n                }\n                final String paramCounter = \"$\" + counter + \"$\";\n                if (messageText.indexOf(paramCounter) >= 0) {\n                    messageText = XStringSupport.replaceAll(messageText, paramCounter, paramText);\n                    ++counter;\n                }\n            }\n        }\n        return messageText;\n    }\n    \n    public static MessageHandler getInstance(final String basename) {\n        synchronized (MessageHandler.classLock) {\n            MessageHandler instance = MessageHandler.mInstances.get(basename);\n            if (instance == null) {\n                instance = new MessageHandler(basename);\n                MessageHandler.mInstances.put(basename, instance);\n            }\n            return instance;\n        }\n    }\n    \n    private MessageHandler(final String basename) {\n        this.mMessages = null;\n        this.mMessages = new Hashtable();\n        this.addMessages(basename, Constants.XBUS_ETC);\n        this.addMessages(basename, Constants.XBUS_PLUGIN_ETC);\n    }\n    \n    private void addMessages(final String basename, final String dir) {\n        final Locale locale = Locale.ENGLISH;\n        final String postfix = \"_\" + locale.toString() + \".properties\";\n        final File dirFile = new File(dir);\n        final String[] messagesFiles = dirFile.list(new MessagesFilter(basename, postfix));\n        for (int i = 0; messagesFiles != null && i < messagesFiles.length; ++i) {\n            final Properties newProps = new Properties();\n            try {\n                final FileInputStream instream = new FileInputStream(dir + messagesFiles[i]);\n                newProps.load(instream);\n                instream.close();\n            }\n            catch (FileNotFoundException e) {\n                System.out.println(\"Cannot find messagefile\");\n                System.exit(1);\n            }\n            catch (IOException e2) {\n                System.out.println(\"Cannot find messagefile\");\n                System.exit(1);\n            }\n            String key = null;\n            final Enumeration keys = newProps.keys();\n            while (keys.hasMoreElements()) {\n                key = keys.nextElement();\n                this.mMessages.put(key, ((Hashtable<K, Object>)newProps).get(key));\n            }\n        }\n    }\n    \n    static {\n        MessageHandler.mInstances = new Hashtable();\n        classLock = Configuration.class;\n    }\n    \n    private static class MessagesFilter implements FilenameFilter\n    {\n        private String mPrefix;\n        private String mPostfix;\n        \n        public MessagesFilter(final String prefix, final String postfix) {\n            this.mPrefix = null;\n            this.mPostfix = null;\n            this.mPrefix = prefix;\n            this.mPostfix = postfix;\n        }\n        \n        @Override\n        public boolean accept(final File dir, final String filename) {\n            return filename.startsWith(this.mPrefix) && filename.endsWith(this.mPostfix);\n        }\n    }\n}\n",
        "token_number_zeroshot": 876,
        "token_number_fewshot": 1274,
        "token_number_cot": 987
    },
    {
        "project_name": "83_xbus",
        "class": "XBUSClassLoader",
        "source_code": "package net.sf.xbus.base.core.reflection;\n\nimport net.sf.xbus.base.core.*;\nimport net.sf.xbus.base.core.trace.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\n\npublic class XBUSClassLoader extends URLClassLoader\n{\n    private static XBUSClassLoader mClassLoader;\n    private static final Object classLock;\n    \n    private XBUSClassLoader(final URL[] urlArray, final ClassLoader parent) {\n        super(urlArray, parent);\n    }\n    \n    public static XBUSClassLoader getInstance(final ClassLoader parent) {\n        return createClassLoader(parent);\n    }\n    \n    private static XBUSClassLoader createClassLoader(final ClassLoader parent) {\n        synchronized (XBUSClassLoader.classLock) {\n            if (XBUSClassLoader.mClassLoader == null) {\n                if (Constants.XBUS_HOME == null) {\n                    Trace.error(\"XBUS_HOME has not been set!\");\n                    System.exit(1);\n                }\n                final Vector urls = new Vector();\n                addUrls(urls, Constants.XBUS_HOME + \"/lib\");\n                addUrls(urls, Constants.XBUS_HOME + \"/lib/runtime\");\n                addUrls(urls, Constants.XBUS_HOME + \"/plugin/lib\");\n                addUrls(urls, Constants.XBUS_HOME + \"/test/lib\");\n                final URL[] urlArray = new URL[urls.size()];\n                for (int i = 0; i < urls.size(); ++i) {\n                    urlArray[i] = urls.elementAt(i);\n                }\n                XBUSClassLoader.mClassLoader = new XBUSClassLoader(urlArray, parent);\n            }\n        }\n        return XBUSClassLoader.mClassLoader;\n    }\n    \n    private static void addUrls(final Vector urls, final String dirName) {\n        final File libPath = new File(dirName);\n        final File[] jars = libPath.listFiles();\n        for (int i = 0; jars != null && i < jars.length; ++i) {\n            if (jars[i].isFile()) {\n                if (!jars[i].getName().endsWith(\"jar\")) {\n                    if (!jars[i].getName().endsWith(\"zip\")) {\n                        continue;\n                    }\n                }\n                try {\n                    urls.add(jars[i].toURL());\n                }\n                catch (MalformedURLException e) {\n                    Trace.error(e);\n                    System.exit(1);\n                }\n            }\n        }\n    }\n    \n    static {\n        XBUSClassLoader.mClassLoader = null;\n        classLock = XBUSClassLoader.class;\n    }\n}\n",
        "token_number_zeroshot": 525,
        "token_number_fewshot": 923,
        "token_number_cot": 637
    },
    {
        "project_name": "77_io-project",
        "class": "ClientGroup",
        "source_code": "package ioproject.server.network;\n\nimport java.lang.ref.*;\nimport ioproject.common.network.*;\nimport java.util.*;\n\npublic class ClientGroup implements Iterable<Client>\n{\n    private ClientGroup parentGroup;\n    private Set<WeakReference<ClientGroup>> subGroups;\n    private Set<Client> clients;\n    private ClientHandler handler;\n    \n    ClientGroup(final ClientGroup theParentGroup) {\n        this.parentGroup = theParentGroup;\n        this.subGroups = new LinkedHashSet<WeakReference<ClientGroup>>();\n        this.clients = new LinkedHashSet<Client>();\n        this.handler = null;\n    }\n    \n    ClientGroup parentGroup() {\n        return this.parentGroup;\n    }\n    \n    synchronized boolean notifyMessageSent(final Client client, final Object message) {\n        if (!this.clients.contains(client)) {\n            return false;\n        }\n        boolean inSubGroup = false;\n        for (final WeakReference<ClientGroup> groupReference : this.subGroups) {\n            inSubGroup = (groupReference.get().notifyMessageSent(client, message) || inSubGroup);\n        }\n        if (!inSubGroup && this.handler != null) {\n            this.handler.messageSent(client, message);\n        }\n        return true;\n    }\n    \n    synchronized boolean notifyMessageReceived(final Client client, final Object message) {\n        if (!this.clients.contains(client)) {\n            return false;\n        }\n        boolean inSubGroup = false;\n        for (final WeakReference<ClientGroup> groupReference : this.subGroups) {\n            inSubGroup = (groupReference.get().notifyMessageReceived(client, message) || inSubGroup);\n        }\n        if (!inSubGroup && this.handler != null) {\n            this.handler.messageReceived(client, message);\n        }\n        return true;\n    }\n    \n    synchronized boolean notifyExceptionCaught(final Client client, final Throwable cause) {\n        if (!this.clients.contains(client)) {\n            return false;\n        }\n        boolean inSubGroup = false;\n        for (final WeakReference<ClientGroup> groupReference : this.subGroups) {\n            inSubGroup = (groupReference.get().notifyExceptionCaught(client, cause) || inSubGroup);\n        }\n        if (!inSubGroup && this.handler != null) {\n            this.handler.exceptionCaught(client, cause);\n        }\n        return true;\n    }\n    \n    @Override\n    public Iterator<Client> iterator() {\n        return Collections.unmodifiableSet((Set<? extends Client>)this.clients).iterator();\n    }\n    \n    public synchronized boolean contains(final Client client) {\n        return this.clients.contains(client);\n    }\n    \n    public synchronized int size() {\n        return this.clients.size();\n    }\n    \n    public synchronized boolean add(final Client client) {\n        final boolean parentContainsClient = this.parentGroup == null || this.parentGroup.contains(client);\n        if (parentContainsClient) {\n            this.clients.add(client);\n        }\n        if (this.handler != null) {\n            this.handler.clientAdded(client);\n        }\n        return parentContainsClient;\n    }\n    \n    public synchronized boolean remove(final Client client) {\n        final boolean clientIsMember = this.clients.contains(client);\n        if (clientIsMember) {\n            this.clients.remove(client);\n            for (final WeakReference<ClientGroup> subGroupReference : this.subGroups) {\n                subGroupReference.get().remove(client);\n            }\n        }\n        if (this.handler != null) {\n            this.handler.clientRemoved(client);\n        }\n        return clientIsMember;\n    }\n    \n    public synchronized ClientGroup createSubGroup() {\n        final ClientGroup subGroup = new ClientGroup(this);\n        this.subGroups.add(new WeakReference<ClientGroup>(subGroup));\n        return subGroup;\n    }\n    \n    public synchronized void addClientHandler(final ClientHandler aHandler) {\n        this.handler = aHandler;\n    }\n}\n",
        "token_number_zeroshot": 795,
        "token_number_fewshot": 1193,
        "token_number_cot": 906
    },
    {
        "project_name": "commons-cli",
        "class": "Option",
        "source_code": "package org.apache.commons.cli;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Option implements Cloneable, Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public static final int UNINITIALIZED = -1;\n    public static final int UNLIMITED_VALUES = -2;\n    private String opt;\n    private String longOpt;\n    private String argName;\n    private String description;\n    private boolean required;\n    private boolean optionalArg;\n    private int numberOfArgs;\n    private Object type;\n    private List values;\n    private char valuesep;\n    \n    public Option(final String opt, final String description) throws IllegalArgumentException {\n        this(opt, null, false, description);\n    }\n    \n    public Option(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(opt, null, hasArg, description);\n    }\n    \n    public Option(final String opt, final String longOpt, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this.argName = \"arg\";\n        this.numberOfArgs = -1;\n        this.values = new ArrayList();\n        OptionValidator.validateOption(opt);\n        this.opt = opt;\n        this.longOpt = longOpt;\n        if (hasArg) {\n            this.numberOfArgs = 1;\n        }\n        this.description = description;\n    }\n    \n    public int getId() {\n        return this.getKey().charAt(0);\n    }\n    \n    String getKey() {\n        if (this.opt == null) {\n            return this.longOpt;\n        }\n        return this.opt;\n    }\n    \n    public String getOpt() {\n        return this.opt;\n    }\n    \n    public Object getType() {\n        return this.type;\n    }\n    \n    public void setType(final Object type) {\n        this.type = type;\n    }\n    \n    public String getLongOpt() {\n        return this.longOpt;\n    }\n    \n    public void setLongOpt(final String longOpt) {\n        this.longOpt = longOpt;\n    }\n    \n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n    \n    public boolean hasOptionalArg() {\n        return this.optionalArg;\n    }\n    \n    public boolean hasLongOpt() {\n        return this.longOpt != null;\n    }\n    \n    public boolean hasArg() {\n        return this.numberOfArgs > 0 || this.numberOfArgs == -2;\n    }\n    \n    public String getDescription() {\n        return this.description;\n    }\n    \n    public void setDescription(final String description) {\n        this.description = description;\n    }\n    \n    public boolean isRequired() {\n        return this.required;\n    }\n    \n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n    \n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n    \n    public String getArgName() {\n        return this.argName;\n    }\n    \n    public boolean hasArgName() {\n        return this.argName != null && this.argName.length() > 0;\n    }\n    \n    public boolean hasArgs() {\n        return this.numberOfArgs > 1 || this.numberOfArgs == -2;\n    }\n    \n    public void setArgs(final int num) {\n        this.numberOfArgs = num;\n    }\n    \n    public void setValueSeparator(final char sep) {\n        this.valuesep = sep;\n    }\n    \n    public char getValueSeparator() {\n        return this.valuesep;\n    }\n    \n    public boolean hasValueSeparator() {\n        return this.valuesep > '\\0';\n    }\n    \n    public int getArgs() {\n        return this.numberOfArgs;\n    }\n    \n    void addValueForProcessing(final String value) {\n        switch (this.numberOfArgs) {\n            case -1: {\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n            }\n            default: {\n                this.processValue(value);\n            }\n        }\n    }\n    \n    private void processValue(String value) {\n        if (this.hasValueSeparator()) {\n            final char sep = this.getValueSeparator();\n            for (int index = value.indexOf(sep); index != -1; index = value.indexOf(sep)) {\n                if (this.values.size() == this.numberOfArgs - 1) {\n                    break;\n                }\n                this.add(value.substring(0, index));\n                value = value.substring(index + 1);\n            }\n        }\n        this.add(value);\n    }\n    \n    private void add(final String value) {\n        if (this.numberOfArgs > 0 && this.values.size() > this.numberOfArgs - 1) {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n        this.values.add(value);\n    }\n    \n    public String getValue() {\n        return this.hasNoValues() ? null : this.values.get(0);\n    }\n    \n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return this.hasNoValues() ? null : this.values.get(index);\n    }\n    \n    public String getValue(final String defaultValue) {\n        final String value = this.getValue();\n        return (value != null) ? value : defaultValue;\n    }\n    \n    public String[] getValues() {\n        return (String[])(this.hasNoValues() ? null : ((String[])this.values.toArray(new String[this.values.size()])));\n    }\n    \n    public List getValuesList() {\n        return this.values;\n    }\n    \n    public String toString() {\n        final StringBuffer buf = new StringBuffer().append(\"[ option: \");\n        buf.append(this.opt);\n        if (this.longOpt != null) {\n            buf.append(\" \").append(this.longOpt);\n        }\n        buf.append(\" \");\n        if (this.hasArgs()) {\n            buf.append(\"[ARG...]\");\n        }\n        else if (this.hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n        buf.append(\" :: \").append(this.description);\n        if (this.type != null) {\n            buf.append(\" :: \").append(this.type);\n        }\n        buf.append(\" ]\");\n        return buf.toString();\n    }\n    \n    private boolean hasNoValues() {\n        return this.values.isEmpty();\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final Option option = (Option)o;\n        Label_0062: {\n            if (this.opt != null) {\n                if (this.opt.equals(option.opt)) {\n                    break Label_0062;\n                }\n            }\n            else if (option.opt == null) {\n                break Label_0062;\n            }\n            return false;\n        }\n        if (this.longOpt != null) {\n            if (this.longOpt.equals(option.longOpt)) {\n                return true;\n            }\n        }\n        else if (option.longOpt == null) {\n            return true;\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        int result = (this.opt != null) ? this.opt.hashCode() : 0;\n        result = 31 * result + ((this.longOpt != null) ? this.longOpt.hashCode() : 0);\n        return result;\n    }\n    \n    public Object clone() {\n        try {\n            final Option option = (Option)super.clone();\n            option.values = new ArrayList(this.values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse) {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n    \n    void clearValues() {\n        this.values.clear();\n    }\n    \n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. Subclasses should use the addValueForProcessing method instead. \");\n    }\n}\n",
        "token_number_zeroshot": 1623,
        "token_number_fewshot": 2021,
        "token_number_cot": 1733
    },
    {
        "project_name": "commons-cli",
        "class": "HelpFormatter",
        "source_code": "package org.apache.commons.cli;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class HelpFormatter\n{\n    public static final int DEFAULT_WIDTH = 74;\n    public static final int DEFAULT_LEFT_PAD = 1;\n    public static final int DEFAULT_DESC_PAD = 3;\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n    public int defaultWidth;\n    public int defaultLeftPad;\n    public int defaultDescPad;\n    public String defaultSyntaxPrefix;\n    public String defaultNewLine;\n    public String defaultOptPrefix;\n    public String defaultLongOptPrefix;\n    public String defaultArgName;\n    protected Comparator optionComparator;\n    \n    public HelpFormatter() {\n        this.defaultWidth = 74;\n        this.defaultLeftPad = 1;\n        this.defaultDescPad = 3;\n        this.defaultSyntaxPrefix = \"usage: \";\n        this.defaultNewLine = System.getProperty(\"line.separator\");\n        this.defaultOptPrefix = \"-\";\n        this.defaultLongOptPrefix = \"--\";\n        this.defaultArgName = \"arg\";\n        this.optionComparator = new OptionComparator();\n    }\n    \n    public void setWidth(final int width) {\n        this.defaultWidth = width;\n    }\n    \n    public int getWidth() {\n        return this.defaultWidth;\n    }\n    \n    public void setLeftPadding(final int padding) {\n        this.defaultLeftPad = padding;\n    }\n    \n    public int getLeftPadding() {\n        return this.defaultLeftPad;\n    }\n    \n    public void setDescPadding(final int padding) {\n        this.defaultDescPad = padding;\n    }\n    \n    public int getDescPadding() {\n        return this.defaultDescPad;\n    }\n    \n    public void setSyntaxPrefix(final String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n    \n    public String getSyntaxPrefix() {\n        return this.defaultSyntaxPrefix;\n    }\n    \n    public void setNewLine(final String newline) {\n        this.defaultNewLine = newline;\n    }\n    \n    public String getNewLine() {\n        return this.defaultNewLine;\n    }\n    \n    public void setOptPrefix(final String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n    \n    public String getOptPrefix() {\n        return this.defaultOptPrefix;\n    }\n    \n    public void setLongOptPrefix(final String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n    \n    public String getLongOptPrefix() {\n        return this.defaultLongOptPrefix;\n    }\n    \n    public void setArgName(final String name) {\n        this.defaultArgName = name;\n    }\n    \n    public String getArgName() {\n        return this.defaultArgName;\n    }\n    \n    public Comparator getOptionComparator() {\n        return this.optionComparator;\n    }\n    \n    public void setOptionComparator(final Comparator comparator) {\n        if (comparator == null) {\n            this.optionComparator = new OptionComparator();\n        }\n        else {\n            this.optionComparator = comparator;\n        }\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final Options options) {\n        this.printHelp(this.defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {\n        this.printHelp(this.defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        this.printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        this.printHelp(this.defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n    \n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        this.printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n    \n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        final PrintWriter pw = new PrintWriter(System.out);\n        this.printHelp(pw, width, cmdLineSyntax, header, options, this.defaultLeftPad, this.defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n    \n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad, final int descPad, final String footer) {\n        this.printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n    \n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad, final int descPad, final String footer, final boolean autoUsage) {\n        if (cmdLineSyntax == null || cmdLineSyntax.length() == 0) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n        if (autoUsage) {\n            this.printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else {\n            this.printUsage(pw, width, cmdLineSyntax);\n        }\n        if (header != null && header.trim().length() > 0) {\n            this.printWrapped(pw, width, header);\n        }\n        this.printOptions(pw, width, options, leftPad, descPad);\n        if (footer != null && footer.trim().length() > 0) {\n            this.printWrapped(pw, width, footer);\n        }\n    }\n    \n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {\n        final StringBuffer buff = new StringBuffer(this.defaultSyntaxPrefix).append(app).append(\" \");\n        final Collection processedGroups = new ArrayList();\n        final List optList = new ArrayList(options.getOptions());\n        Collections.sort((List<Object>)optList, this.getOptionComparator());\n        final Iterator i = optList.iterator();\n        while (i.hasNext()) {\n            final Option option = i.next();\n            final OptionGroup group = options.getOptionGroup(option);\n            if (group != null) {\n                if (!processedGroups.contains(group)) {\n                    processedGroups.add(group);\n                    this.appendOptionGroup(buff, group);\n                }\n            }\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n            if (i.hasNext()) {\n                buff.append(\" \");\n            }\n        }\n        this.printWrapped(pw, width, buff.toString().indexOf(32) + 1, buff.toString());\n    }\n    \n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n        final List optList = new ArrayList(group.getOptions());\n        Collections.sort((List<Object>)optList, this.getOptionComparator());\n        final Iterator i = optList.iterator();\n        while (i.hasNext()) {\n            appendOption(buff, i.next(), true);\n            if (i.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }\n    \n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n        if (!required) {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        if (option.hasArg() && option.hasArgName()) {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }\n    \n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {\n        final int argPos = cmdLineSyntax.indexOf(32) + 1;\n        this.printWrapped(pw, width, this.defaultSyntaxPrefix.length() + argPos, this.defaultSyntaxPrefix + cmdLineSyntax);\n    }\n    \n    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {\n        final StringBuffer sb = new StringBuffer();\n        this.renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n    \n    public void printWrapped(final PrintWriter pw, final int width, final String text) {\n        this.printWrapped(pw, width, 0, text);\n    }\n    \n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {\n        final StringBuffer sb = new StringBuffer(text.length());\n        this.renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n    \n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\n        final String lpad = this.createPadding(leftPad);\n        final String dpad = this.createPadding(descPad);\n        int max = 0;\n        final List prefixList = new ArrayList();\n        final List optList = options.helpOptions();\n        Collections.sort((List<Object>)optList, this.getOptionComparator());\n        for (final Option option : optList) {\n            final StringBuffer optBuf = new StringBuffer(8);\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \" + this.defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else {\n                optBuf.append(lpad).append(this.defaultOptPrefix).append(option.getOpt());\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(this.defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n            if (option.hasArg()) {\n                if (option.hasArgName()) {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else {\n                    optBuf.append(' ');\n                }\n            }\n            prefixList.add(optBuf);\n            max = ((optBuf.length() > max) ? optBuf.length() : max);\n        }\n        int x = 0;\n        final Iterator j = optList.iterator();\n        while (j.hasNext()) {\n            final Option option2 = j.next();\n            final StringBuffer optBuf = new StringBuffer(prefixList.get(x++).toString());\n            if (optBuf.length() < max) {\n                optBuf.append(this.createPadding(max - optBuf.length()));\n            }\n            optBuf.append(dpad);\n            final int nextLineTabStop = max + descPad;\n            if (option2.getDescription() != null) {\n                optBuf.append(option2.getDescription());\n            }\n            this.renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n            if (j.hasNext()) {\n                sb.append(this.defaultNewLine);\n            }\n        }\n        return sb;\n    }\n    \n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, int nextLineTabStop, String text) {\n        int pos = this.findWrapPos(text, width, 0);\n        if (pos == -1) {\n            sb.append(this.rtrim(text));\n            return sb;\n        }\n        sb.append(this.rtrim(text.substring(0, pos))).append(this.defaultNewLine);\n        if (nextLineTabStop >= width) {\n            nextLineTabStop = 1;\n        }\n        final String padding = this.createPadding(nextLineTabStop);\n        while (true) {\n            text = padding + text.substring(pos).trim();\n            pos = this.findWrapPos(text, width, 0);\n            if (pos == -1) {\n                break;\n            }\n            if (text.length() > width && pos == nextLineTabStop - 1) {\n                pos = width;\n            }\n            sb.append(this.rtrim(text.substring(0, pos))).append(this.defaultNewLine);\n        }\n        sb.append(text);\n        return sb;\n    }\n    \n    protected int findWrapPos(final String text, final int width, final int startPos) {\n        int pos = -1;\n        if (((pos = text.indexOf(10, startPos)) != -1 && pos <= width) || ((pos = text.indexOf(9, startPos)) != -1 && pos <= width)) {\n            return pos + 1;\n        }\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n        char c;\n        for (pos = startPos + width; pos >= startPos && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r'; --pos) {}\n        if (pos > startPos) {\n            return pos;\n        }\n        for (pos = startPos + width; pos <= text.length() && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r'; ++pos) {}\n        return (pos == text.length()) ? -1 : pos;\n    }\n    \n    protected String createPadding(final int len) {\n        final StringBuffer sb = new StringBuffer(len);\n        for (int i = 0; i < len; ++i) {\n            sb.append(' ');\n        }\n        return sb.toString();\n    }\n    \n    protected String rtrim(final String s) {\n        if (s == null || s.length() == 0) {\n            return s;\n        }\n        int pos;\n        for (pos = s.length(); pos > 0 && Character.isWhitespace(s.charAt(pos - 1)); --pos) {}\n        return s.substring(0, pos);\n    }\n    \n    private static class OptionComparator implements Comparator\n    {\n        public int compare(final Object o1, final Object o2) {\n            final Option opt1 = (Option)o1;\n            final Option opt2 = (Option)o2;\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n",
        "token_number_zeroshot": 2975,
        "token_number_fewshot": 3373,
        "token_number_cot": 3086
    },
    {
        "project_name": "55_lavalamp",
        "class": "TimeOfDay",
        "source_code": "package net.sf.lavalamp.device;\n\npublic class TimeOfDay implements Comparable<TimeOfDay>\n{\n    private Integer hours;\n    private Integer minutes;\n    \n    public TimeOfDay(final int hours, final int minutes) {\n        this.hours = hours;\n        this.minutes = minutes;\n    }\n    \n    public TimeOfDay(final String time) {\n        this.hours = new Integer(time.substring(0, 2));\n        this.minutes = new Integer(time.substring(3, 5));\n    }\n    \n    @Override\n    public int compareTo(final TimeOfDay that) {\n        final int hourComparison = this.hours.compareTo(that.hours);\n        if (hourComparison != 0) {\n            return hourComparison;\n        }\n        return this.minutes.compareTo(that.minutes);\n    }\n    \n    public Integer getHours() {\n        return this.hours;\n    }\n    \n    public Integer getMinutes() {\n        return this.minutes;\n    }\n    \n    @Override\n    public String toString() {\n        return this.hours + \":\" + this.minutes;\n    }\n    \n    @Override\n    public int hashCode() {\n        return new Integer(100 * this.hours + this.minutes).hashCode();\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final TimeOfDay other = (TimeOfDay)obj;\n        return this.hours.equals(other.hours) && this.minutes.equals(other.minutes);\n    }\n}\n",
        "token_number_zeroshot": 352,
        "token_number_fewshot": 750,
        "token_number_cot": 463
    },
    {
        "project_name": "82_ipcalculator",
        "class": "BinaryCalculate",
        "source_code": "package ipac;\n\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class BinaryCalculate\n{\n    boolean isIPv4;\n    boolean isIPv6;\n    String currentIP;\n    String fullReassembler;\n    String DELIMITER;\n    int lengthOfToken;\n    String IPRangeAddress;\n    String usableRange;\n    int semiCol;\n    String prefix;\n    BigInteger totalIPAddresses;\n    int MAXPREFIX;\n    \n    public BinaryCalculate() {\n        this.isIPv4 = false;\n        this.isIPv6 = false;\n        this.currentIP = \"\";\n        this.fullReassembler = \"\";\n        this.DELIMITER = \"\";\n        this.lengthOfToken = 0;\n        this.IPRangeAddress = \"\";\n        this.usableRange = \"\";\n        this.semiCol = 0;\n        this.prefix = \"\";\n        this.MAXPREFIX = 0;\n    }\n    \n    public String addBinary(String num1, String num2) {\n        boolean carry = false;\n        int size1 = num1.length() - 1;\n        int size2 = num2.length() - 1;\n        String sum = \"\";\n        if (size2 > size1) {\n            final String s = num1;\n            num1 = num2;\n            num2 = s;\n            final int n = size1;\n            size1 = size2;\n            size2 = n;\n        }\n        while (size2 >= 0) {\n            if (num1.charAt(size1) == '0' && num2.charAt(size2) == '0') {\n                if (!carry) {\n                    sum = \"0\" + sum;\n                }\n                else {\n                    sum = \"1\" + sum;\n                }\n                carry = false;\n            }\n            else if (num1.charAt(size1) == '1' && num2.charAt(size2) == '0') {\n                if (!carry) {\n                    sum = \"1\" + sum;\n                }\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            }\n            else if (num1.charAt(size1) == '0' && num2.charAt(size2) == '1') {\n                if (!carry) {\n                    sum = \"1\" + sum;\n                }\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            }\n            else if (num1.charAt(size1) == '1' && num2.charAt(size2) == '1') {\n                if (!carry) {\n                    sum = \"0\" + sum;\n                }\n                else {\n                    sum = \"1\" + sum;\n                }\n                carry = true;\n            }\n            --size1;\n            --size2;\n        }\n        while (size1 >= 0) {\n            if (num1.charAt(size1) == '0') {\n                if (!carry) {\n                    sum = \"0\" + sum;\n                }\n                else {\n                    sum = \"1\" + sum;\n                }\n                carry = false;\n            }\n            else if (num1.charAt(size1) == '1') {\n                if (!carry) {\n                    sum = \"1\" + sum;\n                }\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            }\n            --size1;\n        }\n        if (carry) {\n            sum = \"1\" + sum;\n        }\n        return sum;\n    }\n    \n    public String subBinary(final String num1, final String num2) {\n        String diff = \"\";\n        String twosComp = \"\";\n        for (int size = num1.length() - 1; size >= 0; --size) {\n            if (num1.charAt(size) == '0') {\n                twosComp = \"1\" + twosComp;\n            }\n            else {\n                twosComp = \"0\" + twosComp;\n            }\n        }\n        twosComp = \"0\" + twosComp;\n        twosComp = this.addBinary(twosComp, \"1\");\n        diff = this.addBinary(twosComp, num2);\n        return diff.substring(1);\n    }\n    \n    public String IPCalculate(final String IP, final String IPPrefix) {\n        String outputText = \"\";\n        this.checkIPType(IP.length() - 1);\n        final String subnet = this.convert(IP);\n        final String netmask = this.getNetmask(IPPrefix);\n        this.calculate(IP, IPPrefix);\n        outputText = outputText + \"Total Range: \" + this.IPRangeAddress + \"\\n\";\n        outputText = outputText + \"Usable Range: \" + this.usableRange + \"\\n\";\n        final NumberFormat formatter = new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\n        outputText += \"\\n\";\n        outputText = outputText + \"Total usable IP Addresses : \" + formatter.format(this.totalIPAddresses) + \"\\n\";\n        outputText = outputText + \"Subnet: \" + subnet + \"\\n\";\n        outputText = outputText + \"Binary Subnet: \" + this.getBinaryIP(IP) + \"\\n\";\n        outputText = outputText + \"Broadcast Address: \" + this.currentIP + \"\\n\";\n        outputText = outputText + \"Prefix: \" + this.prefix + \"\\n\";\n        this.checkIPType(netmask.length() - 1);\n        final String outputNetmask = this.convert(netmask);\n        outputText = outputText + \"Netmask: \" + outputNetmask + \"\\n\";\n        final String binaryNetmask = this.getBinaryIP(netmask);\n        outputText = outputText + \"Binary Netmask: \" + binaryNetmask;\n        return outputText;\n    }\n    \n    private String getBinaryIP(final String binaryIP) {\n        String output = \"\";\n        this.checkIPType(binaryIP.length() - 1);\n        for (int i = 0; i < this.MAXPREFIX; ++i) {\n            output += binaryIP.charAt(i);\n            if (i == this.semiCol) {\n                if (i != binaryIP.length() - 1) {\n                    output += this.DELIMITER;\n                }\n                this.semiCol += this.lengthOfToken;\n            }\n        }\n        return output;\n    }\n    \n    private String getNetmask(final String binaryIP) {\n        String invertedIPPrefix = \"\";\n        for (int i = 0; i < this.MAXPREFIX; ++i) {\n            if (binaryIP.charAt(i) == '0') {\n                invertedIPPrefix += \"1\";\n            }\n            else {\n                invertedIPPrefix += \"0\";\n            }\n        }\n        return invertedIPPrefix;\n    }\n    \n    private void calculate(String subnet, final String noOfIPAddresses) {\n        this.currentIP = \"\";\n        final String number1 = subnet;\n        String usableIP = \"\";\n        final String IP = this.addBinary(subnet, noOfIPAddresses);\n        this.checkIPType(subnet.length() - 1);\n        String addSubBinary = \"\";\n        for (int i = 0; i < this.MAXPREFIX - 1; ++i) {\n            addSubBinary += \"0\";\n        }\n        addSubBinary += \"1\";\n        subnet = this.addBinary(addSubBinary, subnet);\n        usableIP = this.convert(subnet);\n        subnet = this.subBinary(addSubBinary, subnet);\n        this.checkIPType(subnet.length() - 1);\n        this.currentIP = this.convert(subnet);\n        this.fullReassembler = \"\";\n        this.semiCol = this.lengthOfToken - 1;\n        this.IPRangeAddress = this.currentIP + \" -- \";\n        this.usableRange = usableIP + \" -- \";\n        this.currentIP = \"\";\n        String currentIPString = \"\";\n        if (IP.length() > 128) {\n            this.IPRangeAddress += \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\n            this.currentIP = \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\n        }\n        else if (IP.length() > 32 && IP.length() < 128) {\n            this.IPRangeAddress += \"255.255.255.255\";\n            this.currentIP = \"255.255.255.255\";\n        }\n        else {\n            final String IPRangeEnd = this.subBinary(addSubBinary, IP);\n            final String endIP = this.convert(IPRangeEnd);\n            this.usableRange += endIP;\n            this.checkIPType(subnet.length() - 1);\n            this.currentIP = this.convert(IP);\n            this.IPRangeAddress += this.currentIP;\n        }\n        currentIPString = this.subBinary(number1, this.convertToBinary(this.currentIP));\n        this.totalIPAddresses = new BigInteger(currentIPString, 2);\n        this.totalIPAddresses = this.totalIPAddresses.add(new BigInteger(\"1\"));\n        int prefixInt = 0;\n        if (this.totalIPAddresses.doubleValue() < 2.0) {\n            prefixInt = this.MAXPREFIX;\n        }\n        else if (this.totalIPAddresses.doubleValue() == 2.0) {\n            prefixInt = this.MAXPREFIX - 2;\n        }\n        else if (this.isIPv6) {\n            final String currentIPString2 = currentIPString.substring(0, 64);\n            final BigInteger totalIPAddresses1 = new BigInteger(currentIPString2, 2);\n            double prefixInt2 = 0.0;\n            if (totalIPAddresses1.doubleValue() > 0.0) {\n                prefixInt2 = Math.log(totalIPAddresses1.doubleValue()) / Math.log(2.0);\n            }\n            final String currentIPString3 = currentIPString.substring(64, 128);\n            final BigInteger totalIPAddresses2 = new BigInteger(currentIPString3, 2);\n            final double prefixInt3 = Math.log(totalIPAddresses2.doubleValue()) / Math.log(2.0);\n            prefixInt = this.MAXPREFIX - (int)Math.ceil(prefixInt2) - (int)Math.round(prefixInt3);\n        }\n        else if (this.isIPv4) {\n            prefixInt = this.MAXPREFIX - (int)Math.ceil(Math.log(this.totalIPAddresses.doubleValue()) / Math.log(2.0));\n        }\n        this.prefix = \"/\" + prefixInt;\n        this.totalIPAddresses = this.totalIPAddresses.subtract(new BigInteger(\"2\"));\n    }\n    \n    public void prefixInPrefixCalculate(String IP, final String IPPrefix, final int noPrefix, final String endPrefix) {\n        try {\n            final String[][] output = new String[noPrefix + 8][2];\n            this.checkIPType(IP.length() - 1);\n            final String subnet = this.convert(IP);\n            final String netmask = this.getNetmask(IPPrefix);\n            this.calculate(IP, IPPrefix);\n            for (int i = 0; i < noPrefix; ++i) {\n                this.calculate(IP, IPPrefix);\n                output[i][0] = this.getStartIP() + \" \" + this.prefix;\n                output[i][1] = this.IPRangeAddress;\n                IP = this.addBinary(this.fullReassembler.substring(this.MAXPREFIX, this.fullReassembler.length()), Integer.toBinaryString(1));\n                this.fullReassembler = \"\";\n            }\n            output[noPrefix + 1][0] = \"Total usable IP Addresses :\";\n            final NumberFormat formatter = new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\n            output[noPrefix + 1][1] = formatter.format(this.totalIPAddresses.multiply(new BigInteger(noPrefix + \"\"))) + \" \";\n            output[noPrefix + 2][0] = \"Subnet:\";\n            output[noPrefix + 2][1] = subnet;\n            final StringTokenizer subnetTokens = new StringTokenizer(this.convertToBinary(subnet), this.DELIMITER);\n            String paddedSubnet = \"\";\n            while (subnetTokens.hasMoreTokens()) {\n                String unpaddedSubnet;\n                for (unpaddedSubnet = subnetTokens.nextToken(); unpaddedSubnet.length() < this.lengthOfToken; unpaddedSubnet = \"0\" + unpaddedSubnet) {}\n                paddedSubnet += unpaddedSubnet;\n            }\n            output[noPrefix + 3][0] = \"Binary Subnet:\";\n            output[noPrefix + 3][1] = this.getBinaryIP(paddedSubnet);\n            output[noPrefix + 4][0] = \"Broadcast Address:\";\n            output[noPrefix + 4][1] = this.currentIP;\n            output[noPrefix + 5][0] = \"Prefix:\";\n            output[noPrefix + 5][1] = endPrefix;\n            this.checkIPType(netmask.length() - 1);\n            output[noPrefix + 6][0] = \"Netmask\";\n            output[noPrefix + 6][1] = this.convert(netmask);\n            output[noPrefix + 7][0] = \"Binary Netmask:\";\n            output[noPrefix + 7][1] = this.getBinaryIP(netmask);\n            new Output(output);\n        }\n        catch (OutOfMemoryError e) {\n            new IPv4().displayError(\"Your computer does not have sufficent memory to process this query.\");\n        }\n    }\n    \n    private void checkIPType(final int size1) {\n        if (size1 == 31) {\n            this.isIPv4 = true;\n            this.lengthOfToken = 8;\n            this.DELIMITER = \".\";\n            this.MAXPREFIX = 32;\n        }\n        else if (size1 == 127) {\n            this.isIPv6 = true;\n            this.lengthOfToken = 16;\n            this.DELIMITER = \":\";\n            this.MAXPREFIX = 128;\n        }\n        this.semiCol = this.lengthOfToken - 1;\n    }\n    \n    private String convert(final String binaryIP) {\n        String outputIP = \"\";\n        String reassembler = \"\";\n        for (int i = 0; i < binaryIP.length(); ++i) {\n            reassembler += binaryIP.charAt(i);\n            this.fullReassembler += binaryIP.charAt(i);\n            if (i == this.semiCol) {\n                if (this.isIPv4) {\n                    outputIP += Integer.parseInt(reassembler, 2);\n                    reassembler = \"\";\n                }\n                else if (this.isIPv6) {\n                    outputIP += Integer.toHexString(Integer.parseInt(reassembler, 2));\n                    reassembler = \"\";\n                }\n                if (i != binaryIP.length() - 1) {\n                    outputIP += this.DELIMITER;\n                }\n                this.semiCol += this.lengthOfToken;\n            }\n        }\n        return outputIP;\n    }\n    \n    private String convertToBinary(final String IP) {\n        final StringTokenizer octetToken = new StringTokenizer(IP);\n        String output = \"\";\n        int radix = 0;\n        if (this.isIPv4) {\n            radix = 10;\n        }\n        else if (this.isIPv6) {\n            radix = 16;\n        }\n        while (octetToken.hasMoreTokens()) {\n            String out;\n            for (out = Integer.toBinaryString(Integer.parseInt(octetToken.nextToken(\".:\"), radix)); out.length() < this.lengthOfToken; out = \"0\" + out) {}\n            output += out;\n        }\n        return output;\n    }\n    \n    private String getStartIP() {\n        final StringTokenizer tokens = new StringTokenizer(this.IPRangeAddress, \" -\");\n        return tokens.nextToken();\n    }\n}\n",
        "token_number_zeroshot": 3297,
        "token_number_fewshot": 3695,
        "token_number_cot": 3408
    },
    {
        "project_name": "82_ipcalculator",
        "class": "WhoIS",
        "source_code": "package ipac;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nimport java.net.*;\nimport java.io.*;\n\npublic class WhoIS extends JPanel implements ActionListener\n{\n    String WHOIS_NAME;\n    String WHOIS_ADDRESS;\n    int WHOIS_PORT;\n    JTextField queryTextField;\n    JButton queryButton;\n    JButton resetButton;\n    JCheckBox lowercaseD;\n    boolean booleanD;\n    JRadioButton lowercaseL;\n    JRadioButton uppercaseL;\n    JRadioButton lowercaseM;\n    JRadioButton uppercaseM;\n    JRadioButton lowercaseX;\n    JRadioButton resetRadioButton;\n    ButtonGroup radioButtonGroup;\n    JPopupMenu popupMenu;\n    JComboBox inverseQueries;\n    JList miscList;\n    \n    public WhoIS() {\n        this.WHOIS_NAME = \"APNIC\";\n        this.WHOIS_ADDRESS = \"whois.apnic.net\";\n        this.WHOIS_PORT = 43;\n        this.radioButtonGroup = new ButtonGroup();\n        final JPanel WhoISPanel = new JPanel();\n        WhoISPanel.setLayout(new BoxLayout(WhoISPanel, 1));\n        this.createPopupMenu();\n        WhoISPanel.add(this.queryPanel());\n        WhoISPanel.add(this.additionalQueriesPanel());\n        WhoISPanel.add(this.queryHintsPanel());\n        this.setBackground(Color.WHITE);\n        this.add(WhoISPanel);\n    }\n    \n    private JPanel queryPanel() {\n        final JPanel queryPanel = new JPanel();\n        queryPanel.setLayout(new FlowLayout(0));\n        final JLabel queryLabel = new JLabel(\"Search for : \");\n        queryPanel.add(queryLabel);\n        (this.queryTextField = new JTextField(40)).addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(final MouseEvent e) {\n                this.checkForTriggerEvent(e);\n            }\n            \n            @Override\n            public void mouseReleased(final MouseEvent e) {\n                this.checkForTriggerEvent(e);\n            }\n            \n            private void checkForTriggerEvent(final MouseEvent e) {\n                if (e.isPopupTrigger()) {\n                    WhoIS.this.popupMenu.show(e.getComponent(), e.getX(), e.getY());\n                }\n            }\n        });\n        this.queryTextField.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(final KeyEvent e) {\n                if (e.getKeyCode() == 10) {\n                    WhoIS.this.startQuery();\n                }\n            }\n        });\n        this.queryTextField.setToolTipText(\"Enter Whois database object you would like to query\");\n        queryPanel.add(this.queryTextField);\n        (this.queryButton = new JButton(\"Query\")).addActionListener(this);\n        queryPanel.add(this.queryButton);\n        (this.resetButton = new JButton(\"Reset\")).addActionListener(this);\n        queryPanel.add(this.resetButton);\n        this.queryTextField.setRequestFocusEnabled(true);\n        queryPanel.setBackground(Color.WHITE);\n        return queryPanel;\n    }\n    \n    private JPanel additionalQueriesPanel() {\n        final JPanel additionalQueriesPanel = new JPanel();\n        additionalQueriesPanel.setLayout(new FlowLayout(0));\n        additionalQueriesPanel.add(this.IPAddressLookups());\n        additionalQueriesPanel.add(this.MiscellaneousQueries());\n        additionalQueriesPanel.setBackground(Color.WHITE);\n        return additionalQueriesPanel;\n    }\n    \n    private JPanel IPAddressLookups() {\n        final JPanel LookupPanel = new JPanel();\n        LookupPanel.setLayout(new BoxLayout(LookupPanel, 1));\n        this.lowercaseL = new JRadioButton(\"1st level less specific\");\n        this.radioButtonGroup.add(this.lowercaseL);\n        LookupPanel.add(this.lowercaseL);\n        this.uppercaseL = new JRadioButton(\"All less specific\");\n        this.radioButtonGroup.add(this.uppercaseL);\n        LookupPanel.add(this.uppercaseL);\n        this.lowercaseM = new JRadioButton(\"1st level more specific\");\n        this.radioButtonGroup.add(this.lowercaseM);\n        LookupPanel.add(this.lowercaseM);\n        this.uppercaseM = new JRadioButton(\"All more specific\");\n        this.radioButtonGroup.add(this.uppercaseM);\n        LookupPanel.add(this.uppercaseM);\n        this.lowercaseX = new JRadioButton(\"Exact match only\");\n        this.radioButtonGroup.add(this.lowercaseX);\n        LookupPanel.add(this.lowercaseX);\n        final Action actionListener = new AbstractAction(\"Associated reverse domain\") {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                WhoIS.this.booleanD = ((JCheckBox)evt.getSource()).isSelected();\n            }\n        };\n        LookupPanel.add(this.lowercaseD = new JCheckBox(actionListener));\n        this.resetRadioButton = new JRadioButton(\"Reset Radio Button\");\n        this.radioButtonGroup.add(this.resetRadioButton);\n        LookupPanel.setBackground(Color.WHITE);\n        this.lowercaseL.setBackground(Color.WHITE);\n        this.uppercaseL.setBackground(Color.WHITE);\n        this.lowercaseM.setBackground(Color.WHITE);\n        this.uppercaseM.setBackground(Color.WHITE);\n        this.lowercaseX.setBackground(Color.WHITE);\n        this.lowercaseD.setBackground(Color.WHITE);\n        final String toolTipText = \"Use these options to view IP address blocks that match or are larger than the IP address or range you wish to query\";\n        this.lowercaseL.setToolTipText(toolTipText);\n        this.uppercaseL.setToolTipText(toolTipText);\n        this.lowercaseM.setToolTipText(toolTipText);\n        this.uppercaseM.setToolTipText(toolTipText);\n        this.lowercaseX.setToolTipText(toolTipText);\n        this.lowercaseD.setToolTipText(toolTipText);\n        return LookupPanel;\n    }\n    \n    private JPanel MiscellaneousQueries() {\n        final JPanel MiscPanel = new JPanel();\n        MiscPanel.setLayout(new BoxLayout(MiscPanel, 1));\n        final JLabel inverseLabel = new JLabel(\"Inverse Queries\");\n        MiscPanel.add(inverseLabel);\n        (this.inverseQueries = new JComboBox()).addItem(\"None\");\n        this.inverseQueries.addItem(\"admin-c\");\n        this.inverseQueries.addItem(\"admin-c,tech-c,zone-c\");\n        this.inverseQueries.addItem(\"author\");\n        this.inverseQueries.addItem(\"cross-mnt\");\n        this.inverseQueries.addItem(\"cross-nfy\");\n        this.inverseQueries.addItem(\"local-as\");\n        this.inverseQueries.addItem(\"mbrs-by-ref\");\n        this.inverseQueries.addItem(\"member-of\");\n        this.inverseQueries.addItem(\"mnt-by\");\n        this.inverseQueries.addItem(\"mnt-lower\");\n        this.inverseQueries.addItem(\"mnt-nfy\");\n        this.inverseQueries.addItem(\"mnt-routes\");\n        this.inverseQueries.addItem(\"notify\");\n        this.inverseQueries.addItem(\"nserver\");\n        this.inverseQueries.addItem(\"origin\");\n        this.inverseQueries.addItem(\"person\");\n        this.inverseQueries.addItem(\"referral-by\");\n        this.inverseQueries.addItem(\"rev-srv\");\n        this.inverseQueries.addItem(\"sub-dom\");\n        this.inverseQueries.addItem(\"tech-c\");\n        this.inverseQueries.addItem(\"upd-to\");\n        this.inverseQueries.addItem(\"zone-c\");\n        this.inverseQueries.setToolTipText(\"Searching for objects in the \" + this.WHOIS_NAME + \" Whois Database that have an attribute matching\" + \" the attribute type chosen from the inverse lookup scroll \" + \"list and the query text given by the user\");\n        MiscPanel.add(this.inverseQueries);\n        final JLabel miscLabel = new JLabel(\"Object Types\");\n        MiscPanel.add(miscLabel);\n        final String[] items = { \"All\", \"as-block\", \"as-set\", \"aut-num\", \"domain\", \"filter-set\", \"inet-rtr\", \"inet6num\", \"inetnum\", \"irt\", \"key-cert\", \"mntner\", \"peering-set\", \"person\", \"role\", \"route\", \"route-set\", \"rtr-set\" };\n        (this.miscList = new JList((E[])items)).setSelectedIndex(0);\n        this.miscList.setToolTipText(\"Limit your search to particular types of objects\");\n        final JScrollPane scrollingList = new JScrollPane(this.miscList);\n        MiscPanel.add(scrollingList);\n        MiscPanel.setBackground(Color.WHITE);\n        this.inverseQueries.setBackground(Color.WHITE);\n        return MiscPanel;\n    }\n    \n    private JPanel queryHintsPanel() {\n        final JPanel queryHintsPanel = new JPanel();\n        queryHintsPanel.setLayout(new FlowLayout(1));\n        final JPanel innerPanel = new JPanel();\n        innerPanel.setLayout(new BoxLayout(innerPanel, 1));\n        final JLabel queryHintsText1 = new JLabel(\"Query hints \");\n        final JLabel emptyLabel = new JLabel(\"EMPTY LABEL\");\n        emptyLabel.setForeground(Color.WHITE);\n        final JLabel queryHintsText2 = new JLabel(\"* Include \\\"AS\\\" in front of an AS number.\");\n        final JLabel queryHintsText3 = new JLabel(\"Example: AS4808\");\n        final JLabel queryHintsText4 = new JLabel(\"* Include \\\"-t\\\" (template only) or \\\"-v\\\" (template and description) in front of an object name to view the template.\");\n        final JLabel queryHintsText5 = new JLabel(\"Example: -t inetnum\");\n        innerPanel.add(queryHintsText1);\n        innerPanel.add(emptyLabel);\n        innerPanel.add(queryHintsText2);\n        innerPanel.add(queryHintsText3);\n        innerPanel.add(queryHintsText4);\n        innerPanel.add(queryHintsText5);\n        queryHintsPanel.setBackground(Color.WHITE);\n        innerPanel.setBackground(Color.WHITE);\n        queryHintsPanel.add(innerPanel);\n        return queryHintsPanel;\n    }\n    \n    private void createPopupMenu() {\n        this.popupMenu = new JPopupMenu();\n        final JMenuItem cut = new JMenuItem(\"Cut\");\n        final JMenuItem copy = new JMenuItem(\"Copy\");\n        final JMenuItem paste = new JMenuItem(\"Paste\");\n        final JMenuItem selectAll = new JMenuItem(\"Select All\");\n        this.popupMenu.add(cut);\n        this.popupMenu.add(copy);\n        this.popupMenu.add(paste);\n        this.popupMenu.add(selectAll);\n        cut.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.cut();\n            }\n        });\n        copy.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.copy();\n            }\n        });\n        paste.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.paste();\n            }\n        });\n        selectAll.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.selectAll();\n            }\n        });\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        if (e.getSource() == this.queryButton) {\n            this.startQuery();\n        }\n        else if (e.getSource() == this.resetButton) {\n            this.reset();\n        }\n    }\n    \n    private void startQuery() {\n        if (this.getQuery().length() < 1) {\n            this.displayError(\"No Query Detected\");\n        }\n        else {\n            this.query(this.getQuery());\n        }\n    }\n    \n    private void displayError(final String error) {\n        JOptionPane.showMessageDialog(this, error, \"Error\", 0);\n    }\n    \n    private void query(final String query) {\n        try {\n            final Socket connection = new Socket(this.WHOIS_ADDRESS, this.WHOIS_PORT);\n            final PrintStream out = new PrintStream(connection.getOutputStream());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line = \"\";\n            out.println(query);\n            String output = \"\";\n            while ((line = in.readLine()) != null) {\n                output = output + line + \"\\n\";\n            }\n            new WhoISOutput(output);\n            output = \"\";\n        }\n        catch (UnknownHostException e) {\n            this.displayError(\"Unknown Whois host: \" + this.WHOIS_ADDRESS);\n        }\n        catch (IOException e2) {\n            this.displayError(\"Whois server could not be contacted.\\nPlease check your internet connection.\");\n        }\n    }\n    \n    private String getQuery() {\n        String query = this.queryTextField.getText().trim();\n        final String iqs = this.inverseQueries.getSelectedItem().toString();\n        if (!iqs.equals(\"None\")) {\n            query = \"-i \" + iqs + \" \" + query;\n        }\n        if (this.lowercaseL.isSelected()) {\n            query = \"-l \" + query;\n        }\n        else if (this.uppercaseL.isSelected()) {\n            query = \"-L \" + query;\n        }\n        else if (this.lowercaseM.isSelected()) {\n            query = \"-m \" + query;\n        }\n        else if (this.uppercaseM.isSelected()) {\n            query = \"-M \" + query;\n        }\n        else if (this.lowercaseX.isSelected()) {\n            query = \"-x \" + query;\n        }\n        if (this.booleanD) {\n            query = \"-d \" + query;\n        }\n        String miscQueries = \"\";\n        final Object[] selected = this.miscList.getSelectedValues();\n        for (int i = 0; i < selected.length; ++i) {\n            if (selected[i] != \"All\") {\n                miscQueries = miscQueries + selected[i] + \",\";\n            }\n        }\n        if (miscQueries != \"\") {\n            miscQueries = miscQueries.substring(0, miscQueries.length() - 1);\n            query = \"-T \" + miscQueries + \" \" + query;\n        }\n        return query;\n    }\n    \n    public void reset() {\n        this.queryTextField.setText(\"\");\n        this.resetRadioButton.setSelected(true);\n        this.lowercaseD.setSelected(false);\n        this.inverseQueries.setSelectedIndex(0);\n        this.miscList.setSelectedIndex(0);\n    }\n}\n",
        "token_number_zeroshot": 2759,
        "token_number_fewshot": 3157,
        "token_number_cot": 2870
    },
    
    {
        "project_name": "31_xisemele",
        "class": "OperationsHelperImpl",
        "source_code": "package net.sf.xisemele.impl;\n\nimport org.w3c.dom.*;\nimport java.util.*;\n\nclass OperationsHelperImpl implements OperationsHelper\n{\n    private static final long serialVersionUID = 1L;\n    \n    @Override\n    public List<Node> children(final Node node) {\n        final ArrayList<Node> children = new ArrayList<Node>();\n        final NodeList nodeList = node.getChildNodes();\n        for (int index = 0; index < nodeList.getLength(); ++index) {\n            final Node item = nodeList.item(index);\n            if (item.getNodeType() == 1) {\n                children.add(item);\n            }\n        }\n        return children;\n    }\n    \n    @Override\n    public Node find(final Document document, final String path) {\n        final String[] names = path.split(\"/\");\n        Node found = null;\n        if (names.length > 0 && names[0].equals(document.getDocumentElement().getNodeName())) {\n            found = document.getDocumentElement();\n            NodeList nodeList = found.getChildNodes();\n            for (int nameIndex = 1; nameIndex < names.length; ++nameIndex) {\n                for (int nodeIndex = 0; nodeIndex < nodeList.getLength(); ++nodeIndex) {\n                    if (nodeList.item(nodeIndex).getNodeName().equals(names[nameIndex])) {\n                        found = nodeList.item(nodeIndex);\n                        nodeList = found.getChildNodes();\n                        break;\n                    }\n                }\n            }\n        }\n        if (found != null && found.getNodeName().equals(names[names.length - 1])) {\n            return found;\n        }\n        return null;\n    }\n    \n    @Override\n    public Node nodeWithName(final List<Node> nodes, final String name) {\n        for (final Node node : nodes) {\n            if (node.getNodeName().equals(name)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public List<Node> sublistWithName(final List<Node> nodes, final String name) {\n        final ArrayList<Node> sublist = new ArrayList<Node>();\n        for (final Node node : nodes) {\n            if (node.getNodeName().equals(name)) {\n                sublist.add(node);\n            }\n        }\n        return sublist;\n    }\n}\n",
        "token_number_zeroshot": 479,
        "token_number_fewshot": 877,
        "token_number_cot": 591
    },
    {
        "project_name": "scribe",
        "class": "Verifier",
        "source_code": "package org.scribe.model;\n\nimport org.scribe.utils.*;\n\npublic class Verifier\n{\n    private final String value;\n    \n    public Verifier(final String value) {\n        Preconditions.checkNotNull(value, \"Must provide a valid string as verifier\");\n        this.value = value;\n    }\n    \n    public String getValue() {\n        return this.value;\n    }\n}\n",
        "token_number_zeroshot": 103,
        "token_number_fewshot": 501,
        "token_number_cot": 214
    },
    {
        "project_name": "scribe",
        "class": "Response",
        "source_code": "package org.scribe.model;\n\nimport java.net.*;\nimport java.io.*;\nimport org.scribe.utils.*;\nimport java.util.*;\n\npublic class Response\n{\n    private static final String EMPTY = \"\";\n    private int code;\n    private String body;\n    private InputStream stream;\n    private Map<String, String> headers;\n    \n    Response(final HttpURLConnection connection) throws IOException {\n        try {\n            connection.connect();\n            this.code = connection.getResponseCode();\n            this.headers = this.parseHeaders(connection);\n            this.stream = (this.wasSuccessful() ? connection.getInputStream() : connection.getErrorStream());\n        }\n        catch (UnknownHostException e) {\n            this.code = 404;\n            this.body = \"\";\n        }\n    }\n    \n    private String parseBodyContents() {\n        return this.body = StreamUtils.getStreamContents(this.getStream());\n    }\n    \n    private Map<String, String> parseHeaders(final HttpURLConnection conn) {\n        final Map<String, String> headers = new HashMap<String, String>();\n        for (final String key : conn.getHeaderFields().keySet()) {\n            headers.put(key, conn.getHeaderFields().get(key).get(0));\n        }\n        return headers;\n    }\n    \n    private boolean wasSuccessful() {\n        return this.getCode() >= 200 && this.getCode() < 400;\n    }\n    \n    public String getBody() {\n        return (this.body != null) ? this.body : this.parseBodyContents();\n    }\n    \n    public InputStream getStream() {\n        return this.stream;\n    }\n    \n    public int getCode() {\n        return this.code;\n    }\n    \n    public Map<String, String> getHeaders() {\n        return this.headers;\n    }\n    \n    public String getHeader(final String name) {\n        return this.headers.get(name);\n    }\n}\n",
        "token_number_zeroshot": 387,
        "token_number_fewshot": 785,
        "token_number_cot": 497
    },
    {
        "project_name": "scribe",
        "class": "OAuthRequest",
        "source_code": "package org.scribe.model;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class OAuthRequest extends Request\n{\n    private static final String OAUTH_PREFIX = \"oauth_\";\n    private Map<String, String> oauthParameters;\n    \n    public OAuthRequest(final Verb verb, final String url) {\n        super(verb, url);\n        this.oauthParameters = new HashMap<String, String>();\n    }\n    \n    public void addOAuthParameter(final String key, final String value) {\n        this.oauthParameters.put(this.checkKey(key), value);\n    }\n    \n    private String checkKey(final String key) {\n        if (key.startsWith(\"oauth_\") || key.equals(\"scope\")) {\n            return key;\n        }\n        throw new IllegalArgumentException(String.format(\"OAuth parameters must either be '%s' or start with '%s'\", \"scope\", \"oauth_\"));\n    }\n    \n    public Map<String, String> getOauthParameters() {\n        return this.oauthParameters;\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"@OAuthRequest(%s, %s)\", this.getVerb(), this.getUrl());\n    }\n}\n",
        "token_number_zeroshot": 261,
        "token_number_fewshot": 659,
        "token_number_cot": 372
    },
    {
        "project_name": "scribe",
        "class": "Token",
        "source_code": "package org.scribe.model;\n\nimport java.io.*;\n\npublic class Token implements Serializable\n{\n    private static final long serialVersionUID = 715000866082812683L;\n    private final String token;\n    private final String secret;\n    private final String rawResponse;\n    \n    public Token(final String token, final String secret) {\n        this(token, secret, null);\n    }\n    \n    public Token(final String token, final String secret, final String rawResponse) {\n        this.token = token;\n        this.secret = secret;\n        this.rawResponse = rawResponse;\n    }\n    \n    public String getToken() {\n        return this.token;\n    }\n    \n    public String getSecret() {\n        return this.secret;\n    }\n    \n    public String getRawResponse() {\n        if (this.rawResponse == null) {\n            throw new IllegalStateException(\"This token object was not constructed by scribe and does not have a rawResponse\");\n        }\n        return this.rawResponse;\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"Token[%s , %s]\", this.token, this.secret);\n    }\n}\n",
        "token_number_zeroshot": 258,
        "token_number_fewshot": 656,
        "token_number_cot": 368
    },
    {
        "project_name": "scribe",
        "class": "OAuthConfig",
        "source_code": "package org.scribe.model;\n\npublic class OAuthConfig\n{\n    private final String apiKey;\n    private final String apiSecret;\n    private final String callback;\n    private final SignatureType signatureType;\n    private final String scope;\n    \n    public OAuthConfig(final String key, final String secret) {\n        this(key, secret, null, null, null);\n    }\n    \n    public OAuthConfig(final String key, final String secret, final String callback, final SignatureType type, final String scope) {\n        this.apiKey = key;\n        this.apiSecret = secret;\n        this.callback = ((callback != null) ? callback : \"oob\");\n        this.signatureType = ((type != null) ? type : SignatureType.Header);\n        this.scope = scope;\n    }\n    \n    public String getApiKey() {\n        return this.apiKey;\n    }\n    \n    public String getApiSecret() {\n        return this.apiSecret;\n    }\n    \n    public String getCallback() {\n        return this.callback;\n    }\n    \n    public SignatureType getSignatureType() {\n        return this.signatureType;\n    }\n    \n    public String getScope() {\n        return this.scope;\n    }\n    \n    public boolean hasScope() {\n        return this.scope != null;\n    }\n}\n",
        "token_number_zeroshot": 286,
        "token_number_fewshot": 684,
        "token_number_cot": 397
    },
    {
        "project_name": "scribe",
        "class": "Request",
        "source_code": "package org.scribe.model;\n\nimport org.scribe.exceptions.*;\nimport org.scribe.utils.*;\nimport java.util.*;\nimport java.net.*;\nimport java.io.*;\nimport java.nio.charset.*;\nimport java.util.concurrent.*;\n\nclass Request\n{\n    private static final String CONTENT_LENGTH = \"Content-Length\";\n    private String url;\n    private Verb verb;\n    private Map<String, String> querystringParams;\n    private Map<String, String> bodyParams;\n    private Map<String, String> headers;\n    private String payload;\n    private HttpURLConnection connection;\n    private String charset;\n    private byte[] bytePayload;\n    private boolean connectionKeepAlive;\n    \n    public Request(final Verb verb, final String url) {\n        this.payload = null;\n        this.bytePayload = null;\n        this.connectionKeepAlive = false;\n        this.verb = verb;\n        this.url = url;\n        this.querystringParams = new HashMap<String, String>();\n        this.bodyParams = new HashMap<String, String>();\n        this.headers = new HashMap<String, String>();\n    }\n    \n    public Response send() {\n        try {\n            this.createConnection();\n            return this.doSend();\n        }\n        catch (IOException ioe) {\n            throw new OAuthException(\"Problems while creating connection\", ioe);\n        }\n    }\n    \n    private void createConnection() throws IOException {\n        final String effectiveUrl = URLUtils.appendParametersToQueryString(this.url, this.querystringParams);\n        if (this.connection == null) {\n            System.setProperty(\"http.keepAlive\", this.connectionKeepAlive ? \"true\" : \"false\");\n            this.connection = (HttpURLConnection)new URL(effectiveUrl).openConnection();\n        }\n    }\n    \n    Response doSend() throws IOException {\n        this.connection.setRequestMethod(this.verb.name());\n        this.addHeaders(this.connection);\n        if (this.verb.equals(Verb.PUT) || this.verb.equals(Verb.POST)) {\n            this.addBody(this.connection, this.getByteBodyContents());\n        }\n        return new Response(this.connection);\n    }\n    \n    void addHeaders(final HttpURLConnection conn) {\n        for (final String key : this.headers.keySet()) {\n            conn.setRequestProperty(key, this.headers.get(key));\n        }\n    }\n    \n    void addBody(final HttpURLConnection conn, final byte[] content) throws IOException {\n        conn.setRequestProperty(\"Content-Length\", String.valueOf(content.length));\n        conn.setDoOutput(true);\n        conn.getOutputStream().write(content);\n    }\n    \n    public void addHeader(final String key, final String value) {\n        this.headers.put(key, value);\n    }\n    \n    public void addBodyParameter(final String key, final String value) {\n        this.bodyParams.put(key, value);\n    }\n    \n    public void addQuerystringParameter(final String key, final String value) {\n        this.querystringParams.put(key, value);\n    }\n    \n    public void addPayload(final String payload) {\n        this.payload = payload;\n    }\n    \n    public void addPayload(final byte[] payload) {\n        this.bytePayload = payload;\n    }\n    \n    public Map<String, String> getQueryStringParams() {\n        try {\n            final Map<String, String> params = new HashMap<String, String>();\n            final String queryString = new URL(this.url).getQuery();\n            params.putAll(URLUtils.queryStringToMap(queryString));\n            params.putAll(this.querystringParams);\n            return params;\n        }\n        catch (MalformedURLException mue) {\n            throw new OAuthException(\"Malformed URL\", mue);\n        }\n    }\n    \n    public Map<String, String> getBodyParams() {\n        return this.bodyParams;\n    }\n    \n    public String getUrl() {\n        return this.url;\n    }\n    \n    public String getSanitizedUrl() {\n        return this.url.replaceAll(\"\\\\?.*\", \"\").replace(\"\\\\:\\\\d{4}\", \"\");\n    }\n    \n    public String getBodyContents() {\n        try {\n            return new String(this.getByteBodyContents(), this.getCharset());\n        }\n        catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Unsupported Charset: \" + this.charset, uee);\n        }\n    }\n    \n    byte[] getByteBodyContents() {\n        if (this.bytePayload != null) {\n            return this.bytePayload;\n        }\n        final String body = (this.payload != null) ? this.payload : URLUtils.formURLEncodeMap(this.bodyParams);\n        try {\n            return body.getBytes(this.getCharset());\n        }\n        catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Unsupported Charset: \" + this.getCharset(), uee);\n        }\n    }\n    \n    public Verb getVerb() {\n        return this.verb;\n    }\n    \n    public Map<String, String> getHeaders() {\n        return this.headers;\n    }\n    \n    public String getCharset() {\n        return (this.charset == null) ? Charset.defaultCharset().name() : this.charset;\n    }\n    \n    public void setConnectTimeout(final int duration, final TimeUnit unit) {\n        this.connection.setConnectTimeout((int)unit.toMillis(duration));\n    }\n    \n    public void setReadTimeout(final int duration, final TimeUnit unit) {\n        this.connection.setReadTimeout((int)unit.toMillis(duration));\n    }\n    \n    public void setCharset(final String charsetName) {\n        this.charset = charsetName;\n    }\n    \n    public void setConnectionKeepAlive(final boolean connectionKeepAlive) {\n        this.connectionKeepAlive = connectionKeepAlive;\n    }\n    \n    void setConnection(final HttpURLConnection connection) {\n        this.connection = connection;\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"@Request(%s %s)\", this.getVerb(), this.getUrl());\n    }\n}\n",
        "token_number_zeroshot": 1184,
        "token_number_fewshot": 1582,
        "token_number_cot": 1294
    },
    {
        "project_name": "17_inspirento",
        "class": "MainMenu",
        "source_code": "package com.allenstudio.ir.ui;\n\nimport com.allenstudio.ir.core.*;\nimport com.allenstudio.ir.util.*;\nimport java.util.*;\nimport javax.swing.*;\nimport java.net.*;\n\npublic class MainMenu extends JMenuBar implements InspirentoWidget\n{\n    private static final String LABEL_SUFFIX = \"Label\";\n    private static final String ICON_SUFFIX = \"Icon\";\n    private static final String SHORTCUT_SUFFIX = \"Shortcut\";\n    private InspirentoMediator mediator;\n    \n    public MainMenu(final InspirentoMediator mediator) {\n        this.mediator = null;\n        this.mediator = mediator;\n        final String[] arr$;\n        final String[] menus = arr$ = InspirentoUtilities.tokenize(UIResources.getString(\"menu\"));\n        for (final String menu : arr$) {\n            this.add(this.createMenu(menu));\n        }\n    }\n    \n    private JMenu createMenu(final String menu) {\n        JMenu jMenu = null;\n        try {\n            final String tempLabel = UIResources.getString(menu + \"Label\");\n            if (tempLabel.length() > 2 && tempLabel.charAt(tempLabel.length() - 2) == '*') {\n                jMenu = new JMenu(tempLabel.substring(0, tempLabel.length() - 2));\n                jMenu.setMnemonic(tempLabel.charAt(tempLabel.length() - 1));\n            }\n            else {\n                jMenu = new JMenu(tempLabel);\n            }\n            final String[] arr$;\n            final String[] items = arr$ = InspirentoUtilities.tokenize(UIResources.getString(menu));\n            for (final String item : arr$) {\n                if (!\"-\".equals(item)) {\n                    if (item.length() > 1 && item.charAt(item.length() - 1) == '>') {\n                        jMenu.add(this.createMenu(item.substring(0, item.length() - 1)));\n                    }\n                    else if (item.charAt(0) == '#') {\n                        final String itemLabel = UIResources.getString(item.substring(1) + \"Label\");\n                        JCheckBoxMenuItem jMenuItem = null;\n                        if (itemLabel.length() > 2 && itemLabel.charAt(itemLabel.length() - 2) == '*') {\n                            jMenuItem = new JCheckBoxMenuItem(itemLabel.substring(0, itemLabel.length() - 2));\n                            jMenuItem.setMnemonic(itemLabel.charAt(itemLabel.length() - 1));\n                        }\n                        else {\n                            jMenuItem = new JCheckBoxMenuItem(itemLabel);\n                        }\n                        this.addShortcutAndIcon(jMenuItem, item);\n                        jMenu.add(jMenuItem);\n                    }\n                    else {\n                        final String itemLabel = UIResources.getString(item + \"Label\");\n                        JMenuItem jMenuItem2 = null;\n                        if (itemLabel.length() > 2 && itemLabel.charAt(itemLabel.length() - 2) == '*') {\n                            jMenuItem2 = new JMenuItem(itemLabel.substring(0, itemLabel.length() - 2));\n                            jMenuItem2.setMnemonic(itemLabel.charAt(itemLabel.length() - 1));\n                        }\n                        else {\n                            jMenuItem2 = new JMenuItem(itemLabel);\n                        }\n                        this.addShortcutAndIcon(jMenuItem2, item);\n                        jMenu.add(jMenuItem2);\n                    }\n                }\n                else {\n                    jMenu.addSeparator();\n                }\n            }\n        }\n        catch (MissingResourceException e) {\n            System.out.println(\"Cannot load certain menu label(s).\\n\" + e);\n            System.exit(2);\n        }\n        return jMenu;\n    }\n    \n    private void addShortcutAndIcon(final JMenuItem item, final String key) {\n        try {\n            final String shortcut = UIResources.getString(key + \"Shortcut\");\n            item.setAccelerator(KeyStroke.getKeyStroke(shortcut));\n        }\n        catch (MissingResourceException ex) {}\n        try {\n            final String path = UIResources.getString(key + \"Icon\");\n            final URL url = this.getClass().getResource(path);\n            if (url != null) {\n                item.setIcon(new ImageIcon(url));\n            }\n            else {\n                System.out.println(\"Warning: icon file lost!\");\n            }\n        }\n        catch (MissingResourceException ex2) {}\n    }\n    \n    @Override\n    public void changed() {\n    }\n}\n",
        "token_number_zeroshot": 880,
        "token_number_fewshot": 1278,
        "token_number_cot": 990
    },
    {
        "project_name": "17_inspirento",
        "class": "XmlElement",
        "source_code": "package com.allenstudio.ir.util;\n\nimport java.util.*;\n\npublic class XmlElement extends Observable implements Cloneable\n{\n    String name;\n    String data;\n    Hashtable<String, String> attributes;\n    List<XmlElement> subElements;\n    XmlElement parent;\n    \n    public XmlElement() {\n        this.subElements = new Vector<XmlElement>();\n        this.attributes = new Hashtable<String, String>(10);\n    }\n    \n    public XmlElement(final String name) {\n        this.name = name;\n        this.attributes = new Hashtable<String, String>(10);\n        this.subElements = new Vector<XmlElement>();\n        this.data = \"\";\n    }\n    \n    public XmlElement(final String name, final Hashtable<String, String> attributes) {\n        this.name = name;\n        this.attributes = attributes;\n        this.subElements = new Vector<XmlElement>();\n    }\n    \n    public XmlElement(final String name, final String data) {\n        this.name = name;\n        this.data = data;\n        this.subElements = new Vector<XmlElement>();\n        this.attributes = new Hashtable<String, String>(10);\n    }\n    \n    public Object addAttribute(final String name, final String value) {\n        if (value != null && name != null) {\n            final Object returnValue = this.attributes.put(name, value);\n            return returnValue;\n        }\n        return null;\n    }\n    \n    public String getAttribute(final String name) {\n        return this.attributes.get(name);\n    }\n    \n    public String getAttribute(final String name, final String defaultValue) {\n        if (this.getAttribute(name) == null) {\n            this.addAttribute(name, defaultValue);\n        }\n        return this.getAttribute(name);\n    }\n    \n    public Hashtable<String, String> getAttributes() {\n        return this.attributes;\n    }\n    \n    public void setAttributes(final Hashtable<String, String> attrs) {\n        this.attributes = attrs;\n    }\n    \n    public Enumeration getAttributeNames() {\n        return this.attributes.keys();\n    }\n    \n    public boolean addElement(final XmlElement e) {\n        e.setParent(this);\n        return this.subElements.add(e);\n    }\n    \n    public XmlElement removeElement(final XmlElement e) {\n        XmlElement child = null;\n        for (int i = 0; i < this.subElements.size(); ++i) {\n            child = this.subElements.get(i);\n            if (child == e) {\n                this.subElements.remove(i);\n            }\n        }\n        return child;\n    }\n    \n    public XmlElement removeElement(final int index) {\n        return this.subElements.remove(index);\n    }\n    \n    public void removeAllElements() {\n        this.subElements.clear();\n    }\n    \n    public void removeFromParent() {\n        if (this.parent == null) {\n            return;\n        }\n        this.parent.removeElement(this);\n        this.parent = null;\n    }\n    \n    public void append(final XmlElement e) {\n        e.removeFromParent();\n        this.addElement(e);\n    }\n    \n    public void insertElement(final XmlElement e, final int index) {\n        e.removeFromParent();\n        this.subElements.add(index, e);\n        e.setParent(this);\n    }\n    \n    public List getElements() {\n        return this.subElements;\n    }\n    \n    public int count() {\n        return this.subElements.size();\n    }\n    \n    public XmlElement getElement(String path) {\n        int i = path.indexOf(46);\n        if (i == 0) {\n            path = path.substring(1);\n            i = path.indexOf(46);\n        }\n        String topName;\n        String subName;\n        if (i > 0) {\n            topName = path.substring(0, i);\n            subName = path.substring(i + 1);\n        }\n        else {\n            topName = path;\n            subName = null;\n        }\n        int j = 0;\n        while (j < this.subElements.size()) {\n            if (this.subElements.get(j).getName().equals(topName)) {\n                if (subName != null) {\n                    return this.subElements.get(j).getElement(subName);\n                }\n                return this.subElements.get(j);\n            }\n            else {\n                ++j;\n            }\n        }\n        return null;\n    }\n    \n    public XmlElement getElement(final int index) {\n        return this.subElements.get(index);\n    }\n    \n    public XmlElement addSubElement(String path) {\n        XmlElement parent = this;\n        while (path.indexOf(46) != -1) {\n            final String name = path.substring(0, path.indexOf(46));\n            path = path.substring(path.indexOf(46) + 1);\n            if (name.length() == 0) {\n                continue;\n            }\n            if (parent.getElement(name) != null) {\n                parent = parent.getElement(name);\n            }\n            else {\n                final XmlElement child = new XmlElement(name);\n                parent.addElement(child);\n                parent = child;\n            }\n        }\n        final XmlElement child = new XmlElement(path);\n        parent.addElement(child);\n        return child;\n    }\n    \n    public XmlElement addSubElement(final XmlElement e) {\n        e.setParent(this);\n        this.subElements.add(e);\n        return e;\n    }\n    \n    public XmlElement addSubElement(final String name, final String data) {\n        final XmlElement e = new XmlElement(name);\n        e.setData(data);\n        e.setParent(this);\n        this.subElements.add(e);\n        return e;\n    }\n    \n    public void setParent(final XmlElement parent) {\n        this.parent = parent;\n    }\n    \n    public XmlElement getParent() {\n        return this.parent;\n    }\n    \n    public void setData(final String d) {\n        this.data = d;\n    }\n    \n    public String getData() {\n        return this.data;\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n    \n    public static void printNode(final XmlElement node, final String indent) {\n        final String data = node.getData();\n        if (data == null || data.equals(\"\")) {\n            System.out.println(indent + node.getName());\n        }\n        else {\n            System.out.println(indent + node.getName() + \" = '\" + data + \"'\");\n        }\n        final Enumeration enumeration = node.getAttributes().keys();\n        while (enumeration.hasMoreElements()) {\n            final String key = enumeration.nextElement();\n            final String value = node.getAttribute(key);\n            System.out.println(indent + key + \":\" + value);\n        }\n        final List subs = node.getElements();\n        final Iterator it = subs.iterator();\n        while (it.hasNext()) {\n            printNode(it.next(), indent + \"    \");\n        }\n    }\n    \n    public Object clone() {\n        try {\n            final XmlElement clone = (XmlElement)super.clone();\n            if (this.attributes != null) {\n                clone.setAttributes((Hashtable<String, String>)this.getAttributes().clone());\n            }\n            if (this.subElements != null) {\n                clone.subElements = new Vector<XmlElement>();\n                final List childs = this.getElements();\n                for (final XmlElement child : childs) {\n                    clone.addSubElement((XmlElement)child.clone());\n                }\n            }\n            return clone;\n        }\n        catch (CloneNotSupportedException cnse) {\n            throw new InternalError(\"Could not clone XmlElement: \" + cnse);\n        }\n    }\n    \n    public void setName(final String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void notifyObservers() {\n        this.setChanged();\n        super.notifyObservers();\n    }\n    \n    private boolean equals(final Object obj1, final Object obj2) {\n        boolean equal = false;\n        if (obj1 == null && obj2 == null) {\n            equal = true;\n        }\n        else if (obj1 != null && obj2 != null) {\n            equal = obj1.equals(obj2);\n        }\n        return equal;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        boolean equal = false;\n        if (obj != null && obj instanceof XmlElement) {\n            final XmlElement other = (XmlElement)obj;\n            if (this.equals(this.attributes, other.attributes) && this.equals(this.data, other.data) && this.equals(this.name, other.name) && this.equals(this.subElements, other.subElements)) {\n                equal = true;\n            }\n        }\n        return equal;\n    }\n    \n    @Override\n    public int hashCode() {\n        int hashCode = 23;\n        if (this.attributes != null) {\n            hashCode += this.attributes.hashCode() * 13;\n        }\n        if (this.data != null) {\n            hashCode += this.data.hashCode() * 17;\n        }\n        if (this.name != null) {\n            hashCode += this.name.hashCode() * 29;\n        }\n        if (this.subElements != null) {\n            hashCode += this.subElements.hashCode() * 57;\n        }\n        return hashCode;\n    }\n}\n",
        "token_number_zeroshot": 1843,
        "token_number_fewshot": 2241,
        "token_number_cot": 1954
    },
    {
        "project_name": "4_rif",
        "class": "WebServiceDescriptor",
        "source_code": "package com.densebrain.rif.server.transport;\n\npublic class WebServiceDescriptor\n{\n    String targetNamespace;\n    String typesNamespace;\n    Class serviceClazz;\n    \n    public WebServiceDescriptor(final Class serviceClazz, final String targetNamespace, final String typesNamespace) {\n        this.serviceClazz = serviceClazz;\n        this.targetNamespace = targetNamespace;\n        this.typesNamespace = typesNamespace;\n    }\n    \n    public Class getServiceClazz() {\n        return this.serviceClazz;\n    }\n    \n    public void setServiceClazz(final Class serviceClazz) {\n        this.serviceClazz = serviceClazz;\n    }\n    \n    public String getTargetNamespace() {\n        return this.targetNamespace;\n    }\n    \n    public void setTargetNamespace(final String targetNamespace) {\n        this.targetNamespace = targetNamespace;\n    }\n    \n    public String getTypesNamespace() {\n        return this.typesNamespace;\n    }\n    \n    public void setTypesNamespace(final String typesNamespace) {\n        this.typesNamespace = typesNamespace;\n    }\n    \n    @Override\n    public int hashCode() {\n        final int PRIME = 31;\n        int result = 1;\n        result = 31 * result + ((this.serviceClazz == null) ? 0 : this.serviceClazz.hashCode());\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final WebServiceDescriptor other = (WebServiceDescriptor)obj;\n        if (this.serviceClazz == null) {\n            if (other.serviceClazz != null) {\n                return false;\n            }\n        }\n        else if (this.serviceClazz != other.serviceClazz) {\n            return false;\n        }\n        return true;\n    }\n}\n",
        "token_number_zeroshot": 413,
        "token_number_fewshot": 811,
        "token_number_cot": 525
    },
    
    {
        "project_name": "26_jipa",
        "class": "Variable",
        "source_code": "package jipa;\n\nimport java.util.*;\n\npublic class Variable\n{\n    public static List<Variable> variableList;\n    private String varName;\n    private int varValue;\n    \n    private Variable(final String varName) {\n        this.varName = varName;\n        this.varValue = 0;\n    }\n    \n    private int getValue() {\n        return this.varValue;\n    }\n    \n    private void setValue(final int varValue) {\n        this.varValue = varValue;\n    }\n    \n    private String getName() {\n        return this.varName;\n    }\n    \n    public static boolean addVariable(final String varName) {\n        if (findVariable(varName) == -1) {\n            Variable.variableList.add(new Variable(varName));\n            return true;\n        }\n        return false;\n    }\n    \n    public static void removeVariable(final String varName) {\n        final int index = findVariable(varName);\n        if (index != -1) {\n            Variable.variableList.remove(index);\n        }\n    }\n    \n    public static int getVariableValue(final String varName) {\n        if (varName.startsWith(\"*\")) {\n            return findVariable(varName.substring(1));\n        }\n        final int varIndex = findVariable(varName);\n        if (varIndex != -1) {\n            return Variable.variableList.get(varIndex).getValue();\n        }\n        return 0;\n    }\n    \n    public static void setVariableValue(final String varName, final int varValue) {\n        final int varIndex = findVariable(varName);\n        if (varIndex != -1) {\n            Variable.variableList.get(varIndex).setValue(varValue);\n        }\n    }\n    \n    private static int findVariable(String varName) {\n        final ListIterator i = Variable.variableList.listIterator();\n        final boolean isReference = varName.startsWith(\"&\");\n        if (isReference) {\n            varName = varName.substring(1);\n        }\n        while (i.hasNext()) {\n            final Variable curVariable = i.next();\n            if (curVariable.getName().equals(varName)) {\n                if (!isReference) {\n                    return i.previousIndex();\n                }\n                return curVariable.getValue();\n            }\n        }\n        return -1;\n    }\n    \n    static {\n        Variable.variableList = new ArrayList<Variable>();\n    }\n}\n",
        "token_number_zeroshot": 499,
        "token_number_fewshot": 897,
        "token_number_cot": 609
    },
    {
        "project_name": "26_jipa",
        "class": "Main",
        "source_code": "package jipa;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n    public static int TOTAL_INSTRUCTIONS;\n    public static String[] instruction;\n    public static int iPtr;\n    \n    public static void main(final String[] args) {\n        while (!loadInstructions((args.length > 0) ? args[0] : \"\")) {}\n        while (true) {\n            processInstruction(Main.instruction[Main.iPtr]);\n        }\n    }\n    \n    public static void processInstruction(final String instruction) {\n        final int spaceLoc = instruction.indexOf(32);\n        final int commaLoc = instruction.indexOf(44);\n        String opcode;\n        String[] operand;\n        if (spaceLoc != -1) {\n            opcode = instruction.substring(0, spaceLoc);\n            operand = splitArguments(instruction.substring(spaceLoc + 1));\n        }\n        else {\n            opcode = instruction;\n            operand = new String[] { null };\n        }\n        switch (opcodes.toOpcode(opcode.toLowerCase())) {\n            case halt: {\n                System.exit(0);\n                break;\n            }\n            case out: {\n                System.out.println(getStringValue(operand[0]));\n                break;\n            }\n            case in: {\n                Variable.setVariableValue(operand[0], readValue());\n                break;\n            }\n            case mov: {\n                Variable.setVariableValue(operand[1], Variable.getVariableValue(operand[0]));\n                Variable.setVariableValue(operand[0], 0);\n                break;\n            }\n            case cpy: {\n                Variable.setVariableValue(operand[1], Variable.getVariableValue(operand[0]));\n                break;\n            }\n            case set: {\n                Variable.setVariableValue(operand[0], getValue(operand[1]));\n                break;\n            }\n            case del: {\n                Variable.removeVariable(operand[0]);\n                break;\n            }\n            case arr: {\n                Variable.addVariable(operand[0]);\n                for (int i = 1; i < Integer.parseInt(operand[1]); ++i) {\n                    Variable.addVariable(operand[0] + \"\" + i);\n                }\n                break;\n            }\n            case var: {\n                Variable.addVariable(operand[0]);\n                break;\n            }\n            case inc: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) + 1);\n                break;\n            }\n            case dec: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) - 1);\n                break;\n            }\n            case add: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) + getValue(operand[1]));\n                break;\n            }\n            case sub: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) - getValue(operand[1]));\n                break;\n            }\n            case mul: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) * getValue(operand[1]));\n                break;\n            }\n            case div: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) / getValue(operand[1]));\n                break;\n            }\n            case mod: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) % getValue(operand[1]));\n                break;\n            }\n            case xor: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) ^ getValue(operand[1]));\n                break;\n            }\n            case or: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) | getValue(operand[1]));\n                break;\n            }\n            case and: {\n                Variable.setVariableValue(operand[0], Variable.getVariableValue(operand[0]) + getValue(operand[1]));\n                break;\n            }\n            case jmp: {\n                Main.iPtr = getJumpValue(operand[0]);\n                break;\n            }\n            case jnz: {\n                if (getValue(operand[0]) != 0) {\n                    Main.iPtr = getJumpValue(operand[1]);\n                    break;\n                }\n                break;\n            }\n            case ja: {\n                if (getValue(operand[0]) > getValue(operand[1])) {\n                    Main.iPtr = getJumpValue(operand[2]);\n                    break;\n                }\n                break;\n            }\n            case jae: {\n                if (getValue(operand[0]) >= getValue(operand[1])) {\n                    Main.iPtr = getJumpValue(operand[2]);\n                    break;\n                }\n                break;\n            }\n            case jb: {\n                if (getValue(operand[0]) < getValue(operand[1])) {\n                    Main.iPtr = getJumpValue(operand[2]);\n                    break;\n                }\n                break;\n            }\n            case jbe: {\n                if (getValue(operand[0]) <= getValue(operand[1])) {\n                    Main.iPtr = getJumpValue(operand[2]);\n                    break;\n                }\n                break;\n            }\n            case jz: {\n                if (getValue(operand[0]) == 0) {\n                    Main.iPtr = getJumpValue(operand[1]);\n                    break;\n                }\n                break;\n            }\n            case je: {\n                if (getValue(operand[0]) == getValue(operand[1])) {\n                    Main.iPtr = getJumpValue(operand[2]);\n                    break;\n                }\n                break;\n            }\n            case jne: {\n                if (getValue(operand[0]) != getValue(operand[1])) {\n                    Main.iPtr = getJumpValue(operand[2]);\n                    break;\n                }\n                break;\n            }\n            case cmp: {\n                if (getValue(operand[1]) == getValue(operand[0])) {\n                    Variable.setVariableValue(operand[2], 1);\n                    break;\n                }\n                Variable.setVariableValue(operand[2], 0);\n                break;\n            }\n        }\n        ++Main.iPtr;\n    }\n    \n    public static String getFileName() {\n        final Scanner in = new Scanner(System.in);\n        System.out.println(\"Enter the full path to the file or type q to quit :\");\n        return in.nextLine();\n    }\n    \n    public static boolean loadInstructions(String fileName) {\n        int i = 0;\n        resetInstructions();\n        if (fileName.isEmpty()) {\n            fileName = getFileName();\n        }\n        if (fileName.equalsIgnoreCase(\"q\")) {\n            System.exit(0);\n        }\n        try {\n            final FileInputStream fin = new FileInputStream(fileName);\n            final BufferedReader inputFile = new BufferedReader(new InputStreamReader(fin));\n            final LineNumberReader linecount = new LineNumberReader(new FileReader(fileName));\n            String currentLine;\n            while ((currentLine = linecount.readLine()) != null) {}\n            Main.TOTAL_INSTRUCTIONS = linecount.getLineNumber();\n            Main.instruction = new String[Main.TOTAL_INSTRUCTIONS];\n            linecount.close();\n            while ((currentLine = inputFile.readLine()) != null) {\n                currentLine = removeComment(currentLine);\n                Main.instruction[i] = currentLine.trim();\n                ++i;\n            }\n            Label.buildLabelList();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n    \n    public static String removeComment(final String line) {\n        if (line.lastIndexOf(59) == -1) {\n            return line.trim();\n        }\n        if (line.lastIndexOf(59) > line.lastIndexOf(34)) {\n            return line.substring(0, line.lastIndexOf(59)).trim();\n        }\n        return line.trim();\n    }\n    \n    public static void resetInstructions() {\n        for (int i = 0; i < Main.TOTAL_INSTRUCTIONS; ++i) {\n            Main.instruction[i] = \"\";\n        }\n    }\n    \n    public static String[] splitArguments(final String original) {\n        int lastArg = 0;\n        final Collection<String> argList = new ArrayList<String>();\n        boolean inQuotes = false;\n        if (original.indexOf(44) == -1) {\n            final String[] args = { original.trim() };\n            return args;\n        }\n        for (int i = 0; i < original.length(); ++i) {\n            if (original.charAt(i) == '\\\"') {\n                inQuotes = !inQuotes;\n            }\n            else if (original.charAt(i) == ',' && !inQuotes) {\n                argList.add(original.substring(lastArg, i).trim());\n                lastArg = i + 1;\n            }\n        }\n        argList.add(original.substring(lastArg).trim());\n        final String[] args = argList.toArray(new String[0]);\n        return args;\n    }\n    \n    public static int getValue(final String operand) {\n        if (!isNumeric(operand)) {\n            return Variable.getVariableValue(operand);\n        }\n        return Integer.parseInt(operand);\n    }\n    \n    public static int getJumpValue(final String operand) {\n        if (isNumeric(operand)) {\n            return Integer.parseInt(operand) - 1;\n        }\n        return Label.findLabel(operand) - 1;\n    }\n    \n    public static int readValue() {\n        final Scanner in = new Scanner(System.in);\n        final String tmpInt = in.nextLine();\n        if (isNumeric(tmpInt)) {\n            return Integer.parseInt(tmpInt);\n        }\n        return 0;\n    }\n    \n    public static String getStringValue(final String original) {\n        String finalString = \"\";\n        boolean inQuotes = false;\n        int lastQuotes = 0;\n        if (original.indexOf(34) == -1) {\n            return Integer.toString(getValue(original));\n        }\n        for (int i = 0; i < original.length(); ++i) {\n            if (original.charAt(i) == '\\\"') {\n                if (inQuotes) {\n                    finalString += original.substring(lastQuotes, i);\n                    inQuotes = false;\n                    lastQuotes = i + 1;\n                }\n                else {\n                    inQuotes = true;\n                    if (i != 0) {\n                        finalString += getValue(original.substring(lastQuotes, i));\n                    }\n                    lastQuotes = i + 1;\n                }\n            }\n        }\n        if (lastQuotes != original.length()) {\n            finalString += getValue(original.substring(lastQuotes));\n        }\n        return finalString;\n    }\n    \n    public static boolean isNumeric(final String str) {\n        try {\n            Integer.parseInt(str);\n            return true;\n        }\n        catch (Exception e) {\n            return false;\n        }\n    }\n    \n    static {\n        Main.TOTAL_INSTRUCTIONS = 0;\n        Main.instruction = new String[0];\n        Main.iPtr = 0;\n    }\n    \n    public enum opcodes\n    {\n        halt, \n        novalue, \n        set, \n        mov, \n        cpy, \n        var, \n        del, \n        arr, \n        add, \n        sub, \n        mul, \n        div, \n        mod, \n        inc, \n        dec, \n        in, \n        out, \n        jmp, \n        jnz, \n        jz, \n        je, \n        ja, \n        jae, \n        jb, \n        jbe, \n        jne, \n        xor, \n        or, \n        and, \n        cmp;\n        \n        public static opcodes toOpcode(final String str) {\n            try {\n                return valueOf(str);\n            }\n            catch (Exception e) {\n                return opcodes.novalue;\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 2436,
        "token_number_fewshot": 2834,
        "token_number_cot": 2546
    },
    
    {
        "project_name": "94_jclo",
        "class": "JCLO",
        "source_code": "package edu.mscd.cs.jclo;\n\nimport java.util.*;\nimport java.lang.reflect.*;\n\npublic class JCLO\n{\n    private Field[] fields;\n    private Object object;\n    private boolean doubleDashes;\n    private boolean hasEquals;\n    private String prefix;\n    private String[][] aliases;\n    \n    public JCLO(final Object object) {\n        this(null, object, null);\n    }\n    \n    public JCLO(final Object object, final String[][] aliases) {\n        this(null, object, aliases);\n    }\n    \n    public JCLO(final String prefix, final Object object) {\n        this(prefix, object, null);\n    }\n    \n    public JCLO(final String prefix, final Object object, final String[][] aliases) {\n        this.prefix = \"\";\n        this.object = object;\n        this.prefix = prefix;\n        this.aliases = aliases;\n        this.fields = object.getClass().getDeclaredFields();\n        for (int i = 0; i < this.fields.length; ++i) {\n            this.fields[i].setAccessible(true);\n        }\n    }\n    \n    private Object getObject(final Field f) {\n        try {\n            return f.get(this.object);\n        }\n        catch (IllegalAccessException iae) {\n            iae.printStackTrace();\n            System.exit(1);\n            return null;\n        }\n    }\n    \n    private Field getField(String key) {\n        final Field f = null;\n        if (this.prefix != null) {\n            key = this.prefix + key;\n        }\n        for (int i = 0; i < this.fields.length; ++i) {\n            final String name = this.fields[i].getName();\n            if (name.equals(key)) {\n                return this.fields[i];\n            }\n        }\n        return null;\n    }\n    \n    public Object getValue(final String key) {\n        final Field f = this.getField(key);\n        if (f == null) {\n            System.out.println(\"Field not found: \" + key);\n            return null;\n        }\n        return this.getObject(f);\n    }\n    \n    private void setObject(final Field f, final Object o) {\n        try {\n            f.set(this.object, o);\n        }\n        catch (IllegalAccessException iae) {\n            iae.printStackTrace();\n        }\n    }\n    \n    private String getArrayType(final Class type) {\n        return type.getComponentType().toString().replaceFirst(\"class.*\\\\.\", \"\");\n    }\n    \n    @Override\n    public String toString() {\n        String r = \"\";\n        boolean first = true;\n        for (int i = 0; i < this.fields.length; ++i) {\n            final Field field = this.fields[i];\n            final String key = field.getName();\n            final Class type = field.getType();\n            final Object object = this.getObject(field);\n            if (!first) {\n                r += \"\\n\";\n            }\n            first = false;\n            if (type.isArray()) {\n                r = r + this.getArrayType(type) + \"[]\" + \": \" + key + \" = \";\n                r += Arrays.toString((Object[])object);\n            }\n            else {\n                r = r + type.toString().replaceFirst(\"class java.lang.\", \"\") + \": \" + key + \" = \" + object;\n            }\n        }\n        return r;\n    }\n    \n    private String getUsageType(final Class type) {\n        if (type.getName().equals(\"boolean\")) {\n            return this.doubleDashes ? \"[=boolean]\" : \"\";\n        }\n        if (type.isArray()) {\n            return (this.doubleDashes ? \"=\" : \" \") + this.getArrayType(type) + \"...\";\n        }\n        return (this.doubleDashes ? \"=\" : \" \") + type.getName().replaceFirst(\"java.lang.\", \"\");\n    }\n    \n    public String usage() {\n        final boolean additional = false;\n        final String[] a = new String[this.fields.length];\n        int count = 0;\n        for (int i = 0; i < this.fields.length; ++i) {\n            final Field field = this.fields[i];\n            String key = field.getName();\n            final Class type = field.getType();\n            if (!key.equals(\"additional\")) {\n                if (this.prefix != null) {\n                    if (!key.startsWith(this.prefix)) {\n                        continue;\n                    }\n                    key = key.replaceFirst(\"^\" + this.prefix, \"\");\n                }\n                if (!Modifier.isFinal(field.getModifiers())) {\n                    key = key.replaceFirst(\"^_([0-9])\", \"$1\");\n                    key = key.replaceAll(\"__\", \"-\");\n                    key = key.replaceAll(\"_\\\\$\", \".\");\n                    a[count++] = (this.doubleDashes ? \"--\" : \"-\") + key + this.getUsageType(type) + \"\\n\";\n                }\n            }\n        }\n        String r = \"\";\n        Arrays.sort(a, 0, count);\n        for (int j = 0; j < a.length; ++j) {\n            if (a[j] != null) {\n                r += a[j];\n            }\n        }\n        return r;\n    }\n    \n    private void parseAdditional(final String[] args, int i) {\n        final int number = args.length - i;\n        final String[] add = new String[number];\n        for (int j = 0; j < number; ++j, ++i) {\n            add[j] = args[i];\n        }\n        final Field f = this.getField(\"additional\");\n        if (f != null) {\n            this.setObject(f, add);\n        }\n        else {\n            System.err.println(\"No varible 'additional' found\");\n        }\n    }\n    \n    private Object addToArray(final Field field, final Object o) {\n        final Object orig = this.getObject(field);\n        final Class componentType = field.getType().getComponentType();\n        Object ret;\n        if (orig == null) {\n            ret = Array.newInstance(componentType, 1);\n            Array.set(ret, 0, o);\n        }\n        else {\n            final int length = Array.getLength(orig);\n            ret = Array.newInstance(componentType, length + 1);\n            int j;\n            for (j = 0; j < length; ++j) {\n                Array.set(ret, j, Array.get(orig, j));\n            }\n            Array.set(ret, j, o);\n        }\n        return ret;\n    }\n    \n    private String getKey(String arg) {\n        if (this.hasEquals) {\n            arg = arg.replaceFirst(\"=.*\", \"\");\n        }\n        if (this.doubleDashes) {\n            arg = arg.substring(2);\n        }\n        else {\n            arg = arg.substring(1);\n        }\n        arg = arg.replaceAll(\"^([0-9])\", \"_$1\");\n        arg = arg.replaceAll(\"-\", \"__\");\n        arg = arg.replaceAll(\"\\\\.\", \"_\\\\$\");\n        if (this.aliases != null) {\n            for (int i = 0; i < this.aliases.length; ++i) {\n                if (this.aliases[i][0].equals(arg)) {\n                    arg = this.aliases[i][1];\n                }\n            }\n        }\n        return arg;\n    }\n    \n    private String getBooleanValue(String arg) {\n        if (!this.hasEquals) {\n            return \"true\";\n        }\n        arg = arg.replaceFirst(\"[^=]*=\", \"\");\n        if (arg.equalsIgnoreCase(\"true\") || arg.equalsIgnoreCase(\"yes\")) {\n            return \"true\";\n        }\n        return \"false\";\n    }\n    \n    private Object makeObject(final String type, final String val) {\n        if (type.equals(\"boolean\")) {\n            return new Boolean(val);\n        }\n        if (type.equals(\"byte\")) {\n            return new Byte(val);\n        }\n        if (type.equals(\"short\")) {\n            return new Short(val);\n        }\n        if (type.equals(\"int\")) {\n            return new Integer(val);\n        }\n        if (type.equals(\"float\")) {\n            return new Float(val);\n        }\n        if (type.equals(\"double\")) {\n            return new Double(val);\n        }\n        if (type.equals(\"long\")) {\n            return new Long(val);\n        }\n        if (type.equals(\"java.lang.String\")) {\n            return val;\n        }\n        if (type.equals(\"char\")) {\n            return new Character(val.charAt(0));\n        }\n        return null;\n    }\n    \n    private String getEqualsValue(final String arg) {\n        if (arg.indexOf(\"=\") == -1) {\n            throw new IllegalArgumentException(\"'\" + arg + \"' requires '=VALUE'\");\n        }\n        return arg.replaceFirst(\"[^=]*=\", \"\");\n    }\n    \n    public void parse(final String[] args) {\n        for (int i = 0; i < args.length; ++i) {\n            if (!args[i].startsWith(\"-\")) {\n                this.parseAdditional(args, i);\n                return;\n            }\n            this.doubleDashes = args[i].startsWith(\"--\");\n            this.hasEquals = (args[i].indexOf(\"=\") != -1);\n            final String key = this.getKey(args[i]);\n            final Field field = this.getField(key);\n            if (field == null) {\n                throw new IllegalArgumentException(\"No such option: \\\"\" + key + \"\\\"\");\n            }\n            final Class type = field.getType();\n            String name = type.getName();\n            if (type.isArray()) {\n                name = type.getComponentType().getName();\n            }\n            String value = null;\n            if (name.equals(\"boolean\")) {\n                value = this.getBooleanValue(args[i]);\n            }\n            else if (this.doubleDashes || this.hasEquals) {\n                value = this.getEqualsValue(args[i]);\n            }\n            else {\n                value = args[++i];\n            }\n            Object o = this.makeObject(name, value);\n            if (o != null) {\n                if (type.isArray()) {\n                    o = this.addToArray(field, o);\n                }\n                this.setObject(field, o);\n            }\n        }\n    }\n    \n    public boolean getBoolean(final String key) {\n        return (boolean)this.getValue(key);\n    }\n    \n    public byte getByte(final String key) {\n        return (byte)this.getValue(key);\n    }\n    \n    public char getChar(final String key) {\n        return (char)this.getValue(key);\n    }\n    \n    public short getShort(final String key) {\n        return (short)this.getValue(key);\n    }\n    \n    public int getInt(final String key) {\n        return (int)this.getValue(key);\n    }\n    \n    public float getFloat(final String key) {\n        return (float)this.getValue(key);\n    }\n    \n    public double getDouble(final String key) {\n        return (double)this.getValue(key);\n    }\n    \n    public long getLong(final String key) {\n        return (long)this.getValue(key);\n    }\n    \n    public String getString(final String key) {\n        return (String)this.getValue(key);\n    }\n    \n    public byte[] getBytes(final String key) {\n        return (byte[])this.getValue(key);\n    }\n    \n    public char[] getChars(final String key) {\n        return (char[])this.getValue(key);\n    }\n    \n    public short[] getShorts(final String key) {\n        return (short[])this.getValue(key);\n    }\n    \n    public int[] getInts(final String key) {\n        return (int[])this.getValue(key);\n    }\n    \n    public float[] getFloats(final String key) {\n        return (float[])this.getValue(key);\n    }\n    \n    public double[] getDoubles(final String key) {\n        return (double[])this.getValue(key);\n    }\n    \n    public long[] getLongs(final String key) {\n        return (long[])this.getValue(key);\n    }\n    \n    public String[] getStrings(final String key) {\n        return (String[])this.getValue(key);\n    }\n    \n    public static void main(final String[] args) {\n        if (args.length == 1 && args[0].equalsIgnoreCase(\"--version\")) {\n            System.out.println(\"1.3.4\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 2458,
        "token_number_fewshot": 2856,
        "token_number_cot": 2569
    },
    {
        "project_name": "33_javaviewcontrol",
        "class": "TokenMgrError",
        "source_code": "package com.pmdesigns.jvc.tools;\n\npublic class TokenMgrError extends Error\n{\n    private static final long serialVersionUID = 1L;\n    static final int LEXICAL_ERROR = 0;\n    static final int STATIC_LEXER_ERROR = 1;\n    static final int INVALID_LEXICAL_STATE = 2;\n    static final int LOOP_DETECTED = 3;\n    int errorCode;\n    \n    protected static final String addEscapes(final String str) {\n        final StringBuffer retval = new StringBuffer();\n        for (int i = 0; i < str.length(); ++i) {\n            switch (str.charAt(i)) {\n                case '\\0': {\n                    break;\n                }\n                case '\\b': {\n                    retval.append(\"\\\\b\");\n                    break;\n                }\n                case '\\t': {\n                    retval.append(\"\\\\t\");\n                    break;\n                }\n                case '\\n': {\n                    retval.append(\"\\\\n\");\n                    break;\n                }\n                case '\\f': {\n                    retval.append(\"\\\\f\");\n                    break;\n                }\n                case '\\r': {\n                    retval.append(\"\\\\r\");\n                    break;\n                }\n                case '\\\"': {\n                    retval.append(\"\\\\\\\"\");\n                    break;\n                }\n                case '\\'': {\n                    retval.append(\"\\\\'\");\n                    break;\n                }\n                case '\\\\': {\n                    retval.append(\"\\\\\\\\\");\n                    break;\n                }\n                default: {\n                    final char ch;\n                    if ((ch = str.charAt(i)) < ' ' || ch > '~') {\n                        final String s = \"0000\" + Integer.toString(ch, 16);\n                        retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                        break;\n                    }\n                    retval.append(ch);\n                    break;\n                }\n            }\n        }\n        return retval.toString();\n    }\n    \n    protected static String LexicalError(final boolean EOFSeen, final int lexState, final int errorLine, final int errorColumn, final String errorAfter, final char curChar) {\n        return \"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\" + \" (\" + (int)curChar + \"), \")) + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\";\n    }\n    \n    @Override\n    public String getMessage() {\n        return super.getMessage();\n    }\n    \n    public TokenMgrError() {\n    }\n    \n    public TokenMgrError(final String message, final int reason) {\n        super(message);\n        this.errorCode = reason;\n    }\n    \n    public TokenMgrError(final boolean EOFSeen, final int lexState, final int errorLine, final int errorColumn, final String errorAfter, final char curChar, final int reason) {\n        this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n    }\n}\n",
        "token_number_zeroshot": 640,
        "token_number_fewshot": 1038,
        "token_number_cot": 752
    },
    {
        "project_name": "85_shop",
        "class": "JSPredicateForm",
        "source_code": "package umd.cs.shop;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class JSPredicateForm extends Vector\n{\n    JSPredicateForm() {\n    }\n    \n    public JSPredicateForm(final String text) {\n        if (text != null) {\n            this.JSPredicateFormInit(new StreamTokenizer(new StringReader(text)));\n        }\n    }\n    \n    public JSPredicateForm(final StreamTokenizer tokenizer) {\n        this.JSPredicateFormInit(tokenizer);\n    }\n    \n    void JSPredicateFormInit(final StreamTokenizer tokenizer) {\n        if (tokenizer == null) {\n            throw new JSParserError();\n        }\n        if (!JSUtil.expectTokenType(JSJshopVars.leftPar, tokenizer, \"expected '('\")) {\n            throw new JSParserError();\n        }\n        if (!JSUtil.readToken(tokenizer, \"Reading Predicate\")) {\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype == JSJshopVars.rightPar) {\n            JSUtil.println(\"Unexpected ) while reading Predicate\");\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype == JSJshopVars.exclamation) {\n            if (!JSUtil.expectTokenType(-3, tokenizer, \"Operator name expected\")) {\n                throw new JSParserError();\n            }\n            tokenizer.pushBack();\n            final String w = JSUtil.readWord(tokenizer, \"JSPredicateForm\");\n            if (w.equals(\"%%%\")) {\n                throw new JSParserError();\n            }\n            this.addElement(\"!\" + w);\n        }\n        else if (tokenizer.ttype == -3 && tokenizer.sval.equalsIgnoreCase(\"not\")) {\n            this.addElement(new String(tokenizer.sval));\n            this.addElement(new JSPredicateForm(tokenizer));\n            if (JSUtil.expectTokenType(JSJshopVars.rightPar, tokenizer, \"JSPredicateForm\")) {\n                return;\n            }\n            throw new JSParserError();\n        }\n        else {\n            if (tokenizer.ttype == -3 && tokenizer.sval.equalsIgnoreCase(\"call\")) {\n                this.addElement(new String(tokenizer.sval));\n                tokenizer.ttype = JSJshopVars.leftPar;\n                tokenizer.pushBack();\n                final JSTerm t = new JSTerm(tokenizer);\n                t.makeEval(true);\n                this.addElement(t);\n                return;\n            }\n            if (tokenizer.ttype != -3) {\n                JSUtil.println(\"PlanningDomain: error\");\n                throw new JSParserError();\n            }\n            tokenizer.pushBack();\n            final String w = JSUtil.readWord(tokenizer, \"JSPredicateForm\");\n            if (w.equals(\"%%%\")) {\n                throw new JSParserError();\n            }\n            this.addElement(w);\n        }\n        if (!JSUtil.readToken(tokenizer, \"JSPredicateForm\")) {\n            throw new JSParserError();\n        }\n        while (tokenizer.ttype != JSJshopVars.rightPar) {\n            tokenizer.pushBack();\n            this.addElement(new JSTerm(tokenizer));\n            if (!JSUtil.readToken(tokenizer, \"JSPredicateForm\")) {\n                throw new JSParserError();\n            }\n        }\n    }\n    \n    public void print() {\n        if (this.size() == 0) {\n            JSUtil.println(\"Predicateform.print(): 0 elements\");\n            return;\n        }\n        final String str = this.elementAt(0);\n        JSUtil.print(\"(\");\n        JSUtil.print(str + \" \");\n        if (str.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm el = this.elementAt(1);\n            el.print();\n        }\n        else {\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el2 = this.elementAt(i);\n                el2.print();\n            }\n        }\n        JSUtil.print(\" ) \");\n    }\n    \n    public StringBuffer toStr() {\n        final StringBuffer res = new StringBuffer();\n        if (this.size() == 0) {\n            JSUtil.println(\"Predicateform.print(): 0 elements\");\n            return res;\n        }\n        res.append(\"(\");\n        final String str = this.elementAt(0);\n        res.append(str);\n        if (str.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm el = this.elementAt(1);\n            res.append(el.toStr());\n        }\n        else {\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el2 = this.elementAt(i);\n                res.append(el2.toStr());\n            }\n        }\n        res.append(\")\");\n        return res;\n    }\n    \n    public JSPredicateForm clonePF() {\n        final JSPredicateForm np = new JSPredicateForm();\n        final String str = this.elementAt(0);\n        if (str.equalsIgnoreCase(\"not\")) {\n            np.addElement(this.elementAt(0));\n            final JSPredicateForm el = this.elementAt(1);\n            np.addElement(el.clonePF());\n        }\n        else {\n            np.addElement(this.elementAt(0));\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                np.addElement(ti.cloneT());\n            }\n        }\n        return np;\n    }\n    \n    public JSPredicateForm applySubstitutionPF(final JSSubstitution alpha) {\n        final JSPredicateForm np = new JSPredicateForm();\n        final String str = this.elementAt(0);\n        if (str.equalsIgnoreCase(\"not\")) {\n            np.addElement(this.elementAt(0));\n            final JSPredicateForm el = this.elementAt(1);\n            np.addElement(el.applySubstitutionPF(alpha));\n        }\n        else {\n            np.addElement(this.elementAt(0));\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                np.addElement(ti.applySubstitutionT(alpha));\n            }\n        }\n        return np;\n    }\n    \n    public JSSubstitution matches(final JSPredicateForm t) {\n        return this.matches(t, new JSSubstitution());\n    }\n    \n    public JSSubstitution matches(final JSPredicateForm t, final JSSubstitution alpha) {\n        JSSubstitution beta = new JSSubstitution();\n        if (this.size() != t.size()) {\n            beta.assignFailure();\n            return beta;\n        }\n        final String functor = this.elementAt(0);\n        if (!functor.equalsIgnoreCase(t.elementAt(0))) {\n            beta.assignFailure();\n            return beta;\n        }\n        if (functor.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm e1 = this.elementAt(1);\n            final JSPredicateForm e2 = t.elementAt(1);\n            beta = e1.matches(e2, alpha);\n            return beta;\n        }\n        JSSubstitution gama = new JSSubstitution();\n        final JSSubstitution newAlpha = alpha.cloneS();\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            if (!ti.equals(t.elementAt(i))) {\n                gama = ti.matches(t.elementAt(i), newAlpha);\n                if (gama.fail()) {\n                    return gama;\n                }\n                beta.addElements(gama);\n                newAlpha.addElements(gama);\n            }\n        }\n        return beta;\n    }\n    \n    public boolean equals(final JSPredicateForm t) {\n        if (t == null) {\n            return false;\n        }\n        final String functor = this.elementAt(0);\n        if (this.size() != t.size()) {\n            return false;\n        }\n        final String functor2 = t.elementAt(0);\n        if (!functor.equalsIgnoreCase(functor2)) {\n            return false;\n        }\n        if (functor.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm e1 = this.elementAt(1);\n            final JSPredicateForm e2 = t.elementAt(1);\n            return e1.equals(e2);\n        }\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            final JSTerm oti = t.elementAt(i);\n            if (!ti.equals(oti)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public JSPredicateForm standarizerPredicateForm() {\n        final JSPredicateForm nTA = new JSPredicateForm();\n        final String str = this.elementAt(0);\n        if (str.equalsIgnoreCase(\"not\")) {\n            nTA.addElement(this.elementAt(0));\n            final JSPredicateForm el = this.elementAt(1);\n            nTA.addElement(el.standarizerPredicateForm());\n            return nTA;\n        }\n        nTA.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nTA.addElement(ti.standardizerTerm());\n        }\n        return nTA;\n    }\n}\n",
        "token_number_zeroshot": 1866,
        "token_number_fewshot": 2264,
        "token_number_cot": 1979
    },
    {
        "project_name": "85_shop",
        "class": "JSTerm",
        "source_code": "package umd.cs.shop;\n\nimport java.io.*;\n\npublic class JSTerm extends JSPredicateForm\n{\n    private boolean isVariable;\n    private boolean isConstant;\n    private boolean isFunction;\n    private boolean isEval;\n    \n    JSTerm() {\n    }\n    \n    JSTerm(final StreamTokenizer tokenizer) {\n        this.isEval = false;\n        if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype != JSJshopVars.leftPar) {\n            if (tokenizer.ttype != JSJshopVars.interrogation) {\n                if (tokenizer.ttype == JSJshopVars.percent) {\n                    if (!JSUtil.expectTokenType(-3, tokenizer, \" Expecting word as term\")) {\n                        throw new JSParserError();\n                    }\n                    this.addElement(\"%\" + tokenizer.sval);\n                }\n                else if (tokenizer.ttype == -2) {\n                    this.addElement(new Double(tokenizer.nval).toString());\n                }\n                else {\n                    if (tokenizer.ttype != -3) {\n                        JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Term expected\");\n                        throw new JSParserError();\n                    }\n                    tokenizer.pushBack();\n                    final String varname = JSUtil.readWord(tokenizer, \"Expecting constant symbol as term\");\n                    this.addElement(varname);\n                }\n                this.isVariable = false;\n                this.isConstant = true;\n                this.isFunction = false;\n                return;\n            }\n            if (!JSUtil.readToken(tokenizer, \"Expecting variable name in term\")) {\n                throw new JSParserError();\n            }\n            tokenizer.pushBack();\n            final String varname = JSUtil.readWord(tokenizer, \"Expecting variable name in term\");\n            this.addElement(\"?\" + varname);\n            this.isVariable = true;\n            this.isConstant = false;\n            this.isFunction = false;\n        }\n        else {\n            this.isVariable = false;\n            this.isConstant = false;\n            this.isFunction = true;\n            if (tokenizer.ttype != JSJshopVars.leftPar) {\n                JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Expected (\");\n                throw new JSParserError();\n            }\n            if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                throw new JSParserError();\n            }\n            if (tokenizer.ttype == -3 && tokenizer.sval.equalsIgnoreCase(\"call\")) {\n                this.isEval = true;\n                if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                    throw new JSParserError();\n                }\n            }\n            if (tokenizer.ttype != -3 || !tokenizer.sval.equalsIgnoreCase(\"list\")) {\n                if (tokenizer.ttype == JSJshopVars.lessT) {\n                    if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                        throw new JSParserError();\n                    }\n                    if (tokenizer.ttype == JSJshopVars.equalT) {\n                        this.addElement(\"<=\");\n                    }\n                    else {\n                        this.addElement(\"<\");\n                        tokenizer.pushBack();\n                    }\n                }\n                else if (tokenizer.ttype == JSJshopVars.greaterT) {\n                    if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                        throw new JSParserError();\n                    }\n                    if (tokenizer.ttype == JSJshopVars.equalT) {\n                        this.addElement(\">=\");\n                    }\n                    else {\n                        this.addElement(\">\");\n                        tokenizer.pushBack();\n                    }\n                }\n                else if (tokenizer.ttype == JSJshopVars.plus || tokenizer.ttype == JSJshopVars.minus || tokenizer.ttype == JSJshopVars.slash || tokenizer.ttype == JSJshopVars.astherisk) {\n                    this.addElement(JSUtil.stringTokenizer(tokenizer));\n                }\n                else {\n                    if (tokenizer.ttype != -3) {\n                        JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Term expected\");\n                        throw new JSParserError();\n                    }\n                    tokenizer.pushBack();\n                    final String w = JSUtil.readWord(tokenizer, \"JSTerm\");\n                    if (w.equals(\"%%%\")) {\n                        JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Term expected\");\n                        throw new JSParserError();\n                    }\n                    this.addElement(w);\n                }\n                try {\n                    tokenizer.nextToken();\n                    while (tokenizer.ttype != JSJshopVars.rightPar) {\n                        tokenizer.pushBack();\n                        this.addElement(new JSTerm(tokenizer));\n                        tokenizer.nextToken();\n                    }\n                }\n                catch (Exception e) {\n                    JSUtil.println(\"JSTerm: Error reading control parameters: \" + e);\n                    System.exit(1);\n                }\n                return;\n            }\n            if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                throw new JSParserError();\n            }\n            if (tokenizer.ttype == JSJshopVars.rightPar) {\n                this.addElement(\"nil\");\n                this.makeConstant();\n                return;\n            }\n            tokenizer.pushBack();\n            this.addElement(\".\");\n            this.addElement(new JSTerm(tokenizer));\n            this.addElement(this.parseList(tokenizer));\n        }\n    }\n    \n    public JSTerm parseList(final StreamTokenizer tokenizer) {\n        final JSTerm t = new JSTerm();\n        if (!JSUtil.readToken(tokenizer, \"Expecting elements of the list\")) {\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype == JSJshopVars.rightPar) {\n            t.addElement(\"nil\");\n            t.makeConstant();\n            return t;\n        }\n        if (tokenizer.ttype != JSJshopVars.dot) {\n            tokenizer.pushBack();\n            t.makeFunction();\n            t.addElement(\".\");\n            t.addElement(new JSTerm(tokenizer));\n            t.addElement(this.parseList(tokenizer));\n            return t;\n        }\n        final JSTerm cdr = new JSTerm(tokenizer);\n        if (!JSUtil.expectTokenType(JSJshopVars.rightPar, tokenizer, \"Expecting ')' for term.\")) {\n            throw new JSParserError();\n        }\n        if (cdr.isVariable || cdr.elementAt(0).equalsIgnoreCase(\"nil\") || cdr.elementAt(0).equals(\".\")) {\n            return cdr;\n        }\n        t.addElement(\".\");\n        t.addElement(cdr);\n        final JSTerm r = new JSTerm();\n        r.addElement(\"nil\");\n        r.makeConstant();\n        t.addElement(r);\n        return t;\n    }\n    \n    private void printList(final JSTerm t) {\n        final String str = \"nil\";\n        if (str.equalsIgnoreCase(t.elementAt(0))) {\n            JSUtil.print(\") \");\n            return;\n        }\n        if (t.isVariable) {\n            JSUtil.print(\" . \");\n            t.print();\n            JSUtil.print(\") \");\n            return;\n        }\n        JSTerm tt = t.elementAt(1);\n        tt.print();\n        JSUtil.print(\" \");\n        tt = t.elementAt(2);\n        this.printList(tt);\n    }\n    \n    @Override\n    public void print() {\n        if (this.isVariable || this.isConstant) {\n            JSUtil.print(this.elementAt(0) + \" \");\n        }\n        else {\n            JSUtil.print(\"(\");\n            if (this.elementAt(0).equals(\".\")) {\n                JSUtil.print(\"list \");\n                this.printList(this);\n                return;\n            }\n            if (this.isEval) {\n                JSUtil.print(\"call \");\n            }\n            JSUtil.print(this.elementAt(0) + \" \");\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el = this.elementAt(i);\n                el.print();\n            }\n            JSUtil.print(\")\");\n        }\n    }\n    \n    public JSTerm cloneT() {\n        final JSTerm nt = new JSTerm();\n        nt.isEval = this.isEval;\n        if (this.isConstant()) {\n            nt.addElement(this.elementAt(0));\n            nt.makeConstant();\n            return nt;\n        }\n        if (this.isVariable()) {\n            nt.addElement(this.elementAt(0));\n            nt.makeVariable();\n            return nt;\n        }\n        nt.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nt.addElement(ti.cloneT());\n        }\n        nt.makeFunction();\n        return nt;\n    }\n    \n    public JSTerm applySubstitutionT(final JSSubstitution alpha) {\n        if (this.isConstant()) {\n            return this.cloneT();\n        }\n        if (this.isVariable()) {\n            final JSTerm nt = alpha.instance(this);\n            return nt.cloneT();\n        }\n        final JSTerm nt = new JSTerm();\n        nt.makeEval(this.isEval);\n        nt.makeFunction();\n        nt.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nt.addElement(ti.applySubstitutionT(alpha));\n        }\n        return nt;\n    }\n    \n    public JSSubstitution matches(final JSTerm t) {\n        return this.matches(t, new JSSubstitution());\n    }\n    \n    public JSSubstitution matches(final JSTerm t, final JSSubstitution alpha) {\n        final JSSubstitution beta = new JSSubstitution();\n        if (this.isConstant()) {\n            if (!t.isConstant()) {\n                return t.matches(this, alpha);\n            }\n            if (!this.equals(t)) {\n                beta.assignFailure();\n            }\n            return beta;\n        }\n        else if (this.isVariable()) {\n            final JSTerm nt = alpha.instance(this);\n            if (!nt.equals(this)) {\n                return nt.matches(t, alpha);\n            }\n            beta.addElement(new JSPairVarTerm(this, t));\n            return beta;\n        }\n        else {\n            if (t.isVariable) {\n                return t.matches(this);\n            }\n            if (!t.isFunction()) {\n                beta.assignFailure();\n                return beta;\n            }\n            if (this.size() != t.size()) {\n                beta.assignFailure();\n                return beta;\n            }\n            final String functor = this.elementAt(0);\n            if (!functor.equalsIgnoreCase(t.elementAt(0))) {\n                beta.assignFailure();\n                return beta;\n            }\n            JSSubstitution gama = new JSSubstitution();\n            final JSSubstitution newAlpha = (JSSubstitution)alpha.clone();\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                if (!ti.equals(t.elementAt(i))) {\n                    gama = ti.matches(t.elementAt(i), newAlpha);\n                    if (gama.fail()) {\n                        gama.assignFailure();\n                        return gama;\n                    }\n                    beta.addElements(gama);\n                    newAlpha.addElements(gama);\n                }\n            }\n            return beta;\n        }\n    }\n    \n    public boolean equals(final JSTerm t) {\n        if (this.isConstant()) {\n            if (!t.isConstant()) {\n                return false;\n            }\n            final String name = this.elementAt(0);\n            final String name2 = t.elementAt(0);\n            return name.equalsIgnoreCase(name2);\n        }\n        else if (this.isVariable()) {\n            if (!t.isVariable()) {\n                return false;\n            }\n            final String name = this.elementAt(0);\n            final String name2 = t.elementAt(0);\n            return name.equalsIgnoreCase(name2);\n        }\n        else {\n            if (!t.isFunction()) {\n                return false;\n            }\n            if (this.size() != t.size()) {\n                return false;\n            }\n            final String functor = this.elementAt(0);\n            final String functor2 = t.elementAt(0);\n            if (!functor.equalsIgnoreCase(functor2)) {\n                return false;\n            }\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                final JSTerm oti = t.elementAt(i);\n                if (!ti.equals(oti)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    public boolean isVariable() {\n        return this.isVariable;\n    }\n    \n    public boolean isConstant() {\n        return this.isConstant;\n    }\n    \n    public boolean isFunction() {\n        return this.isFunction;\n    }\n    \n    public boolean isEval() {\n        return this.isEval;\n    }\n    \n    public void makeFunction() {\n        this.isVariable = false;\n        this.isConstant = false;\n        this.isFunction = true;\n    }\n    \n    public void makeVariable() {\n        this.isVariable = true;\n        this.isConstant = false;\n        this.isFunction = false;\n    }\n    \n    public void makeConstant() {\n        this.isVariable = false;\n        this.isConstant = true;\n        this.isFunction = false;\n    }\n    \n    public void makeEval(final boolean evaluable) {\n        this.isEval = evaluable;\n    }\n    \n    @Override\n    public StringBuffer toStr() {\n        final StringBuffer res = new StringBuffer();\n        if (this.isVariable || this.isConstant) {\n            res.append(this.elementAt(0) + \" \");\n        }\n        else {\n            res.append(\"(\");\n            res.append(this.elementAt(0) + \" \");\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el = this.elementAt(i);\n                res.append(el.toStr());\n            }\n            res.append(\")\");\n        }\n        return res;\n    }\n    \n    public boolean isGround() {\n        if (this.isConstant()) {\n            return true;\n        }\n        if (this.isVariable()) {\n            return false;\n        }\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            if (!ti.isGround()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public JSTerm standardizerTerm() {\n        final JSTerm nt = new JSTerm();\n        nt.makeEval(this.isEval);\n        if (this.isConstant()) {\n            nt.addElement(this.elementAt(0));\n            nt.makeConstant();\n            return nt;\n        }\n        if (this.isVariable()) {\n            nt.addElement(this.elementAt(0) + String.valueOf(JSJshopVars.VarCounter));\n            nt.makeVariable();\n            return nt;\n        }\n        nt.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nt.addElement(ti.standardizerTerm());\n        }\n        nt.makeFunction();\n        return nt;\n    }\n    \n    public JSTerm call() {\n        if (this.isConstant()) {\n            return (JSTerm)this.clone();\n        }\n        if (!this.isEval() && this.isVariable()) {\n            return (JSTerm)this.clone();\n        }\n        if (this.isVariable()) {\n            return new JSTerm();\n        }\n        final JSTerm f = new JSTerm();\n        f.makeFunction();\n        f.addElement(this.elementAt(0));\n        for (int i = 1; i < this.size(); ++i) {\n            f.addElement(this.elementAt(i).call());\n        }\n        if (!this.isEval()) {\n            return f;\n        }\n        final String op = new String(f.elementAt(0));\n        final JSTerm operant1 = f.elementAt(1).call();\n        if (operant1.size() == 0 && !op.equalsIgnoreCase(\"not\")) {\n            return new JSTerm();\n        }\n        JSTerm t;\n        if (JSEvaluate.OperantNum(op) > 1) {\n            final JSTerm operant2 = f.elementAt(2).call();\n            if (operant2.size() == 0) {\n                return new JSTerm();\n            }\n            t = JSEvaluate.applyOperator(op, operant1, operant2);\n        }\n        else {\n            t = JSEvaluate.applyOperatorUnary(op, operant1);\n        }\n        return t;\n    }\n}\n",
        "token_number_zeroshot": 3382,
        "token_number_fewshot": 3780,
        "token_number_cot": 3494
    },
    {
        "project_name": "85_shop",
        "class": "JSJshop",
        "source_code": "package umd.cs.shop;\n\nimport javax.swing.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\n\npublic final class JSJshop\n{\n    public static boolean corbaToHicap;\n    public static JApplet applet;\n    private JSPlanningDomain dom;\n    private JSPlanningProblem prob;\n    private JSListPlanningProblem probSet;\n    private JSPlan sol;\n    private JSJshopNode tree;\n    private JSPairPlanTSListNodes solution;\n    \n    public static void main(final String[] args) {\n        if (args.length < 2 || args.length > 4) {\n            JSUtil.println(\"Usage :\");\n            JSUtil.println(\" java JSJshop <domainDef-file-name> <problemDef-file-name> [number-of-plans]\");\n            JSUtil.println(\"[number-of-plans] can be 'one' or 'all'. The default value is 'one'\");\n            return;\n        }\n        final String one = \"one\";\n        final String all = \"all\";\n        try {\n            for (int i = 2; i < args.length; ++i) {\n                if (one.equalsIgnoreCase(args[i])) {\n                    JSJshopVars.allPlans = false;\n                }\n                else if (all.equalsIgnoreCase(args[i])) {\n                    JSJshopVars.allPlans = true;\n                }\n                else {\n                    final int level = JSJshopVars.flagLevel = Integer.valueOf(args[i]);\n                }\n            }\n        }\n        catch (NumberFormatException e) {\n            JSUtil.println(\"Invalid parameter\");\n            return;\n        }\n        new JSJshop(args[0], args[1]);\n    }\n    \n    public JSJshop() {\n        this.probSet = new JSListPlanningProblem();\n        this.tree = null;\n    }\n    \n    public JSJshop(final String nameDomainFile, final String nameProblemFile) {\n        this.probSet = new JSListPlanningProblem();\n        this.tree = null;\n        JSUtil.println(\"Reading file \" + nameDomainFile);\n        if (!this.parserFile(nameDomainFile)) {\n            if (!JSJshopVars.flagExit) {\n                return;\n            }\n            System.exit(0);\n        }\n        JSUtil.println(\"Domain file parsed successfully\");\n        JSUtil.println(\"Reading file \" + nameProblemFile);\n        if (!this.parserFile(nameProblemFile)) {\n            if (!JSJshopVars.flagExit) {\n                return;\n            }\n            System.exit(0);\n        }\n        JSUtil.println(\"Problem file parsed successfully\");\n        for (int k = 0; k < this.probSet.size(); ++k) {\n            this.prob = this.probSet.elementAt(k);\n            JSUtil.println(\"Solving Problem :\" + this.prob.Name());\n            final JSListPairPlanTStateNodes allPlans = this.dom.solveAll(this.prob, JSJshopVars.allPlans);\n            if (allPlans.isEmpty()) {\n                (this.sol = new JSPlan()).assignFailure();\n                this.solution = new JSPairPlanTSListNodes(new JSPairPlanTState(this.sol, new JSTState()), new Vector());\n                JSUtil.println(\"0 plans found\");\n            }\n            else {\n                this.solution = allPlans.elementAt(0);\n                this.sol = this.solution.planS().plan();\n                JSUtil.println(allPlans.size() + \" plans found.\");\n                if (JSJshopVars.flagLevel > 0) {\n                    JSUtil.println(\"********* PLANS *******\");\n                    for (int i = 0; i < allPlans.size(); ++i) {\n                        JSUtil.println(\"Plan # \" + (i + 1));\n                        final JSPairPlanTSListNodes pair = allPlans.elementAt(i);\n                        pair.planS().plan().printPlan();\n                    }\n                }\n            }\n        }\n    }\n    \n    public JSJshop(final String nameFile, final JSTaskAtom pred) {\n        this.probSet = new JSListPlanningProblem();\n        this.tree = null;\n        this.setFile(nameFile, pred);\n    }\n    \n    public JSJshopNode getTree() {\n        return this.tree;\n    }\n    \n    public JSPairPlanTSListNodes getSolution() {\n        return this.solution;\n    }\n    \n    public JSListLogicalAtoms getAddList() {\n        if (this.tree == null) {\n            return null;\n        }\n        return this.solution.planS().tState().addList();\n    }\n    \n    public JSListLogicalAtoms getDeleteList() {\n        if (this.tree == null) {\n            return null;\n        }\n        return this.solution.planS().tState().deleteList();\n    }\n    \n    public JSPairPlanTSListNodes setFile(final String nameFile, final JSTaskAtom pred) {\n        Vector listNodes = new Vector();\n        JSJshopVars.VarCounter = 0;\n        this.parserFile(nameFile);\n        JSUtil.flag(\"File parsed\");\n        this.dom.print();\n        JSUtil.flag(\"<- domain\");\n        this.prob.print();\n        JSUtil.flag(\"<- problem\");\n        JSJshopVars.allPlans = false;\n        final JSListPairPlanTStateNodes listPairs = this.dom.solveAll(this.prob, JSJshopVars.allPlans);\n        if (listPairs.size() == 0) {\n            return null;\n        }\n        final JSPairPlanTSListNodes pair = listPairs.elementAt(0);\n        JSUtil.flag(\"**After planning\");\n        this.sol = pair.planS().plan();\n        if (this.sol.isFailure()) {\n            JSUtil.print(\"*NO* SOLUTION FOUND\");\n            return null;\n        }\n        JSUtil.print(\"SOLUTION FOUND\");\n        pair.planS().tState().print();\n        JSUtil.println(\"***************FINAL SOLUTION*******\");\n        this.sol.print();\n        JSUtil.println(\"********* list-tree FINAL SOLUTION*******\");\n        listNodes = pair.listNodes();\n        for (int i = 0; i < listNodes.size(); ++i) {\n            final JSJshopNode node = listNodes.elementAt(i);\n            node.print2();\n        }\n        final JSJshopNode node = listNodes.elementAt(listNodes.size() - 1);\n        listNodes.removeElement(node);\n        this.tree = new JSJshopNode(node, listNodes);\n        JSUtil.println(\"********* tree FINAL SOLUTION*******\");\n        this.tree.print();\n        return this.solution = pair;\n    }\n    \n    public void testParser() {\n        try {\n            final FileReader fr = new FileReader(\"farp.shp\");\n            final StreamTokenizer tokenizer = new StreamTokenizer(fr);\n            JSUtil.initParseTable(tokenizer);\n            while (tokenizer.nextToken() != -1) {\n                if (tokenizer.ttype == -2) {\n                    System.err.print(new Double(tokenizer.nval).toString() + \" \");\n                }\n                if (tokenizer.ttype == JSJshopVars.leftPar) {\n                    System.err.print(\"( \");\n                }\n                if (tokenizer.ttype == JSJshopVars.rightPar) {\n                    System.err.print(\") \");\n                }\n                if (tokenizer.ttype == JSJshopVars.colon) {\n                    System.err.print(\": \");\n                }\n                if (tokenizer.ttype == JSJshopVars.semicolon) {\n                    System.err.print(\"; \");\n                }\n                if (tokenizer.ttype == JSJshopVars.apostrophe) {\n                    System.err.print(\"' \");\n                }\n                if (tokenizer.ttype == JSJshopVars.exclamation) {\n                    System.err.print(\"! \");\n                }\n                if (tokenizer.ttype == JSJshopVars.interrogation) {\n                    System.err.print(\"? \");\n                }\n                if (tokenizer.ttype == JSJshopVars.minus) {\n                    System.err.print(\"- \");\n                }\n                if (tokenizer.ttype == JSJshopVars.lessT) {\n                    System.err.print(\"< \");\n                }\n                if (tokenizer.ttype == JSJshopVars.equalT) {\n                    System.err.print(\"= \");\n                }\n                if (tokenizer.ttype == JSJshopVars.greaterT) {\n                    System.err.print(\"> \");\n                }\n                if (tokenizer.ttype == JSJshopVars.plus) {\n                    System.err.print(\"+ \");\n                }\n                if (tokenizer.ttype == JSJshopVars.backquote) {\n                    System.err.print(\"` \");\n                }\n                if (tokenizer.ttype == JSJshopVars.slash) {\n                    System.err.print(\"/ \");\n                }\n                if (tokenizer.ttype == JSJshopVars.coma) {\n                    System.err.print(\", \");\n                }\n                if (tokenizer.ttype == JSJshopVars.astherisk) {\n                    System.err.print(\"* \");\n                }\n                if (tokenizer.ttype == JSJshopVars.rightBrac) {\n                    System.err.print(\"] \");\n                }\n                if (tokenizer.ttype == JSJshopVars.leftBrac) {\n                    System.err.print(\"[ \");\n                }\n                if (tokenizer.ttype == JSJshopVars.verticalL) {\n                    System.err.print(\"| \");\n                }\n                if (tokenizer.ttype == -3) {\n                    System.err.print(tokenizer.sval + \" \");\n                }\n            }\n            fr.close();\n        }\n        catch (Exception e) {\n            JSUtil.println(\"Error reading control parameters: \" + e);\n            System.exit(1);\n        }\n    }\n    \n    public boolean parserFile(final String libraryFile) {\n        final String libraryDirectory = \".\";\n        try {\n            final FileReader fr = new FileReader(libraryFile);\n            final StreamTokenizer tokenizer = new StreamTokenizer(fr);\n            tokenizer.lowerCaseMode(true);\n            JSUtil.initParseTable(tokenizer);\n            if (fr == null) {\n                JSUtil.println(\"Can not open file : \" + libraryFile);\n                return false;\n            }\n            while (tokenizer.nextToken() != -1) {\n                this.processToken(tokenizer);\n            }\n            fr.close();\n        }\n        catch (IOException e) {\n            System.out.println(\"Error in readFile() : \" + e);\n            return false;\n        }\n        catch (JSParserError parserError) {\n            System.out.println(\"Error in parsing file\");\n            return false;\n        }\n        return true;\n    }\n    \n    public BufferedReader getBufferedReader(final String dir, final String file) {\n        return this.getBufferedReader(dir, file);\n    }\n    \n    public BufferedReader getBufferedReader(final String dir, final String file, final JApplet applet) {\n        if (file == null) {\n            return null;\n        }\n        BufferedReader br = null;\n        FileInputStream libraryFileInputStream = null;\n        InputStream conn = null;\n        try {\n            if (applet != null) {\n                final URL url = this.getAppletURL(file, applet);\n                if (url == null) {\n                    System.err.println(\"Util.getBufferedReader() error: cannot get URL\");\n                    return null;\n                }\n                conn = url.openStream();\n                if (conn == null) {\n                    System.err.println(\"Util.getBufferedReader() error: cannot open URL\");\n                    return null;\n                }\n            }\n            else {\n                libraryFileInputStream = new FileInputStream(dir + File.separator + file);\n            }\n        }\n        catch (IOException e) {\n            System.err.println(\"Error 1 in Util.getBufferedReader : \" + e);\n            return null;\n        }\n        if (applet != null) {\n            br = new BufferedReader(new InputStreamReader(conn));\n        }\n        else {\n            try {\n                br = new BufferedReader(new InputStreamReader(libraryFileInputStream, System.getProperty(\"file.encoding\")));\n            }\n            catch (UnsupportedEncodingException e2) {\n                System.err.println(\"Error 2 in Util.getBufferedReader : \" + e2);\n                return null;\n            }\n        }\n        return br;\n    }\n    \n    public URL getAppletURL(final String file, final JApplet applet) {\n        try {\n            return new URL(applet.getCodeBase() + file);\n        }\n        catch (MalformedURLException e) {\n            return null;\n        }\n    }\n    \n    public void processToken(final StreamTokenizer tokenizer) {\n        if (tokenizer.ttype != JSJshopVars.leftPar) {\n            System.err.println(\"Line : \" + tokenizer.lineno() + \" Expected '('\");\n            throw new JSParserError();\n        }\n        if (!JSUtil.expectTokenType(-3, tokenizer, \"Expected 'defdomain or defproblem' \")) {\n            throw new JSParserError();\n        }\n        tokenizer.pushBack();\n        final String w = JSUtil.readWord(tokenizer, \"JSJshop>>processToken\");\n        if (w.equals(\"%%%\")) {\n            throw new JSParserError();\n        }\n        if (w.equalsIgnoreCase(\"defdomain\")) {\n            this.dom = new JSPlanningDomain(tokenizer);\n            return;\n        }\n        if (w.equalsIgnoreCase(\"defproblem\")) {\n            this.prob = new JSPlanningProblem(tokenizer);\n            this.probSet.addElement(this.prob);\n            return;\n        }\n        System.err.println(\"Line : \" + tokenizer.lineno() + \" Expecting defdomain or defproblem\");\n        throw new JSParserError();\n    }\n    \n    public JSPlanningDomain dom() {\n        return this.dom;\n    }\n    \n    public JSPlanningProblem prob() {\n        return this.prob;\n    }\n    \n    public JSPlan sol() {\n        return this.sol;\n    }\n    \n    public JSJshopNode tree() {\n        return this.tree;\n    }\n    \n    static {\n        JSJshop.corbaToHicap = false;\n    }\n}\n",
        "token_number_zeroshot": 2779,
        "token_number_fewshot": 3177,
        "token_number_cot": 2891
    },
    {
        "project_name": "85_shop",
        "class": "JSState",
        "source_code": "package umd.cs.shop;\n\nimport java.io.*;\n\npublic class JSState extends JSListLogicalAtoms\n{\n    private String label;\n    \n    public JSState() {\n    }\n    \n    public JSState(final StreamTokenizer tokenizer) {\n        super(tokenizer);\n    }\n    \n    public void addElementsToState(final JSListLogicalAtoms s) {\n        int j = 0;\n        for (int i = 0; i < s.size(); ++i) {\n            if (!this.contains(s.elementAt(i))) {\n                this.insertElementAt(s.elementAt(i), j);\n                ++j;\n            }\n        }\n    }\n    \n    JSState apply(final JSPlan pl) {\n        final JSState ns = new JSState();\n        JSUtil.flag20(\"<STATE>.apply(<JSPlan>) not implemented yet\");\n        return ns;\n    }\n    \n    JSTState applyOp(final JSOperator op, final JSSubstitution alpha, final JSListLogicalAtoms addL, final JSListLogicalAtoms delL) {\n        final JSListLogicalAtoms add = op.addList();\n        final JSListLogicalAtoms del = op.deleteList();\n        final JSListLogicalAtoms opAddL = add.applySubstitutionListLogicalAtoms(alpha);\n        final JSListLogicalAtoms opDelL = del.applySubstitutionListLogicalAtoms(alpha);\n        final JSState ns = new JSState();\n        final JSListLogicalAtoms nAddL = new JSListLogicalAtoms();\n        final JSListLogicalAtoms nDelL = new JSListLogicalAtoms();\n        if (JSJshopVars.flagLevel > 3) {\n            JSUtil.print(\" Matching Operator : (\");\n            JSUtil.print(\":Operator \");\n            op.head().applySubstitutionTA(alpha).print();\n            JSUtil.print(\"-: \");\n            opDelL.print();\n            JSUtil.print(\"+: \");\n            opAddL.print();\n            JSUtil.println(\")\");\n        }\n        for (short i = 0; i < this.size(); ++i) {\n            final JSPredicateForm el = this.elementAt(i);\n            if (!opDelL.contains(el)) {\n                ns.addElement(el);\n            }\n        }\n        ns.addElementsToState(opAddL);\n        for (short i = 0; i < addL.size(); ++i) {\n            final JSPredicateForm el = addL.elementAt(i);\n            if (!opDelL.contains(el)) {\n                nAddL.addElement(el);\n            }\n        }\n        nAddL.addElements(opAddL);\n        for (short i = 0; i < delL.size(); ++i) {\n            final JSPredicateForm el = delL.elementAt(i);\n            if (!opAddL.contains(el)) {\n                nDelL.addElement(el);\n            }\n        }\n        nDelL.addElements(opDelL);\n        if (JSJshopVars.flagLevel > 3) {\n            JSUtil.println(\"The resulting state :\");\n            ns.print();\n            JSUtil.println(\"-----------\");\n        }\n        return new JSTState(ns, nAddL, nDelL);\n    }\n    \n    public JSSubstitution satisfies(final JSListLogicalAtoms conds, final JSSubstitution alpha, final JSListAxioms axioms) {\n        final JSListSubstitution satisfiers = axioms.TheoremProver(conds, this, alpha, false);\n        JSSubstitution answer;\n        if (satisfiers.fail()) {\n            answer = new JSSubstitution();\n            answer.assignFailure();\n        }\n        else {\n            answer = (JSSubstitution)alpha.clone();\n            answer.addElements(satisfiers.elementAt(0));\n        }\n        return answer;\n    }\n    \n    public JSListSubstitution satisfiesAll(final JSListLogicalAtoms conds, final JSSubstitution alpha, final JSListAxioms axioms) {\n        final String first = conds.Label();\n        final boolean findfirst = !first.equalsIgnoreCase(\"first\");\n        final JSListSubstitution answers = new JSListSubstitution();\n        final JSListSubstitution satisfiers = axioms.TheoremProver(conds, this, alpha, findfirst);\n        for (int i = 0; i < satisfiers.size(); ++i) {\n            final JSSubstitution beta = (JSSubstitution)satisfiers.elementAt(i).clone();\n            beta.addElements((JSSubstitution)alpha.clone());\n            answers.addElement(beta);\n        }\n        return answers;\n    }\n    \n    public JSListSubstitution satisfiesTAm(final JSPredicateForm t, final JSSubstitution alpha) {\n        final JSListSubstitution answers = new JSListSubstitution();\n        if (JSJshopVars.flagLevel > 7) {\n            System.out.println(\" \");\n        }\n        for (int i = 0; i < this.size(); ++i) {\n            final JSPredicateForm el = this.elementAt(i);\n            final JSSubstitution subs = t.matches(el, alpha);\n            if (!subs.fail()) {\n                if (JSJshopVars.flagLevel > 7) {\n                    JSUtil.println(\" Goal matches atom: \");\n                    el.print();\n                }\n                answers.addElement(subs);\n            }\n        }\n        if (JSJshopVars.flagLevel > 7 && answers.isEmpty()) {\n            JSUtil.println(\" Goal does not match any atom.\");\n        }\n        return answers;\n    }\n}\n",
        "token_number_zeroshot": 1131,
        "token_number_fewshot": 1529,
        "token_number_cot": 1242
    },
    {
        "project_name": "7_sfmis",
        "class": "Base64",
        "source_code": "package com.hf.sfm.crypt;\n\npublic class Base64\n{\n    private static final byte[] _$23169;\n    private static final byte[] _$23168;\n    private static final char[] _$23167;\n    private static final char[] _$23166;\n    \n    public static byte[] altBase64ToByteArray(final String s) {\n        return _$23180(s, true);\n    }\n    \n    private static byte[] _$23180(final String s, final boolean flag) {\n        final byte[] bb = flag ? Base64._$23169 : Base64._$23168;\n        final int i = s.length();\n        final int j = i / 4;\n        if (4 * j != i) {\n            throw new IllegalArgumentException(\"String length must be a multiple of four.\");\n        }\n        int k = 0;\n        int l = j;\n        if (i != 0) {\n            if (s.charAt(i - 1) == '=') {\n                ++k;\n                --l;\n            }\n            if (s.charAt(i - 2) == '=') {\n                ++k;\n            }\n        }\n        final byte[] bc = new byte[3 * j - k];\n        int i2 = 0;\n        int j2 = 0;\n        for (int k2 = 0; k2 < l; ++k2) {\n            final int l2 = _$23183(s.charAt(i2++), bb);\n            final int j3 = _$23183(s.charAt(i2++), bb);\n            final int l3 = _$23183(s.charAt(i2++), bb);\n            final int j4 = _$23183(s.charAt(i2++), bb);\n            bc[j2++] = (byte)(l2 << 2 | j3 >> 4);\n            bc[j2++] = (byte)(j3 << 4 | l3 >> 2);\n            bc[j2++] = (byte)(l3 << 6 | j4);\n        }\n        if (k != 0) {\n            final int i3 = _$23183(s.charAt(i2++), bb);\n            final int k3 = _$23183(s.charAt(i2++), bb);\n            bc[j2++] = (byte)(i3 << 2 | k3 >> 4);\n            if (k == 1) {\n                final int i4 = _$23183(s.charAt(i2++), bb);\n                bc[j2++] = (byte)(k3 << 4 | i4 >> 2);\n            }\n        }\n        return bc;\n    }\n    \n    public static byte[] base64ToByteArray(final String s) {\n        return _$23180(s, false);\n    }\n    \n    private static int _$23183(final char c, final byte[] bb) {\n        final byte b = bb[c];\n        if (b < 0) {\n            throw new IllegalArgumentException(\"Illegal character \" + c);\n        }\n        return b;\n    }\n    \n    public static String byteArrayToAltBase64(final byte[] bb) {\n        return _$23170(bb, true);\n    }\n    \n    private static String _$23170(final byte[] bb, final boolean flag) {\n        final int i = bb.length;\n        final int j = i / 3;\n        final int k = i - 3 * j;\n        final int l = 4 * ((i + 2) / 3);\n        final StringBuffer stringbuffer = new StringBuffer(l);\n        final char[] ac = flag ? Base64._$23167 : Base64._$23166;\n        int i2 = 0;\n        for (int j2 = 0; j2 < j; ++j2) {\n            final int k2 = bb[i2++] & 0xFF;\n            final int i3 = bb[i2++] & 0xFF;\n            final int k3 = bb[i2++] & 0xFF;\n            stringbuffer.append(ac[k2 >> 2]);\n            stringbuffer.append(ac[(k2 << 4 & 0x3F) | i3 >> 4]);\n            stringbuffer.append(ac[(i3 << 2 & 0x3F) | k3 >> 6]);\n            stringbuffer.append(ac[k3 & 0x3F]);\n        }\n        if (k != 0) {\n            final int l2 = bb[i2++] & 0xFF;\n            stringbuffer.append(ac[l2 >> 2]);\n            if (k == 1) {\n                stringbuffer.append(ac[l2 << 4 & 0x3F]);\n                stringbuffer.append(\"==\");\n            }\n            else {\n                final int j3 = bb[i2++] & 0xFF;\n                stringbuffer.append(ac[(l2 << 4 & 0x3F) | j3 >> 4]);\n                stringbuffer.append(ac[j3 << 2 & 0x3F]);\n                stringbuffer.append('=');\n            }\n        }\n        return stringbuffer.toString();\n    }\n    \n    public static String byteArrayToBase64(final byte[] bb) {\n        return _$23170(bb, false);\n    }\n    \n    public static void main(final String[] args) {\n        String s = \"0123456789\";\n        byte[] b = s.getBytes();\n        s = byteArrayToBase64(b);\n        System.out.println(s);\n        b = base64ToByteArray(s);\n        System.out.println(new String(b));\n    }\n    \n    static {\n        _$23169 = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1, 62, 9, 10, 11, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 12, 13, 14, -1, 15, 63, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 18, 19, 21, 20, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 22, 23, 24, 25 };\n        _$23168 = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 };\n        _$23167 = new char[] { '!', '\\\"', '#', '$', '%', '&', '\\'', '(', ')', ',', '-', '.', ':', ';', '<', '>', '@', '[', ']', '^', '`', '_', '{', '|', '}', '~', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '?' };\n        _$23166 = new char[] { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };\n    }\n}\n",
        "token_number_zeroshot": 2304,
        "token_number_fewshot": 2702,
        "token_number_cot": 2415
    },
    
    {
        "project_name": "javaml",
        "class": "DefaultDataset",
        "source_code": "package net.sf.javaml.core;\n\nimport net.sf.javaml.distance.*;\nimport java.util.*;\n\npublic class DefaultDataset extends Vector<Instance> implements Dataset\n{\n    private int maxAttributes;\n    private static final long serialVersionUID = 8586030444860912681L;\n    private TreeSet<Object> classes;\n    \n    public DefaultDataset(final Collection<Instance> coll) {\n        this.maxAttributes = 0;\n        this.classes = new TreeSet<Object>();\n        this.addAll(coll);\n    }\n    \n    public DefaultDataset() {\n        this.maxAttributes = 0;\n        this.classes = new TreeSet<Object>();\n    }\n    \n    private void check(final Collection<? extends Instance> c) {\n        for (final Instance i : c) {\n            this.check(i);\n        }\n    }\n    \n    private void check(final Instance i) {\n        if (i.classValue() != null) {\n            this.classes.add(i.classValue());\n        }\n        if (i.noAttributes() > this.maxAttributes) {\n            this.maxAttributes = i.noAttributes();\n        }\n    }\n    \n    @Override\n    public synchronized boolean addAll(final Collection<? extends Instance> c) {\n        this.check(c);\n        return super.addAll(c);\n    }\n    \n    @Override\n    public synchronized boolean addAll(final int index, final Collection<? extends Instance> c) {\n        this.check(c);\n        return super.addAll(index, c);\n    }\n    \n    @Override\n    public void clear() {\n        this.classes.clear();\n        super.clear();\n    }\n    \n    @Override\n    public synchronized boolean add(final Instance e) {\n        this.check(e);\n        return super.add(e);\n    }\n    \n    @Override\n    public void add(final int index, final Instance e) {\n        this.check(e);\n        super.add(index, e);\n    }\n    \n    @Override\n    public synchronized void addElement(final Instance e) {\n        this.check(e);\n        super.addElement(e);\n    }\n    \n    @Override\n    public synchronized void insertElementAt(final Instance e, final int index) {\n        this.check(e);\n        super.insertElementAt(e, index);\n    }\n    \n    @Override\n    public synchronized void setElementAt(final Instance e, final int index) {\n        this.check(e);\n        super.setElementAt(e, index);\n    }\n    \n    @Override\n    public Instance instance(final int index) {\n        return super.get(index);\n    }\n    \n    @Override\n    public SortedSet<Object> classes() {\n        return this.classes;\n    }\n    \n    @Override\n    public Set<Instance> kNearest(final int k, final Instance inst, final DistanceMeasure dm) {\n        final Map<Instance, Double> closest = new HashMap<Instance, Double>();\n        double max = Double.POSITIVE_INFINITY;\n        for (final Instance tmp : this) {\n            final double d = dm.measure(inst, tmp);\n            if (dm.compare(d, max) && !inst.equals(tmp)) {\n                closest.put(tmp, d);\n                if (closest.size() <= k) {\n                    continue;\n                }\n                max = this.removeFarthest(closest);\n            }\n        }\n        return closest.keySet();\n    }\n    \n    private double removeFarthest(final Map<Instance, Double> vector) {\n        Instance tmp = null;\n        double max = 0.0;\n        for (final Instance inst : vector.keySet()) {\n            final double d = vector.get(inst);\n            if (d > max) {\n                max = d;\n                tmp = inst;\n            }\n        }\n        vector.remove(tmp);\n        return max;\n    }\n    \n    @Override\n    public Dataset[] folds(final int numFolds, final Random rg) {\n        final Dataset[] out = new Dataset[numFolds];\n        final List<Integer> indices = new Vector<Integer>();\n        for (int i = 0; i < this.size(); ++i) {\n            indices.add(i);\n        }\n        final int size = this.size() / numFolds + 1;\n        final int[][] array = new int[numFolds][size];\n        for (int j = 0; j < size; ++j) {\n            for (int k = 0; k < numFolds; ++k) {\n                if (indices.size() > 0) {\n                    array[k][j] = indices.remove(rg.nextInt(indices.size()));\n                }\n                else {\n                    array[k][j] = -1;\n                }\n            }\n        }\n        for (int j = 0; j < numFolds; ++j) {\n            int[] indi;\n            if (array[j][size - 1] == -1) {\n                indi = new int[size - 1];\n                System.arraycopy(array[j], 0, indi, 0, size - 1);\n            }\n            else {\n                indi = new int[size];\n                System.arraycopy(array[j], 0, indi, 0, size);\n            }\n            out[j] = new Fold(this, indi);\n        }\n        return out;\n    }\n    \n    @Override\n    public int noAttributes() {\n        if (this.size() == 0) {\n            return 0;\n        }\n        return this.get(0).noAttributes();\n    }\n    \n    @Override\n    public int classIndex(final Object clazz) {\n        if (clazz != null) {\n            return this.classes().headSet(clazz).size();\n        }\n        return -1;\n    }\n    \n    @Override\n    public Object classValue(final int index) {\n        int i = 0;\n        for (final Object o : this.classes) {\n            if (i == index) {\n                return o;\n            }\n            ++i;\n        }\n        return null;\n    }\n    \n    @Override\n    public Dataset copy() {\n        final DefaultDataset out = new DefaultDataset();\n        for (final Instance i : this) {\n            out.add(i.copy());\n        }\n        return out;\n    }\n}\n",
        "token_number_zeroshot": 1258,
        "token_number_fewshot": 1656,
        "token_number_cot": 1369
    },
    {
        "project_name": "javaml",
        "class": "SparseInstance",
        "source_code": "package net.sf.javaml.core;\n\nimport java.util.*;\n\npublic class SparseInstance extends AbstractInstance implements Instance\n{\n    private HashMap<Integer, Double> data;\n    private double defaultValue;\n    private int noAttributes;\n    private static final long serialVersionUID = -7642462956857985858L;\n    \n    public void setNoAttributes(final int noAttributes) {\n        this.noAttributes = noAttributes;\n    }\n    \n    public SparseInstance() {\n        this(-1);\n    }\n    \n    public SparseInstance(final int noAttributes) {\n        this(noAttributes, 0.0, null);\n    }\n    \n    public SparseInstance(final int noAttributes, final double defaultValue) {\n        this(noAttributes, defaultValue, null);\n    }\n    \n    public SparseInstance(final int noAttributes, final Object classValue) {\n        this(noAttributes, 0.0, classValue);\n    }\n    \n    public SparseInstance(final int noAttributes, final double defaultValue, final Object classValue) {\n        super(classValue);\n        this.data = new HashMap<Integer, Double>();\n        this.noAttributes = -1;\n        this.defaultValue = defaultValue;\n        this.noAttributes = noAttributes;\n    }\n    \n    public SparseInstance(final double[] datavector) {\n        this(datavector, 0.0, null);\n    }\n    \n    public SparseInstance(final double[] datavector, final double defaultValue) {\n        this(datavector, defaultValue, null);\n    }\n    \n    public SparseInstance(final double[] datavector, final Object classValue) {\n        this(datavector, 0.0, classValue);\n    }\n    \n    public SparseInstance(final double[] datavector, final double defaultValue, final Object classValue) {\n        super(classValue);\n        this.data = new HashMap<Integer, Double>();\n        this.noAttributes = -1;\n        this.defaultValue = defaultValue;\n        this.initiate(datavector);\n    }\n    \n    private void initiate(final double[] datavector) {\n        this.data.clear();\n        this.noAttributes = datavector.length;\n        for (int i = 0; i < datavector.length; ++i) {\n            if (datavector[i] != this.defaultValue) {\n                this.put(Integer.valueOf(i), Double.valueOf(datavector[i]));\n            }\n        }\n    }\n    \n    @Override\n    public double value(final int pos) {\n        return this.get(pos);\n    }\n    \n    @Override\n    public void clear() {\n        this.data.clear();\n    }\n    \n    @Override\n    public boolean containsKey(final Object key) {\n        return this.data.containsKey(key);\n    }\n    \n    @Override\n    public boolean containsValue(final Object value) {\n        return this.data.containsValue(value);\n    }\n    \n    @Override\n    public Set<Map.Entry<Integer, Double>> entrySet() {\n        return this.data.entrySet();\n    }\n    \n    @Override\n    public Double get(final Object key) {\n        if (this.data.containsKey(key)) {\n            return this.data.get(key);\n        }\n        return this.defaultValue;\n    }\n    \n    @Override\n    public boolean isEmpty() {\n        return this.data.isEmpty();\n    }\n    \n    @Override\n    public TreeSet<Integer> keySet() {\n        final TreeSet<Integer> set = new TreeSet<Integer>();\n        set.addAll(this.data.keySet());\n        return set;\n    }\n    \n    @Override\n    public Double put(final Integer key, final Double value) {\n        return this.data.put(key, value);\n    }\n    \n    @Override\n    public void putAll(final Map<? extends Integer, ? extends Double> m) {\n        this.data.putAll(m);\n    }\n    \n    @Override\n    public Double remove(final Object key) {\n        return this.data.remove(key);\n    }\n    \n    @Deprecated\n    @Override\n    public int size() {\n        return this.data.size();\n    }\n    \n    @Override\n    public Collection<Double> values() {\n        return this.data.values();\n    }\n    \n    @Override\n    public int noAttributes() {\n        if (this.noAttributes >= 0) {\n            return this.noAttributes;\n        }\n        if (this.data.keySet().size() == 0) {\n            return 0;\n        }\n        return Collections.max((Collection<? extends Integer>)this.data.keySet()) + 1;\n    }\n    \n    @Override\n    public void removeAttribute(final int remove) {\n        this.data.remove(remove);\n        final List<Integer> indices = new Vector<Integer>();\n        indices.addAll(this.data.keySet());\n        Collections.sort(indices);\n        for (int i = 0; i < indices.size(); ++i) {\n            final int index = indices.get(i);\n            if (index > remove) {\n                this.data.put(index - 1, this.data.get(index));\n                this.data.remove(index);\n            }\n        }\n        --this.noAttributes;\n    }\n    \n    @Override\n    public String toString() {\n        return \"{\" + this.data.toString() + \";\" + this.classValue() + \"}\";\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + ((this.data == null) ? 0 : this.data.hashCode());\n        final long temp = Double.doubleToLongBits(this.defaultValue);\n        result = 31 * result + (int)(temp ^ temp >>> 32);\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final SparseInstance other = (SparseInstance)obj;\n        if (this.data == null) {\n            if (other.data != null) {\n                return false;\n            }\n        }\n        else if (!this.data.equals(other.data)) {\n            return false;\n        }\n        return Double.doubleToLongBits(this.defaultValue) == Double.doubleToLongBits(other.defaultValue);\n    }\n    \n    @Override\n    public Instance copy() {\n        final SparseInstance out = new SparseInstance();\n        (out.data = new HashMap<Integer, Double>()).putAll(this.data);\n        out.defaultValue = this.defaultValue;\n        out.noAttributes = this.noAttributes;\n        out.setClassValue(this.classValue());\n        return out;\n    }\n    \n    @Override\n    public void removeAttributes(final Set<Integer> indices) {\n        final List<Integer> indix = new Vector<Integer>();\n        indix.addAll(indices);\n        Collections.sort(indix);\n        for (int i = indix.size() - 1; i >= 0; --i) {\n            this.removeAttribute(indix.get(i));\n        }\n    }\n}\n",
        "token_number_zeroshot": 1419,
        "token_number_fewshot": 1817,
        "token_number_cot": 1530
    },
    {
        "project_name": "javaml",
        "class": "ARFFHandler",
        "source_code": "package net.sf.javaml.tools.data;\n\nimport java.io.*;\nimport be.abeel.util.*;\nimport net.sf.javaml.core.*;\nimport java.util.*;\n\npublic class ARFFHandler\n{\n    public static Dataset loadARFF(final File file) throws FileNotFoundException {\n        return loadARFF(file, -1);\n    }\n    \n    public static Dataset loadARFF(final File file, final int classIndex) throws FileNotFoundException {\n        final LineIterator it = new LineIterator(file);\n        it.setSkipBlanks(true);\n        it.setCommentIdentifier(\"%\");\n        it.setSkipComments(true);\n        final Dataset out = new DefaultDataset();\n        boolean dataMode = false;\n        for (final String line : it) {\n            if (dataMode) {\n                final String[] arr = line.split(\",\");\n                double[] values;\n                if (classIndex == -1) {\n                    values = new double[arr.length];\n                }\n                else {\n                    values = new double[arr.length - 1];\n                }\n                String classValue = null;\n                for (int i = 0; i < arr.length; ++i) {\n                    if (i == classIndex) {\n                        classValue = arr[i];\n                    }\n                    else {\n                        double val;\n                        try {\n                            val = Double.parseDouble(arr[i]);\n                        }\n                        catch (NumberFormatException e) {\n                            val = Double.NaN;\n                        }\n                        if (i > classIndex) {\n                            values[i - 1] = val;\n                        }\n                        else {\n                            values[i] = val;\n                        }\n                    }\n                }\n                out.add((Instance)new DenseInstance(values, classValue));\n            }\n            if (line.equalsIgnoreCase(\"@data\")) {\n                dataMode = true;\n            }\n        }\n        return out;\n    }\n}\n",
        "token_number_zeroshot": 388,
        "token_number_fewshot": 786,
        "token_number_cot": 500
    },
    {
        "project_name": "javaml",
        "class": "Fold",
        "source_code": "package net.sf.javaml.core;\n\nimport net.sf.javaml.distance.*;\nimport java.util.*;\n\nclass Fold implements Dataset\n{\n    private int[] indices;\n    private Dataset parent;\n    \n    public Fold(final Dataset parent, final int[] indices) {\n        this.indices = indices;\n        this.parent = parent;\n    }\n    \n    @Override\n    public boolean add(final Instance i) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public SortedSet<Object> classes() {\n        return this.parent.classes();\n    }\n    \n    @Override\n    public Dataset[] folds(final int numFolds, final Random rg) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public Instance instance(final int index) {\n        return this.parent.instance(this.indices[index]);\n    }\n    \n    @Override\n    public Set<Instance> kNearest(final int k, final Instance inst, final DistanceMeasure dm) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public void add(final int index, final Instance element) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public boolean addAll(final Collection<? extends Instance> c) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public boolean addAll(final int index, final Collection<? extends Instance> c) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public boolean contains(final Object o) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public boolean containsAll(final Collection<?> c) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public Instance get(final int index) {\n        return this.instance(index);\n    }\n    \n    @Override\n    public int indexOf(final Object o) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public boolean isEmpty() {\n        return false;\n    }\n    \n    @Override\n    public Iterator<Instance> iterator() {\n        return new FoldIterator();\n    }\n    \n    @Override\n    public int lastIndexOf(final Object o) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public ListIterator<Instance> listIterator() {\n        return new FoldIterator();\n    }\n    \n    @Override\n    public ListIterator<Instance> listIterator(final int index) {\n        return new FoldIterator(index);\n    }\n    \n    @Override\n    public boolean remove(final Object o) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public Instance remove(final int index) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public boolean removeAll(final Collection<?> c) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public boolean retainAll(final Collection<?> c) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public Instance set(final int index, final Instance element) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public int size() {\n        return this.indices.length;\n    }\n    \n    @Override\n    public List<Instance> subList(final int fromIndex, final int toIndex) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public Object[] toArray() {\n        final Object[] out = new Object[this.indices.length];\n        for (int i = 0; i < this.size(); ++i) {\n            out[i] = this.instance(i);\n        }\n        return out;\n    }\n    \n    @Override\n    public <T> T[] toArray(final T[] a) {\n        final Vector<T> tmp = new Vector<T>();\n        for (final Instance i : this) {\n            tmp.add((T)i);\n        }\n        return tmp.toArray(a);\n    }\n    \n    @Override\n    public int noAttributes() {\n        return this.parent.noAttributes();\n    }\n    \n    @Override\n    public int classIndex(final Object clazz) {\n        return this.parent.classIndex(clazz);\n    }\n    \n    @Override\n    public Object classValue(final int index) {\n        return this.parent.classValue(index);\n    }\n    \n    @Override\n    public Dataset copy() {\n        final Dataset out = new DefaultDataset();\n        for (final Instance i : this) {\n            out.add(i.copy());\n        }\n        return out;\n    }\n    \n    class FoldIterator implements ListIterator<Instance>\n    {\n        private int currentIndex;\n        \n        public FoldIterator(final int index) {\n            this.currentIndex = 0;\n            this.currentIndex = index;\n        }\n        \n        public FoldIterator(final Fold fold) {\n            this(fold, 0);\n        }\n        \n        @Override\n        public boolean hasNext() {\n            return this.currentIndex < Fold.this.indices.length;\n        }\n        \n        @Override\n        public Instance next() {\n            ++this.currentIndex;\n            return Fold.this.instance(this.currentIndex - 1);\n        }\n        \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n        }\n        \n        @Override\n        public void add(final Instance arg0) {\n            throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n        }\n        \n        @Override\n        public boolean hasPrevious() {\n            return this.currentIndex > 0;\n        }\n        \n        @Override\n        public int nextIndex() {\n            return this.currentIndex;\n        }\n        \n        @Override\n        public Instance previous() {\n            --this.currentIndex;\n            return Fold.this.instance(this.currentIndex);\n        }\n        \n        @Override\n        public int previousIndex() {\n            return this.currentIndex;\n        }\n        \n        @Override\n        public void set(final Instance arg0) {\n            throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 1341,
        "token_number_fewshot": 1739,
        "token_number_cot": 1451
    },
    {
        "project_name": "javaml",
        "class": "DenseInstance",
        "source_code": "package net.sf.javaml.core;\n\nimport java.util.*;\n\npublic class DenseInstance extends AbstractInstance implements Instance\n{\n    private static final long serialVersionUID = 3284511291715269081L;\n    private double[] attributes;\n    \n    public DenseInstance(final double[] att) {\n        this(att, null);\n    }\n    \n    public DenseInstance(final double[] att, final Object classValue) {\n        super(classValue);\n        this.attributes = att.clone();\n    }\n    \n    private DenseInstance() {\n    }\n    \n    public DenseInstance(final int size) {\n        this(new double[size]);\n    }\n    \n    @Override\n    public double value(final int pos) {\n        return this.attributes[pos];\n    }\n    \n    @Override\n    public void clear() {\n        this.attributes = new double[this.attributes.length];\n    }\n    \n    @Override\n    public boolean containsKey(final Object key) {\n        if (key instanceof Integer) {\n            final int i = (int)key;\n            return i >= 0 && i < this.attributes.length;\n        }\n        return false;\n    }\n    \n    @Override\n    public boolean containsValue(final Object value) {\n        if (value instanceof Number) {\n            final double val = ((Number)value).doubleValue();\n            for (int i = 0; i < this.attributes.length; ++i) {\n                if (Math.abs(val - this.attributes[i]) < 1.0E-8) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    @Override\n    public Set<Map.Entry<Integer, Double>> entrySet() {\n        final HashMap<Integer, Double> map = new HashMap<Integer, Double>();\n        for (int i = 0; i < this.attributes.length; ++i) {\n            map.put(i, this.attributes[i]);\n        }\n        return map.entrySet();\n    }\n    \n    @Override\n    public Double get(final Object key) {\n        return this.attributes[(int)key];\n    }\n    \n    @Override\n    public boolean isEmpty() {\n        return false;\n    }\n    \n    @Override\n    public SortedSet<Integer> keySet() {\n        final TreeSet<Integer> keys = new TreeSet<Integer>();\n        for (int i = 0; i < this.attributes.length; ++i) {\n            keys.add(i);\n        }\n        return keys;\n    }\n    \n    @Override\n    public Double put(final Integer key, final Double value) {\n        final double val = this.attributes[key];\n        this.attributes[key] = value;\n        return val;\n    }\n    \n    @Override\n    public void putAll(final Map<? extends Integer, ? extends Double> m) {\n        for (final Integer key : m.keySet()) {\n            this.attributes[key] = (double)m.get(key);\n        }\n    }\n    \n    @Override\n    public Double remove(final Object key) {\n        throw new UnsupportedOperationException(\"Cannot unset values from a dense instance.\");\n    }\n    \n    @Deprecated\n    @Override\n    public int size() {\n        return this.attributes.length;\n    }\n    \n    @Override\n    public Collection<Double> values() {\n        final Collection<Double> vals = new ArrayList<Double>();\n        for (final double v : this.attributes) {\n            vals.add(v);\n        }\n        return vals;\n    }\n    \n    @Override\n    public int noAttributes() {\n        return this.attributes.length;\n    }\n    \n    @Override\n    public String toString() {\n        return \"{\" + Arrays.toString(this.attributes) + \";\" + this.classValue() + \"}\";\n    }\n    \n    @Override\n    public void removeAttribute(final int i) {\n        final double[] tmp = this.attributes.clone();\n        System.arraycopy(tmp, 0, this.attributes = new double[tmp.length - 1], 0, i);\n        System.arraycopy(tmp, i + 1, this.attributes, i, tmp.length - i - 1);\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + Arrays.hashCode(this.attributes);\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final DenseInstance other = (DenseInstance)obj;\n        return Arrays.equals(this.attributes, other.attributes);\n    }\n    \n    @Override\n    public Instance copy() {\n        final DenseInstance out = new DenseInstance();\n        out.attributes = this.attributes.clone();\n        out.setClassValue(this.classValue());\n        return out;\n    }\n    \n    @Override\n    public void removeAttributes(final Set<Integer> indices) {\n        final double[] tmp = this.attributes.clone();\n        this.attributes = new double[tmp.length - indices.size()];\n        int index = 0;\n        for (int i = 0; i < tmp.length; ++i) {\n            if (!indices.contains(i)) {\n                this.attributes[index++] = tmp[i];\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 1088,
        "token_number_fewshot": 1486,
        "token_number_cot": 1199
    },
    {
        "project_name": "javaml",
        "class": "Complex",
        "source_code": "package net.sf.javaml.core;\n\npublic class Complex\n{\n    public double im;\n    public double re;\n    public static final Complex I;\n    \n    public Complex(final double re, final double im) {\n        this.im = 0.0;\n        this.re = 0.0;\n        this.re = re;\n        this.im = im;\n    }\n    \n    public Complex() {\n        this(0.0, 0.0);\n    }\n    \n    @Override\n    public String toString() {\n        return this.re + \" + \" + this.im + \"i\";\n    }\n    \n    public double abs() {\n        return Math.sqrt(this.re * this.re + this.im * this.im);\n    }\n    \n    public void plus(final Complex b) {\n        this.re += b.re;\n        this.im += b.re;\n    }\n    \n    public void minus(final Complex b) {\n        this.re -= b.re;\n        this.im -= b.im;\n    }\n    \n    public void times(final Complex b) {\n        final double real = this.re * b.re - this.im * b.im;\n        final double imag = this.re * b.im + this.im * b.re;\n        this.re = real;\n        this.im = imag;\n    }\n    \n    public void times(final double alpha) {\n        this.re *= alpha;\n        this.im *= alpha;\n    }\n    \n    public void conjugate() {\n        this.im = -this.im;\n    }\n    \n    public static Complex plus(final Complex a, final Complex b) {\n        final double real = a.re + b.re;\n        final double imag = a.im + b.im;\n        return new Complex(real, imag);\n    }\n    \n    public static Complex multiply(final Complex a, final double d) {\n        return new Complex(a.re * d, a.im * d);\n    }\n    \n    public static Complex multiply(final Complex a, final Complex b) {\n        final double real = a.re * b.re - a.im * b.im;\n        final double imag = a.re * b.im + a.im * b.re;\n        return new Complex(real, imag);\n    }\n    \n    static {\n        I = new Complex(0.0, 1.0);\n    }\n}\n",
        "token_number_zeroshot": 489,
        "token_number_fewshot": 887,
        "token_number_cot": 599
    },
    {
        "project_name": "javaml",
        "class": "AbstractInstance",
        "source_code": "package net.sf.javaml.core;\n\nimport java.util.*;\n\npublic abstract class AbstractInstance implements Instance\n{\n    private static final long serialVersionUID = -1712202124913999825L;\n    static int nextID;\n    private final int ID;\n    private Object classValue;\n    \n    @Override\n    public int getID() {\n        return this.ID;\n    }\n    \n    @Override\n    public Iterator<Double> iterator() {\n        return new InstanceValueIterator();\n    }\n    \n    protected AbstractInstance() {\n        this(null);\n    }\n    \n    protected AbstractInstance(final Object classValue) {\n        this.ID = AbstractInstance.nextID;\n        ++AbstractInstance.nextID;\n        this.classValue = classValue;\n    }\n    \n    @Override\n    public Object classValue() {\n        return this.classValue;\n    }\n    \n    @Override\n    public void setClassValue(final Object classValue) {\n        this.classValue = classValue;\n    }\n    \n    @Override\n    public Instance minus(final Instance min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) - ((Map<K, Double>)min).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance minus(final double min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) - min);\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance divide(final double min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) / min);\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance multiply(final double value) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) * value);\n        }\n        return out;\n    }\n    \n    @Override\n    public int hashCode() {\n        return this.ID;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final AbstractInstance other = (AbstractInstance)obj;\n        return this.ID == other.ID;\n    }\n    \n    @Override\n    public Instance multiply(final Instance value) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) * ((Map<K, Double>)value).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance divide(final Instance min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) / ((Map<K, Double>)min).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance add(final double min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) + min);\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance add(final Instance min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) + ((Map<K, Double>)min).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance sqrt() {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, Math.sqrt(((Map<K, Double>)this).get(i)));\n        }\n        return out;\n    }\n    \n    static {\n        AbstractInstance.nextID = 0;\n    }\n    \n    class InstanceValueIterator implements Iterator<Double>\n    {\n        private int index;\n        \n        InstanceValueIterator() {\n            this.index = 0;\n        }\n        \n        @Override\n        public boolean hasNext() {\n            return this.index < AbstractInstance.this.noAttributes() - 1;\n        }\n        \n        @Override\n        public Double next() {\n            ++this.index;\n            return AbstractInstance.this.value(this.index - 1);\n        }\n        \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove from instance using the iterator.\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 1156,
        "token_number_fewshot": 1554,
        "token_number_cot": 1267
    },
    {
        "project_name": "40_glengineer",
        "class": "GroupAgent",
        "source_code": "package glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport java.util.*;\nimport glengineer.*;\nimport javax.swing.*;\nimport glengineer.agents.setters.*;\n\npublic abstract class GroupAgent extends Agent\n{\n    protected LinkedList<Agent> childrenAgents;\n    \n    public GroupAgent() {\n        this.childrenAgents = new LinkedList<Agent>();\n        this.settings = new Settings();\n    }\n    \n    @Override\n    public String getFirstName() {\n        if (this.childrenAgents.isEmpty()) {\n            return null;\n        }\n        final Iterator<Agent> i = this.childrenAgents.iterator();\n        while (i.hasNext()) {\n            final String result = i.next().getFirstName();\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public String getLastName() {\n        if (this.childrenAgents.isEmpty()) {\n            return null;\n        }\n        final Iterator<Agent> i = this.childrenAgents.descendingIterator();\n        while (i.hasNext()) {\n            final String result = i.next().getLastName();\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public boolean isComponent(final String componentName) {\n        return false;\n    }\n    \n    @Override\n    public boolean isGroup(final String firstName, final String lastName) {\n        return this.getFirstName().equals(firstName) && this.getLastName().equals(lastName);\n    }\n    \n    @Override\n    public boolean isGap() {\n        return false;\n    }\n    \n    @Override\n    public boolean equals(final Agent agent) {\n        return agent.isGroup(this.getFirstName(), this.getLastName());\n    }\n    \n    public void addAgent(final Agent agent) {\n        if (agent == null) {\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\n        }\n        this.childrenAgents.add(agent);\n    }\n    \n    public List<Agent> getChildren() {\n        return Collections.unmodifiableList((List<? extends Agent>)this.childrenAgents);\n    }\n    \n    public int getNumberOfChildren() {\n        return this.childrenAgents.size();\n    }\n    \n    public ComponentAgent getComponent(final String name) {\n        for (final Agent child : this.childrenAgents) {\n            if (child.isComponent(name)) {\n                return (ComponentAgent)child;\n            }\n        }\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\n    }\n    \n    public GroupAgent getGroup(final String firstName, final String lastName) {\n        for (final Agent child : this.childrenAgents) {\n            if (child.isGroup(firstName, lastName)) {\n                return (GroupAgent)child;\n            }\n        }\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\n    }\n    \n    @Override\n    public ComponentAgent findDependingComponentByName(final String componentName) {\n        ComponentAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingComponentByName(componentName);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public GroupAgent findDependingGroupByNames(final String firstName, final String lastName) {\n        if (this.isGroup(firstName, lastName)) {\n            return this;\n        }\n        GroupAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingGroupByNames(firstName, lastName);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public ParallelGroupAgent findDependingParallelGroupByNames(final String firstName, final String lastName) {\n        if (this.isGroup(firstName, lastName) && this instanceof ParallelGroupAgent) {\n            return (ParallelGroupAgent)this;\n        }\n        GroupAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\n            if (result != null) {\n                return (ParallelGroupAgent)result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public SequentialGroupAgent findDependingSequentialGroupByNames(final String firstName, final String lastName) {\n        if (this.isGroup(firstName, lastName) && this instanceof SequentialGroupAgent) {\n            return (SequentialGroupAgent)this;\n        }\n        GroupAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\n            if (result != null) {\n                return (SequentialGroupAgent)result;\n            }\n        }\n        return null;\n    }\n    \n    public void removeGapsFromParallelGroups() {\n        this.passTheCallToSubgroups();\n        this.removeGapsFromParallelSubgroupsWithOtherContent();\n        this.replaceParallelSubgroupsWithGapsByTheirSingleGaps();\n        this.replaceContinuousSequencesOfGapsBySingleGaps();\n        this.replaceGroupsWithSingleElementsByThatElements();\n    }\n    \n    private void passTheCallToSubgroups() {\n        for (final Agent child : this.childrenAgents) {\n            if (child instanceof GroupAgent) {\n                ((GroupAgent)child).removeGapsFromParallelGroups();\n            }\n        }\n    }\n    \n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\n        for (final Agent child : this.childrenAgents) {\n            if (child instanceof ParallelGroupAgent) {\n                final ParallelGroupAgent parallel = (ParallelGroupAgent)child;\n                if (parallel.containsGapsOnly()) {\n                    continue;\n                }\n                parallel.removeAllGaps();\n            }\n        }\n    }\n    \n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (child instanceof ParallelGroupAgent) {\n                final ParallelGroupAgent parallel = (ParallelGroupAgent)child;\n                final Agent gap = parallel.getGapsType();\n                if (gap == null) {\n                    continue;\n                }\n                li.set(gap);\n            }\n        }\n    }\n    \n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (!child.isGap()) {\n                continue;\n            }\n            final Agent currentGap = child;\n            while (li.hasNext()) {\n                final Agent nextGap = li.next();\n                if (!nextGap.isGap()) {\n                    break;\n                }\n                if (!nextGap.equals(currentGap)) {\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types was found in a group.\");\n                }\n                li.remove();\n            }\n        }\n    }\n    \n    private void replaceGroupsWithSingleElementsByThatElements() {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (child instanceof GroupAgent) {\n                final GroupAgent nextSubgroup = (GroupAgent)child;\n                if (nextSubgroup.getNumberOfChildren() != 1) {\n                    continue;\n                }\n                li.set(nextSubgroup.getChildren().get(0));\n            }\n        }\n    }\n    \n    public void replaceTemporaryGapsByRealGaps(final GroupLayoutEngineer.TemporaryGapsToGaps map) {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (child instanceof GroupAgent) {\n                ((GroupAgent)child).replaceTemporaryGapsByRealGaps(map);\n            }\n            if (child instanceof TemporaryGapAgent) {\n                li.set(map.gap((TemporaryGapAgent)child));\n            }\n        }\n    }\n    \n    @Override\n    public void addContentToGroup(final GroupLayout.Group parentGroup, final GroupCreatorAndElementAdder creatorAndAdder) {\n        creatorAndAdder.addGroupToGroup(this.groupContent(creatorAndAdder), this.settings, parentGroup);\n    }\n    \n    public abstract GroupLayout.Group groupContent(final GroupCreatorAndElementAdder p0);\n    \n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\n    \n    public void addGapBefore(final GapAgent gap, final Agent element) {\n        if (this.childrenAgents.isEmpty()) {\n            this.childrenAgents.add(gap);\n            return;\n        }\n        final ListIterator<Agent> iter = this.childrenAgents.listIterator();\n        while (iter.hasNext()) {\n            if (iter.next().equals(element)) {\n                iter.previous();\n                iter.add(gap);\n                return;\n            }\n        }\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + this.toString() + \" not found\");\n    }\n    \n    public void addGapAfter(final GapAgent gap, final Agent element) {\n        if (this.childrenAgents.isEmpty()) {\n            this.childrenAgents.add(gap);\n            return;\n        }\n        final ListIterator<Agent> iter = this.childrenAgents.listIterator();\n        while (iter.hasNext()) {\n            if (iter.next().equals(element)) {\n                iter.add(gap);\n                return;\n            }\n        }\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + this.toString() + \" not found\");\n    }\n    \n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement\n    {\n        protected GroupAgent parentGroupAgent;\n        protected Agent elementAgent;\n        \n        public FunctionsOnGroupAndElementImplementation(final GroupAgent parent, final Agent element) {\n            this.parentGroupAgent = parent;\n            this.elementAgent = element;\n        }\n        \n        @Override\n        public void addPrecedingGap(final int size) {\n            this.parentGroupAgent.addGapBefore(new GapAgent(size), this.elementAgent);\n        }\n        \n        @Override\n        public void addPrecedingGap(final int min, final int pref, final int max) {\n            this.parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), this.elementAgent);\n        }\n        \n        @Override\n        public void addFollowingGap(final int size) {\n            this.parentGroupAgent.addGapAfter(new GapAgent(size), this.elementAgent);\n        }\n        \n        @Override\n        public void addFollowingGap(final int min, final int pref, final int max) {\n            this.parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), this.elementAgent);\n        }\n    }\n}\n",
        "token_number_zeroshot": 2225,
        "token_number_fewshot": 2623,
        "token_number_cot": 2336
    },
    {
        "project_name": "40_glengineer",
        "class": "Block",
        "source_code": "package glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\npublic abstract class Block extends CharTable\n{\n    protected Scheme scheme;\n    \n    public Block(final Scheme scheme, final int x1, final int y1, final int x2, final int y2) {\n        if (x1 < 0 || y1 < 0 || x1 > x2 || y1 > y2 || x2 > scheme.x2 || y2 > scheme.y2) {\n            throw new IllegalArgumentException(\"improper block definition: \" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \".\");\n        }\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.scheme = scheme;\n    }\n    \n    public Block(final Scheme scheme, final CharPosition p1, final CharPosition p2) {\n        this(scheme, p1.x, p1.y, p2.x, p2.y);\n    }\n    \n    public Block(final Scheme scheme) {\n        this.x1 = 0;\n        this.y1 = 0;\n        this.x2 = scheme.x2;\n        this.y2 = scheme.y2;\n        this.scheme = scheme;\n    }\n    \n    public abstract Block subblock(final int p0, final int p1, final int p2, final int p3);\n    \n    @Override\n    public char charAt(final int x, final int y) {\n        try {\n            return this.scheme.lines[y].charAt(x);\n        }\n        catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position \" + new CharPosition(x, y) + \" out of block.\\n\" + this);\n        }\n    }\n    \n    @Override\n    public String textAt(final int x1, final int x2, final int y) {\n        try {\n            return this.scheme.lines[y].substring(x1, x2);\n        }\n        catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n    \n    public boolean containsOnlyOneWord() {\n        if (this.isTrivial()) {\n            throw new IllegalArgumentException(\"cannot search in a trivial block\");\n        }\n        final HWordPosition firstWord = this.firstWord_Horizontally();\n        if (firstWord.y == this.y2) {\n            throw new IllegalArgumentException(\"cannot verify unicity of an word in an empty block\");\n        }\n        final WordPosition lastWord = this.lastWord_Horizontally();\n        return firstWord.equals(lastWord);\n    }\n    \n    public abstract List<Block> extractSequentialSubblocks();\n    \n    public abstract List<Block> extractParallelSubblocks();\n    \n    @Override\n    public String toString() {\n        String result = \"Block(\" + this.x1 + \",\" + this.y1 + \", \" + this.x2 + \",\" + this.y2 + \"):\\n\";\n        final int frameWidth = this.x2 - this.x1 + 4;\n        final char[] line = new char[frameWidth];\n        Arrays.fill(line, '#');\n        final String lineString = \" \" + new String(line);\n        result = result.concat(lineString + \"\\n\");\n        for (int y = this.y1; y < this.y2; ++y) {\n            result = result.concat(\" # \" + this.scheme.textAt(this.x1, this.x2, y) + \" #\\n\");\n        }\n        result = result.concat(lineString);\n        return result;\n    }\n    \n    public String getUpperLine() {\n        return this.textAt(this.x1, this.x2, this.y1);\n    }\n}\n",
        "token_number_zeroshot": 795,
        "token_number_fewshot": 1193,
        "token_number_cot": 905
    },
    {
        "project_name": "39_diffi",
        "class": "StringIncrementor",
        "source_code": "package de.beiri22.stringincrementor;\n\nimport de.beiri22.stringincrementor.helper.*;\nimport de.beiri22.stringincrementor.relativestring.*;\nimport java.io.*;\n\npublic class StringIncrementor\n{\n    public static RelativeString diff(final String a, final String b) {\n        return diff(a, b, false);\n    }\n    \n    public static RelativeString diff(final String a, final String b, final boolean verbose) {\n        final RelativeString result = new RelativeString();\n        final ExtBoolArray vergeben = new ExtBoolArray(b.length());\n        System.out.println(\"Creating index...\");\n        final IndexedString ai = new IndexedString(a);\n        System.out.println(\"Searching links...\");\n        final char[] target = new char[13];\n        for (int posB = 0; posB < b.length() - 12; ++posB) {\n            int l = 13;\n            b.getChars(posB, posB + 13, target, 0);\n            int posA = ai.indexOf(target);\n            if (posA == -1) {\n                if (verbose && posB % (b.length() / 1000) == 0) {\n                    System.out.println(\"@ \" + Math.round(posB / b.length() * 1000.0) / 10.0 + \"%\");\n                }\n            }\n            else {\n                int posALast = posA;\n                while (posA != -1 && posB + l < b.length() && posA + l < a.length()) {\n                    ++l;\n                    if (a.charAt(posA + l - 1) != b.charAt(posB + l - 1)) {\n                        posALast = posA;\n                        final char[] target2 = new char[l];\n                        b.getChars(posB, posB + l, target2, 0);\n                        posA = ai.indexOf(target2);\n                    }\n                }\n                if (posA == -1) {\n                    --l;\n                    posA = posALast;\n                }\n                vergeben.setTrue(posB, posB + l - 1);\n                final StringLink sl = new StringLink(posA, posB, l);\n                if (verbose) {\n                    System.out.println(sl + \" @ \" + Math.round(posB / b.length() * 1000.0) / 10.0 + \"%\");\n                }\n                result.addLink(sl);\n                posB += l - 1;\n            }\n        }\n        final StringBuilder rest = new StringBuilder();\n        synchronized (rest) {\n            for (int i = 0; i < b.length(); ++i) {\n                if (vergeben.isFalse(i, i)) {\n                    rest.append(b.charAt(i));\n                }\n            }\n        }\n        result.setAbsolute(rest.toString());\n        return result;\n    }\n    \n    public static String patch(final String a, final RelativeString r) {\n        return patch(a, r, false);\n    }\n    \n    public static String patch(final String a, final RelativeString r, final boolean verbose) {\n        final StringBuilder result = new StringBuilder(r.getLength());\n        int posAbs = 0;\n        for (int i = 0; i < r.linksCount(); ++i) {\n            final StringLink si = r.getLink(i);\n            if (result.length() != si.getPosNew()) {\n                final int diff = si.getPosNew() - result.length();\n                if (verbose) {\n                    System.out.println(\"Adding \" + diff + \" absolute Bytes from pos#\" + posAbs);\n                }\n                result.append(r.getAbsolute().substring(posAbs, posAbs + diff));\n                posAbs += diff;\n            }\n            if (verbose) {\n                System.out.println(\"Adding Link: \" + si);\n            }\n            result.append(a.substring(si.getPosOrig(), si.getPosOrig() + si.getLen()));\n        }\n        result.append(r.getAbsolute().substring(posAbs));\n        return result.toString();\n    }\n}\n",
        "token_number_zeroshot": 850,
        "token_number_fewshot": 1248,
        "token_number_cot": 962
    },
    {
        "project_name": "39_diffi",
        "class": "IndexedString",
        "source_code": "package de.beiri22.stringincrementor.helper;\n\npublic final class IndexedString\n{\n    private char[] values;\n    private int[][] index;\n    \n    private int count(final char c) {\n        int result = 0;\n        for (int i = 0; i < this.values.length; ++i) {\n            if (this.values[i] == c) {\n                ++result;\n            }\n        }\n        return result;\n    }\n    \n    public IndexedString(final String s) {\n        this.values = new char[s.length()];\n        s.getChars(0, s.length(), this.values, 0);\n        this.index = new int[256][];\n        for (char c = '\\0'; c < '\\u0100'; ++c) {\n            this.index[c] = new int[this.count(c)];\n            int idx = 0;\n            for (int i = 0; i < this.values.length; ++i) {\n                if (this.values[i] == c) {\n                    this.index[c][idx++] = i;\n                }\n            }\n        }\n    }\n    \n    public int indexOf(final char[] target) {\n        final char first = target[0];\n        final int tl = target.length;\n        final int max = this.values.length - tl;\n        for (final int i : this.index[first]) {\n            if (i <= max) {\n                int j = i + 1;\n                final int end = i + tl;\n                for (int k = 1; j < end && this.values[j] == target[k]; ++j, ++k) {}\n                if (j == end) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}\n",
        "token_number_zeroshot": 385,
        "token_number_fewshot": 783,
        "token_number_cot": 496
    },
    {
        "project_name": "68_biblestudy",
        "class": "Queue",
        "source_code": "package bible.util;\n\nimport java.util.*;\n\npublic class Queue\n{\n    public static final int NO_MAXIMUM = -1;\n    private int numItems;\n    private int maxNumItems;\n    private int maxCapacity;\n    private Node first;\n    private Node last;\n    \n    public Queue() {\n        this(-1);\n    }\n    \n    public Queue(final int capacity) {\n        this.first = null;\n        this.last = null;\n        this.numItems = 0;\n        this.maxNumItems = 0;\n        this.maxCapacity = capacity;\n    }\n    \n    public boolean isEmpty() {\n        return this.first == null;\n    }\n    \n    public void enqueue(final Object someObject) {\n        if (someObject != null) {\n            final Node newNode = new Node(someObject);\n            synchronized (this) {\n                if (this.isEmpty()) {\n                    this.first = newNode;\n                    this.last = newNode;\n                }\n                else {\n                    this.last.next = newNode;\n                    this.last = newNode;\n                }\n                ++this.numItems;\n                if (this.numItems > this.maxNumItems) {\n                    this.maxNumItems = this.numItems;\n                }\n            }\n        }\n    }\n    \n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (this.isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        }\n        else if (this.first == this.last) {\n            obj = this.first.value;\n            this.first = null;\n            this.last = null;\n        }\n        else {\n            obj = this.first.value;\n            this.first = this.first.next;\n        }\n        --this.numItems;\n        return obj;\n    }\n    \n    public synchronized int remove(final Object object) {\n        final int originalNumItems = this.numItems;\n        while (this.first != null && this.first.value.equals(object)) {\n            this.first = this.first.next;\n            --this.numItems;\n        }\n        if (this.first == null) {\n            this.last = null;\n        }\n        else {\n            Node current = this.first;\n            while (current.next != null) {\n                if (current.next.value.equals(object)) {\n                    current.next = current.next.next;\n                    --this.numItems;\n                    if (current.next != null) {\n                        continue;\n                    }\n                    this.last = current;\n                }\n                else {\n                    current = current.next;\n                }\n            }\n        }\n        return originalNumItems - this.numItems;\n    }\n    \n    public synchronized void refreshElement(final Object object) {\n        this.remove(object);\n        this.enqueue(object);\n    }\n    \n    public int getNumberItems() {\n        return this.numItems;\n    }\n    \n    public int getPeakNumberItems() {\n        return this.maxNumItems;\n    }\n    \n    public Vector getObjects() {\n        final Vector tempVector = new Vector(this.numItems, 10);\n        for (Node i = this.first; i != null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        return tempVector;\n    }\n    \n    public boolean maxCapacityExceeded() {\n        return this.numItems > this.maxCapacity - 1 && this.maxCapacity != -1;\n    }\n    \n    @Override\n    public String toString() {\n        return this.getClass().getName() + \":[numItems=\" + this.numItems + \", maxNumItems=\" + this.maxNumItems + \", maxCapacity=\" + this.maxCapacity + \", getObjects()=\" + this.getObjects() + \"\\r\\n]\";\n    }\n    \n    class Node\n    {\n        Node next;\n        Object value;\n        \n        public Node(final Object obj) {\n            this.value = obj;\n        }\n    }\n}\n",
        "token_number_zeroshot": 785,
        "token_number_fewshot": 1183,
        "token_number_cot": 895
    },
    {
        "project_name": "68_biblestudy",
        "class": "Verse",
        "source_code": "package bible.obj;\n\nimport java.util.*;\nimport java.sql.*;\nimport bible.util.*;\n\npublic class Verse implements Identifible\n{\n    private int id;\n    private String text;\n    private TranslationReference transRef;\n    private static HashMap translations;\n    private static WeakHashMap verseCache;\n    private static final String COLUMNS = \"Verse_ID, Text, Translation_ID, Book_ID, Chapter, Verse_No\";\n    \n    public static Verse New(final int id) {\n        Verse verse = Verse.verseCache.get(new Integer(id));\n        if (verse == null) {\n            verse = new Verse(id);\n        }\n        return verse;\n    }\n    \n    @Override\n    public int getId() {\n        return this.id;\n    }\n    \n    public String getText() {\n        return this.text;\n    }\n    \n    @Override\n    public String getValue() {\n        return this.getText();\n    }\n    \n    public TranslationReference getTranslationReference() {\n        return this.transRef;\n    }\n    \n    public Reference getReference() {\n        return this.transRef.getReference();\n    }\n    \n    @Override\n    public String toString() {\n        return this.getClass().getName() + \":[\" + this.id + \" \" + this.transRef + \" \" + this.text + \"]\";\n    }\n    \n    public static int GetId(final Translation translation, final Book book, final int chapterId, final int verseId) {\n        return GetId(translation.getId(), book.getId(), chapterId, verseId);\n    }\n    \n    public static ArrayList Get(final Translation[] translations, final int bookId, final int chapterId, final int verseId) {\n        final ArrayList verses = new ArrayList(translations.length);\n        for (int index = 0; index < translations.length; ++index) {\n            verses.add(New(GetId(translations[index].getId(), bookId, chapterId, verseId)));\n        }\n        return verses;\n    }\n    \n    public static ArrayList Get(final Translation[] translations, final Reference begin, final Reference end) {\n        System.out.println(\"Verse.Get translations=\" + Util.ToString(translations));\n        final ArrayList verses = new ArrayList();\n        DbResult result = null;\n        final String query = \"select Verse_ID from Verse where \" + ((translations != null && translations.length > 0) ? (\"Translation_ID in (\" + Util.ToString(Util.ToIntArray(translations)) + \") and \") : \"\") + \"Book_ID >= \" + begin.getBookId() + \" and Book_ID <= \" + end.getBookId() + \" and Chapter >= \" + begin.getChapterNo() + \" and Chapter <= \" + end.getChapterNo() + \" and Verse_No >= \" + begin.getVerseNo() + \" and Verse_No <= \" + end.getVerseNo();\n        System.out.println(\"Verse.Get query=\" + query);\n        try {\n            result = Database.Query(query);\n            while (result.next()) {\n                verses.add(New(result.getInt(\"Verse_ID\")));\n            }\n        }\n        catch (SQLException e) {\n            e.printStackTrace();\n        }\n        finally {\n            DbResult.Close(result);\n        }\n        return verses;\n    }\n    \n    public static int GetId(int translationId, final int bookId, final int chapterId, final int verseId) {\n        translationId = Translation.Normalize(translationId);\n        HashMap translation = Verse.translations.get(new Integer(translationId));\n        if (translation == null) {\n            translation = new HashMap(11);\n            Verse.translations.put(new Integer(translationId), translation);\n        }\n        HashMap book = translation.get(new Integer(bookId));\n        if (book == null) {\n            book = new HashMap(97);\n            translation.put(new Integer(bookId), book);\n        }\n        HashMap chapter = book.get(new Integer(chapterId));\n        if (chapter == null) {\n            chapter = new HashMap(47);\n            book.put(new Integer(chapterId), chapter);\n        }\n        final Integer id = chapter.get(new Integer(verseId));\n        int intId;\n        if (id == null) {\n            intId = ReadId(translationId, bookId, chapterId, verseId);\n            if (intId > 0) {\n                chapter.put(new Integer(verseId), new Integer(intId));\n            }\n        }\n        else {\n            intId = id;\n        }\n        System.out.println(\"Verse.GetId(\" + translationId + \", \" + bookId + \", \" + chapterId + \", \" + verseId + \")=\" + intId);\n        return intId;\n    }\n    \n    private Verse(final int id) {\n        DbResult result = null;\n        final String query = \"select Verse_ID, Text, Translation_ID, Book_ID, Chapter, Verse_No from Verse where Verse_ID = \" + id;\n        try {\n            result = Database.Query(query);\n            if (result.next()) {\n                this.complete(result);\n            }\n        }\n        catch (SQLException e) {\n            e.printStackTrace();\n        }\n        finally {\n            DbResult.Close(result);\n        }\n    }\n    \n    private Verse(final DbResult result) throws SQLException {\n        this.complete(result);\n    }\n    \n    private void complete(final DbResult result) throws SQLException {\n        this.id = result.getInt(\"Verse_ID\");\n        this.text = result.getString(\"Text\");\n        this.transRef = new TranslationReference(Translation.Get(result.getInt(\"Translation_ID\")), new Reference(result.getInt(\"Book_ID\"), result.getInt(\"Chapter\"), result.getInt(\"Verse_No\")));\n        Verse.verseCache.put(new Integer(this.id), this);\n    }\n    \n    private static int ReadId(final int translationId, final int bookId, final int chapterId, final int verseId) {\n        int id = -1;\n        DbResult result = null;\n        final String query = \"select Verse_ID, Text, Translation_ID, Book_ID, Chapter, Verse_No from Verse where Translation_ID = \" + translationId + \" and Book_ID = \" + bookId + \" and Chapter = \" + chapterId + \" and Verse_No = \" + verseId;\n        try {\n            result = Database.Query(query);\n            if (result.next()) {\n                id = new Verse(result).getId();\n            }\n        }\n        catch (SQLException e) {\n            e.printStackTrace();\n        }\n        finally {\n            DbResult.Close(result);\n        }\n        return id;\n    }\n    \n    static {\n        Verse.translations = new HashMap();\n        Verse.verseCache = new WeakHashMap();\n    }\n}\n",
        "token_number_zeroshot": 1341,
        "token_number_fewshot": 1739,
        "token_number_cot": 1451
    },
    {
        "project_name": "javex",
        "class": "Expression",
        "source_code": "package org.javex;\n\nimport org.javex.utils.*;\nimport org.javex.functions.logical.*;\nimport org.javex.functions.math.*;\nimport org.javex.functions.date.*;\nimport org.javex.functions.string.*;\nimport java.util.*;\n\npublic abstract class Expression\n{\n    protected String expression;\n    protected ExpressionStack stack;\n    protected List externalFunctions;\n    protected static Map reservedFunctions;\n    boolean prepared;\n    \n    public List getExternalFunctions() {\n        return this.externalFunctions;\n    }\n    \n    public Expression(final String s) {\n        this.prepared = false;\n        this.stack = new ExpressionStack();\n        this.expression = s;\n    }\n    \n    protected void doEvaluationStack() {\n        final Stack<String> operands = new Stack<String>();\n        final ExpressionStack values = new ExpressionStack();\n        int input = 0;\n        final int size = this.stack.size();\n        int parentesis = 0;\n        while (input < size) {\n            final String expression = this.stack.get(input);\n            if (JavexUtils.isReservedChar(expression) || this.isFunction(expression)) {\n                if (expression.equals(\"(\")) {\n                    ++parentesis;\n                    operands.push(expression);\n                }\n                else if (expression.equals(\")\")) {\n                    boolean b = true;\n                    while (!operands.isEmpty()) {\n                        if (!b) {\n                            break;\n                        }\n                        final String op = operands.peek();\n                        if (!op.equals(\"(\")) {\n                            values.push(operands.pop());\n                        }\n                        else {\n                            operands.pop();\n                            b = false;\n                            --parentesis;\n                        }\n                    }\n                }\n                else if (expression.equals(\"+\") || expression.equals(\"-\")) {\n                    boolean b = true;\n                    while (!operands.isEmpty() && b) {\n                        final String op = operands.peek();\n                        if (op.equals(\"+\") || op.equals(\"-\") || op.equals(\"(\")) {\n                            b = false;\n                        }\n                        if (!op.equals(\"(\")) {\n                            values.push(operands.pop());\n                        }\n                    }\n                    operands.push(expression);\n                }\n                else if ((expression.equalsIgnoreCase(\"and\") || expression.equalsIgnoreCase(\"or\")) && parentesis == 0) {\n                    boolean b = true;\n                    while (!operands.isEmpty() && b) {\n                        final String op = operands.peek();\n                        if (op.equalsIgnoreCase(\"and\") || op.equalsIgnoreCase(\"or\")) {\n                            b = false;\n                        }\n                        values.push(operands.pop());\n                    }\n                    operands.push(expression);\n                }\n                else {\n                    boolean b = true;\n                    if (this.isLogicalFunction(expression)) {\n                        while (!operands.isEmpty() && b) {\n                            final String op = operands.peek();\n                            if (!this.isLogicalFunction(op) && !op.equals(\"(\")) {\n                                values.push(operands.pop());\n                            }\n                            else {\n                                b = false;\n                            }\n                        }\n                    }\n                    operands.push(expression);\n                }\n            }\n            else {\n                values.push(expression);\n            }\n            ++input;\n        }\n        while (!operands.isEmpty()) {\n            values.push(operands.pop());\n        }\n        this.stack = values;\n    }\n    \n    private static void putFunction(final FunctionExpression f, final Map map) {\n        map.put(f, f);\n    }\n    \n    public static FunctionExpression getReservedFunctions(final String simbol) {\n        if (Expression.reservedFunctions == null) {\n            Expression.reservedFunctions = new TreeMap();\n            putFunction(new AndFunction(), Expression.reservedFunctions);\n            putFunction(new BetweenFunction(), Expression.reservedFunctions);\n            putFunction(new ContainsFunction(), Expression.reservedFunctions);\n            putFunction(new EndsWithFunction(), Expression.reservedFunctions);\n            putFunction(new EqualsFunction(), Expression.reservedFunctions);\n            putFunction(new GreaterEqThanFunction(), Expression.reservedFunctions);\n            putFunction(new GreaterThanFunction(), Expression.reservedFunctions);\n            putFunction(new IsEmptyFunction(), Expression.reservedFunctions);\n            putFunction(new IsFunction(), Expression.reservedFunctions);\n            putFunction(new IsNullFunction(), Expression.reservedFunctions);\n            putFunction(new LessEqThanFunction(), Expression.reservedFunctions);\n            putFunction(new LessThanFunction(), Expression.reservedFunctions);\n            putFunction(new NotEqualsFunction(), Expression.reservedFunctions);\n            putFunction(new NotFunction(), Expression.reservedFunctions);\n            putFunction(new NotCharFunction(), Expression.reservedFunctions);\n            putFunction(new OrFunction(), Expression.reservedFunctions);\n            putFunction(new StartsWithFunction(), Expression.reservedFunctions);\n            putFunction(new MatchesFunction(), Expression.reservedFunctions);\n            putFunction(new InListFunction(), Expression.reservedFunctions);\n            putFunction(new AbsFunction(), Expression.reservedFunctions);\n            putFunction(new DivideFunction(), Expression.reservedFunctions);\n            putFunction(new MultiplyFunction(), Expression.reservedFunctions);\n            putFunction(new PlusFunction(), Expression.reservedFunctions);\n            putFunction(new SqrtFunction(), Expression.reservedFunctions);\n            putFunction(new SubstractFunction(), Expression.reservedFunctions);\n            putFunction(new PowerFunction(), Expression.reservedFunctions);\n            putFunction(new PowerCharFunction(), Expression.reservedFunctions);\n            putFunction(new DateAddFunction(), Expression.reservedFunctions);\n            putFunction(new DateDiffFunction(), Expression.reservedFunctions);\n            putFunction(new LengthFunction(), Expression.reservedFunctions);\n            putFunction(new SubStringFunction(), Expression.reservedFunctions);\n            putFunction(new ToLowerFunction(), Expression.reservedFunctions);\n            putFunction(new ToUpperFunction(), Expression.reservedFunctions);\n        }\n        final FunctionExpression comp = new GenericFunctionExpression(simbol);\n        return Expression.reservedFunctions.get(comp);\n    }\n    \n    public boolean isReservedFunction(final String simbol) {\n        final Object o = getReservedFunctions(simbol);\n        return o != null;\n    }\n    \n    public boolean isLogicalFunction(final String simbol) {\n        final FunctionExpression o = this.getFunction(simbol);\n        return o != null && o.getType() == FunctionExpression.LOGICAL;\n    }\n    \n    public boolean isMathFunction(final String simbol) {\n        final FunctionExpression o = this.getFunction(simbol);\n        return o != null && o.getType() == FunctionExpression.MATH;\n    }\n    \n    public boolean isDateFunction(final String simbol) {\n        final FunctionExpression o = this.getFunction(simbol);\n        return o != null && o.getType() == FunctionExpression.DATE;\n    }\n    \n    public boolean isStringFunction(final String simbol) {\n        final FunctionExpression o = this.getFunction(simbol);\n        return o != null && o.getType() == FunctionExpression.STRING;\n    }\n    \n    public FunctionExpression getExternalFunction(final String simbol) {\n        FunctionExpression f = null;\n        if (this.externalFunctions != null) {\n            final Iterator it = this.externalFunctions.iterator();\n            while (it.hasNext()) {\n                f = it.next();\n                if (f.getSimbol().equalsIgnoreCase(simbol)) {\n                    return f;\n                }\n            }\n        }\n        return null;\n    }\n    \n    public boolean isExternalFunction(final String simbol) {\n        final FunctionExpression f = this.getExternalFunction(simbol);\n        return f != null;\n    }\n    \n    public FunctionExpression getFunction(final String simbol) {\n        FunctionExpression f = null;\n        f = getReservedFunctions(simbol);\n        if (f != null) {\n            return f;\n        }\n        f = this.getExternalFunction(simbol);\n        return f;\n    }\n    \n    public boolean isFunction(final String simbol) {\n        final FunctionExpression f = this.getFunction(simbol);\n        return f != null;\n    }\n    \n    public Expression() {\n        this.prepared = false;\n    }\n    \n    private void stack(final String c, final Stack stack) {\n        if (!stack.isEmpty()) {\n            final String aux = stack.peek();\n            stack.pop();\n            stack.push(String.valueOf(aux) + c);\n        }\n        else {\n            stack.push(c);\n        }\n    }\n    \n    public void prepare() {\n        this.tokenize();\n        this.doEvaluationStack();\n        this.prepared = true;\n    }\n    \n    private ExpressionStack getStackCopy() {\n        final ExpressionStack st = new ExpressionStack();\n        for (int n = 0; n < this.stack.size(); ++n) {\n            st.add(new String(this.stack.get(n).toString()));\n        }\n        return st;\n    }\n    \n    public abstract Object evaluate() throws Exception;\n    \n    private void tokenize() {\n        boolean quote = false;\n        if (this.stack == null) {\n            this.stack = new ExpressionStack();\n        }\n        else {\n            this.stack.clear();\n        }\n        for (int n = 0; n < this.expression.length(); ++n) {\n            final String c = new StringBuilder().append(this.expression.charAt(n)).toString();\n            final boolean reserved = JavexUtils.isReservedChar(c);\n            final boolean isSpace = JavexUtils.isSpace(c);\n            final boolean isQuote = JavexUtils.isQuote(c);\n            if (isQuote && quote) {\n                quote = false;\n                this.stack(c, this.stack);\n            }\n            else if (isQuote && !quote) {\n                quote = true;\n                this.stack.push(c);\n            }\n            else if (reserved && quote) {\n                this.stack(c, this.stack);\n            }\n            else if (reserved && !quote) {\n                if (!this.stack.isEmpty()) {\n                    if (this.isFunction(String.valueOf(this.stack.peek()) + c)) {\n                        this.stack.push(String.valueOf(this.stack.pop()) + c);\n                    }\n                    else {\n                        this.stack.push(c);\n                    }\n                }\n                else {\n                    this.stack.push(c);\n                }\n            }\n            else if (!isQuote && quote) {\n                this.stack(c, this.stack);\n            }\n            else if (!isSpace && !this.stack.isEmpty() && !this.isFunction(this.stack.peek()) && !JavexUtils.isReservedChar(this.stack.peek())) {\n                this.stack.push(String.valueOf(this.stack.pop()) + c);\n            }\n            else if (!isSpace && (this.stack.isEmpty() || (!this.stack.isEmpty() && (JavexUtils.isReservedChar(this.stack.peek()) || this.isFunction(this.stack.peek()))))) {\n                this.stack.push(c);\n            }\n            else if (isSpace) {\n                this.stack.push(c);\n            }\n        }\n        final ExpressionStack st = new ExpressionStack();\n        for (int n2 = 0; n2 < this.stack.size(); ++n2) {\n            final String s1 = this.stack.get(n2).trim();\n            if (s1.length() > 0) {\n                st.add(s1);\n            }\n        }\n        this.stack = st;\n        for (int n2 = 0; n2 < this.stack.size(); ++n2) {\n            final String s1 = this.stack.get(n2);\n            if (JavexUtils.isNumber(s1) && n2 >= 1) {\n                final String s2 = this.stack.get(n2 - 1);\n                final String ss1 = (n2 > 1) ? this.stack.get(n2 - 2) : \"(\";\n                final boolean b = JavexUtils.isReservedChar(ss1);\n                if ((s2.equals(\"-\") || s2.equals(\"+\")) && b) {\n                    this.stack.set(n2 - 1, String.valueOf(s2) + s1);\n                    this.stack.remove(n2);\n                    --n2;\n                }\n            }\n        }\n        for (int m = this.stack.size(), n3 = 0; n3 < m; ++n3) {\n            if (this.stack.get(n3).equals(\",\") && n3 + 1 < this.stack.size() && n3 > 0) {\n                final String a = String.valueOf(this.stack.get(n3 - 1)) + this.stack.get(n3) + this.stack.get(n3 + 1);\n                this.stack.set(n3 - 1, a);\n                this.stack.remove(n3);\n                this.stack.remove(n3);\n                m -= 2;\n                --n3;\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 2506,
        "token_number_fewshot": 2904,
        "token_number_cot": 2616
    },
    {
        "project_name": "compiler",
        "class": "RecordType",
        "source_code": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Bob Jervis\n *   Google Inc.\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino.jstype;\n\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n\nimport java.util.Map;\nimport java.util.Set;\n\npublic class RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n\n  private final boolean declared;\n  private boolean isFrozen = false;\n\n  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n    this(registry, properties, true);\n  }\n\n  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties,\n      boolean declared) {\n    super(registry, null, null);\n    setPrettyPrint(true);\n    this.declared = declared;\n\n    for (String property : properties.keySet()) {\n      RecordProperty prop = properties.get(property);\n      if (prop == null) {\n        throw new IllegalStateException(\n            \"RecordProperty associated with a property should not be null!\");\n      }\n      if (declared) {\n        defineDeclaredProperty(\n            property, prop.getType(), prop.getPropertyNode());\n      } else {\n        defineSynthesizedProperty(\n            property, prop.getType(), prop.getPropertyNode());\n      }\n    }\n\n    // Freeze the record type.\n    isFrozen = true;\n  }\n\n  /** @return Is this synthesized for internal bookkeeping? */\n  boolean isSynthetic() {\n    return !declared;\n  }\n\n  boolean checkRecordEquivalenceHelper(\n      RecordType otherRecord, EquivalenceMethod eqMethod) {\n    Set<String> keySet = getOwnPropertyNames();\n    Set<String> otherKeySet = otherRecord.getOwnPropertyNames();\n    if (!otherKeySet.equals(keySet)) {\n      return false;\n    }\n    for (String key : keySet) {\n      if (!otherRecord.getPropertyType(key).checkEquivalenceHelper(\n              getPropertyType(key), eqMethod)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public ObjectType getImplicitPrototype() {\n    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n  }\n\n  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode) {\n    if (isFrozen) {\n      return false;\n    }\n\n    return super.defineProperty(propertyName, type, inferred,\n        propertyNode);\n  }\n\n  JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n      RecordType thatRecord = that.toMaybeRecordType();\n      RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n      builder.setSynthesized(true);\n\n      for (String property : getOwnPropertyNames()) {\n        if (thatRecord.hasProperty(property) &&\n            !thatRecord.getPropertyType(property).isInvariant(\n                getPropertyType(property))) {\n          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n        }\n\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n\n      for (String property : thatRecord.getOwnPropertyNames()) {\n        if (!hasProperty(property)) {\n          builder.addProperty(property, thatRecord.getPropertyType(property),\n              thatRecord.getPropertyNode(property));\n        }\n      }\n\n      return builder.build();\n    }\n\n    JSType greatestSubtype = registry.getNativeType(\n        JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj =\n        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n        .getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n\n      for (String propName : getOwnPropertyNames()) {\n        JSType propType = getPropertyType(propName);\n        UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n        for (ObjectType alt :\n                 registry.getEachReferenceTypeWithProperty(propName)) {\n          JSType altPropType = alt.getPropertyType(propName);\n          if (altPropType != null && !alt.isEquivalentTo(this) &&\n              alt.isSubtype(that) &&\n              propType.isInvariant(altPropType)) {\n            builder.addAlternate(alt);\n          }\n        }\n        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n      }\n    }\n    return greatestSubtype;\n  }\n\n  @Override\n  RecordType toMaybeRecordType() {\n    return this;\n  }\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Top of the record types is the empty record, or OBJECT_TYPE.\n    if (registry.getNativeObjectType(\n            JSTypeNative.OBJECT_TYPE).isSubtype(that)) {\n      return true;\n    }\n\n    // A type is a subtype of a record type if it itself is a record\n    // type and it has at least the same members as the parent record type\n    // with the same types.\n    if (!that.isRecordType()) {\n      return false;\n    }\n\n    return RecordType.isSubtype(this, that.toMaybeRecordType());\n  }\n\n  /** Determines if typeA is a subtype of typeB */\n  static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    for (String property : typeB.getOwnPropertyNames()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (typeA.isPropertyTypeDeclared(property)) {\n        // If one declared property isn't invariant,\n        // then the whole record isn't covariant.\n        if (!propA.isInvariant(propB)) {\n          return false;\n        }\n      } else {\n\n        if (!propA.isSubtype(propB)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n}\n",
        "token_number_zeroshot": 1600,
        "token_number_fewshot": 1998,
        "token_number_cot": 1711
    },
    {
        "project_name": "compiler",
        "class": "ScopedAliases",
        "source_code": "/*\n * Copyright 2010 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.SourcePosition;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\n\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\npublic class ScopedAliases implements HotSwapCompilerPass {\n  /** Name used to denote an scoped function block used for aliasing. */\n  static final String SCOPING_METHOD_NAME = \"goog.scope\";\n\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n\n  // Errors\n  static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n      \"The call to goog.scope must be alone in a single statement.\");\n\n  static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS =\n      DiagnosticType.error(\n          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n          \"The call to goog.scope must take only a single parameter.  It must\" +\n              \" be an anonymous function that itself takes no parameters.\");\n\n  static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n      \"The body of a goog.scope function cannot reference 'this'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_RETURN\",\n      \"The body of a goog.scope function cannot use 'return'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_THROW\",\n      \"The body of a goog.scope function cannot use 'throw'.\");\n\n  static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n      \"The alias {0} is assigned a value more than once.\");\n\n  static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n      \"The local variable {0} is in a goog.scope and is not an alias.\");\n\n  public ScopedAliases(AbstractCompiler compiler,\n                       @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n                       AliasTransformationHandler transformationHandler) {\n    this.compiler = compiler;\n    this.preprocessorSymbolTable = preprocessorSymbolTable;\n    this.transformationHandler = transformationHandler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }\n\n  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  private interface AliasUsage {\n    public void applyAlias();\n  }\n\n  private class AliasedNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final Node aliasDefinition;\n\n    AliasedNode(Node aliasReference, Node aliasDefinition) {\n      this.aliasReference = aliasReference;\n      this.aliasDefinition = aliasDefinition;\n    }\n\n    @Override\n    public void applyAlias() {\n      aliasReference.getParent().replaceChild(\n          aliasReference, aliasDefinition.cloneTree());\n    }\n  }\n\n  private class AliasedTypeNode implements AliasUsage {\n    private final Node typeReference;\n    private final Node aliasDefinition;\n    private final String aliasName;\n\n    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n        String aliasName) {\n      this.typeReference = typeReference;\n      this.aliasDefinition = aliasDefinition;\n      this.aliasName = aliasName;\n    }\n\n    @Override\n    public void applyAlias() {\n      String typeName = typeReference.getString();\n      String aliasExpanded =\n          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n      Preconditions.checkState(typeName.startsWith(aliasName));\n      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n    }\n  }\n\n\n  private class Traversal implements NodeTraversal.ScopedCallback {\n    // The job of this class is to collect these three data sets.\n\n    // The order of this list determines the order that aliases are applied.\n    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();\n\n    private final List<Node> scopeCalls = Lists.newArrayList();\n\n    private final List<AliasUsage> aliasUsages = Lists.newArrayList();\n\n    // This map is temporary and cleared for each scope.\n    private final Map<String, Var> aliases = Maps.newHashMap();\n\n    // Suppose you create an alias.\n    // var x = goog.x;\n    // As a side-effect, this means you can shadow the namespace 'goog'\n    // in inner scopes. When we inline the namespaces, we have to rename\n    // these shadows.\n    //\n    // Fortunately, we already have a name uniquifier that runs during tree\n    // normalization (before optimizations). We run it here on a limited\n    // set of variables, but only as a last resort (because this will screw\n    // up warning messages downstream).\n    private final Set<String> forbiddenLocals = Sets.newHashSet();\n    private boolean hasNamespaceShadows = false;\n\n    private boolean hasErrors = false;\n\n    private AliasTransformation transformation = null;\n\n    Collection<Node> getAliasDefinitionsInOrder() {\n      return aliasDefinitionsInOrder;\n    }\n\n    private List<AliasUsage> getAliasUsages() {\n      return aliasUsages;\n    }\n\n    List<Node> getScopeCalls() {\n      return scopeCalls;\n    }\n\n    boolean hasErrors() {\n      return hasErrors;\n    }\n\n    private boolean isCallToScopeMethod(Node n) {\n      return n.isCall() &&\n          SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n    }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n      }\n\n      if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n      }\n    }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isFunction() && t.inGlobalScope()) {\n        // Do not traverse in to functions except for goog.scope functions.\n        if (parent == null || !isCallToScopeMethod(parent)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n      Node testNode = n;\n      Node next = null;\n      for (; next != null || testNode.isScript();) {\n        next = testNode.getNext();\n        testNode = testNode.getParent();\n      }\n\n      int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();\n      int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();\n      SourcePosition<AliasTransformation> pos =\n          new SourcePosition<AliasTransformation>() {};\n      pos.setPositionInformation(\n          n.getLineno(), n.getCharno(), endLine, endChar);\n      return pos;\n    }\n\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n      compiler.report(t.makeError(n, error, arguments));\n      hasErrors = true;\n    }\n\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        if (parent.isVar() &&\n            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n\n          int rootIndex = qualifiedName.indexOf(\".\");\n          if (rootIndex != -1) {\n            String qNameRoot = qualifiedName.substring(0, rootIndex);\n            if (!aliases.containsKey(qNameRoot)) {\n              forbiddenLocals.add(qNameRoot);\n            }\n          }\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n\n    /** Find out if there are any local shadows of namespaces. */\n    private void findNamespaceShadows(NodeTraversal t) {\n      if (hasNamespaceShadows) {\n        return;\n      }\n\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        if (forbiddenLocals.contains(v.getName())) {\n          hasNamespaceShadows = true;\n          return;\n        }\n      }\n    }\n\n    /**\n     * Rename any local shadows of namespaces.\n     * This should be a very rare occurrence, so only do this traversal\n     * if we know that we need it.\n     */\n    private void renameNamespaceShadows(NodeTraversal t) {\n      if (hasNamespaceShadows) {\n        MakeDeclaredNamesUnique.Renamer renamer =\n            new MakeDeclaredNamesUnique.WhitelistedRenamer(\n                new MakeDeclaredNamesUnique.ContextualRenamer(),\n                forbiddenLocals);\n        for (String s : forbiddenLocals) {\n          renamer.addDeclaredName(s);\n        }\n        MakeDeclaredNamesUnique uniquifier =\n            new MakeDeclaredNamesUnique(renamer);\n        NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier);\n      }\n    }\n\n    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n      if (preprocessorSymbolTable != null) {\n        preprocessorSymbolTable.addReference(n.getFirstChild());\n      }\n      if (!parent.isExprResult()) {\n        report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n      }\n      if (n.getChildCount() != 2) {\n        // The goog.scope call should have exactly 1 parameter.  The first\n        // child is the \"goog.scope\" and the second should be the parameter.\n        report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n      } else {\n        Node anonymousFnNode = n.getChildAtIndex(1);\n        if (!anonymousFnNode.isFunction() ||\n            NodeUtil.getFunctionName(anonymousFnNode) != null ||\n            NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n          report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n        } else {\n          scopeCalls.add(n);\n        }\n      }\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }\n\n    private void fixTypeNode(Node typeNode) {\n      if (typeNode.isString()) {\n        String name = typeNode.getString();\n        int endIndex = name.indexOf('.');\n        if (endIndex == -1) {\n          endIndex = name.length();\n        }\n        String baseName = name.substring(0, endIndex);\n        Var aliasVar = aliases.get(baseName);\n        if (aliasVar != null) {\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n        }\n      }\n\n      for (Node child = typeNode.getFirstChild(); child != null;\n           child = child.getNext()) {\n        fixTypeNode(child);\n      }\n    }\n  }\n}\n",
        "token_number_zeroshot": 3607,
        "token_number_fewshot": 4005,
        "token_number_cot": 3718
    },
    {
        "project_name": "compiler",
        "class": "CheckGlobalThis",
        "source_code": "/*\n * Copyright 2007 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\n/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n */\npublic final class CheckGlobalThis implements Callback {\n\n  public static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n      \"JSC_USED_GLOBAL_THIS\",\n      \"dangerous use of the global 'this' object\");\n\n  private final AbstractCompiler compiler;\n\n  /**\n   * If {@code assignLhsChild != null}, then the node being traversed is\n   * a descendant of the first child of an ASSIGN node. assignLhsChild's\n   * parent is this ASSIGN node.\n   */\n  public Node assignLhsChild = null;\n\n  public CheckGlobalThis(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.isFunction()) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n\n            // object literal keys\n            pType == Token.STRING_KEY)) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n    }\n\n    if (parent != null && parent.isAssign()) {\n      Node lhs = parent.getFirstChild();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.isGetProp() &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.isGetProp() &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isThis() && shouldReportThis(n)) {\n      compiler.report(t.makeError(n, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }\n\n  public boolean shouldReportThis(Node n) {\n    Node parent = n.getParent();\n    if (assignLhsChild != null) {\n      // Always report a THIS on the left side of an assign.\n      return true;\n    }\n\n    // Also report a THIS with a property access.\n    return parent != null && NodeUtil.isGet(parent);\n  }\n\n  /**\n   * Gets a function's JSDoc information, if it has any. Checks for a few\n   * patterns (ellipses show where JSDoc would be):\n   * <pre>\n   * ... function() {}\n   * ... x = function() {};\n   * var ... x = function() {};\n   * ... var x = function() {};\n   * </pre>\n   */\n  public JSDocInfo getFunctionJsDocInfo(Node n) {\n    JSDocInfo jsDoc = n.getJSDocInfo();\n    Node parent = n.getParent();\n    if (jsDoc == null) {\n      int parentType = parent.getType();\n      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n        jsDoc = parent.getJSDocInfo();\n        if (jsDoc == null && parentType == Token.NAME) {\n          Node gramps = parent.getParent();\n          if (gramps.isVar()) {\n            jsDoc = gramps.getJSDocInfo();\n          }\n        }\n      }\n    }\n    return jsDoc;\n  }\n}\n",
        "token_number_zeroshot": 1540,
        "token_number_fewshot": 1938,
        "token_number_cot": 1652
    },
    {
        "project_name": "compiler",
        "class": "ExploitAssigns",
        "source_code": "/*\n * Copyright 2006 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\n/**\n * Tries to chain assignments together.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author acleung@google.com (Alan Leung)\n *\n */\npublic class ExploitAssigns extends AbstractPeepholeOptimization {\n\n  @Override\n  public Node optimizeSubtree(Node subtree) {\n    for (Node child = subtree.getFirstChild(); child != null;) {\n      Node next = child.getNext();\n      if (NodeUtil.isExprAssign(child)) {\n        collapseAssign(child.getFirstChild(), child, subtree);\n      }\n      child = next;\n    }\n    return subtree;\n  }\n\n  /**\n   * Try to collapse the given assign into subsequent expressions.\n   */\n  private void collapseAssign(Node assign, Node expr,\n      Node exprParent) {\n    Node leftValue = assign.getFirstChild();\n    Node rightValue = leftValue.getNext();\n    if (isCollapsibleValue(leftValue, true) &&\n        collapseAssignEqualTo(expr, exprParent, leftValue)) {\n      reportCodeChange();\n    } else if (isCollapsibleValue(rightValue, false) &&\n        collapseAssignEqualTo(expr, exprParent, rightValue)) {\n      reportCodeChange();\n    } else if (rightValue.isAssign()) {\n      // Recursively deal with nested assigns.\n      collapseAssign(rightValue, expr, exprParent);\n    }\n  }\n\n  /**\n   * Determines whether we know enough about the given value to be able\n   * to collapse it into subsequent expressions.\n   *\n   * For example, we can collapse booleans and variable names:\n   * <code>\n   * x = 3; y = x; // y = x = 3;\n   * a = true; b = true; // b = a = true;\n   * <code>\n   * But we won't try to collapse complex expressions.\n   *\n   * @param value The value node.\n   * @param isLValue Whether it's on the left-hand side of an expr.\n   */\n  private boolean isCollapsibleValue(Node value, boolean isLValue) {\n    switch (value.getType()) {\n      case Token.GETPROP:\n        // Do not collapse GETPROPs on arbitrary objects, because\n        // they may be implemented setter functions, and oftentimes\n        // setter functions fail on native objects. This is OK for \"THIS\"\n        // objects, because we assume that they are non-native.\n        return !isLValue || value.getFirstChild().isThis();\n\n      case Token.NAME:\n        return true;\n\n      default:\n        return NodeUtil.isImmutableValue(value);\n    }\n  }\n\n  /**\n   * Collapse the given assign expression into the expression directly\n   * following it, if possible.\n   *\n   * @param expr The expression that may be moved.\n   * @param exprParent The parent of {@code expr}.\n   * @param value The value of this expression, expressed as a node. Each\n   *     expression may have multiple values, so this function may be called\n   *     multiple times for the same expression. For example,\n   *     <code>\n   *     a = true;\n   *     </code>\n   *     is equal to the name \"a\" and the boolean \"true\".\n   * @return Whether the expression was collapsed successfully.\n   */\n  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n    Node name = node.getFirstChild();\n    if (name.isName()\n        && isNameAssignedTo(name.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @return Whether name is assigned in the expression rooted at node.\n   */\n\n  private boolean isNameAssignedTo(String name, Node node) {\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (isNameAssignedTo(name, c)) {\n        return true;\n      }\n    }\n\n    if (node.isName()) {\n      Node parent = node.getParent();\n      if (parent.isAssign() && parent.getFirstChild() == node) {\n        if (name.equals(node.getString())) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}",
        "token_number_zeroshot": 1756,
        "token_number_fewshot": 2154,
        "token_number_cot": 1869
    },
    {
        "project_name": "52_lagoon",
        "class": "LagoonGUI",
        "source_code": "package nu.staldal.lagoon;\n\nimport java.awt.event.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xtree.*;\nimport java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class LagoonGUI extends Frame implements WindowListener\n{\n    private static final boolean DEBUG = false;\n    private Panel buttonPanel;\n    private Panel inputPanel;\n    private Panel centerPanel;\n    private Button loadButton;\n    private Button saveButton;\n    private Button buildButton;\n    private Button forceButton;\n    private Button exitButton;\n    private InputComponent sitemapFile;\n    private InputComponent sourceDir;\n    private InputComponent targetURL;\n    private String password;\n    private Label statusLabel;\n    private TextArea progressArea;\n    private LagoonProcessor processor;\n    private long sitemapLastModified;\n    \n    public static void main(final String[] args) throws Exception {\n        final LagoonGUI appFrame = new LagoonGUI();\n        appFrame.show();\n        if (args.length > 0) {\n            appFrame.loadProperties(new File(args[0]));\n        }\n    }\n    \n    LagoonGUI() {\n        super(\"Lagoon\");\n        this.processor = null;\n        this.sitemapLastModified = 0L;\n        this.addWindowListener(this);\n        this.add(this.inputPanel = new Panel(), \"North\");\n        this.inputPanel.setLayout(new GridLayout(0, 1));\n        this.inputPanel.add(this.sitemapFile = new InputComponent(this, \"Sitemap file\", \"\", true));\n        this.inputPanel.add(this.sourceDir = new InputComponent(this, \"Source directory\", \".\"));\n        this.inputPanel.add(this.targetURL = new InputComponent(this, \"Target URL\", \".\"));\n        this.add(this.centerPanel = new Panel(), \"Center\");\n        this.centerPanel.setLayout(new BorderLayout());\n        this.centerPanel.add(this.progressArea = new TextArea(null, 5, 50, 1), \"North\");\n        this.progressArea.setEditable(false);\n        this.centerPanel.add(this.statusLabel = new Label(\"Not initialized\"), \"South\");\n        this.add(this.buttonPanel = new Panel(), \"South\");\n        this.buttonPanel.add(this.loadButton = new Button(\"Load Properties\"));\n        this.loadButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.loadPropertyFile();\n            }\n        });\n        this.buttonPanel.add(this.saveButton = new Button(\"Save Properties\"));\n        this.saveButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.savePropertyFile();\n            }\n        });\n        this.buttonPanel.add(this.buildButton = new Button(\"Build\"));\n        this.buildButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.build(false);\n            }\n        });\n        this.buttonPanel.add(this.forceButton = new Button(\"Force build\"));\n        this.forceButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.build(true);\n            }\n        });\n        this.buttonPanel.add(this.exitButton = new Button(\"Exit\"));\n        this.exitButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.exit();\n            }\n        });\n        this.setBackground(Color.lightGray);\n        this.pack();\n    }\n    \n    @Override\n    public void windowOpened(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowClosing(final WindowEvent e) {\n        this.exit();\n    }\n    \n    @Override\n    public void windowClosed(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowIconified(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowDeiconified(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowActivated(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowDeactivated(final WindowEvent e) {\n    }\n    \n    private void build(final boolean force) {\n        this.loadButton.setEnabled(false);\n        this.saveButton.setEnabled(false);\n        this.buildButton.setEnabled(false);\n        this.forceButton.setEnabled(false);\n        this.sitemapFile.setEnabled(false);\n        this.sourceDir.setEnabled(false);\n        this.targetURL.setEnabled(false);\n        final File sm = new File(this.sitemapFile.getValue());\n        if (this.processor == null || this.sitemapFile.hasChanged() || this.sourceDir.hasChanged() || this.targetURL.hasChanged()) {\n            this.init();\n        }\n        else if (sm.lastModified() > this.sitemapLastModified) {\n            this.init();\n        }\n        if (this.processor != null) {\n            final long timeBefore = System.currentTimeMillis();\n            this.progressArea.setText(\"--- Start build ---\\n\");\n            this.statusLabel.setText(\"Building...\");\n            try {\n                final boolean success = this.processor.build(force);\n                final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                if (!success) {\n                    this.progressArea.append(\"--- Build finished with error(s) \" + showTime(timeElapsed) + \" ---\");\n                    final MessageDialog ed = new MessageDialog(this, \"Building error\", \"Error(s) occured while building\");\n                    ed.show();\n                }\n                else {\n                    this.progressArea.append(\"--- Build finished successfully \" + showTime(timeElapsed) + \" ---\");\n                }\n            }\n            catch (FileNotFoundException e) {\n                final MessageDialog ed2 = new MessageDialog(this, \"Fatal Building error\", \"File not found: \" + e.getMessage());\n                ed2.show();\n            }\n            catch (IOException e2) {\n                final MessageDialog ed2 = new MessageDialog(this, \"Fatal Building error\", e2.toString());\n                ed2.show();\n            }\n            this.statusLabel.setText(\"Ready\");\n        }\n        else {\n            this.statusLabel.setText(\"Not initialized\");\n        }\n        this.sitemapLastModified = sm.lastModified();\n        this.loadButton.setEnabled(true);\n        this.saveButton.setEnabled(true);\n        this.buildButton.setEnabled(true);\n        this.forceButton.setEnabled(true);\n        this.sitemapFile.setEnabled(true);\n        this.sourceDir.setEnabled(true);\n        this.targetURL.setEnabled(true);\n    }\n    \n    private void exit() {\n        try {\n            if (this.processor != null) {\n                this.processor.destroy();\n            }\n        }\n        catch (IOException e) {\n            System.err.println(\"Error destroying LagoonProcessor: \" + e.toString());\n        }\n        System.exit(0);\n    }\n    \n    private void init() {\n        this.statusLabel.setText(\"Initializing...\");\n        try {\n            if (this.processor != null) {\n                this.processor.destroy();\n            }\n        }\n        catch (IOException e) {\n            System.err.println(\"Error destroying LagoonProcessor: \" + e.toString());\n        }\n        this.processor = null;\n        try {\n            Element sitemapTree;\n            try {\n                final FileInputStream fis = new FileInputStream(new File(this.sitemapFile.getValue()));\n                final InputSource is = new InputSource(this.sitemapFile.getValue());\n                is.setByteStream(fis);\n                sitemapTree = TreeBuilder.parseXML(is, false);\n                fis.close();\n            }\n            catch (SAXException e2) {\n                final Exception ee = e2.getException();\n                if (ee == null) {\n                    e2.printStackTrace();\n                    throw new LagoonException(e2.getMessage());\n                }\n                if (ee instanceof IOException) {\n                    throw (IOException)ee;\n                }\n                ee.printStackTrace();\n                throw new LagoonException(ee.getMessage());\n            }\n            final PrintWriter pw = new PrintWriter(new TextAreaWriter(this.progressArea), true);\n            this.processor = new LagoonProcessor(this.targetURL.getValue(), sitemapTree, new File(this.sourceDir.getValue()), this.password, pw, pw);\n        }\n        catch (AuthenticationMissingException e5) {\n            final PasswordDialog pwd = new PasswordDialog(this, \"Password\", \"Password needed to access target\");\n            pwd.show();\n            this.password = pwd.getPassword();\n            if (this.password != null) {\n                this.init();\n            }\n        }\n        catch (AuthenticationException e6) {\n            final PasswordDialog pwd = new PasswordDialog(this, \"Password\", \"Invalid password, try again\");\n            pwd.show();\n            this.password = pwd.getPassword();\n            if (this.password != null) {\n                this.init();\n            }\n        }\n        catch (FileNotFoundException e3) {\n            final MessageDialog ed = new MessageDialog(this, \"Initializing error\", \"File not found: \" + e3.getMessage());\n            ed.show();\n        }\n        catch (IOException e) {\n            final MessageDialog ed = new MessageDialog(this, \"Initializing error\", e.toString());\n            ed.show();\n        }\n        catch (LagoonException e4) {\n            final MessageDialog ed = new MessageDialog(this, \"Initializing error\", e4.getMessage());\n            ed.show();\n        }\n    }\n    \n    private void loadPropertyFile() {\n        final FileDialog propertyFileDialog = new FileDialog(this, \"Load property file\");\n        propertyFileDialog.show();\n        final File propertyFile = (propertyFileDialog.getFile() == null) ? null : new File(propertyFileDialog.getDirectory(), propertyFileDialog.getFile());\n        if (propertyFile != null) {\n            this.loadProperties(propertyFile);\n        }\n    }\n    \n    private void loadProperties(final File propertyFile) {\n        try {\n            final FileInputStream fis = new FileInputStream(propertyFile);\n            final Properties prop = new Properties();\n            prop.load(fis);\n            fis.close();\n            this.sitemapFile.setValue(getProperty(prop, \"sitemapFile\"));\n            this.sourceDir.setValue(getProperty(prop, \"sourceDir\"));\n            this.targetURL.setValue(getProperty(prop, \"targetURL\"));\n            this.password = prop.getProperty(\"password\");\n        }\n        catch (LagoonException e) {\n            final MessageDialog ed = new MessageDialog(this, \"Error in propertry file\", e.getMessage());\n            ed.show();\n        }\n        catch (IOException e2) {\n            final MessageDialog ed = new MessageDialog(this, \"Error reading property file\", e2.toString());\n            ed.show();\n        }\n    }\n    \n    private void savePropertyFile() {\n        final FileDialog propertyFileDialog = new FileDialog(this, \"Save property file\", 1);\n        propertyFileDialog.show();\n        final File propertyFile = (propertyFileDialog.getFile() == null) ? null : new File(propertyFileDialog.getDirectory(), propertyFileDialog.getFile());\n        if (propertyFile != null) {\n            try {\n                final FileOutputStream fos = new FileOutputStream(propertyFile);\n                final Properties prop = new Properties();\n                prop.setProperty(\"sitemapFile\", this.sitemapFile.getValue());\n                prop.setProperty(\"sourceDir\", this.sourceDir.getValue());\n                prop.setProperty(\"targetURL\", this.targetURL.getValue());\n                if (this.password != null) {\n                    final YesNoQueryDialog ynDialog = new YesNoQueryDialog(this, \"Save property file\", \"Save password in property file?\", \"Yes\", \"No\");\n                    ynDialog.show();\n                    if (ynDialog.getResult()) {\n                        prop.setProperty(\"password\", this.password);\n                    }\n                }\n                prop.store(fos, \"Lagoon properties\");\n                fos.close();\n                this.statusLabel.setText(\"Properties saved\");\n            }\n            catch (IOException e) {\n                final MessageDialog ed = new MessageDialog(this, \"Error writing property file\", e.toString());\n                ed.show();\n            }\n        }\n    }\n    \n    private static String getProperty(final Properties prop, final String name) throws LagoonException {\n        final String value = prop.getProperty(name);\n        if (value == null) {\n            throw new LagoonException(\"Property \" + name + \" not specified\");\n        }\n        return value.trim();\n    }\n    \n    private static String showTime(final long ms) {\n        if (ms < 10000L) {\n            return \"in \" + ms + \" ms\";\n        }\n        return \"in \" + ms / 1000L + \" s\";\n    }\n}\n",
        "token_number_zeroshot": 2482,
        "token_number_fewshot": 2880,
        "token_number_cot": 2594
    },
    {
        "project_name": "52_lagoon",
        "class": "LagoonCLI",
        "source_code": "package nu.staldal.lagoon;\n\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport java.io.*;\nimport nu.staldal.xtree.*;\n\npublic class LagoonCLI\n{\n    private static boolean DEBUG;\n    private static final String syntaxMsg = \"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\";\n    private static Properties properties;\n    \n    public static void main(final String[] args) {\n        boolean force = false;\n        boolean build = false;\n        long interval = 0L;\n        if (args.length < 1) {\n            System.out.println(\"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\");\n            return;\n        }\n        if (args.length > 1 && args[1].equals(\"build\")) {\n            build = true;\n        }\n        else if (args.length > 1 && args[1].equals(\"force\")) {\n            force = true;\n        }\n        else if (args.length > 1) {\n            try {\n                interval = 1000 * Integer.parseInt(args[1]);\n            }\n            catch (NumberFormatException e5) {\n                System.out.println(\"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\");\n                return;\n            }\n            if (interval < 1L) {\n                System.out.println(\"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\");\n                return;\n            }\n        }\n        LagoonProcessor processor;\n        try {\n            System.out.println(\"Initializing Lagoon...\");\n            String targetURL;\n            File sourceDir;\n            File sitemapFile;\n            String password;\n            if (args[0].endsWith(\".xml\") || args[0].endsWith(\".sitemap\")) {\n                targetURL = System.getProperty(\"user.dir\");\n                sourceDir = new File(targetURL);\n                sitemapFile = new File(args[0]);\n                password = null;\n            }\n            else {\n                final File propertyFile = new File(args[0]);\n                LagoonCLI.properties = new Properties();\n                final FileInputStream fis = new FileInputStream(propertyFile);\n                LagoonCLI.properties.load(fis);\n                fis.close();\n                targetURL = getProperty(\"targetURL\");\n                sitemapFile = new File(getProperty(\"sitemapFile\"));\n                sourceDir = new File(getProperty(\"sourceDir\"));\n                password = LagoonCLI.properties.getProperty(\"password\");\n            }\n            Element sitemapTree;\n            try {\n                sitemapTree = TreeBuilder.parseXML(TreeBuilder.fileToInputSource(sitemapFile), false);\n            }\n            catch (SAXException e) {\n                final Exception ee = e.getException();\n                if (ee == null) {\n                    e.printStackTrace();\n                    throw new LagoonException(e.getMessage());\n                }\n                if (ee instanceof IOException) {\n                    throw (IOException)ee;\n                }\n                ee.printStackTrace();\n                throw new LagoonException(ee.getMessage());\n            }\n            processor = new LagoonProcessor(targetURL, sitemapTree, sourceDir, password, new PrintWriter(System.out, true), new PrintWriter(System.err, true));\n        }\n        catch (AuthenticationMissingException e6) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"Password is required but not specified\");\n            return;\n        }\n        catch (AuthenticationException e7) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"Incorrect password\");\n            return;\n        }\n        catch (FileNotFoundException e2) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"File not found: \" + e2.getMessage());\n            return;\n        }\n        catch (IOException e3) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"I/O error: \" + e3.toString());\n            if (LagoonCLI.DEBUG) {\n                e3.printStackTrace();\n            }\n            return;\n        }\n        catch (LagoonException e4) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(e4.getMessage());\n            return;\n        }\n        System.out.println(\"Lagoon initialized successfully\");\n        try {\n            if (build) {\n                System.out.println(\"Building website...\");\n                final long timeBefore = System.currentTimeMillis();\n                if (!processor.build(false)) {\n                    System.out.println(\"...with errors...\");\n                }\n                final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                showTime(timeElapsed);\n            }\n            else if (force) {\n                System.out.println(\"Force building website...\");\n                final long timeBefore = System.currentTimeMillis();\n                if (!processor.build(true)) {\n                    System.out.println(\"...with errors...\");\n                }\n                final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                showTime(timeElapsed);\n            }\n            else if (interval > 0L) {\n                while (true) {\n                    System.out.println(\"Building website...\");\n                    final long timeBefore = System.currentTimeMillis();\n                    if (!processor.build(false)) {\n                        System.out.println(\"...with errors...\");\n                    }\n                    final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                    showTime(timeElapsed);\n                    if (timeElapsed < interval) {\n                        try {\n                            Thread.sleep(interval - timeElapsed);\n                        }\n                        catch (InterruptedException ex) {}\n                    }\n                }\n            }\n            else {\n                final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                while (true) {\n                    System.out.println(\"Ready\");\n                    final String s = in.readLine();\n                    if (s.length() < 1) {\n                        continue;\n                    }\n                    final char c = Character.toLowerCase(s.charAt(0));\n                    if (c == 'b') {\n                        System.out.println(\"Building website...\");\n                        final long timeBefore2 = System.currentTimeMillis();\n                        if (!processor.build(false)) {\n                            System.out.println(\"...with errors...\");\n                        }\n                        final long timeElapsed2 = System.currentTimeMillis() - timeBefore2;\n                        showTime(timeElapsed2);\n                    }\n                    else if (c == 'f') {\n                        System.out.println(\"Force building website...\");\n                        final long timeBefore2 = System.currentTimeMillis();\n                        if (!processor.build(true)) {\n                            System.out.println(\"...with errors...\");\n                        }\n                        final long timeElapsed2 = System.currentTimeMillis() - timeBefore2;\n                        showTime(timeElapsed2);\n                    }\n                    else {\n                        if (c == 'q') {\n                            break;\n                        }\n                        continue;\n                    }\n                }\n            }\n            if (LagoonCLI.DEBUG) {\n                final Thread[] threads = new Thread[Thread.activeCount()];\n                Thread.enumerate(threads);\n                for (int i = 0; i < threads.length; ++i) {\n                    if (threads[i] != null && threads[i] != Thread.currentThread()) {\n                        System.out.println(\"Thread still running: \" + threads[i]);\n                    }\n                }\n            }\n            System.out.println(\"Exiting Lagoon...\");\n            processor.destroy();\n            System.exit(0);\n        }\n        catch (FileNotFoundException e2) {\n            System.err.println(\"File not found: \" + e2.getMessage());\n        }\n        catch (IOException e3) {\n            System.err.println(\"I/O error: \" + e3.toString());\n            if (LagoonCLI.DEBUG) {\n                e3.printStackTrace();\n            }\n        }\n    }\n    \n    private static String getProperty(final String name) throws LagoonException {\n        final String value = LagoonCLI.properties.getProperty(name);\n        if (value == null) {\n            throw new LagoonException(\"Property \" + name + \" not specified\");\n        }\n        return value.trim();\n    }\n    \n    private static void showTime(final long ms) {\n        if (ms < 10000L) {\n            System.out.println(\"in \" + ms + \" ms\");\n        }\n        else {\n            System.out.println(\"in \" + ms / 1000L + \" s\");\n        }\n    }\n    \n    static {\n        LagoonCLI.DEBUG = false;\n    }\n}\n",
        "token_number_zeroshot": 1768,
        "token_number_fewshot": 2166,
        "token_number_cot": 1880
    },
    {
        "project_name": "jdom",
        "class": "JDOMResult",
        "source_code": "package org.jdom2.transform;\n\nimport javax.xml.transform.sax.*;\nimport org.xml.sax.ext.*;\nimport org.jdom2.*;\nimport java.util.*;\nimport org.jdom2.input.sax.*;\nimport org.xml.sax.helpers.*;\nimport org.xml.sax.*;\n\npublic class JDOMResult extends SAXResult\n{\n    public static final String JDOM_FEATURE = \"http://jdom.org/jdom2/transform/JDOMResult/feature\";\n    private List<Content> resultlist;\n    private Document resultdoc;\n    private boolean queried;\n    private JDOMFactory factory;\n    \n    public JDOMResult() {\n        this.resultlist = null;\n        this.resultdoc = null;\n        this.queried = false;\n        this.factory = null;\n        final DocumentBuilder builder = new DocumentBuilder();\n        super.setHandler(builder);\n        super.setLexicalHandler(builder);\n    }\n    \n    public void setResult(final List<Content> result) {\n        this.resultlist = result;\n        this.queried = false;\n    }\n    \n    public List<Content> getResult() {\n        List<Content> nodes = Collections.emptyList();\n        this.retrieveResult();\n        if (this.resultlist != null) {\n            nodes = this.resultlist;\n        }\n        else if (this.resultdoc != null && !this.queried) {\n            final List<Content> content = this.resultdoc.getContent();\n            nodes = new ArrayList<Content>(content.size());\n            while (content.size() != 0) {\n                final Content o = content.remove(0);\n                nodes.add(o);\n            }\n            this.resultlist = nodes;\n            this.resultdoc = null;\n        }\n        this.queried = true;\n        return nodes;\n    }\n    \n    public void setDocument(final Document document) {\n        this.resultdoc = document;\n        this.resultlist = null;\n        this.queried = false;\n    }\n    \n    public Document getDocument() {\n        Document doc = null;\n        this.retrieveResult();\n        if (this.resultdoc != null) {\n            doc = this.resultdoc;\n        }\n        else if (this.resultlist != null && !this.queried) {\n            try {\n                JDOMFactory f = this.getFactory();\n                if (f == null) {\n                    f = new DefaultJDOMFactory();\n                }\n                doc = f.document(null);\n                doc.setContent(this.resultlist);\n                this.resultdoc = doc;\n                this.resultlist = null;\n            }\n            catch (RuntimeException ex1) {\n                return null;\n            }\n        }\n        this.queried = true;\n        return doc;\n    }\n    \n    public void setFactory(final JDOMFactory factory) {\n        this.factory = factory;\n    }\n    \n    public JDOMFactory getFactory() {\n        return this.factory;\n    }\n    \n    private void retrieveResult() {\n        if (this.resultlist == null && this.resultdoc == null) {\n            this.setResult(((DocumentBuilder)this.getHandler()).getResult());\n        }\n    }\n    \n    public void setHandler(final ContentHandler handler) {\n    }\n    \n    public void setLexicalHandler(final LexicalHandler handler) {\n    }\n    \n    private static class FragmentHandler extends SAXHandler\n    {\n        private Element dummyRoot;\n        \n        public FragmentHandler(final JDOMFactory factory) {\n            super(factory);\n            this.pushElement(this.dummyRoot = new Element(\"root\", null, null));\n        }\n        \n        public List<Content> getResult() {\n            try {\n                this.flushCharacters();\n            }\n            catch (SAXException ex) {}\n            return this.getDetachedContent(this.dummyRoot);\n        }\n        \n        private List<Content> getDetachedContent(final Element elt) {\n            final List<Content> content = elt.getContent();\n            final List<Content> nodes = new ArrayList<Content>(content.size());\n            while (content.size() != 0) {\n                final Content o = content.remove(0);\n                nodes.add(o);\n            }\n            return nodes;\n        }\n    }\n    \n    private class DocumentBuilder extends XMLFilterImpl implements LexicalHandler\n    {\n        private FragmentHandler saxHandler;\n        private boolean startDocumentReceived;\n        \n        public DocumentBuilder() {\n            this.saxHandler = null;\n            this.startDocumentReceived = false;\n        }\n        \n        public List<Content> getResult() {\n            List<Content> mresult = null;\n            if (this.saxHandler != null) {\n                mresult = this.saxHandler.getResult();\n                this.saxHandler = null;\n                this.startDocumentReceived = false;\n            }\n            return mresult;\n        }\n        \n        private void ensureInitialization() throws SAXException {\n            if (!this.startDocumentReceived) {\n                this.startDocument();\n            }\n        }\n        \n        public void startDocument() throws SAXException {\n            this.startDocumentReceived = true;\n            JDOMResult.this.setResult(null);\n            super.setContentHandler(this.saxHandler = new FragmentHandler(JDOMResult.this.getFactory()));\n            super.startDocument();\n        }\n        \n        public void startElement(final String nsURI, final String localName, final String qName, final Attributes atts) throws SAXException {\n            this.ensureInitialization();\n            super.startElement(nsURI, localName, qName, atts);\n        }\n        \n        public void startPrefixMapping(final String prefix, final String uri) throws SAXException {\n            this.ensureInitialization();\n            super.startPrefixMapping(prefix, uri);\n        }\n        \n        public void characters(final char[] ch, final int start, final int length) throws SAXException {\n            this.ensureInitialization();\n            super.characters(ch, start, length);\n        }\n        \n        public void ignorableWhitespace(final char[] ch, final int start, final int length) throws SAXException {\n            this.ensureInitialization();\n            super.ignorableWhitespace(ch, start, length);\n        }\n        \n        public void processingInstruction(final String target, final String data) throws SAXException {\n            this.ensureInitialization();\n            super.processingInstruction(target, data);\n        }\n        \n        public void skippedEntity(final String name) throws SAXException {\n            this.ensureInitialization();\n            super.skippedEntity(name);\n        }\n        \n        public void startDTD(final String name, final String publicId, final String systemId) throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.startDTD(name, publicId, systemId);\n        }\n        \n        public void endDTD() throws SAXException {\n            this.saxHandler.endDTD();\n        }\n        \n        public void startEntity(final String name) throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.startEntity(name);\n        }\n        \n        public void endEntity(final String name) throws SAXException {\n            this.saxHandler.endEntity(name);\n        }\n        \n        public void startCDATA() throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.startCDATA();\n        }\n        \n        public void endCDATA() throws SAXException {\n            this.saxHandler.endCDATA();\n        }\n        \n        public void comment(final char[] ch, final int start, final int length) throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.comment(ch, start, length);\n        }\n    }\n}\n",
        "token_number_zeroshot": 1483,
        "token_number_fewshot": 1881,
        "token_number_cot": 1595
    },
    {
        "project_name": "jdom",
        "class": "SAXOutputter",
        "source_code": "package org.jdom2.output;\n\nimport org.xml.sax.ext.*;\nimport java.util.*;\nimport org.jdom2.*;\nimport org.xml.sax.*;\nimport org.jdom2.output.support.*;\n\npublic class SAXOutputter\n{\n    private static final SAXOutputProcessor DEFAULT_PROCESSOR;\n    private ContentHandler contentHandler;\n    private ErrorHandler errorHandler;\n    private DTDHandler dtdHandler;\n    private EntityResolver entityResolver;\n    private LexicalHandler lexicalHandler;\n    private DeclHandler declHandler;\n    private boolean declareNamespaces;\n    private boolean reportDtdEvents;\n    private SAXOutputProcessor processor;\n    private Format format;\n    \n    public SAXOutputter() {\n        this.declareNamespaces = false;\n        this.reportDtdEvents = true;\n        this.processor = SAXOutputter.DEFAULT_PROCESSOR;\n        this.format = Format.getRawFormat();\n    }\n    \n    public SAXOutputter(final ContentHandler contentHandler) {\n        this(contentHandler, null, null, null, null);\n    }\n    \n    public SAXOutputter(final ContentHandler contentHandler, final ErrorHandler errorHandler, final DTDHandler dtdHandler, final EntityResolver entityResolver) {\n        this(contentHandler, errorHandler, dtdHandler, entityResolver, null);\n    }\n    \n    public SAXOutputter(final ContentHandler contentHandler, final ErrorHandler errorHandler, final DTDHandler dtdHandler, final EntityResolver entityResolver, final LexicalHandler lexicalHandler) {\n        this.declareNamespaces = false;\n        this.reportDtdEvents = true;\n        this.processor = SAXOutputter.DEFAULT_PROCESSOR;\n        this.format = Format.getRawFormat();\n        this.contentHandler = contentHandler;\n        this.errorHandler = errorHandler;\n        this.dtdHandler = dtdHandler;\n        this.entityResolver = entityResolver;\n        this.lexicalHandler = lexicalHandler;\n    }\n    \n    public SAXOutputter(final SAXOutputProcessor processor, final Format format, final ContentHandler contentHandler, final ErrorHandler errorHandler, final DTDHandler dtdHandler, final EntityResolver entityResolver, final LexicalHandler lexicalHandler) {\n        this.declareNamespaces = false;\n        this.reportDtdEvents = true;\n        this.processor = SAXOutputter.DEFAULT_PROCESSOR;\n        this.format = Format.getRawFormat();\n        this.processor = ((processor == null) ? SAXOutputter.DEFAULT_PROCESSOR : processor);\n        this.format = ((format == null) ? Format.getRawFormat() : format);\n        this.contentHandler = contentHandler;\n        this.errorHandler = errorHandler;\n        this.dtdHandler = dtdHandler;\n        this.entityResolver = entityResolver;\n        this.lexicalHandler = lexicalHandler;\n    }\n    \n    public void setContentHandler(final ContentHandler contentHandler) {\n        this.contentHandler = contentHandler;\n    }\n    \n    public ContentHandler getContentHandler() {\n        return this.contentHandler;\n    }\n    \n    public void setErrorHandler(final ErrorHandler errorHandler) {\n        this.errorHandler = errorHandler;\n    }\n    \n    public ErrorHandler getErrorHandler() {\n        return this.errorHandler;\n    }\n    \n    public void setDTDHandler(final DTDHandler dtdHandler) {\n        this.dtdHandler = dtdHandler;\n    }\n    \n    public DTDHandler getDTDHandler() {\n        return this.dtdHandler;\n    }\n    \n    public void setEntityResolver(final EntityResolver entityResolver) {\n        this.entityResolver = entityResolver;\n    }\n    \n    public EntityResolver getEntityResolver() {\n        return this.entityResolver;\n    }\n    \n    public void setLexicalHandler(final LexicalHandler lexicalHandler) {\n        this.lexicalHandler = lexicalHandler;\n    }\n    \n    public LexicalHandler getLexicalHandler() {\n        return this.lexicalHandler;\n    }\n    \n    public void setDeclHandler(final DeclHandler declHandler) {\n        this.declHandler = declHandler;\n    }\n    \n    public DeclHandler getDeclHandler() {\n        return this.declHandler;\n    }\n    \n    public boolean getReportNamespaceDeclarations() {\n        return this.declareNamespaces;\n    }\n    \n    public void setReportNamespaceDeclarations(final boolean declareNamespaces) {\n        this.declareNamespaces = declareNamespaces;\n    }\n    \n    public boolean getReportDTDEvents() {\n        return this.reportDtdEvents;\n    }\n    \n    public void setReportDTDEvents(final boolean reportDtdEvents) {\n        this.reportDtdEvents = reportDtdEvents;\n    }\n    \n    public void setFeature(final String name, final boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/features/namespace-prefixes\".equals(name)) {\n            this.setReportNamespaceDeclarations(value);\n        }\n        else if (\"http://xml.org/sax/features/namespaces\".equals(name)) {\n            if (!value) {\n                throw new SAXNotSupportedException(name);\n            }\n        }\n        else {\n            if (!\"http://xml.org/sax/features/validation\".equals(name)) {\n                throw new SAXNotRecognizedException(name);\n            }\n            this.setReportDTDEvents(value);\n        }\n    }\n    \n    public boolean getFeature(final String name) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/features/namespace-prefixes\".equals(name)) {\n            return this.declareNamespaces;\n        }\n        if (\"http://xml.org/sax/features/namespaces\".equals(name)) {\n            return true;\n        }\n        if (\"http://xml.org/sax/features/validation\".equals(name)) {\n            return this.reportDtdEvents;\n        }\n        throw new SAXNotRecognizedException(name);\n    }\n    \n    public void setProperty(final String name, final Object value) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/properties/lexical-handler\".equals(name) || \"http://xml.org/sax/handlers/LexicalHandler\".equals(name)) {\n            this.setLexicalHandler((LexicalHandler)value);\n        }\n        else {\n            if (!\"http://xml.org/sax/properties/declaration-handler\".equals(name) && !\"http://xml.org/sax/handlers/DeclHandler\".equals(name)) {\n                throw new SAXNotRecognizedException(name);\n            }\n            this.setDeclHandler((DeclHandler)value);\n        }\n    }\n    \n    public Object getProperty(final String name) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/properties/lexical-handler\".equals(name) || \"http://xml.org/sax/handlers/LexicalHandler\".equals(name)) {\n            return this.getLexicalHandler();\n        }\n        if (\"http://xml.org/sax/properties/declaration-handler\".equals(name) || \"http://xml.org/sax/handlers/DeclHandler\".equals(name)) {\n            return this.getDeclHandler();\n        }\n        throw new SAXNotRecognizedException(name);\n    }\n    \n    public SAXOutputProcessor getSAXOutputProcessor() {\n        return this.processor;\n    }\n    \n    public void setSAXOutputProcessor(final SAXOutputProcessor processor) {\n        this.processor = ((processor == null) ? SAXOutputter.DEFAULT_PROCESSOR : processor);\n    }\n    \n    public Format getFormat() {\n        return this.format;\n    }\n    \n    public void setFormat(final Format format) {\n        this.format = ((format == null) ? Format.getRawFormat() : format);\n    }\n    \n    private final SAXTarget buildTarget(final Document doc) {\n        String publicID = null;\n        String systemID = null;\n        if (doc != null) {\n            final DocType dt = doc.getDocType();\n            if (dt != null) {\n                publicID = dt.getPublicID();\n                systemID = dt.getSystemID();\n            }\n        }\n        return new SAXTarget(this.contentHandler, this.errorHandler, this.dtdHandler, this.entityResolver, this.lexicalHandler, this.declHandler, this.declareNamespaces, this.reportDtdEvents, publicID, systemID);\n    }\n    \n    public void output(final Document document) throws JDOMException {\n        this.processor.process(this.buildTarget(document), this.format, document);\n    }\n    \n    public void output(final List<? extends Content> nodes) throws JDOMException {\n        this.processor.processAsDocument(this.buildTarget(null), this.format, nodes);\n    }\n    \n    public void output(final Element node) throws JDOMException {\n        this.processor.processAsDocument(this.buildTarget(null), this.format, node);\n    }\n    \n    public void outputFragment(final List<? extends Content> nodes) throws JDOMException {\n        if (nodes == null) {\n            return;\n        }\n        this.processor.process(this.buildTarget(null), this.format, nodes);\n    }\n    \n    public void outputFragment(final Content node) throws JDOMException {\n        if (node == null) {\n            return;\n        }\n        final SAXTarget out = this.buildTarget(null);\n        switch (node.getCType()) {\n            case CDATA: {\n                this.processor.process(out, this.format, (CDATA)node);\n                break;\n            }\n            case Comment: {\n                this.processor.process(out, this.format, (Comment)node);\n                break;\n            }\n            case Element: {\n                this.processor.process(out, this.format, (Element)node);\n                break;\n            }\n            case EntityRef: {\n                this.processor.process(out, this.format, (EntityRef)node);\n                break;\n            }\n            case ProcessingInstruction: {\n                this.processor.process(out, this.format, (ProcessingInstruction)node);\n                break;\n            }\n            case Text: {\n                this.processor.process(out, this.format, (Text)node);\n                break;\n            }\n            default: {\n                this.handleError(new JDOMException(\"Invalid element content: \" + node));\n                break;\n            }\n        }\n    }\n    \n    private void handleError(final JDOMException exception) throws JDOMException {\n        if (this.errorHandler != null) {\n            try {\n                this.errorHandler.error(new SAXParseException(exception.getMessage(), null, exception));\n                return;\n            }\n            catch (SAXException se) {\n                if (se.getException() instanceof JDOMException) {\n                    throw (JDOMException)se.getException();\n                }\n                throw new JDOMException(se.getMessage(), se);\n            }\n            throw exception;\n        }\n        throw exception;\n    }\n    \n    @Deprecated\n    public JDOMLocator getLocator() {\n        return null;\n    }\n    \n    static {\n        DEFAULT_PROCESSOR = new DefaultSAXOutputProcessor();\n    }\n    \n    private static final class DefaultSAXOutputProcessor extends AbstractSAXOutputProcessor\n    {\n    }\n}\n",
        "token_number_zeroshot": 2204,
        "token_number_fewshot": 2602,
        "token_number_cot": 2316
    },
    {
        "project_name": "jdom",
        "class": "NamespaceStack",
        "source_code": "package org.jdom2.util;\n\nimport org.jdom2.internal.*;\nimport org.jdom2.*;\nimport java.util.*;\n\npublic final class NamespaceStack implements Iterable<Namespace>\n{\n    private static final Namespace[] EMPTY;\n    private static final Iterable<Namespace> EMPTYITER;\n    private static final Comparator<Namespace> NSCOMP;\n    private static final Namespace[] DEFAULTSEED;\n    private Namespace[][] added;\n    private Namespace[][] scope;\n    private int depth;\n    \n    private static final int binarySearch(final Namespace[] data, int left, int right, final Namespace key) {\n        --right;\n        while (left <= right) {\n            final int mid = left + right >>> 1;\n            if (data[mid] == key) {\n                return mid;\n            }\n            final int cmp = NamespaceStack.NSCOMP.compare(data[mid], key);\n            if (cmp < 0) {\n                left = mid + 1;\n            }\n            else {\n                if (cmp <= 0) {\n                    return mid;\n                }\n                right = mid - 1;\n            }\n        }\n        return -left - 1;\n    }\n    \n    public NamespaceStack() {\n        this(NamespaceStack.DEFAULTSEED);\n    }\n    \n    public NamespaceStack(final Namespace[] seed) {\n        this.added = new Namespace[10][];\n        this.scope = new Namespace[10][];\n        this.depth = -1;\n        ++this.depth;\n        this.added[this.depth] = seed;\n        this.scope[this.depth] = this.added[this.depth];\n    }\n    \n    private static final Namespace[] checkNamespace(final List<Namespace> store, final Namespace namespace, final Namespace[] scope) {\n        if (namespace == scope[0]) {\n            return scope;\n        }\n        if (namespace.getPrefix().equals(scope[0].getPrefix())) {\n            store.add(namespace);\n            final Namespace[] nscope = ArrayCopy.copyOf(scope, scope.length);\n            nscope[0] = namespace;\n            return nscope;\n        }\n        int ip = binarySearch(scope, 1, scope.length, namespace);\n        if (ip >= 0 && namespace == scope[ip]) {\n            return scope;\n        }\n        store.add(namespace);\n        if (ip >= 0) {\n            final Namespace[] nscope2 = ArrayCopy.copyOf(scope, scope.length);\n            nscope2[ip] = namespace;\n            return nscope2;\n        }\n        final Namespace[] nscope2 = ArrayCopy.copyOf(scope, scope.length + 1);\n        ip = -ip - 1;\n        System.arraycopy(nscope2, ip, nscope2, ip + 1, nscope2.length - ip - 1);\n        nscope2[ip] = namespace;\n        return nscope2;\n    }\n    \n    public void push(final Element element) {\n        final List<Namespace> toadd = new ArrayList<Namespace>(8);\n        final Namespace mns = element.getNamespace();\n        Namespace[] newscope = checkNamespace(toadd, mns, this.scope[this.depth]);\n        if (element.hasAdditionalNamespaces()) {\n            for (final Namespace ns : element.getAdditionalNamespaces()) {\n                if (ns == mns) {\n                    continue;\n                }\n                newscope = checkNamespace(toadd, ns, newscope);\n            }\n        }\n        if (element.hasAttributes()) {\n            for (final Attribute a : element.getAttributes()) {\n                final Namespace ns2 = a.getNamespace();\n                if (ns2 == Namespace.NO_NAMESPACE) {\n                    continue;\n                }\n                if (ns2 == mns) {\n                    continue;\n                }\n                newscope = checkNamespace(toadd, ns2, newscope);\n            }\n        }\n        this.pushStack(mns, newscope, toadd);\n    }\n    \n    public void push(final Attribute att) {\n        final List<Namespace> toadd = new ArrayList<Namespace>(1);\n        final Namespace mns = att.getNamespace();\n        final Namespace[] newscope = checkNamespace(toadd, mns, this.scope[this.depth]);\n        this.pushStack(mns, newscope, toadd);\n    }\n    \n    private final void pushStack(final Namespace mns, Namespace[] newscope, final List<Namespace> toadd) {\n        ++this.depth;\n        if (this.depth >= this.scope.length) {\n            this.scope = ArrayCopy.copyOf(this.scope, this.scope.length * 2);\n            this.added = ArrayCopy.copyOf(this.added, this.scope.length);\n        }\n        if (toadd.isEmpty()) {\n            this.added[this.depth] = NamespaceStack.EMPTY;\n        }\n        else {\n            this.added[this.depth] = toadd.toArray(new Namespace[toadd.size()]);\n            if (this.added[this.depth][0] == mns) {\n                Arrays.sort(this.added[this.depth], 1, this.added[this.depth].length, NamespaceStack.NSCOMP);\n            }\n            else {\n                Arrays.sort(this.added[this.depth], NamespaceStack.NSCOMP);\n            }\n        }\n        if (mns != newscope[0]) {\n            if (toadd.isEmpty()) {\n                newscope = ArrayCopy.copyOf(newscope, newscope.length);\n            }\n            final Namespace tmp = newscope[0];\n            int ip = -binarySearch(newscope, 1, newscope.length, tmp) - 1;\n            --ip;\n            System.arraycopy(newscope, 1, newscope, 0, ip);\n            newscope[ip] = tmp;\n            ip = binarySearch(newscope, 0, newscope.length, mns);\n            System.arraycopy(newscope, 0, newscope, 1, ip);\n            newscope[0] = mns;\n        }\n        this.scope[this.depth] = newscope;\n    }\n    \n    public void pop() {\n        if (this.depth <= 0) {\n            throw new IllegalStateException(\"Cannot over-pop the stack.\");\n        }\n        this.scope[this.depth] = null;\n        this.added[this.depth] = null;\n        --this.depth;\n    }\n    \n    public Iterable<Namespace> addedForward() {\n        if (this.added[this.depth].length == 0) {\n            return NamespaceStack.EMPTYITER;\n        }\n        return new NamespaceIterable(this.added[this.depth], true);\n    }\n    \n    public Iterable<Namespace> addedReverse() {\n        if (this.added[this.depth].length == 0) {\n            return NamespaceStack.EMPTYITER;\n        }\n        return new NamespaceIterable(this.added[this.depth], false);\n    }\n    \n    public Iterator<Namespace> iterator() {\n        return new ForwardWalker(this.scope[this.depth]);\n    }\n    \n    public Namespace[] getScope() {\n        return ArrayCopy.copyOf(this.scope[this.depth], this.scope[this.depth].length);\n    }\n    \n    public boolean isInScope(final Namespace ns) {\n        if (ns == this.scope[this.depth][0]) {\n            return true;\n        }\n        final int ip = binarySearch(this.scope[this.depth], 1, this.scope[this.depth].length, ns);\n        return ip >= 0 && ns == this.scope[this.depth][ip];\n    }\n    \n    static {\n        EMPTY = new Namespace[0];\n        EMPTYITER = new EmptyIterable();\n        NSCOMP = new Comparator<Namespace>() {\n            public int compare(final Namespace ns1, final Namespace ns2) {\n                return ns1.getPrefix().compareTo(ns2.getPrefix());\n            }\n        };\n        DEFAULTSEED = new Namespace[] { Namespace.NO_NAMESPACE, Namespace.XML_NAMESPACE };\n    }\n    \n    private static final class ForwardWalker implements Iterator<Namespace>\n    {\n        private final Namespace[] namespaces;\n        int cursor;\n        \n        public ForwardWalker(final Namespace[] namespaces) {\n            this.cursor = 0;\n            this.namespaces = namespaces;\n        }\n        \n        public boolean hasNext() {\n            return this.cursor < this.namespaces.length;\n        }\n        \n        public Namespace next() {\n            if (this.cursor >= this.namespaces.length) {\n                throw new NoSuchElementException(\"Cannot over-iterate...\");\n            }\n            return this.namespaces[this.cursor++];\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove Namespaces from iterator\");\n        }\n    }\n    \n    private static final class BackwardWalker implements Iterator<Namespace>\n    {\n        private final Namespace[] namespaces;\n        int cursor;\n        \n        public BackwardWalker(final Namespace[] namespaces) {\n            this.cursor = -1;\n            this.namespaces = namespaces;\n            this.cursor = namespaces.length - 1;\n        }\n        \n        public boolean hasNext() {\n            return this.cursor >= 0;\n        }\n        \n        public Namespace next() {\n            if (this.cursor < 0) {\n                throw new NoSuchElementException(\"Cannot over-iterate...\");\n            }\n            return this.namespaces[this.cursor--];\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove Namespaces from iterator\");\n        }\n    }\n    \n    private static final class NamespaceIterable implements Iterable<Namespace>\n    {\n        private final boolean forward;\n        private final Namespace[] namespaces;\n        \n        public NamespaceIterable(final Namespace[] data, final boolean forward) {\n            this.forward = forward;\n            this.namespaces = data;\n        }\n        \n        public Iterator<Namespace> iterator() {\n            return this.forward ? new ForwardWalker(this.namespaces) : new BackwardWalker(this.namespaces);\n        }\n    }\n    \n    private static final class EmptyIterable implements Iterable<Namespace>, Iterator<Namespace>\n    {\n        public Iterator<Namespace> iterator() {\n            return this;\n        }\n        \n        public boolean hasNext() {\n            return false;\n        }\n        \n        public Namespace next() {\n            throw new NoSuchElementException(\"Can not call next() on an empty Iterator.\");\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove Namespaces from iterator\");\n        }\n    }\n}\n",
        "token_number_zeroshot": 2047,
        "token_number_fewshot": 2445,
        "token_number_cot": 2158
    },
    {
        "project_name": "jdom",
        "class": "XMLOutputter",
        "source_code": "package org.jdom2.output;\n\nimport java.util.*;\nimport org.jdom2.*;\nimport java.io.*;\nimport org.jdom2.output.support.*;\n\npublic final class XMLOutputter implements Cloneable\n{\n    private static final DefaultXMLProcessor DEFAULTPROCESSOR;\n    private Format myFormat;\n    private XMLOutputProcessor myProcessor;\n    \n    private static final Writer makeWriter(final OutputStream out, final Format format) throws UnsupportedEncodingException {\n        return new BufferedWriter(new OutputStreamWriter(new BufferedOutputStream(out), format.getEncoding()));\n    }\n    \n    public XMLOutputter(final Format format, final XMLOutputProcessor processor) {\n        this.myFormat = null;\n        this.myProcessor = null;\n        this.myFormat = ((format == null) ? Format.getRawFormat() : format.clone());\n        this.myProcessor = ((processor == null) ? XMLOutputter.DEFAULTPROCESSOR : processor);\n    }\n    \n    public XMLOutputter() {\n        this(null, null);\n    }\n    \n    public XMLOutputter(final XMLOutputter that) {\n        this(that.myFormat, null);\n    }\n    \n    public XMLOutputter(final Format format) {\n        this(format, null);\n    }\n    \n    public XMLOutputter(final XMLOutputProcessor processor) {\n        this(null, processor);\n    }\n    \n    public void setFormat(final Format newFormat) {\n        this.myFormat = newFormat.clone();\n    }\n    \n    public Format getFormat() {\n        return this.myFormat;\n    }\n    \n    public XMLOutputProcessor getXMLOutputProcessor() {\n        return this.myProcessor;\n    }\n    \n    public void setXMLOutputProcessor(final XMLOutputProcessor processor) {\n        this.myProcessor = processor;\n    }\n    \n    public final void output(final Document doc, final OutputStream out) throws IOException {\n        this.output(doc, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final DocType doctype, final OutputStream out) throws IOException {\n        this.output(doctype, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final Element element, final OutputStream out) throws IOException {\n        this.output(element, makeWriter(out, this.myFormat));\n    }\n    \n    public final void outputElementContent(final Element element, final OutputStream out) throws IOException {\n        this.outputElementContent(element, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final List<? extends Content> list, final OutputStream out) throws IOException {\n        this.output(list, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final CDATA cdata, final OutputStream out) throws IOException {\n        this.output(cdata, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final Text text, final OutputStream out) throws IOException {\n        this.output(text, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final Comment comment, final OutputStream out) throws IOException {\n        this.output(comment, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final ProcessingInstruction pi, final OutputStream out) throws IOException {\n        this.output(pi, makeWriter(out, this.myFormat));\n    }\n    \n    public void output(final EntityRef entity, final OutputStream out) throws IOException {\n        this.output(entity, makeWriter(out, this.myFormat));\n    }\n    \n    public final String outputString(final Document doc) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(doc, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final DocType doctype) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(doctype, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final Element element) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(element, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final List<? extends Content> list) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(list, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final CDATA cdata) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(cdata, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final Text text) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(text, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final Comment comment) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(comment, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final ProcessingInstruction pi) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(pi, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final EntityRef entity) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(entity, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputElementContentString(final Element element) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.outputElementContent(element, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final void output(final Document doc, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, doc);\n        out.flush();\n    }\n    \n    public final void output(final DocType doctype, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, doctype);\n        out.flush();\n    }\n    \n    public final void output(final Element element, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, element);\n        out.flush();\n    }\n    \n    public final void outputElementContent(final Element element, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, element.getContent());\n        out.flush();\n    }\n    \n    public final void output(final List<? extends Content> list, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, list);\n        out.flush();\n    }\n    \n    public final void output(final CDATA cdata, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, cdata);\n        out.flush();\n    }\n    \n    public final void output(final Text text, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, text);\n        out.flush();\n    }\n    \n    public final void output(final Comment comment, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, comment);\n        out.flush();\n    }\n    \n    public final void output(final ProcessingInstruction pi, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, pi);\n        out.flush();\n    }\n    \n    public final void output(final EntityRef entity, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, entity);\n        out.flush();\n    }\n    \n    public String escapeAttributeEntities(final String str) {\n        return XMLOutputter.DEFAULTPROCESSOR.escapeAttributeEntities(str, this.myFormat);\n    }\n    \n    public String escapeElementEntities(final String str) {\n        return XMLOutputter.DEFAULTPROCESSOR.escapeElementEntities(str, this.myFormat);\n    }\n    \n    public XMLOutputter clone() {\n        try {\n            return (XMLOutputter)super.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e.toString());\n        }\n    }\n    \n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(\"XMLOutputter[omitDeclaration = \");\n        buffer.append(this.myFormat.omitDeclaration);\n        buffer.append(\", \");\n        buffer.append(\"encoding = \");\n        buffer.append(this.myFormat.encoding);\n        buffer.append(\", \");\n        buffer.append(\"omitEncoding = \");\n        buffer.append(this.myFormat.omitEncoding);\n        buffer.append(\", \");\n        buffer.append(\"indent = '\");\n        buffer.append(this.myFormat.indent);\n        buffer.append(\"'\");\n        buffer.append(\", \");\n        buffer.append(\"expandEmptyElements = \");\n        buffer.append(this.myFormat.expandEmptyElements);\n        buffer.append(\", \");\n        buffer.append(\"lineSeparator = '\");\n        for (final char ch : this.myFormat.lineSeparator.toCharArray()) {\n            switch (ch) {\n                case '\\r': {\n                    buffer.append(\"\\\\r\");\n                    break;\n                }\n                case '\\n': {\n                    buffer.append(\"\\\\n\");\n                    break;\n                }\n                case '\\t': {\n                    buffer.append(\"\\\\t\");\n                    break;\n                }\n                default: {\n                    buffer.append(\"[\" + (int)ch + \"]\");\n                    break;\n                }\n            }\n        }\n        buffer.append(\"', \");\n        buffer.append(\"textMode = \");\n        buffer.append(this.myFormat.mode + \"]\");\n        return buffer.toString();\n    }\n    \n    static {\n        DEFAULTPROCESSOR = new DefaultXMLProcessor();\n    }\n    \n    private static final class DefaultXMLProcessor extends AbstractXMLOutputProcessor\n    {\n        public String escapeAttributeEntities(final String str, final Format format) {\n            final StringWriter sw = new StringWriter();\n            try {\n                super.attributeEscapedEntitiesFilter(sw, new FormatStack(format), str);\n            }\n            catch (IOException ex) {}\n            return sw.toString();\n        }\n        \n        public final String escapeElementEntities(final String str, final Format format) {\n            return Format.escapeText(format.getEscapeStrategy(), format.getLineSeparator(), str);\n        }\n    }\n}\n",
        "token_number_zeroshot": 2105,
        "token_number_fewshot": 2503,
        "token_number_cot": 2219
    },
    {
        "project_name": "64_jtailgui",
        "class": "IndexFileAction",
        "source_code": "package fr.pingtimeout.jtail.gui.action;\n\nimport java.awt.event.*;\nimport fr.pingtimeout.jtail.util.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport fr.pingtimeout.jtail.gui.message.*;\nimport fr.pingtimeout.jtail.gui.controller.*;\nimport fr.pingtimeout.jtail.io.index.*;\nimport java.util.*;\nimport fr.pingtimeout.jtail.io.*;\nimport fr.pingtimeout.jtail.gui.model.*;\nimport java.io.*;\n\npublic class IndexFileAction extends JTailAbstractAction implements Observer\n{\n    private static final ResourceBundle bundle;\n    private static final ImageIcon OPEN_ICON;\n    private final JTailMainModel jTailMainModel;\n    private final OpenFileModel openFileModel;\n    \n    public IndexFileAction(final JTailMainModel jTailMainModel, final OpenFileModel openFileModel) {\n        super(IndexFileAction.bundle.getString(\"action.open.label\"), IndexFileAction.bundle.getString(\"action.open.tooltip\"), IndexFileAction.bundle.getString(\"action.open.mnemonic\"), IndexFileAction.bundle.getString(\"action.open.accelerator\"), IndexFileAction.OPEN_ICON);\n        this.jTailMainModel = jTailMainModel;\n        this.openFileModel = openFileModel;\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent actionEvent) {\n        JTailLogger.debug(\"File : {}\", this.openFileModel.getFile());\n        JTailLogger.debug(\"Index type : {}\", this.openFileModel.getIndexType());\n        Component dialog;\n        for (dialog = (Component)actionEvent.getSource(); !(dialog instanceof JDialog); dialog = dialog.getParent()) {}\n        dialog.setVisible(false);\n        if (this.openFileModel.getFile() == null) {\n            InformationHandler.handle(true, UIMessage.INFO_NO_FILE_SELECTED, new Object[0]);\n            return;\n        }\n        Class<? extends FileIndex> indexerClass = null;\n        switch (this.openFileModel.getIndexType()) {\n            case MEMORY_BASED: {\n                indexerClass = RamFileIndex.class;\n                break;\n            }\n            case FILE_BASED: {\n                indexerClass = RomFileIndex.class;\n                break;\n            }\n        }\n        FileIndexer fileIndexer;\n        try {\n            fileIndexer = new FileIndexer(this.openFileModel.getFile(), indexerClass);\n            fileIndexer.addObserver(this);\n        }\n        catch (FileNotFoundException e) {\n            ExceptionHandler.handle(e, UIMessage.ERROR_FILE_NOT_FOUND, this.openFileModel.getFile().getName());\n            return;\n        }\n        final FileIndexerWorker fileIndexerWorker = new FileIndexerWorker(fileIndexer);\n        fileIndexerWorker.execute();\n    }\n    \n    @Override\n    public void update(final Observable o, final Object arg) {\n        JTailLogger.debug(\"Notification received : {} emitted by {}\", arg, o);\n        if ((int)arg == 100) {\n            final FileIndexer fileIndexer = (FileIndexer)o;\n            final File file = fileIndexer.getFile();\n            try {\n                final LineReader lineReader = new LineReader(file, fileIndexer.getIndex());\n                final JTailModel model = new JTailModel(file, lineReader);\n                this.jTailMainModel.add(model);\n            }\n            catch (FileNotFoundException e) {\n                ExceptionHandler.handle(e, UIMessage.ERROR_FILE_NOT_FOUND, file.getName());\n            }\n            catch (Exception e2) {\n                ExceptionHandler.handle(e2, UIMessage.ERROR_GENERIC_MESSAGE, new Object[0]);\n            }\n        }\n    }\n    \n    static {\n        bundle = ResourceBundle.getBundle(\"fr.pingtimeout.jtail.gui.language\");\n        OPEN_ICON = new ImageIcon(OpenFileAction.class.getResource(\"add16.png\"));\n    }\n}\n",
        "token_number_zeroshot": 766,
        "token_number_fewshot": 1164,
        "token_number_cot": 878
    },
    {
        "project_name": "64_jtailgui",
        "class": "JTailPanel",
        "source_code": "package fr.pingtimeout.jtail.gui.view;\n\nimport fr.pingtimeout.jtail.util.*;\nimport fr.pingtimeout.jtail.gui.controller.*;\nimport java.awt.event.*;\nimport java.awt.*;\nimport java.util.*;\nimport fr.pingtimeout.jtail.gui.model.*;\nimport javax.swing.*;\nimport javax.swing.table.*;\n\npublic class JTailPanel extends JPanel implements Observer\n{\n    final JTailModel model;\n    final JScrollPane scrollPane;\n    final JScrollBar verticalScrollBar;\n    final JTable dataTable;\n    final DefaultTableModel tableModel;\n    final int characterHeight;\n    private int maxCharacterWidth;\n    \n    public JTailPanel(final JTailModel model) {\n        JTailLogger.debug(\"Building a new JTailPanel\");\n        (this.model = model).addObserver(this);\n        this.verticalScrollBar = new JScrollBar();\n        this.tableModel = new DefaultTableModel(new String[] { \"#\", \"\" }, 0) {\n            @Override\n            public boolean isCellEditable(final int row, final int col) {\n                return false;\n            }\n        };\n        this.dataTable = new JTable(this.tableModel);\n        (this.scrollPane = new JScrollPane(this.dataTable)).setVerticalScrollBarPolicy(21);\n        this.scrollPane.setHorizontalScrollBarPolicy(30);\n        this.verticalScrollBar.addAdjustmentListener(new ScrollBarAdjustmentController(this, this.model));\n        this.addComponentListener(new JTailSizeController(this, this.model));\n        this.setLayout(new BorderLayout());\n        this.add(this.scrollPane, \"Center\");\n        this.add(this.verticalScrollBar, \"East\");\n        final FontMetrics metrics = this.dataTable.getFontMetrics(this.dataTable.getFont());\n        this.characterHeight = metrics.getHeight() - 1;\n        this.maxCharacterWidth = metrics.stringWidth(\"0\") + 2;\n    }\n    \n    public int getCharacterHeight() {\n        return this.characterHeight;\n    }\n    \n    public JScrollBar getVerticalScrollBar() {\n        return this.verticalScrollBar;\n    }\n    \n    @Override\n    public void update(final Observable observable, final Object arg) {\n        if (observable == this.model) {\n            final JTailModelEvent event = (JTailModelEvent)arg;\n            JTailLogger.debug(\"JTailPanel just received a notification : \" + arg);\n            if (event.type == JTailModelEvent.Type.RESIZED) {\n                JTailLogger.debug(\"The window has beed resized\");\n                final BoundedRangeModel rangeModel = this.verticalScrollBar.getModel();\n                rangeModel.setValueIsAdjusting(true);\n                rangeModel.setMinimum(event.minLine);\n                rangeModel.setValue(event.firstLine);\n                rangeModel.setExtent(event.nbDisplayedLines);\n                rangeModel.setMaximum(event.maxLine);\n                rangeModel.setValueIsAdjusting(false);\n                if (event.minLine == event.firstLine && event.maxLine == event.nbDisplayedLines) {\n                    this.verticalScrollBar.setEnabled(false);\n                }\n                else if (!this.verticalScrollBar.isEnabled()) {\n                    this.verticalScrollBar.setEnabled(true);\n                }\n                this.updateDataTable(this.model.getLineNumbers(), this.model.getContent());\n            }\n            else if (event.type == JTailModelEvent.Type.SCROLLED) {\n                JTailLogger.debug(\"The user scrolled the file\");\n                final String lineNumbers = this.model.getLineNumbers();\n                this.updateDataTable(this.model.getLineNumbers(), this.model.getContent());\n            }\n        }\n    }\n    \n    private void updateDataTable(final String lineNumbers, final String lines) {\n        while (this.tableModel.getRowCount() > 0) {\n            this.tableModel.removeRow(0);\n        }\n        final String[] lineNumbersArray = lineNumbers.split(\"\\n\");\n        final String[] linesArray = lines.split(\"\\n\");\n        for (int i = 0; i < lineNumbersArray.length; ++i) {\n            final String lineNumberTmp = lineNumbersArray[i];\n            final String lineTmp = (i < linesArray.length) ? linesArray[i] : \"\";\n            this.tableModel.addRow(new String[] { lineNumberTmp, lineTmp });\n        }\n        this.dataTable.setAutoResizeMode(3);\n        JTailLogger.debug(\"Resizing column widths\");\n        JTailLogger.debug(\"DataTable width : {}\", this.dataTable.getWidth());\n        JTailLogger.debug(\"Highest line number : {}\", lineNumbersArray[lineNumbersArray.length - 1]);\n        final TableColumn numbersColumn = this.dataTable.getColumnModel().getColumn(0);\n        final TableColumn linesColumn = this.dataTable.getColumnModel().getColumn(1);\n        final int numbersColumnWidth = lineNumbersArray[lineNumbersArray.length - 1].length() * this.maxCharacterWidth;\n        final int linesColumnWidth = this.dataTable.getWidth() - numbersColumnWidth;\n        JTailLogger.debug(\"numbersColumnWidth : {}\", numbersColumnWidth);\n        JTailLogger.debug(\"linesColumnWidth : {}\", linesColumnWidth);\n        numbersColumn.setPreferredWidth(numbersColumnWidth);\n        linesColumn.setPreferredWidth(linesColumnWidth);\n    }\n}\n",
        "token_number_zeroshot": 1017,
        "token_number_fewshot": 1415,
        "token_number_cot": 1129
    },
    {
        "project_name": "24_saxpath",
        "class": "Axis",
        "source_code": "package org.saxpath;\n\npublic class Axis\n{\n    public static final int INVALID_AXIS = 0;\n    public static final int CHILD = 1;\n    public static final int DESCENDANT = 2;\n    public static final int PARENT = 3;\n    public static final int ANCESTOR = 4;\n    public static final int FOLLOWING_SIBLING = 5;\n    public static final int PRECEDING_SIBLING = 6;\n    public static final int FOLLOWING = 7;\n    public static final int PRECEDING = 8;\n    public static final int ATTRIBUTE = 9;\n    public static final int NAMESPACE = 10;\n    public static final int SELF = 11;\n    public static final int DESCENDANT_OR_SELF = 12;\n    public static final int ANCESTOR_OR_SELF = 13;\n    \n    public static String lookup(final int axisNum) {\n        switch (axisNum) {\n            case 1: {\n                return \"child\";\n            }\n            case 2: {\n                return \"descendant\";\n            }\n            case 3: {\n                return \"parent\";\n            }\n            case 4: {\n                return \"ancestor\";\n            }\n            case 5: {\n                return \"following-sibling\";\n            }\n            case 6: {\n                return \"preceding-sibling\";\n            }\n            case 7: {\n                return \"following\";\n            }\n            case 8: {\n                return \"preceding\";\n            }\n            case 9: {\n                return \"attribute\";\n            }\n            case 10: {\n                return \"namespace\";\n            }\n            case 11: {\n                return \"self\";\n            }\n            case 12: {\n                return \"descendant-or-self\";\n            }\n            case 13: {\n                return \"ancestor-or-self\";\n            }\n            default: {\n                return null;\n            }\n        }\n    }\n    \n    public static int lookup(final String axisName) {\n        if (\"child\".equals(axisName)) {\n            return 1;\n        }\n        if (\"descendant\".equals(axisName)) {\n            return 2;\n        }\n        if (\"parent\".equals(axisName)) {\n            return 3;\n        }\n        if (\"ancestor\".equals(axisName)) {\n            return 4;\n        }\n        if (\"following-sibling\".equals(axisName)) {\n            return 5;\n        }\n        if (\"preceding-sibling\".equals(axisName)) {\n            return 6;\n        }\n        if (\"following\".equals(axisName)) {\n            return 7;\n        }\n        if (\"preceding\".equals(axisName)) {\n            return 8;\n        }\n        if (\"attribute\".equals(axisName)) {\n            return 9;\n        }\n        if (\"namespace\".equals(axisName)) {\n            return 10;\n        }\n        if (\"self\".equals(axisName)) {\n            return 11;\n        }\n        if (\"descendant-or-self\".equals(axisName)) {\n            return 12;\n        }\n        if (\"ancestor-or-self\".equals(axisName)) {\n            return 13;\n        }\n        return 0;\n    }\n}\n",
        "token_number_zeroshot": 677,
        "token_number_fewshot": 1075,
        "token_number_cot": 787
    },
    {
        "project_name": "24_saxpath",
        "class": "XPathLexer",
        "source_code": "package com.werken.saxpath;\n\nclass XPathLexer\n{\n    private String xpath;\n    private int currentPosition;\n    private int endPosition;\n    private Token previousToken;\n    \n    public XPathLexer(final String xpath) {\n        this.setXPath(xpath);\n    }\n    \n    XPathLexer() {\n    }\n    \n    void setXPath(final String xpath) {\n        this.xpath = xpath;\n        this.currentPosition = 0;\n        this.endPosition = xpath.length();\n    }\n    \n    public String getXPath() {\n        return this.xpath;\n    }\n    \n    public Token nextToken() {\n        Token token = null;\n        do {\n            token = null;\n            Label_0769: {\n                switch (this.LA(1)) {\n                    case '$': {\n                        token = this.dollar();\n                        break;\n                    }\n                    case '\\\"':\n                    case '\\'': {\n                        token = this.literal();\n                        break;\n                    }\n                    case '/': {\n                        token = this.slashes();\n                        break;\n                    }\n                    case ',': {\n                        token = this.comma();\n                        break;\n                    }\n                    case '(': {\n                        token = this.leftParen();\n                        break;\n                    }\n                    case ')': {\n                        token = this.rightParen();\n                        break;\n                    }\n                    case '[': {\n                        token = this.leftBracket();\n                        break;\n                    }\n                    case ']': {\n                        token = this.rightBracket();\n                        break;\n                    }\n                    case '+': {\n                        token = this.plus();\n                        break;\n                    }\n                    case '-': {\n                        token = this.minus();\n                        break;\n                    }\n                    case '<':\n                    case '>': {\n                        token = this.relationalOperator();\n                        break;\n                    }\n                    case '=': {\n                        token = this.equals();\n                        break;\n                    }\n                    case '!': {\n                        if (this.LA(2) == '=') {\n                            token = this.notEquals();\n                            break;\n                        }\n                        token = this.not();\n                        break;\n                    }\n                    case '|': {\n                        token = this.pipe();\n                        break;\n                    }\n                    case '@': {\n                        token = this.at();\n                        break;\n                    }\n                    case ':': {\n                        if (this.LA(2) == ':') {\n                            token = this.doubleColon();\n                            break;\n                        }\n                        token = this.colon();\n                        break;\n                    }\n                    case '*': {\n                        token = this.star();\n                        break;\n                    }\n                    case '.': {\n                        switch (this.LA(2)) {\n                            case '0':\n                            case '1':\n                            case '2':\n                            case '3':\n                            case '4':\n                            case '5':\n                            case '6':\n                            case '7':\n                            case '8':\n                            case '9': {\n                                token = this.number();\n                                break Label_0769;\n                            }\n                            default: {\n                                token = this.dots();\n                                break Label_0769;\n                            }\n                        }\n                        break;\n                    }\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9': {\n                        token = this.number();\n                        break;\n                    }\n                    case '\\t':\n                    case '\\n':\n                    case '\\r':\n                    case ' ': {\n                        token = this.whitespace();\n                        break;\n                    }\n                    default: {\n                        if (this.isIdentifierStartChar(this.LA(1))) {\n                            token = this.identifierOrOperatorName();\n                            break;\n                        }\n                        break;\n                    }\n                }\n            }\n            if (token == null) {\n                token = new Token(-1, this.getXPath(), this.currentPosition(), this.endPosition());\n            }\n        } while (token.getTokenType() == -2);\n        this.setPreviousToken(token);\n        return token;\n    }\n    \n    Token identifierOrOperatorName() {\n        Token token = null;\n        final Token previousToken = this.getPreviousToken();\n        if (previousToken != null) {\n            switch (previousToken.getTokenType()) {\n                case 1:\n                case 3:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                case 10:\n                case 11:\n                case 12:\n                case 16:\n                case 17:\n                case 18:\n                case 19:\n                case 20:\n                case 21:\n                case 22:\n                case 24:\n                case 25:\n                case 26:\n                case 28:\n                case 29:\n                case 32: {\n                    token = this.identifier();\n                    break;\n                }\n                default: {\n                    token = this.operatorName();\n                    break;\n                }\n            }\n        }\n        else {\n            token = this.identifier();\n        }\n        return token;\n    }\n    \n    Token identifier() {\n        Token token = null;\n        final int start = this.currentPosition();\n        while (this.hasMoreChars() && this.isIdentifierChar(this.LA(1))) {\n            this.consume();\n        }\n        token = new Token(15, this.getXPath(), start, this.currentPosition());\n        return token;\n    }\n    \n    Token operatorName() {\n        Token token = null;\n        switch (this.LA(1)) {\n            case 'a': {\n                token = this.and();\n                break;\n            }\n            case 'o': {\n                token = this.or();\n                break;\n            }\n            case 'm': {\n                token = this.mod();\n                break;\n            }\n            case 'd': {\n                token = this.div();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    Token mod() {\n        Token token = null;\n        if (this.LA(1) == 'm' && this.LA(2) == 'o' && this.LA(3) == 'd' && !this.isIdentifierChar(this.LA(4))) {\n            token = new Token(25, this.getXPath(), this.currentPosition(), this.currentPosition() + 3);\n            this.consume();\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token div() {\n        Token token = null;\n        if (this.LA(1) == 'd' && this.LA(2) == 'i' && this.LA(3) == 'v' && !this.isIdentifierChar(this.LA(4))) {\n            token = new Token(24, this.getXPath(), this.currentPosition(), this.currentPosition() + 3);\n            this.consume();\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token and() {\n        Token token = null;\n        if (this.LA(1) == 'a' && this.LA(2) == 'n' && this.LA(3) == 'd' && !this.isIdentifierChar(this.LA(4))) {\n            token = new Token(28, this.getXPath(), this.currentPosition(), this.currentPosition() + 3);\n            this.consume();\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token or() {\n        Token token = null;\n        if (this.LA(1) == 'o' && this.LA(2) == 'r' && !this.isIdentifierChar(this.LA(3))) {\n            token = new Token(29, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token number() {\n        final int start = this.currentPosition();\n        boolean periodAllowed = true;\n    Label_0099:\n        while (true) {\n            switch (this.LA(1)) {\n                case '.': {\n                    if (periodAllowed) {\n                        periodAllowed = false;\n                        this.consume();\n                        continue;\n                    }\n                    break Label_0099;\n                }\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9': {\n                    this.consume();\n                    continue;\n                }\n                default: {\n                    break Label_0099;\n                }\n            }\n        }\n        Token token = null;\n        if (periodAllowed) {\n            token = new Token(30, this.getXPath(), start, this.currentPosition());\n        }\n        else {\n            token = new Token(31, this.getXPath(), start, this.currentPosition());\n        }\n        return token;\n    }\n    \n    Token whitespace() {\n        this.consume();\n    Label_0070:\n        while (this.hasMoreChars()) {\n            switch (this.LA(1)) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case ' ': {\n                    this.consume();\n                    continue;\n                }\n                default: {\n                    break Label_0070;\n                }\n            }\n        }\n        return new Token(-2, this.getXPath(), 0, 0);\n    }\n    \n    Token comma() {\n        final Token token = new Token(32, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token equals() {\n        final Token token = new Token(21, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token minus() {\n        final Token token = new Token(6, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token plus() {\n        final Token token = new Token(5, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token dollar() {\n        final Token token = new Token(26, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token pipe() {\n        final Token token = new Token(17, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token at() {\n        final Token token = new Token(16, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token colon() {\n        final Token token = new Token(18, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token doubleColon() {\n        final Token token = new Token(19, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n        this.consume();\n        this.consume();\n        return token;\n    }\n    \n    Token not() {\n        final Token token = new Token(23, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token notEquals() {\n        final Token token = new Token(22, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n        this.consume();\n        this.consume();\n        return token;\n    }\n    \n    Token relationalOperator() {\n        Token token = null;\n        switch (this.LA(1)) {\n            case '<': {\n                if (this.LA(2) == '=') {\n                    token = new Token(8, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                    this.consume();\n                }\n                else {\n                    token = new Token(7, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                }\n                this.consume();\n                break;\n            }\n            case '>': {\n                if (this.LA(2) == '=') {\n                    token = new Token(10, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                    this.consume();\n                }\n                else {\n                    token = new Token(9, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                }\n                this.consume();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    Token star() {\n        final Token token = new Token(20, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token literal() {\n        Token token = null;\n        final char match = this.LA(1);\n        this.consume();\n        final int start = this.currentPosition();\n        while (token == null && this.hasMoreChars()) {\n            if (this.LA(1) == match) {\n                token = new Token(27, this.getXPath(), start, this.currentPosition());\n            }\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token dots() {\n        Token token = null;\n        switch (this.LA(2)) {\n            case '.': {\n                token = new Token(14, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                this.consume();\n                this.consume();\n                break;\n            }\n            default: {\n                token = new Token(13, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                this.consume();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    Token leftBracket() {\n        final Token token = new Token(3, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token rightBracket() {\n        final Token token = new Token(4, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token leftParen() {\n        final Token token = new Token(1, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token rightParen() {\n        final Token token = new Token(2, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token slashes() {\n        Token token = null;\n        switch (this.LA(2)) {\n            case '/': {\n                token = new Token(12, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                this.consume();\n                this.consume();\n                break;\n            }\n            default: {\n                token = new Token(11, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                this.consume();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    char LA(final int i) {\n        if (this.currentPosition + (i - 1) >= this.endPosition()) {\n            return '\\uffff';\n        }\n        return this.getXPath().charAt(this.currentPosition() + (i - 1));\n    }\n    \n    void consume() {\n        ++this.currentPosition;\n    }\n    \n    void consume(final int i) {\n        this.currentPosition += i;\n    }\n    \n    int currentPosition() {\n        return this.currentPosition;\n    }\n    \n    int endPosition() {\n        return this.endPosition;\n    }\n    \n    Token getPreviousToken() {\n        return this.previousToken;\n    }\n    \n    void setPreviousToken(final Token previousToken) {\n        this.previousToken = previousToken;\n    }\n    \n    boolean hasMoreChars() {\n        return this.currentPosition() < this.endPosition();\n    }\n    \n    boolean isIdentifierChar(final char c) {\n        switch (c) {\n            case '-':\n            case '.': {\n                return true;\n            }\n            default: {\n                return Character.isUnicodeIdentifierPart(c);\n            }\n        }\n    }\n    \n    boolean isIdentifierStartChar(final char c) {\n        return c == '_' || Character.isUnicodeIdentifierStart(c);\n    }\n}\n",
        "token_number_zeroshot": 3341,
        "token_number_fewshot": 3739,
        "token_number_cot": 3452
    },
    {
        "project_name": "88_jopenchart",
        "class": "CoordSystemUtilities",
        "source_code": "package de.progra.charting;\n\nimport de.progra.charting.model.*;\nimport java.text.*;\nimport java.awt.font.*;\nimport java.awt.geom.*;\nimport java.awt.*;\n\npublic class CoordSystemUtilities\n{\n    protected final int marginOffset = 6;\n    protected CoordSystem c;\n    protected ChartDataModelConstraints constraints;\n    protected ChartDataModelConstraints constraints2;\n    protected ChartDataModel model;\n    \n    public CoordSystemUtilities(final CoordSystem coord, final ChartDataModelConstraints constraints, final ChartDataModelConstraints constraints2, final ChartDataModel model) {\n        this.c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n    \n    public int computeLeftMargin() {\n        double xmin = this.constraints.getMinimumColumnValue();\n        double xmax = this.constraints.getMaximumColumnValue();\n        if (xmin <= 0.0 && xmax > 0.0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            final TextLayout layout = new TextLayout(this.c.getYAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n            int maxlmargin = this.computeYAxisLabelWidth() + 6;\n            maxlmargin = Math.max(maxlmargin, (int)layout.getBounds().getWidth() + 6);\n            int margin = (int)(maxlmargin - xmin / (xmin + xmax) * (this.c.getBounds().getWidth() - this.c.getRightMargin()));\n            margin += 5;\n            final int n = margin;\n            this.c.getClass();\n            if (n < 20) {\n                this.c.getClass();\n                margin = 20;\n            }\n            return margin;\n        }\n        this.c.getClass();\n        return 20;\n    }\n    \n    public int computeRightMargin() {\n        final TextLayout layout = new TextLayout(this.c.getXAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n        final double width = layout.getBounds().getWidth();\n        this.c.getClass();\n        final int n = (int)(width + 15.0 / 3.0);\n        this.c.getClass();\n        return Math.max(n, 15);\n    }\n    \n    public int computeTopMargin() {\n        final TextLayout layout = new TextLayout(this.c.getYAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n        final double height = layout.getBounds().getHeight();\n        this.c.getClass();\n        final int n = (int)(height + 15.0 / 3.0 + layout.getDescent());\n        this.c.getClass();\n        return Math.max(n, 15);\n    }\n    \n    public int computeBottomMargin() {\n        double ymin = this.constraints.getMinimumValue().doubleValue();\n        double ymax = this.constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0.0 && ymax > 0.0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            final TextLayout layout = new TextLayout(this.c.getXAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n            int maxbmargin = this.computeXAxisLabelHeight() + 6;\n            maxbmargin = Math.max(maxbmargin, (int)layout.getBounds().getHeight() + 6);\n            int margin = (int)(maxbmargin - ymin / (ymin + ymax) * (this.c.getBounds().getHeight() - this.c.getTopMargin()));\n            margin += 10;\n            final int n = margin;\n            this.c.getClass();\n            if (n < 20) {\n                this.c.getClass();\n                margin = 20;\n            }\n            return margin;\n        }\n        this.c.getClass();\n        return 20;\n    }\n    \n    public int computeXAxisLabelHeight() {\n        final double min = this.constraints.getMinimumColumnValue();\n        final double max = this.constraints.getMaximumColumnValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0.0;\n        int height = 0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        boolean paint = false;\n        final DecimalFormat df = this.c.getXDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int)r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n    \n    public int computeYAxisLabelWidth() {\n        final double min = this.constraints.getMinimumValue().doubleValue();\n        final double max = this.constraints.getMaximumValue().doubleValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0.0;\n        int width = 0;\n        if (this.constraints.getMinimumColumnValue() > 0.0) {\n            xpt = this.constraints.getMinimumColumnValue();\n        }\n        else if (this.constraints.getMaximumColumnValue() < 0.0 && this.c.getSecondYAxis() != null) {\n            xpt = this.constraints.getMaximumColumnValue();\n        }\n        boolean paint = false;\n        final DecimalFormat df = this.c.getYDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int)r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n    \n    public void drawNumericalXAxisTicks(final Graphics2D g) {\n        final AffineTransform at = this.c.getTransform(0);\n        final double min = this.constraints.getMinimumColumnValue();\n        final double max = this.constraints.getMaximumColumnValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0.0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        final Point2D p = new Point2D.Double(0.0, 0.0);\n        final Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        final DecimalFormat df = this.c.getXDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        final boolean paintLabels = this.c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            final Point2D v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - 3.0, v.getX(), v.getY() + 3.0);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float)(v.getX() - r.getWidth() / 2.0), (float)(v.getY() + r.getHeight() + 6.0));\n            }\n            paint = !paint;\n        }\n    }\n    \n    public void drawXAxisTicks(final Graphics2D g) {\n        final AffineTransform at = this.c.getTransform(0);\n        final int min = (int)this.constraints.getMinimumColumnValue();\n        final int max = (int)this.constraints.getMaximumColumnValue();\n        final double tick = 1.0;\n        double ypt = 0.0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        final Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        final Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        final DecimalFormat df = this.c.getXDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        final boolean paint = false;\n        final boolean paintLabels = this.c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; ++i) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - 3.0, v.getX(), v.getY() + 3.0);\n            if (i + 1 < max) {\n                g.draw(ticks);\n            }\n            if (oldv != null && paintLabels) {\n                final String sb = (String)this.model.getColumnValueAt(i);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float)(oldv.getX() + (v.getX() - oldv.getX()) / 2.0 - r.getWidth() / 2.0), (float)(v.getY() + r.getHeight() + 6.0));\n            }\n            oldv = v;\n        }\n    }\n    \n    public void drawYAxisTicks(final Graphics2D g) {\n        final AffineTransform at = this.c.getTransform(0);\n        final double min = this.constraints.getMinimumValue().doubleValue();\n        final double max = this.constraints.getMaximumValue().doubleValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0.0;\n        if (this.constraints.getMinimumColumnValue() > 0.0) {\n            xpt = this.constraints.getMinimumColumnValue();\n        }\n        else if (this.constraints.getMaximumColumnValue() < 0.0 && this.c.getSecondYAxis() != null) {\n            xpt = this.constraints.getMaximumColumnValue();\n        }\n        final Point2D p = new Point2D.Double(0.0, 0.0);\n        final Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        final DecimalFormat df = this.c.getYDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        final Color backupColor = g.getColor();\n        g.setFont(f);\n        final boolean paintLabels = this.c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            final Point2D v = at.transform(p, null);\n            ticks.setLine(v.getX() - 3.0, v.getY(), v.getX() + 3.0, v.getY());\n            g.draw(ticks);\n            if (d != min && !this.c.isPaintOnlyTick()) {\n                final Line2D xax = this.getXAxisLine2D();\n                ticks.setLine(v.getX() + 3.0, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !this.c.isPaintAltTick())) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float)(v.getX() - r.getWidth() - 6.0), (float)(v.getY() + r.getHeight() / 2.0));\n            }\n            paint = !paint;\n        }\n    }\n    \n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        final AffineTransform at = this.c.getTransform(0);\n        final Point2D l = at.transform(new Point2D.Double(this.constraints.getMinimumColumnValue(), ypt), null);\n        final Point2D r = at.transform(new Point2D.Double(this.constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n    \n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        if (this.constraints.getMinimumColumnValue() > 0.0) {\n            xpt = this.constraints.getMinimumColumnValue();\n        }\n        else if (this.constraints.getMaximumColumnValue() < 0.0 && this.c.getSecondYAxis() != null) {\n            xpt = this.constraints.getMaximumColumnValue();\n        }\n        final AffineTransform at = this.c.getTransform(0);\n        final Point2D o = at.transform(new Point2D.Double(xpt, this.constraints.getMaximumValue().doubleValue()), null);\n        final Point2D u = at.transform(new Point2D.Double(xpt, this.constraints.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n    \n    public Line2D getSecondYAxisLine2D() {\n        final double xpt = this.constraints2.getMaximumColumnValue();\n        final AffineTransform at = this.c.getTransform(1);\n        final Point2D o = at.transform(new Point2D.Double(xpt, this.constraints2.getMaximumValue().doubleValue()), null);\n        final Point2D u = at.transform(new Point2D.Double(xpt, this.constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n",
        "token_number_zeroshot": 3125,
        "token_number_fewshot": 3523,
        "token_number_cot": 3237
    },
    {
        "project_name": "88_jopenchart",
        "class": "DefaultChart",
        "source_code": "package de.progra.charting;\n\nimport de.progra.charting.model.*;\nimport java.awt.*;\nimport de.progra.charting.render.*;\nimport java.util.*;\n\npublic class DefaultChart extends AbstractChart\n{\n    public static int LINEAR_X_LINEAR_Y;\n    public static int NO_COORDINATE_SYSTEM;\n    \n    protected DefaultChart() {\n    }\n    \n    public DefaultChart(final ChartDataModel model, final String title) {\n        this();\n        this.setChartDataModel(model);\n        this.setRowColorModel(new RowColorModel(model));\n        this.setLegend(new Legend(this.getRowColorModel()));\n        this.setTitle(new Title(title));\n    }\n    \n    public DefaultChart(final ChartDataModel model, final String title, final int coord) {\n        this(model, title);\n        if (coord == DefaultChart.LINEAR_X_LINEAR_Y) {\n            this.setCoordSystem(new CoordSystem(model));\n        }\n    }\n    \n    public DefaultChart(final ChartDataModel model, final String title, final int coord, final String xaxis, final String yaxis) {\n        this(model, title, coord);\n        this.getCoordSystem().setXAxisUnit(xaxis);\n        this.getCoordSystem().setYAxisUnit(yaxis);\n    }\n    \n    @Override\n    public Dimension getPreferredSize() {\n        return null;\n    }\n    \n    @Override\n    public void render(final Graphics2D g) {\n        final int width = (int)this.getBounds().getWidth();\n        final int height = (int)this.getBounds().getHeight();\n        final Title t = this.getTitle();\n        final Legend l = this.getLegend();\n        final CoordSystem c = this.getCoordSystem();\n        final Collection renderer = this.getChartRenderer().values();\n        g.setColor(Color.white);\n        g.fillRect(0, 0, width, height);\n        g.setColor(Color.black);\n        int titleheight = 0;\n        int legendwidth = 0;\n        if (t != null) {\n            final Dimension title = t.getPreferredSize();\n            t.setBounds(new Rectangle(width / 2 - (int)(title.getWidth() / 2.0), 0, (int)title.getWidth(), (int)title.getHeight()));\n            t.render(g);\n            titleheight = (int)t.getBounds().getHeight();\n        }\n        if (l != null) {\n            final Dimension legend = l.getPreferredSize();\n            l.setBounds(new Rectangle((int)(width - legend.getWidth()), (int)(height / 2 - legend.getHeight() / 2.0 + titleheight), (int)legend.getWidth(), (int)legend.getHeight()));\n            l.render(g);\n            legendwidth = (int)l.getBounds().getWidth();\n        }\n        if (c != null) {\n            c.setBounds(new Rectangle(0, titleheight, width - legendwidth, height - titleheight));\n        }\n        if (!renderer.isEmpty()) {\n            for (final AbstractChartRenderer cr : renderer) {\n                cr.setBounds(new Rectangle(0, titleheight, width - legendwidth, height - titleheight - 5));\n                cr.render(g);\n            }\n        }\n        if (c != null) {\n            c.render(g);\n        }\n    }\n    \n    static {\n        DefaultChart.LINEAR_X_LINEAR_Y = 0;\n        DefaultChart.NO_COORDINATE_SYSTEM = 1;\n    }\n}\n",
        "token_number_zeroshot": 702,
        "token_number_fewshot": 1100,
        "token_number_cot": 813
    },
    {
        "project_name": "15_beanbin",
        "class": "ReflectionSearch",
        "source_code": "package net.sourceforge.beanbin.reflect;\n\nimport net.sourceforge.beanbin.search.*;\nimport java.lang.annotation.*;\nimport net.sourceforge.beanbin.*;\nimport net.sourceforge.beanbin.query.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class ReflectionSearch\n{\n    private Class clazz;\n    private Query query;\n    \n    public ReflectionSearch(final Class clazz) {\n        this.clazz = clazz;\n        this.query = new Query();\n    }\n    \n    public boolean hasAnnotation(final String term) {\n        for (final Annotation anno : this.clazz.getAnnotations()) {\n            final String name = anno.annotationType().getName();\n            final String className = name.substring(name.lastIndexOf(\".\") + 1);\n            final String termName = term.toString().substring(1);\n            if (this.hasWildcard(termName)) {\n                final WildcardSearch wild = new WildcardSearch(termName);\n                if (wild.doesMatch(name)) {\n                    return true;\n                }\n                if (wild.doesMatch(className)) {\n                    return true;\n                }\n            }\n            else {\n                if (name.equals(termName)) {\n                    return true;\n                }\n                if (className.equals(termName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean hasWildcard(final String term) {\n        return term.indexOf(\"*\") != -1;\n    }\n    \n    public ReflectionSearch methodsThatHave(final String term) throws BeanBinException {\n        this.query.add(new MethodReflectionCriteria(this.clazz, term, SearchType.EQUALS));\n        return this;\n    }\n    \n    public ReflectionSearch methodsThatDontHave(final String term) throws BeanBinException {\n        this.query.add(new MethodReflectionCriteria(this.clazz, term, SearchType.DOESNOTEQUAL));\n        return this;\n    }\n    \n    public ReflectionSearch and() {\n        this.query.setNextConditional(Conditional.AND);\n        return this;\n    }\n    \n    public ReflectionSearch or() {\n        this.query.setNextConditional(Conditional.OR);\n        return this;\n    }\n    \n    public List<Method> getMethods() throws BeanBinException {\n        List<Method> list = (List<Method>)ReflectionShelf.getInstance().get(this.query);\n        if (list == null) {\n            list = new ArrayList<Method>();\n            for (final Criteria criteria : this.query.getCriterias()) {\n                if (criteria instanceof ReflectionCriteria) {\n                    final ReflectionCriteria crit = (ReflectionCriteria)criteria;\n                    final Conditional cond = crit.getPreviousCondition();\n                    if (cond != null) {\n                        if (cond == Conditional.AND) {\n                            this.intersect(list, crit.getResults());\n                        }\n                        else {\n                            this.union(list, crit.getResults());\n                        }\n                    }\n                    else {\n                        list = crit.getResults();\n                    }\n                }\n            }\n            ReflectionShelf.getInstance().put(this.query, list);\n        }\n        return list;\n    }\n    \n    protected void intersect(final List<Method> master, final List<Method> toadd) {\n        for (int i = 0; i < master.size(); ++i) {\n            if (!toadd.contains(master.get(i))) {\n                master.remove(i--);\n            }\n        }\n    }\n    \n    protected void union(final List<Method> master, final List<Method> toadd) {\n        for (final Method method : toadd) {\n            if (!master.contains(method)) {\n                master.add(method);\n            }\n        }\n    }\n}\n",
        "token_number_zeroshot": 733,
        "token_number_fewshot": 1131,
        "token_number_cot": 844
    },
    {
        "project_name": "12_dsachat",
        "class": "Handler",
        "source_code": "package dsachat.server;\n\nimport java.io.*;\nimport dsachat.share.*;\nimport dsachat.share.hero.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class Handler implements InputListener\n{\n    private Vector<Entry> clients;\n    \n    public Handler() {\n        this.clients = new Vector<Entry>();\n    }\n    \n    public void addConnection(final ConnectionEndpoint cl) {\n        final Entry n = new Entry();\n        n.ce = cl;\n        n.name = \"\";\n        try {\n            while (!cl.isConnected()) {}\n            for (int i = 0; i < this.clients.size(); ++i) {\n                final UserEvent ev = new UserEvent(false, this.clients.elementAt(i).name);\n                cl.send(ev);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n        this.clients.addElement(n);\n    }\n    \n    public void removeConnection(final ConnectionEndpoint cl) {\n        String name = null;\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).ce.getClientPort() == cl.getClientPort()) {\n                name = this.clients.elementAt(i).name;\n                this.clients.removeElementAt(i);\n                break;\n            }\n        }\n        if (name != null) {\n            final UserEvent newCon = new UserEvent(true, name);\n            this.sendAllObj(newCon);\n        }\n    }\n    \n    @Override\n    public void handleInput(final InputEvent e) {\n        final Object o = e.getData();\n        final ConnectionEndpoint con = e.getSource();\n        if (o.getClass().equals(String.class)) {\n            String msg = o.toString();\n            if (msg.startsWith(\"/\")) {\n                final String[] cmd = msg.substring(1).split(\"\\\\s\", 2);\n                msg = cmd[1];\n                if (cmd[0].matches(\"(d(ice)?)|(w\\u00fcrfel)\")) {\n                    this.rollDice(con, msg.trim());\n                    return;\n                }\n                if (cmd[0].matches(\"(w(hisper)?)|(f(l\\u00fcster)?)\")) {\n                    this.whisper(con, msg.trim());\n                    return;\n                }\n                if (cmd[0].matches(\"me\")) {\n                    this.sendAllObj(new String(\"*\" + this.getName(con) + \": \" + msg));\n                    return;\n                }\n                if (cmd[0].equals(\"/getheros\")) {\n                    this.sendHeros(con);\n                    return;\n                }\n                this.sendOneSystemMsg(con, \"command /\" + cmd[0] + \" not found\");\n                return;\n            }\n            else {\n                this.sendAllStr(con, o.toString());\n            }\n        }\n        if (o.getClass().equals(Challenge.class)) {\n            final Challenge c = (Challenge)o;\n            final String send = c.roll();\n            final String to = c.getTo();\n            if (to == null) {\n                this.sendAllStr(con, send);\n            }\n            else {\n                if (!c.isSilent()) {\n                    try {\n                        con.send(send);\n                    }\n                    catch (IOException e2) {\n                        e2.printStackTrace();\n                    }\n                }\n                this.sendToOneStr(con, to, send);\n            }\n        }\n        if (o.getClass().equals(ChallReq.class)) {\n            final ChallReq cr = (ChallReq)o;\n            for (final Entry i : this.clients) {\n                if (i.name.equals(cr.getTo())) {\n                    try {\n                        i.ce.send(cr);\n                    }\n                    catch (IOException e2) {\n                        e2.printStackTrace();\n                    }\n                    return;\n                }\n            }\n        }\n        if (o.getClass().equals(Hero.class)) {\n            final Hero h = (Hero)o;\n            final String name = this.updateHero(con, h);\n            if (name == null) {\n                System.out.println(this.getName(con) + \" updated his hero\");\n                return;\n            }\n            final UserEvent newCon = new UserEvent(false, name);\n            System.out.println(this.getName(con) + \" connected\");\n            this.sendAllObj(newCon);\n            try {\n                con.send(\"Welcome \" + h.getName());\n            }\n            catch (IOException e2) {\n                e2.printStackTrace();\n            }\n        }\n        if (o.getClass().equals(UserEvent.class) && !this.isGmConnected()) {\n            final UserEvent newCon2 = (UserEvent)o;\n            for (int j = 0; j < this.clients.size(); ++j) {\n                if (this.clients.elementAt(j).ce.getClientPort() == con.getClientPort()) {\n                    this.clients.elementAt(j).name = \"Gamemaster\";\n                }\n            }\n            System.out.println(\"Gamemaster connected\");\n            this.sendAllObj(newCon2);\n            try {\n                con.send(\"Welcome \" + newCon2.getName());\n            }\n            catch (IOException e3) {\n                e3.printStackTrace();\n            }\n        }\n    }\n    \n    private void sendHeros(final ConnectionEndpoint con) {\n        final Vector<Hero> vh = new Vector<Hero>();\n        for (final Entry e : this.clients) {\n            if (e.hero != null) {\n                vh.addElement(e.hero);\n            }\n        }\n        try {\n            con.send(vh);\n        }\n        catch (IOException e2) {\n            e2.printStackTrace();\n        }\n    }\n    \n    private boolean isGmConnected() {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).name.equals(\"Gamemaster\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private void sendOneSystemMsg(final ConnectionEndpoint con, final String string) {\n        try {\n            con.send(string);\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void sendAllSystemMsg(final String string) {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            try {\n                this.clients.elementAt(i).ce.send(string);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private void whisper(final ConnectionEndpoint con, final String cmd) {\n        final String[] split = cmd.split(\"\\\\s\", 2);\n        final String to = split[0];\n        final String tail = split[1];\n        String send = this.getName(con) + \" whispers: \" + tail;\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).name.equals(to)) {\n                this.sendOneSystemMsg(this.clients.elementAt(i).ce, send);\n            }\n        }\n        send = \"You whisper to \" + to + \": \" + tail;\n        this.sendOneSystemMsg(con, send);\n    }\n    \n    private void rollDice(final ConnectionEndpoint con, final String cmd) {\n        if (cmd.matches(\".*\\\\+.*\")) {\n            final Matcher m = Pattern.compile(\"(\\\\d*)[wd](\\\\d+)\\\\+(\\\\d+).*\").matcher(cmd);\n            if (m.matches()) {\n                final int count = (m.group(1) == null || m.group(1).equals(\"\")) ? 1 : Integer.parseInt(m.group(1));\n                final int sides = Integer.parseInt(m.group(2));\n                final int mod = Integer.parseInt(m.group(3));\n                String ret = this.getName(con) + \" rolled \" + cmd + \" --> \";\n                int sum = 0;\n                for (int i = 0; i < count; ++i) {\n                    sum += Challenge.dice(sides);\n                }\n                sum += mod;\n                ret += sum;\n                this.sendAllSystemMsg(ret);\n            }\n        }\n        else {\n            final Matcher m = Pattern.compile(\"(\\\\d*)[wd](\\\\d+).*\").matcher(cmd);\n            if (m.matches()) {\n                final int count = (m.group(1) == null || m.group(1).equals(\"\")) ? 1 : Integer.parseInt(m.group(1));\n                final int sides = Integer.parseInt(m.group(2));\n                String ret2 = this.getName(con) + \" rolls \" + cmd + \" --> \";\n                for (int j = 0; j < count; ++j) {\n                    ret2 = ret2 + Challenge.dice(sides) + \"  \";\n                }\n                this.sendAllSystemMsg(ret2);\n            }\n        }\n    }\n    \n    private void sendToOneStr(final ConnectionEndpoint con, final String to, final String send) {\n        final String sender = this.getName(con);\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).name.equals(to)) {\n                try {\n                    final String msg = sender + \": \" + send;\n                    this.clients.elementAt(i).ce.send(msg);\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    \n    private String updateHero(final ConnectionEndpoint con, final Hero h) {\n        int i = 0;\n        while (i < this.clients.size()) {\n            if (this.clients.elementAt(i).ce.getClientPort() == con.getClientPort()) {\n                this.clients.elementAt(i).hero = h;\n                if (this.clients.elementAt(i).name.equals(\"\")) {\n                    this.clients.elementAt(i).name = h.getName();\n                    return h.getName();\n                }\n                return null;\n            }\n            else {\n                ++i;\n            }\n        }\n        return null;\n    }\n    \n    private void sendAllStr(final ConnectionEndpoint con, final String string) {\n        final String sender = this.getName(con);\n        for (int i = 0; i < this.clients.size(); ++i) {\n            try {\n                final String msg = sender + \": \" + string;\n                this.clients.elementAt(i).ce.send(msg);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private void sendAllObj(final Object o) {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            try {\n                this.clients.elementAt(i).ce.send(o);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private String getName(final ConnectionEndpoint con) {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).ce.getClientPort() == con.getClientPort()) {\n                return this.clients.elementAt(i).name;\n            }\n        }\n        return null;\n    }\n}\n",
        "token_number_zeroshot": 2215,
        "token_number_fewshot": 2613,
        "token_number_cot": 2325
    },
    {
        "project_name": "12_dsachat",
        "class": "InternalChatFrame",
        "source_code": "package dsachat.client.gui;\n\nimport javax.swing.text.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport java.awt.event.*;\n\npublic class InternalChatFrame extends JInternalFrame implements ActionListener, MouseListener\n{\n    private static final long serialVersionUID = -1182316470653600880L;\n    private JList list;\n    private DefaultListModel listModel;\n    private JTextPane showTxt;\n    private JTextField txtInput;\n    private MainFrame parent;\n    private StyledDocument doc;\n    private JPopupMenu listPop;\n    private JPopupMenu txtPop;\n    \n    public InternalChatFrame(final MainFrame parent) {\n        super(\"Chat\", true, false, true, true);\n        this.listModel = new DefaultListModel();\n        this.parent = parent;\n        this.createGUI();\n        this.setLocation(0, 0);\n    }\n    \n    private void createGUI() {\n        final GridBagConstraints c = new GridBagConstraints();\n        final JSplitPane split = new JSplitPane(1);\n        (this.list = new JList(this.listModel)).setVisible(true);\n        this.list.setSelectionMode(0);\n        this.list.addMouseListener(this);\n        final JScrollPane scrList = new JScrollPane(this.list);\n        split.setLeftComponent(scrList);\n        final JPanel right = new JPanel(new GridBagLayout());\n        (this.showTxt = new JTextPane()).setEditable(false);\n        this.showTxt.addMouseListener(this);\n        this.addStylesToDocument(this.doc = this.showTxt.getStyledDocument());\n        final JScrollPane scrTxt = new JScrollPane(this.showTxt);\n        scrTxt.setHorizontalScrollBarPolicy(31);\n        c.gridx = 0;\n        c.gridy = 0;\n        c.fill = 1;\n        c.weightx = 1.0;\n        c.weighty = 0.8;\n        c.insets = new Insets(0, 0, 5, 0);\n        right.add(scrTxt, c);\n        (this.txtInput = new JTextField()).addActionListener(this.parent);\n        this.txtInput.setActionCommand(\"sendInput\");\n        c.gridx = 0;\n        c.gridy = 1;\n        c.fill = 1;\n        c.weightx = 1.0;\n        c.weighty = 0.0;\n        c.insets = new Insets(5, 0, 0, 0);\n        right.add(this.txtInput, c);\n        split.setRightComponent(right);\n        split.setDividerLocation(100);\n        this.add(split);\n        this.listPop = new JPopupMenu();\n        JMenuItem menuItem = new JMenuItem(\"Change Color\");\n        menuItem.setActionCommand(\"chooseColor\");\n        menuItem.addActionListener(this);\n        this.listPop.add(menuItem);\n        menuItem = new JMenuItem(\"whisper\");\n        menuItem.setActionCommand(\"whisper\");\n        menuItem.addActionListener(this);\n        this.listPop.add(menuItem);\n        this.txtPop = new JPopupMenu();\n        menuItem = new JMenuItem(\"Change Color\");\n        menuItem.setActionCommand(\"bgColor\");\n        menuItem.addActionListener(this);\n        this.txtPop.add(menuItem);\n        final Dimension drawSize = this.parent.getSize();\n        this.setSize(drawSize.width - 400, drawSize.height - 55);\n    }\n    \n    public void addText(String line) {\n        try {\n            if (!line.matches(\".*:.*\")) {\n                this.doc.insertString(this.doc.getLength(), line + \"\\n\", this.doc.getStyle(\"system\"));\n                return;\n            }\n            String[] a = line.split(\":\", 2);\n            String styleName = a[0];\n            if (styleName.matches(\".*whispers.*\")) {\n                a = styleName.split(\"\\\\s\");\n                styleName = a[0];\n            }\n            if (styleName.startsWith(\"You \")) {\n                styleName = this.parent.hero.getName();\n            }\n            if (styleName.startsWith(\"*\")) {\n                line = a[0] + a[1];\n                styleName = a[0].substring(1);\n            }\n            final Style s = this.doc.getStyle(styleName);\n            boolean bold = false;\n            if (line.matches(\".*\\\\*.*\") && line.matches(\".*[\\\\+_].*\")) {\n                final String[] msgAr = line.split(\"\\\\*\");\n                for (int i = 0; i < msgAr.length; ++i) {\n                    if (i % 2 == 0) {\n                        StyleConstants.setItalic(s, false);\n                    }\n                    else {\n                        StyleConstants.setItalic(s, true);\n                    }\n                    final String[] str = msgAr[i].split(\"[\\\\+_]\");\n                    if (bold) {\n                        for (int j = 0; j < str.length; ++j) {\n                            bold = (j % 2 == 0);\n                            StyleConstants.setBold(s, bold);\n                            this.doc.insertString(this.doc.getLength(), str[j], s);\n                        }\n                    }\n                    else {\n                        for (int j = 0; j < str.length; ++j) {\n                            bold = (j % 2 != 0);\n                            StyleConstants.setBold(s, bold);\n                            this.doc.insertString(this.doc.getLength(), str[j], s);\n                        }\n                    }\n                }\n                StyleConstants.setItalic(s, false);\n                StyleConstants.setBold(s, false);\n            }\n            else if (line.matches(\".*\\\\*.*\")) {\n                final String[] msgAr = line.split(\"\\\\*\");\n                for (int i = 0; i < msgAr.length; ++i) {\n                    if (i % 2 == 0) {\n                        StyleConstants.setItalic(s, false);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                    else {\n                        StyleConstants.setItalic(s, true);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                }\n                StyleConstants.setItalic(s, false);\n            }\n            else if (line.matches(\".*[\\\\+_].*\")) {\n                final String[] msgAr = line.split(\"[\\\\+_]\");\n                for (int i = 0; i < msgAr.length; ++i) {\n                    if (i % 2 == 0) {\n                        StyleConstants.setBold(s, false);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                    else {\n                        StyleConstants.setBold(s, true);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                }\n                StyleConstants.setBold(s, false);\n            }\n            else {\n                this.doc.insertString(this.doc.getLength(), line, s);\n            }\n            this.doc.insertString(this.doc.getLength(), \"\\n\", this.doc.getStyle(\"regular\"));\n        }\n        catch (BadLocationException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    protected void addStylesToDocument(final StyledDocument doc) {\n        final Style def = StyleContext.getDefaultStyleContext().getStyle(\"default\");\n        final Style regular = doc.addStyle(\"regular\", def);\n        StyleConstants.setFontFamily(def, \"SansSerif\");\n        Style s = doc.addStyle(\"italic\", regular);\n        StyleConstants.setItalic(s, true);\n        s = doc.addStyle(\"bold\", regular);\n        StyleConstants.setBold(s, true);\n        s = doc.addStyle(\"bold-italic\", regular);\n        StyleConstants.setBold(s, true);\n        StyleConstants.setItalic(s, true);\n        s = doc.addStyle(\"name\", regular);\n        StyleConstants.setForeground(s, Color.BLUE);\n        StyleConstants.setFontSize(s, 16);\n        s = doc.addStyle(\"system\", regular);\n        StyleConstants.setForeground(s, new Color(0.0f, 0.6f, 0.0f, 1.0f));\n        StyleConstants.setItalic(s, true);\n        StyleConstants.setFontSize(s, 14);\n        s = doc.addStyle(\"small\", regular);\n        StyleConstants.setFontSize(s, 10);\n        s = doc.addStyle(\"large\", regular);\n        StyleConstants.setFontSize(s, 16);\n    }\n    \n    private void changeStyle(final int fontSize, final Color c, final boolean isBold, final boolean isItalic, final String name) {\n        final Style s = this.doc.getStyle(name);\n        if (c != null) {\n            StyleConstants.setForeground(s, c);\n        }\n        StyleConstants.setBold(s, isBold);\n        StyleConstants.setItalic(s, isItalic);\n    }\n    \n    public void addUser(final String user) {\n        this.listModel.add(0, user);\n        this.list.ensureIndexIsVisible(0);\n        this.list.setSelectedIndex(0);\n        this.list.validate();\n        final Style parent = this.doc.getStyle(\"regular\");\n        this.doc.addStyle(user, parent);\n    }\n    \n    public void deleteUser(final String user) {\n        this.listModel.removeElement(user);\n    }\n    \n    public String[] getUserlist() {\n        final String[] uList = new String[this.listModel.size()];\n        for (int i = 0; i < this.listModel.size(); ++i) {\n            uList[i] = this.listModel.elementAt(i);\n        }\n        return uList;\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        final String name = this.list.getSelectedValue();\n        if (e.getActionCommand().equals(\"chooseColor\")) {\n            final Color newColor = JColorChooser.showDialog(this, \"Choose Color for user \" + name, Color.black);\n            if (newColor != null) {\n                this.changeStyle(12, newColor, false, false, name);\n            }\n        }\n        if (e.getActionCommand().equals(\"bgColor\")) {\n            final Color newColor = JColorChooser.showDialog(this, \"Choose Color for user \" + name, Color.black);\n            if (newColor != null) {\n                this.showTxt.setBackground(newColor);\n            }\n        }\n        if (e.getActionCommand().equals(\"whisper\")) {\n            final String wUser = \"/w \" + name + \" \";\n            this.txtInput.setText(wUser);\n        }\n    }\n    \n    @Override\n    public void mouseClicked(final MouseEvent e) {\n    }\n    \n    @Override\n    public void mouseEntered(final MouseEvent e) {\n    }\n    \n    @Override\n    public void mouseExited(final MouseEvent e) {\n    }\n    \n    @Override\n    public void mousePressed(final MouseEvent e) {\n        this.maybeShowPopup(e);\n    }\n    \n    @Override\n    public void mouseReleased(final MouseEvent e) {\n        this.maybeShowPopup(e);\n    }\n    \n    private void maybeShowPopup(final MouseEvent e) {\n        if (e.isPopupTrigger()) {\n            if (e.getSource().equals(this.list)) {\n                this.listPop.show(this.list, e.getX(), e.getY());\n            }\n            if (e.getSource().equals(this.showTxt)) {\n                this.txtPop.show(this.list, e.getX(), e.getY());\n            }\n        }\n    }\n    \n    public String getChatlog() {\n        return this.showTxt.getText();\n    }\n}\n",
        "token_number_zeroshot": 2278,
        "token_number_fewshot": 2676,
        "token_number_cot": 2390
    }
]