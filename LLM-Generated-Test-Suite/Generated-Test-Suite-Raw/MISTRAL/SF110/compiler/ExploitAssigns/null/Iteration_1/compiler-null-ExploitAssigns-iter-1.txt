```java
package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class ExploitAssignsTest {

    private ExploitAssigns exploitAssigns;
    private Node mockNode;

    @Before
    public void setUp() {
        exploitAssigns = new ExploitAssigns();
        mockNode = mock(Node.class);
    }

    @Test
    public void testOptimizeSubtree() {
        Node subtree = mock(Node.class);
        Node child1 = mock(Node.class);
        Node child2 = mock(Node.class);

        when(subtree.getFirstChild()).thenReturn(child1);
        when(child1.getNext()).thenReturn(child2);
        when(child2.getNext()).thenReturn(null);

        when(NodeUtil.isExprAssign(child1)).thenReturn(true);
        when(NodeUtil.isExprAssign(child2)).thenReturn(false);

        Node firstChild = mock(Node.class);
        when(child1.getFirstChild()).thenReturn(firstChild);

        exploitAssigns.optimizeSubtree(subtree);

        verify(subtree).getFirstChild();
        verify(child1).getNext();
        verify(child2).getNext();
        verify(NodeUtil).isExprAssign(child1);
        verify(NodeUtil).isExprAssign(child2);
        verify(child1).getFirstChild();
    }

    @Test
    public void testCollapseAssign() {
        Node assign = mock(Node.class);
        Node expr = mock(Node.class);
        Node exprParent = mock(Node.class);

        Node leftValue = mock(Node.class);
        Node rightValue = mock(Node.class);

        when(assign.getFirstChild()).thenReturn(leftValue);
        when(leftValue.getNext()).thenReturn(rightValue);

        when(exploitAssigns.isCollapsibleValue(leftValue, true)).thenReturn(true);
        when(exploitAssigns.collapseAssignEqualTo(expr, exprParent, leftValue)).thenReturn(true);

        exploitAssigns.collapseAssign(assign, expr, exprParent);

        verify(assign).getFirstChild();
        verify(leftValue).getNext();
        verify(exploitAssigns).isCollapsibleValue(leftValue, true);
        verify(exploitAssigns).collapseAssignEqualTo(expr, exprParent, leftValue);
    }

    @Test
    public void testIsCollapsibleValue() {
        Node value = mock(Node.class);

        when(value.getType()).thenReturn(Token.NAME);
        assertTrue(exploitAssigns.isCollapsibleValue(value, true));

        when(value.getType()).thenReturn(Token.GETPROP);
        Node firstChild = mock(Node.class);
        when(value.getFirstChild()).thenReturn(firstChild);
        when(firstChild.isThis()).thenReturn(true);
        assertTrue(exploitAssigns.isCollapsibleValue(value, true));

        when(firstChild.isThis()).thenReturn(false);
        assertFalse(exploitAssigns.isCollapsibleValue(value, true));

        when(value.getType()).thenReturn(Token.NUMBER);
        when(NodeUtil.isImmutableValue(value)).thenReturn(true);
        assertTrue(exploitAssigns.isCollapsibleValue(value, true));
    }

    @Test
    public void testCollapseAssignEqualTo() {
        Node expr = mock(Node.class);
        Node exprParent = mock(Node.class);
        Node value = mock(Node.class);

        Node assign = mock(Node.class);
        Node next = mock(Node.class);

        when(expr.getFirstChild()).thenReturn(assign);
        when(expr.getNext()).thenReturn(next);

        when(next.getType()).thenReturn(Token.NAME);
        when(next.isQualifiedName()).thenReturn(true);
        when(next.getQualifiedName()).thenReturn("test");
        when(value.isQualifiedName()).thenReturn(true);
        when(value.getQualifiedName()).thenReturn("test");
        when(exploitAssigns.isSafeReplacement(next, assign)).thenReturn(true);

        assertTrue(exploitAssigns.collapseAssignEqualTo(expr, exprParent, value));

        verify(expr).getFirstChild();
        verify(expr).getNext();
        verify(next).getType();
        verify(next).isQualifiedName();
        verify(next).getQualifiedName();
        verify(value).isQualifiedName();
        verify(value).getQualifiedName();
        verify(exploitAssigns).isSafeReplacement(next, assign);
        verify(exprParent).removeChild(expr);
        verify(expr).removeChild(assign);
        verify(next).replaceChild(next, assign);
    }

    @Test
    public void testIsSafeReplacement() {
        Node node = mock(Node.class);
        Node replacement = mock(Node.class);

        when(node.isName()).thenReturn(true);
        assertTrue(exploitAssigns.isSafeReplacement(node, replacement));

        when(node.isName()).thenReturn(false);
        when(node.isGetProp()).thenReturn(true);
        Node name = mock(Node.class);
        when(node.getFirstChild()).thenReturn(name);
        when(name.isName()).thenReturn(true);
        when(name.getString()).thenReturn("test");
        when(exploitAssigns.isNameAssignedTo("test", replacement)).thenReturn(false);

        assertTrue(exploitAssigns.isSafeReplacement(node, replacement));

        when(exploitAssigns.isNameAssignedTo("test", replacement)).thenReturn(true);
        assertFalse(exploitAssigns.isSafeReplacement(node, replacement));
    }

    @Test
    public void testIsNameAssignedTo() {
        Node node = mock(Node.class);
        Node child = mock(Node.class);

        when(node.getFirstChild()).thenReturn(child);
        when(child.getNext()).thenReturn(null);

        when(child.isName()).thenReturn(true);
        Node parent = mock(Node.class);
        when(child.getParent()).thenReturn(parent);
        when(parent.isAssign()).thenReturn(true);
        when(parent.getFirstChild()).thenReturn(child);
        when(child.getString()).thenReturn("test");

        assertTrue(exploitAssigns.isNameAssignedTo("test", node));

        when(child.getString()).thenReturn("other");
        assertFalse(exploitAssigns.isNameAssignedTo("test", node));
    }
}
```