```java
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import org.junit.Before;
import org.junit.Test;

public class ExploitAssignsTest {

    private ExploitAssigns exploitAssigns;
    private Node mockNode;
    private Node mockChildNode;
    private Node mockNextNode;

    @Before
    public void setUp() {
        exploitAssigns = new ExploitAssigns();
        mockNode = mock(Node.class);
        mockChildNode = mock(Node.class);
        mockNextNode = mock(Node.class);
    }

    @Test
    public void testOptimizeSubtree_NoChildren() {
        when(mockNode.getFirstChild()).thenReturn(null);

        Node result = exploitAssigns.optimizeSubtree(mockNode);

        assertEquals(mockNode, result);
    }

    @Test
    public void testOptimizeSubtree_WithExprAssign() {
        when(mockNode.getFirstChild()).thenReturn(mockChildNode);
        when(mockChildNode.getNext()).thenReturn(null);
        when(NodeUtil.isExprAssign(mockChildNode)).thenReturn(true);

        Node result = exploitAssigns.optimizeSubtree(mockNode);

        assertEquals(mockNode, result);
        verify(mockChildNode).getFirstChild();
    }

    @Test
    public void testCollapseAssign_WithCollapsibleValue() {
        Node mockAssign = mock(Node.class);
        Node mockExpr = mock(Node.class);
        Node mockExprParent = mock(Node.class);
        Node mockLeftValue = mock(Node.class);
        Node mockRightValue = mock(Node.class);

        when(mockAssign.getFirstChild()).thenReturn(mockLeftValue);
        when(mockLeftValue.getNext()).thenReturn(mockRightValue);
        when(exploitAssigns.isCollapsibleValue(mockLeftValue, true)).thenReturn(true);
        when(exploitAssigns.collapseAssignEqualTo(mockExpr, mockExprParent, mockLeftValue)).thenReturn(true);

        exploitAssigns.collapseAssign(mockAssign, mockExpr, mockExprParent);

        verify(exploitAssigns).reportCodeChange();
    }

    @Test
    public void testIsCollapsibleValue_GetProp() {
        Node mockValue = mock(Node.class);
        when(mockValue.getType()).thenReturn(Token.GETPROP);
        when(mockValue.getFirstChild()).thenReturn(mock(Node.class));
        when(mockValue.getFirstChild().isThis()).thenReturn(true);

        boolean result = exploitAssigns.isCollapsibleValue(mockValue, true);

        assertTrue(result);
    }

    @Test
    public void testIsCollapsibleValue_Name() {
        Node mockValue = mock(Node.class);
        when(mockValue.getType()).thenReturn(Token.NAME);

        boolean result = exploitAssigns.isCollapsibleValue(mockValue, true);

        assertTrue(result);
    }

    @Test
    public void testIsCollapsibleValue_ImmutableValue() {
        Node mockValue = mock(Node.class);
        when(NodeUtil.isImmutableValue(mockValue)).thenReturn(true);

        boolean result = exploitAssigns.isCollapsibleValue(mockValue, true);

        assertTrue(result);
    }

    @Test
    public void testCollapseAssignEqualTo_QualifiedName() {
        Node mockExpr = mock(Node.class);
        Node mockExprParent = mock(Node.class);
        Node mockValue = mock(Node.class);
        Node mockAssign = mock(Node.class);
        Node mockNext = mock(Node.class);

        when(mockExpr.getFirstChild()).thenReturn(mockAssign);
        when(mockExpr.getNext()).thenReturn(mockNext);
        when(mockNext.getType()).thenReturn(Token.NAME);
        when(mockNext.isQualifiedName()).thenReturn(true);
        when(mockValue.isQualifiedName()).thenReturn(true);
        when(mockNext.getQualifiedName()).thenReturn("qualifiedName");
        when(mockValue.getQualifiedName()).thenReturn("qualifiedName");
        when(exploitAssigns.isSafeReplacement(mockNext, mockAssign)).thenReturn(true);

        boolean result = exploitAssigns.collapseAssignEqualTo(mockExpr, mockExprParent, mockValue);

        assertTrue(result);
        verify(mockExprParent).removeChild(mockExpr);
        verify(mockExpr).removeChild(mockAssign);
        verify(mockExprParent).replaceChild(mockNext, mockAssign);
    }

    @Test
    public void testIsSafeReplacement_Name() {
        Node mockNode = mock(Node.class);
        Node mockReplacement = mock(Node.class);

        when(mockNode.isName()).thenReturn(true);

        boolean result = exploitAssigns.isSafeReplacement(mockNode, mockReplacement);

        assertTrue(result);
    }

    @Test
    public void testIsSafeReplacement_GetProp() {
        Node mockNode = mock(Node.class);
        Node mockReplacement = mock(Node.class);
        Node mockName = mock(Node.class);

        when(mockNode.isGetProp()).thenReturn(true);
        when(mockNode.getFirstChild()).thenReturn(mockName);
        when(mockName.isName()).thenReturn(true);
        when(exploitAssigns.isNameAssignedTo(anyString(), eq(mockReplacement))).thenReturn(false);

        boolean result = exploitAssigns.isSafeReplacement(mockNode, mockReplacement);

        assertTrue(result);
    }

    @Test
    public void testIsNameAssignedTo_Assigned() {
        Node mockNode = mock(Node.class);
        Node mockChild = mock(Node.class);

        when(mockNode.getFirstChild()).thenReturn(mockChild);
        when(mockChild.getNext()).thenReturn(null);
        when(mockChild.isName()).thenReturn(true);
        when(mockChild.getParent()).thenReturn(mockNode);
        when(mockNode.isAssign()).thenReturn(true);
        when(mockNode.getFirstChild()).thenReturn(mockChild);
        when(mockChild.getString()).thenReturn("name");

        boolean result = exploitAssigns.isNameAssignedTo("name", mockNode);

        assertTrue(result);
    }

    @Test
    public void testIsNameAssignedTo_NotAssigned() {
        Node mockNode = mock(Node.class);

        when(mockNode.getFirstChild()).thenReturn(null);

        boolean result = exploitAssigns.isNameAssignedTo("name", mockNode);

        assertFalse(result);
    }
}
```