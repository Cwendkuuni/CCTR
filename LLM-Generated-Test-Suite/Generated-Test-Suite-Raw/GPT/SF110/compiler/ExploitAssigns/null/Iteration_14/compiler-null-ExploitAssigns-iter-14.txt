```java
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

public class ExploitAssignsTest {

    private ExploitAssigns exploitAssigns;
    private Node subtree;
    private Node expr;
    private Node exprParent;
    private Node assign;
    private Node leftValue;
    private Node rightValue;

    @Before
    public void setUp() {
        exploitAssigns = new ExploitAssigns();
        subtree = mock(Node.class);
        expr = mock(Node.class);
        exprParent = mock(Node.class);
        assign = mock(Node.class);
        leftValue = mock(Node.class);
        rightValue = mock(Node.class);
    }

    @Test
    public void testOptimizeSubtree() {
        Node child = mock(Node.class);
        Node next = mock(Node.class);

        when(subtree.getFirstChild()).thenReturn(child);
        when(child.getNext()).thenReturn(next);
        when(NodeUtil.isExprAssign(child)).thenReturn(true);
        when(child.getFirstChild()).thenReturn(assign);

        exploitAssigns.optimizeSubtree(subtree);

        verify(subtree, times(1)).getFirstChild();
        verify(child, times(1)).getNext();
        verify(NodeUtil.class, times(1)).isExprAssign(child);
    }

    @Test
    public void testCollapseAssign() {
        when(assign.getFirstChild()).thenReturn(leftValue);
        when(leftValue.getNext()).thenReturn(rightValue);
        when(exploitAssigns.isCollapsibleValue(leftValue, true)).thenReturn(true);
        when(exploitAssigns.collapseAssignEqualTo(expr, exprParent, leftValue)).thenReturn(true);

        exploitAssigns.collapseAssign(assign, expr, exprParent);

        verify(assign, times(1)).getFirstChild();
        verify(leftValue, times(1)).getNext();
        verify(exploitAssigns, times(1)).isCollapsibleValue(leftValue, true);
        verify(exploitAssigns, times(1)).collapseAssignEqualTo(expr, exprParent, leftValue);
    }

    @Test
    public void testIsCollapsibleValue() {
        when(leftValue.getType()).thenReturn(Token.NAME);
        assertTrue(exploitAssigns.isCollapsibleValue(leftValue, true));

        when(leftValue.getType()).thenReturn(Token.GETPROP);
        when(leftValue.getFirstChild()).thenReturn(mock(Node.class));
        when(leftValue.getFirstChild().isThis()).thenReturn(true);
        assertTrue(exploitAssigns.isCollapsibleValue(leftValue, true));

        when(leftValue.getType()).thenReturn(Token.STRING);
        when(NodeUtil.isImmutableValue(leftValue)).thenReturn(true);
        assertTrue(exploitAssigns.isCollapsibleValue(leftValue, false));
    }

    @Test
    public void testCollapseAssignEqualTo() {
        Node next = mock(Node.class);
        Node parent = mock(Node.class);

        when(expr.getFirstChild()).thenReturn(assign);
        when(exprParent.getNext()).thenReturn(next);
        when(next.getType()).thenReturn(Token.NAME);
        when(next.isQualifiedName()).thenReturn(true);
        when(next.getQualifiedName()).thenReturn("qualifiedName");
        when(value.isQualifiedName()).thenReturn(true);
        when(value.getQualifiedName()).thenReturn("qualifiedName");
        when(exploitAssigns.isSafeReplacement(next, assign)).thenReturn(true);

        assertTrue(exploitAssigns.collapseAssignEqualTo(expr, exprParent, value));

        verify(expr, times(1)).getFirstChild();
        verify(exprParent, times(1)).getNext();
        verify(next, times(1)).getType();
        verify(next, times(1)).isQualifiedName();
        verify(next, times(1)).getQualifiedName();
        verify(value, times(1)).isQualifiedName();
        verify(value, times(1)).getQualifiedName();
        verify(exploitAssigns, times(1)).isSafeReplacement(next, assign);
    }

    @Test
    public void testIsSafeReplacement() {
        when(node.isName()).thenReturn(true);
        assertTrue(exploitAssigns.isSafeReplacement(node, replacement));

        when(node.isName()).thenReturn(false);
        when(node.isGetProp()).thenReturn(true);
        when(node.getFirstChild()).thenReturn(mock(Node.class));
        when(node.getFirstChild().isName()).thenReturn(true);
        when(exploitAssigns.isNameAssignedTo(anyString(), eq(replacement))).thenReturn(false);

        assertTrue(exploitAssigns.isSafeReplacement(node, replacement));
    }

    @Test
    public void testIsNameAssignedTo() {
        Node c = mock(Node.class);
        when(node.getFirstChild()).thenReturn(c);
        when(c.getNext()).thenReturn(null);
        when(c.isName()).thenReturn(true);
        when(c.getParent()).thenReturn(mock(Node.class));
        when(c.getParent().isAssign()).thenReturn(true);
        when(c.getParent().getFirstChild()).thenReturn(c);
        when(c.getString()).thenReturn("name");

        assertTrue(exploitAssigns.isNameAssignedTo("name", node));

        verify(node, times(1)).getFirstChild();
        verify(c, times(1)).getNext();
        verify(c, times(1)).isName();
        verify(c, times(1)).getParent();
        verify(c.getParent(), times(1)).isAssign();
        verify(c.getParent(), times(1)).getFirstChild();
        verify(c, times(1)).getString();
    }
}
```

This test suite uses Mockito to mock the `Node` class and its methods, allowing us to focus on testing the logic within the `ExploitAssigns` class. Each test method is designed to cover different aspects of the class's functionality.