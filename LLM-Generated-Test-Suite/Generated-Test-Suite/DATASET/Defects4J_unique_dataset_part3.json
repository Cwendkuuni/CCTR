[
    {
        "project_name": "Cli",
        "bug-id": "2",
        "class": "PosixParser",
        "fqdn": "org.apache.commons.cli",
        "source_code": "/**\n * Copyright 1999-2001,2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private ArrayList tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * <p>Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.</p>\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, \n                               boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n        String token;\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, \n                                               token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token)) {\n                \ttokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[] {  });\n    }\n\n    /**\n     * <p>Adds the remaining tokens to the processed tokens list.</p>\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if ((currentOption != null) && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If it is a hyphen then add the hyphen directly to\n     * the processed tokens list.</p>\n     *\n     * @param hyphen The hyphen token\n     */\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(\"-\" + ch);\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "13",
        "class": "WriteableCommandLineImpl",
        "fqdn": "org.apache.commons.cli2.commandline",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          final List defaultValues) {\n        // First grab the command line values\n        List valueList = (List) values.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        // Thirdly try the option's default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n\n        // Finally use an empty list\n        if (valueList == null) {\n            valueList = Collections.EMPTY_LIST;\n        }\n\n        return valueList;\n    }\n\n      // First grab the command line values\n\n      // Finally use an empty list\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public void addProperty(final String property,\n                            final String value) {\n        properties.setProperty(property, value);\n    }\n\n    public String getProperty(final String property,\n                              final String defaultValue) {\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties() {\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "13",
        "class": "ArgumentImpl",
        "fqdn": "org.apache.commons.cli2.option",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\nimport org.apache.commons.cli2.validation.InvalidArgumentException;\nimport org.apache.commons.cli2.validation.Validator;\n\n/**\n * An implementation of an Argument.\n */\npublic class ArgumentImpl\n    extends OptionImpl implements Argument {\n    private static final char NUL = '\\0';\n\n    /**\n     * The default value for the initial separator char.\n     */\n    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;\n\n    /**\n     * The default value for the subsequent separator char.\n     */\n    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;\n\n    /**\n     * The default token to indicate that remaining arguments should be consumed\n     * as values.\n     */\n    public static final String DEFAULT_CONSUME_REMAINING = \"--\";\n    private final String name;\n    private final String description;\n    private final int minimum;\n    private final int maximum;\n    private final char initialSeparator;\n    private final char subsequentSeparator;\n    private final boolean subsequentSplit;\n    private final Validator validator;\n    private final String consumeRemaining;\n    private final List defaultValues;\n    private final ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n    /**\n     * Creates a new Argument instance.\n     *\n     * @param name\n     *            The name of the argument\n     * @param description\n     *            A description of the argument\n     * @param minimum\n     *            The minimum number of values needed to be valid\n     * @param maximum\n     *            The maximum number of values allowed to be valid\n     * @param initialSeparator\n     *            The char separating option from value\n     * @param subsequentSeparator\n     *            The char separating values from each other\n     * @param validator\n     *            The object responsible for validating the values\n     * @param consumeRemaining\n     *            The String used for the \"consuming option\" group\n     * @param valueDefaults\n     *            The values to be used if none are specified.\n     * @param id\n     *            The id of the option, 0 implies automatic assignment.\n     *\n     * @see OptionImpl#OptionImpl(int,boolean)\n     */\n    public ArgumentImpl(final String name,\n                        final String description,\n                        final int minimum,\n                        final int maximum,\n                        final char initialSeparator,\n                        final char subsequentSeparator,\n                        final Validator validator,\n                        final String consumeRemaining,\n                        final List valueDefaults,\n                        final int id) {\n        super(id, false);\n\n        this.name = (name == null) ? \"arg\" : name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n        this.initialSeparator = initialSeparator;\n        this.subsequentSeparator = subsequentSeparator;\n        this.subsequentSplit = subsequentSeparator != NUL;\n        this.validator = validator;\n        this.consumeRemaining = consumeRemaining;\n        this.defaultValues = valueDefaults;\n\n        if (minimum > maximum) {\n            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n        }\n\n        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {\n            if (valueDefaults.size() < minimum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n            }\n\n            if (valueDefaults.size() > maximum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n            }\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public void processValues(final WriteableCommandLine commandLine,\n                              final ListIterator arguments,\n                              final Option option)\n        throws OptionException {\n        // count of arguments processed for this option.\n        int argumentCount = 0;\n\n        while (arguments.hasNext() && (argumentCount < maximum)) {\n            final String allValuesQuoted = (String) arguments.next();\n            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n            // should we ignore things that look like options?\n            if (allValuesQuoted.equals(consumeRemaining)) {\n                while (arguments.hasNext() && (argumentCount < maximum)) {\n                    ++argumentCount;\n                    commandLine.addValue(option, arguments.next());\n                }\n            }\n            // does it look like an option?\n            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n                arguments.previous();\n\n                break;\n            }\n            // should we split the string up?\n            else if (subsequentSplit) {\n                final StringTokenizer values =\n                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n                arguments.remove();\n\n                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                    ++argumentCount;\n\n                    final String token = values.nextToken();\n                    commandLine.addValue(option, token);\n                    arguments.add(token);\n                }\n\n                if (values.hasMoreTokens()) {\n                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                              values.nextToken());\n                }\n            }\n            // it must be a value as it is\n            else {\n                ++argumentCount;\n                commandLine.addValue(option, allValues);\n            }\n        }\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        return true;\n    }\n\n    public Set getPrefixes() {\n        return Collections.EMPTY_SET;\n    }\n\n    public void process(WriteableCommandLine commandLine,\n                        ListIterator args)\n        throws OptionException {\n        processValues(commandLine, args, this);\n    }\n\n    public char getInitialSeparator() {\n        return this.initialSeparator;\n    }\n\n    public char getSubsequentSeparator() {\n        return this.subsequentSeparator;\n    }\n\n    public Set getTriggers() {\n        return Collections.EMPTY_SET;\n    }\n\n    public String getConsumeRemaining() {\n        return this.consumeRemaining;\n    }\n\n    public List getDefaultValues() {\n        return this.defaultValues;\n    }\n\n    public Validator getValidator() {\n        return this.validator;\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        validate(commandLine, this);\n    }\n\n    public void validate(final WriteableCommandLine commandLine,\n                         final Option option)\n        throws OptionException {\n        final List values = commandLine.getValues(option);\n\n        if (values.size() < minimum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n        }\n\n        if (values.size() > maximum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                      (String) values.get(maximum));\n        }\n\n        if (validator != null) {\n            try {\n                validator.validate(values);\n            } catch (InvalidArgumentException ive) {\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                          ive.getMessage());\n            }\n        }\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        // do we display the outer optionality\n        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        // allow numbering if multiple args\n        final boolean numbered =\n            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\n        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n        // if infinite args are allowed then crop the list\n        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\n        int i = 0;\n\n        // for each argument\n        while (i < max) {\n            // if we're past the first add a space\n            if (i > 0) {\n                buffer.append(' ');\n            }\n\n            // if the next arg is optional\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append('[');\n            }\n\n            if (bracketed) {\n                buffer.append('<');\n            }\n\n            // add name\n            buffer.append(name);\n            ++i;\n\n            // if numbering\n            if (numbered) {\n                buffer.append(i);\n            }\n\n            if (bracketed) {\n                buffer.append('>');\n            }\n        }\n\n        // if infinite args are allowed\n        if (maximum == Integer.MAX_VALUE) {\n            // append elipsis\n            buffer.append(\" ...\");\n        }\n\n        // for each argument\n        while (i > 0) {\n            --i;\n\n            // if the next arg is optional\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append(']');\n            }\n        }\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final HelpLine helpLine = new HelpLineImpl(this, depth);\n\n        return Collections.singletonList(helpLine);\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    /**\n     * If there are any leading or trailing quotes remove them from the\n     * specified token.\n     *\n     * @param token\n     *            the token to strip leading and trailing quotes\n     *\n     * @return String the possibly modified token\n     */\n    public String stripBoundaryQuotes(String token) {\n        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n            return token;\n        }\n\n        token = token.substring(1, token.length() - 1);\n\n        return token;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n        defaultValues(commandLine, this);\n    }\n\n    public void defaultValues(final WriteableCommandLine commandLine,\n                              final Option option) {\n        commandLine.setDefaultValues(option, defaultValues);\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "13",
        "class": "WriteableCommandLine",
        "fqdn": "org.apache.commons.cli2",
        "source_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2;\n\nimport java.util.List;\n\n/**\n * A CommandLine that detected values and options can be written to.\n */\npublic interface WriteableCommandLine extends CommandLine {\n\n    /**\n     * Adds an Option to the CommandLine\n     * @param option the Option to add\n     */\n    void addOption(final Option option);\n\n    /**\n     * Adds a value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the value to add\n     */\n    void addValue(final Option option, final Object value);\n\n    /**\n     * Retrieves the Argument values specified on the command line for the\n     * specified Option, this doesn't return any values supplied\n     * programmatically as defaults.\n     *\n     * @param option the Option associated with the values\n     * @return a list of values or an empty List if none are found\n     */\n\n    /**\n     * Sets the default values for an Option in the CommandLine\n     * @param option the Option to add to\n     * @param defaultValues the defaults for the option\n     */\n    void setDefaultValues(final Option option, final List defaultValues);\n\n    /**\n     * Adds a switch value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the switch value to add\n     * @throws IllegalStateException if the switch has already been added\n     */\n    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n\n    /**\n     * Sets the default state for a Switch in the CommandLine.\n     * @param option the Option to add to\n     * @param defaultSwitch the defaults state for ths switch\n     */\n    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n\n    /**\n     * Adds a property value to a name in the CommandLine.\n     * Replaces any existing value for the property.\n     *\n     * @param property the name of the property\n     * @param value the value of the property\n     */\n    void addProperty(final String property, final String value);\n\n    /**\n     * Detects whether the argument looks like an Option trigger\n     * @param argument the argument to test\n     * @return true if the argument looks like an Option trigger\n     */\n    boolean looksLikeOption(final String argument);\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "39",
        "class": "TypeHandler",
        "fqdn": "org.apache.commons.cli",
        "source_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n * This is a temporary implementation. TypeHandler will handle the\n * pluggableness of OptionTypes and it will direct all of these types\n * of conversion functionalities to ConvertUtils component in Commons\n * already. BeanUtils I think.\n *\n * @version $Id$\n */\npublic class TypeHandler\n{\n    /**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */\n    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n    /**\n     * Create a number from a String. If a . is present, it creates a\n     * Double, otherwise a Long.\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>\n     * @throws ParseException if <code>str</code> is not a number\n     */\n    public static Number createNumber(final String str) throws ParseException\n    {\n        try\n        {\n            if (str.indexOf('.') != -1)\n            {\n                return Double.valueOf(str);\n            }\n            return Long.valueOf(str);\n        }\n        catch (final NumberFormatException e)\n        {\n            throw new ParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the class whose name is <code>classname</code>.\n     *\n     * @param classname the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String classname) throws ParseException\n    {\n        try\n        {\n            return Class.forName(classname);\n        }\n        catch (final ClassNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n    }\n\n    /**\n     * Returns the date represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     * @throws UnsupportedOperationException always\n     */\n    public static Date createDate(final String str)\n    {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Returns the URL represented by <code>str</code>.\n     *\n     * @param str the URL string\n     * @return The URL in <code>str</code> is well-formed\n     * @throws ParseException if the URL in <code>str</code> is not well-formed\n     */\n    public static URL createURL(final String str) throws ParseException\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (final MalformedURLException e)\n        {\n            throw new ParseException(\"Unable to parse the URL: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File represented by <code>str</code>.\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(final String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by <code>str</code>.\n     *\n     * @param str the file location\n     * @return The file input stream represented by <code>str</code>.\n     * @throws ParseException if the file is not exist or not readable\n     */\n\n    /**\n     * Returns the File[] represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     * @throws UnsupportedOperationException always\n     */\n    public static File[] createFiles(final String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "29",
        "class": "Util",
        "fqdn": "org.apache.commons.cli",
        "source_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classs within this package.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\nclass Util\n{\n    /**\n     * Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n    {\n        if (str == null)\n        {\n            return null;\n        }\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n\n    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\"))\n        {\n            str = str.substring(1, str.length());\n        }\n        int length = str.length();\n        if (str.endsWith(\"\\\"\"))\n        {\n            str = str.substring(0, length - 1);\n        }\n        \n        return str;\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "17",
        "class": "PosixParser",
        "fqdn": "org.apache.commons.cli",
        "source_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * If it is a hyphen then add the hyphen directly to\n     * the processed tokens list.\n     *\n     * @param hyphen The hyphen token\n     */\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "35",
        "class": "Options",
        "fqdn": "org.apache.commons.cli",
        "source_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Main entry-point into the library.\n * <p>\n * Options represents a collection of {@link Option} objects, which\n * describe the possible options for a command-line.\n * <p>\n * It may flexibly parse long and short options, with or without\n * values.  Additionally, it may parse only a portion of a commandline,\n * allowing for flexible multi-stage parsing.\n *\n * @see org.apache.commons.cli.CommandLine\n *\n * @version $Id$\n */\npublic class Options implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** a map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<Object>();\n\n    /** a map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>();\n\n    /**\n     * Add the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(OptionGroup group)\n    {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    /**\n     * Lists the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }\n\n    /**\n     * Add an option that only contains a short name.\n     * The option does not take an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(String opt, String description)\n    {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Add an option that only contains a short-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, boolean hasArg, String description)\n    {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Add an option that contains a short-name and a long-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n    {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(Option opt)\n    {\n        String key = opt.getKey();\n\n        // add it to the long option list\n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        // if the option is required add it to the required list\n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    /**\n     * Retrieve a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions()\n    {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }\n\n    /**\n     * Returns the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List getRequiredOptions()\n    {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Retrieve the {@link Option} matching the long or short name specified.\n     * The leading hyphens in the name are ignored (up to 2).\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    /**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns the OptionGroup the <code>opt</code> belongs to.\n     * @param opt the option whose OptionGroup is being queried.\n     *\n     * @return the OptionGroup if <code>opt</code> is part\n     * of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(Option opt)\n    {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "40",
        "class": "TypeHandler",
        "fqdn": "org.apache.commons.cli",
        "source_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n * This is a temporary implementation. TypeHandler will handle the\n * pluggableness of OptionTypes and it will direct all of these types\n * of conversion functionalities to ConvertUtils component in Commons\n * already. BeanUtils I think.\n */\npublic class TypeHandler\n{\n    /**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */\n    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n    /**\n     * Create a number from a String. If a . is present, it creates a\n     * Double, otherwise a Long.\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>\n     * @throws ParseException if <code>str</code> is not a number\n     */\n    public static Number createNumber(final String str) throws ParseException\n    {\n        try\n        {\n            if (str.indexOf('.') != -1)\n            {\n                return Double.valueOf(str);\n            }\n            return Long.valueOf(str);\n        }\n        catch (final NumberFormatException e)\n        {\n            throw new ParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the class whose name is <code>classname</code>.\n     *\n     * @param classname the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String classname) throws ParseException\n    {\n        try\n        {\n            return Class.forName(classname);\n        }\n        catch (final ClassNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n    }\n\n    /**\n     * Returns the date represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     * @throws UnsupportedOperationException always\n     */\n    public static Date createDate(final String str)\n    {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Returns the URL represented by <code>str</code>.\n     *\n     * @param str the URL string\n     * @return The URL in <code>str</code> is well-formed\n     * @throws ParseException if the URL in <code>str</code> is not well-formed\n     */\n    public static URL createURL(final String str) throws ParseException\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (final MalformedURLException e)\n        {\n            throw new ParseException(\"Unable to parse the URL: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File represented by <code>str</code>.\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(final String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by <code>str</code>.\n     *\n     * @param str the file location\n     * @return The file input stream represented by <code>str</code>.\n     * @throws ParseException if the file is not exist or not readable\n     */\n    public static FileInputStream openFile(String str) throws ParseException\n    {\n        try\n        {\n            return new FileInputStream(str);\n        }\n        catch (FileNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find file: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File[] represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     * @throws UnsupportedOperationException always\n     */\n    public static File[] createFiles(final String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n"
    },
    {
        "project_name": "Cli",
        "bug-id": "26",
        "class": "OptionBuilder",
        "fqdn": "org.apache.commons.cli",
        "source_code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n *\n * <p>Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @since 1.0\n */\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Object type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static OptionBuilder instance = new OptionBuilder();\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = \"arg\";\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n\n\n        // PMM 9/6/02 - these were missing\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(String name)\n    {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator(':')\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withType(Object newType)\n    {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n            // create the option\n        Option option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n\n        // return the Option instance\n        return option;\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "11",
        "class": "ArchiveStreamFactory",
        "fqdn": "org.apache.commons.compress.archivers",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n\n/**\n * <p>Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order add other implementations you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).</p>\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * \n * @Immutable\n */\npublic class ArchiveStreamFactory {\n\n    /**\n     * Constant used to identify the AR archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String AR = \"ar\";\n    /**\n     * Constant used to identify the CPIO archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String CPIO = \"cpio\";\n    /**\n     * Constant used to identify the Unix DUMP archive format.\n     * @since Commons Compress 1.3\n     */\n    public static final String DUMP = \"dump\";\n    /**\n     * Constant used to identify the JAR archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String JAR = \"jar\";\n    /**\n     * Constant used to identify the TAR archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String TAR = \"tar\";\n    /**\n     * Constant used to identify the ZIP archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String ZIP = \"zip\";\n\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException {\n        \n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        \n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveInputStream(in);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveInputStream(in);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveInputStream(in);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveInputStream(in);\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            return new DumpArchiveInputStream(in);\n        }\n        \n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    /**\n     * Create an archive output stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\" or \"cpio\"\n     * @param out the output stream\n     * @return the archive output stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveOutputStream(out);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveOutputStream(out);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveOutputStream(out);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "33",
        "class": "DeflateCompressorInputStream",
        "fqdn": "org.apache.commons.compress.compressors.deflate",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.compressors.deflate;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.zip.Inflater;\nimport java.util.zip.InflaterInputStream;\n\nimport org.apache.commons.compress.compressors.CompressorInputStream;\n\n/**\n * Deflate decompressor.\n * @since 1.9\n */\npublic class DeflateCompressorInputStream extends CompressorInputStream {\n    \n    private final InputStream in;\n\n    /**\n     * Creates a new input stream that decompresses Deflate-compressed data\n     * from the specified input stream.\n     *\n     * @param       inputStream where to read the compressed data\n     *\n     */\n    public DeflateCompressorInputStream(InputStream inputStream) {\n        this(inputStream, new DeflateParameters());\n    }\n\n    /**\n     * Creates a new input stream that decompresses Deflate-compressed data\n     * from the specified input stream.\n     *\n     * @param       inputStream where to read the compressed data\n     * @param       parameters parameters\n     */\n    public DeflateCompressorInputStream(InputStream inputStream,\n                                        DeflateParameters parameters) {\n        in = new InflaterInputStream(inputStream, new Inflater(!parameters.withZlibHeader()));\n    }\n    \n    /** {@inheritDoc} */\n    @Override\n    public int read() throws IOException {\n        int ret = in.read();\n        count(ret == -1 ? 0 : 1);\n        return ret;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        int ret = in.read(buf, off, len);\n        count(ret);\n        return ret;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public long skip(long n) throws IOException {\n        return in.skip(n);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int available() throws IOException {\n        return in.available();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n    \n    /**\n     * Checks if the signature matches what is expected for a zlib / deflated file\n     *  with the zlib header.\n     * \n     * @param signature\n     *            the bytes to check\n     * @param length\n     *            the number of bytes to check\n     * @return true, if this stream is zlib / deflate compressed with a header\n     * stream, false otherwise\n     * \n     * @since 1.9\n     */\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "7",
        "class": "TarUtils",
        "fqdn": "org.apache.commons.compress.archivers.tar",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.tar;\n\n/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\n// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)\npublic class TarUtils {\n\n    private static final int BYTE_MASK = 255;\n\n    /** Private constructor to prevent instantiation of this utility class. */\n    private TarUtils(){    \n    }\n\n    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * Parsing stops when a NUL is found, or a trailing space,\n     * or the buffer length is reached.\n     *\n     * Behaviour with non-octal input is currently undefined.\n     * \n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal string.\n     */\n    public static long parseOctal(byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) { // Found trailing null\n                break;\n            }\n\n            // Ignore leading spaces ('0' can be ignored anyway)\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                    continue;\n                }\n\n                if (currentByte == (byte) ' ') { // Found trailing space\n                    break;\n                }\n            }\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        \"Invalid octal digit at position \"+i+\" in '\"+new String(buffer, offset, length)+\"'\");\n            }\n            result = (result << 3) + (currentByte - '0');// TODO needs to reject invalid bytes\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) buffer[i]);\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Copy a name (StringBuffer) into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        // copy until end of input or output is reached.\n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        // Pad any remaining output bytes with NUL\n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    /**\n     * Fill buffer with unsigned octal number, padded with leading zeroes.\n     * \n     * @param value number to convert to octal - treated as unsigned\n     * @param buffer destination buffer\n     * @param offset starting offset in buffer\n     * @param length length of buffer to fill\n     * @throws IllegalArgumentException if the value will not fit in the buffer\n     */\n    public static void formatUnsignedOctalString(final long value, byte[] buffer,\n            final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                // CheckStyle:MagicNumber OFF\n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                // CheckStyle:MagicNumber ON\n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { // leading zeros\n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    /**\n     * Write an octal integer into a buffer.\n     *\n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by space and NUL\n     * \n     * @param value The value to write\n     * @param buf The buffer to receive the output\n     * @param offset The starting offset into the buffer\n     * @param length The size of the output buffer\n     * @return The updated offset, i.e offset+length\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // For space and trailing null\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; // Trailing space\n        buf[offset + idx]   = 0; // Trailing null\n\n        return offset + length;\n    }\n\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; // For space\n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }\n\n    /**\n     * Writes an octal value into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by NUL and then space.\n     *\n     * @param value The value to convert\n     * @param buf The destination buffer\n     * @param offset The starting offset into the buffer.\n     * @param length The size of the buffer.\n     * @return The updated value of offset, i.e. offset+length\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // for NUL and space\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; // Trailing null\n        buf[offset + idx]     = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }\n\n    /**\n     * Compute the checksum of a tar entry header.\n     *\n     * @param buf The tar entry's header buffer.\n     * @return The computed checksum.\n     */\n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "34",
        "class": "X7875_NewUnix",
        "fqdn": "org.apache.commons.compress.archivers.zip",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.zip.ZipException;\n\nimport static org.apache.commons.compress.archivers.zip.ZipUtil.reverse;\nimport static org.apache.commons.compress.archivers.zip.ZipUtil.signedByteToUnsignedInt;\nimport static org.apache.commons.compress.archivers.zip.ZipUtil.unsignedIntToSignedByte;\n\n/**\n * An extra field that stores UNIX UID/GID data (owner &amp; group ownership) for a given\n * zip entry.  We're using the field definition given in Info-Zip's source archive:\n * zip-3.0.tar.gz/proginfo/extrafld.txt\n *\n * <pre>\n * Local-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x7875        Short       tag for this extra block type (\"ux\")\n * TSize         Short       total data size for this block\n * Version       1 byte      version of this extra field, currently 1\n * UIDSize       1 byte      Size of UID field\n * UID           Variable    UID for this entry (little endian)\n * GIDSize       1 byte      Size of GID field\n * GID           Variable    GID for this entry (little endian)\n *\n * Central-header version:\n *\n * Value         Size        Description\n * -----         ----        -----------\n * 0x7855        Short       tag for this extra block type (\"Ux\")\n * TSize         Short       total data size for this block (0)\n * </pre>\n * @since 1.5\n */\npublic class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable {\n    private static final ZipShort HEADER_ID = new ZipShort(0x7875);\n    private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\n    private static final long serialVersionUID = 1L;\n\n    private int version = 1; // always '1' according to current info-zip spec.\n\n    // BigInteger helps us with little-endian / big-endian conversions.\n    // (thanks to BigInteger.toByteArray() and a reverse() method we created).\n    // Also, the spec theoretically allows UID/GID up to 255 bytes long!\n    //\n    // NOTE:  equals() and hashCode() currently assume these can never be null.\n    private BigInteger uid;\n    private BigInteger gid;\n\n    /**\n     * Constructor for X7875_NewUnix.\n     */\n    public X7875_NewUnix() {\n        reset();\n    }\n\n    /**\n     * The Header-ID.\n     *\n     * @return the value for the header id for this extrafield\n     */\n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }\n\n    /**\n     * Gets the UID as a long.  UID is typically a 32 bit unsigned\n     * value on most UNIX systems, so we return a long to avoid\n     * integer overflow into the negatives in case values above\n     * and including 2^31 are being used.\n     *\n     * @return the UID value.\n     */\n    public long getUID() { return ZipUtil.bigToLong(uid); }\n\n    /**\n     * Gets the GID as a long.  GID is typically a 32 bit unsigned\n     * value on most UNIX systems, so we return a long to avoid\n     * integer overflow into the negatives in case values above\n     * and including 2^31 are being used.\n     *\n     * @return the GID value.\n     */\n    public long getGID() { return ZipUtil.bigToLong(gid); }\n\n    /**\n     * Sets the UID.\n     *\n     * @param l UID value to set on this extra field.\n     */\n    public void setUID(long l) {\n        this.uid = ZipUtil.longToBig(l);\n    }\n\n    /**\n     * Sets the GID.\n     *\n     * @param l GID value to set on this extra field.\n     */\n    public void setGID(long l) {\n        this.gid = ZipUtil.longToBig(l);\n    }\n\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    public ZipShort getLocalFileDataLength() {\n        int uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\n        int gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n\n        // The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n        return new ZipShort(3 + uidSize + gidSize);\n    }\n\n    /**\n     * Length of the extra field in the central directory data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    public ZipShort getCentralDirectoryLength() {\n        return getLocalFileDataLength();\n    }\n\n    /**\n     * The actual data to put into local file data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    public byte[] getLocalFileDataData() {\n        byte[] uidBytes = uid.toByteArray();\n        byte[] gidBytes = gid.toByteArray();\n\n        // BigInteger might prepend a leading-zero to force a positive representation\n        // (e.g., so that the sign-bit is set to zero).  We need to remove that\n        // before sending the number over the wire.\n        uidBytes = trimLeadingZeroesForceMinLength(uidBytes);\n        gidBytes = trimLeadingZeroesForceMinLength(gidBytes);\n\n        // Couldn't bring myself to just call getLocalFileDataLength() when we've\n        // already got the arrays right here.  Yeah, yeah, I know, premature\n        // optimization is the root of all...\n        //\n        // The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n        byte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n\n        // reverse() switches byte array from big-endian to little-endian.\n        reverse(uidBytes);\n        reverse(gidBytes);\n\n        int pos = 0;\n        data[pos++] = unsignedIntToSignedByte(version);\n        data[pos++] = unsignedIntToSignedByte(uidBytes.length);\n        System.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\n        pos += uidBytes.length;\n        data[pos++] = unsignedIntToSignedByte(gidBytes.length);\n        System.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\n        return data;\n    }\n\n    /**\n     * The actual data to put into central directory data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    public byte[] getCentralDirectoryData() {\n        return new byte[0];\n    }\n\n    /**\n     * Populate data from this array as if it was in local file data.\n     *\n     * @param data   an array of bytes\n     * @param offset the start offset\n     * @param length the number of bytes in the array from offset\n     * @throws java.util.zip.ZipException on error\n     */\n    public void parseFromLocalFileData(\n            byte[] data, int offset, int length\n    ) throws ZipException {\n        reset();\n        this.version = signedByteToUnsignedInt(data[offset++]);\n        int uidSize = signedByteToUnsignedInt(data[offset++]);\n        byte[] uidBytes = new byte[uidSize];\n        System.arraycopy(data, offset, uidBytes, 0, uidSize);\n        offset += uidSize;\n        this.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\n\n        int gidSize = signedByteToUnsignedInt(data[offset++]);\n        byte[] gidBytes = new byte[gidSize];\n        System.arraycopy(data, offset, gidBytes, 0, gidSize);\n        this.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n    }\n\n    /**\n     * Doesn't do anything since this class doesn't store anything\n     * inside the central directory.\n     */\n    public void parseFromCentralDirectoryData(\n            byte[] buffer, int offset, int length\n    ) throws ZipException {\n    }\n\n    /**\n     * Reset state back to newly constructed state.  Helps us make sure\n     * parse() calls always generate clean results.\n     */\n    private void reset() {\n        // Typical UID/GID of the first non-root user created on a unix system.\n        uid = ONE_THOUSAND;\n        gid = ONE_THOUSAND;\n    }\n\n    /**\n     * Returns a String representation of this class useful for\n     * debugging purposes.\n     *\n     * @return A String representation of this class useful for\n     *         debugging purposes.\n     */\n    @Override\n    public String toString() {\n        return \"0x7875 Zip Extra Field: UID=\" + uid + \" GID=\" + gid;\n    }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof X7875_NewUnix) {\n            X7875_NewUnix xf = (X7875_NewUnix) o;\n            // We assume uid and gid can never be null.\n            return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int hc = -1234567 * version;\n        // Since most UID's and GID's are below 65,536, this is (hopefully!)\n        // a nice way to make sure typical UID and GID values impact the hash\n        // as much as possible.\n        hc ^= Integer.rotateLeft(uid.hashCode(), 16);\n        hc ^= gid.hashCode();\n        return hc;\n    }\n\n    /**\n     * Not really for external usage, but marked \"package\" visibility\n     * to help us JUnit it.   Trims a byte array of leading zeroes while\n     * also enforcing a minimum length, and thus it really trims AND pads\n     * at the same time.\n     *\n     * @param array byte[] array to trim & pad.\n     * @return trimmed & padded byte[] array.\n     */\n    static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n        if (array == null) {\n            return array;\n        }\n\n        int pos = 0;\n        for (byte b : array) {\n            if (b == 0) {\n                pos++;\n            } else {\n                break;\n            }\n        }\n\n        /*\n\n        I agonized over my choice of MIN_LENGTH=1.  Here's the situation:\n        InfoZip (the tool I am using to test interop) always sets these\n        to length=4.  And so a UID of 0 (typically root) for example is\n        encoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just\n        as easily be encoded as {1,0} (len=1, 8 bits of zero) according to\n        the spec.\n\n        In the end I decided on MIN_LENGTH=1 for four reasons:\n\n        1.)  We are adhering to the spec as far as I can tell, and so\n             a consumer that cannot parse this is broken.\n\n        2.)  Fundamentally, zip files are about shrinking things, so\n             let's save a few bytes per entry while we can.\n\n        3.)  Of all the people creating zip files using commons-\n             compress, how many care about UNIX UID/GID attributes\n             of the files they store?   (e.g., I am probably thinking\n             way too hard about this and no one cares!)\n\n        4.)  InfoZip's tool, even though it carefully stores every UID/GID\n             for every file zipped on a unix machine (by default) currently\n             appears unable to ever restore UID/GID.\n             unzip -X has no effect on my machine, even when run as root!!!!\n\n        And thus it is decided:  MIN_LENGTH=1.\n\n        If anyone runs into interop problems from this, feel free to set\n        it to MIN_LENGTH=4 at some future time, and then we will behave\n        exactly like InfoZip (requires changes to unit tests, though).\n\n        And I am sorry that the time you spent reading this comment is now\n        gone and you can never have it back.\n\n        */\n        final int MIN_LENGTH = 1;\n\n        byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n        int startPos = trimmedArray.length - (array.length - pos);\n        System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n        return trimmedArray;\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "42",
        "class": "UnixStat",
        "fqdn": "org.apache.commons.compress.archivers.zip",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.zip;\n\n/**\n * Constants from stat.h on Unix systems.\n */\n// CheckStyle:InterfaceIsTypeCheck OFF - backward compatible\npublic interface UnixStat {\n\n    /**\n     * Bits used for permissions (and sticky bit)\n     */\n    int PERM_MASK = 07777;\n    /**\n     * Bits used to indicate the filesystem object type.\n     * @since 1.14\n     */\n    /**\n     * Indicates symbolic links.\n     */\n    int LINK_FLAG = 0120000;\n    /**\n     * Indicates plain files.\n     */\n    int FILE_FLAG = 0100000;\n    /**\n     * Indicates directories.\n     */\n    int DIR_FLAG = 040000;\n\n    // ----------------------------------------------------------\n    // somewhat arbitrary choices that are quite common for shared\n    // installations\n    // -----------------------------------------------------------\n\n    /**\n     * Default permissions for symbolic links.\n     */\n    int DEFAULT_LINK_PERM = 0777;\n\n    /**\n     * Default permissions for directories.\n     */\n    int DEFAULT_DIR_PERM = 0755;\n\n    /**\n     * Default permissions for plain files.\n     */\n    int DEFAULT_FILE_PERM = 0644;\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "16",
        "class": "ArchiveStreamFactory",
        "fqdn": "org.apache.commons.compress.archivers",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n\n/**\n * <p>Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order add other implementations you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).</p>\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * \n * @Immutable\n */\npublic class ArchiveStreamFactory {\n\n    /**\n     * Constant used to identify the AR archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String AR = \"ar\";\n    /**\n     * Constant used to identify the CPIO archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String CPIO = \"cpio\";\n    /**\n     * Constant used to identify the Unix DUMP archive format.\n     * @since Commons Compress 1.3\n     */\n    public static final String DUMP = \"dump\";\n    /**\n     * Constant used to identify the JAR archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String JAR = \"jar\";\n    /**\n     * Constant used to identify the TAR archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String TAR = \"tar\";\n    /**\n     * Constant used to identify the ZIP archive format.\n     * @since Commons Compress 1.1\n     */\n    public static final String ZIP = \"zip\";\n\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException {\n\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n\n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveInputStream(in);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveInputStream(in);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveInputStream(in);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveInputStream(in);\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    /**\n     * Create an archive output stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\" or \"cpio\"\n     * @param out the output stream\n     * @return the archive output stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveOutputStream(out);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveOutputStream(out);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveOutputStream(out);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n                try {\n                    TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    // COMPRESS-191 - verify the header checksum\n                    tais.getNextEntry();\n                        return new TarArchiveInputStream(in);\n                } catch (Exception e) { // NOPMD\n                    // can generate IllegalArgumentException as well\n                    // as IOException\n                    // autodetection, simply not a TAR\n                    // ignored\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "19",
        "class": "Zip64ExtendedInformationExtraField",
        "fqdn": "org.apache.commons.compress.archivers.zip",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.util.zip.ZipException;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n\n/**\n * Holds size and other extended information for entries that use Zip64\n * features.\n *\n * <p>From {@link \"http://www.pkware.com/documents/casestudies/APPNOTE.TXT PKWARE's APPNOTE.TXT\"}\n * <pre>\n * Zip64 Extended Information Extra Field (0x0001):\n *\n *          The following is the layout of the zip64 extended \n *          information \"extra\" block. If one of the size or\n *          offset fields in the Local or Central directory\n *          record is too small to hold the required data,\n *          a Zip64 extended information record is created.\n *          The order of the fields in the zip64 extended \n *          information record is fixed, but the fields will\n *          only appear if the corresponding Local or Central\n *          directory record field is set to 0xFFFF or 0xFFFFFFFF.\n *\n *          Note: all fields stored in Intel low-byte/high-byte order.\n *\n *          Value      Size       Description\n *          -----      ----       -----------\n *  (ZIP64) 0x0001     2 bytes    Tag for this \"extra\" block type\n *          Size       2 bytes    Size of this \"extra\" block\n *          Original \n *          Size       8 bytes    Original uncompressed file size\n *          Compressed\n *          Size       8 bytes    Size of compressed data\n *          Relative Header\n *          Offset     8 bytes    Offset of local header record\n *          Disk Start\n *          Number     4 bytes    Number of the disk on which\n *                                this file starts \n *\n *          This entry in the Local header must include BOTH original\n *          and compressed file size fields. If encrypting the \n *          central directory and bit 13 of the general purpose bit\n *          flag is set indicating masking, the value stored in the\n *          Local Header for the original file size will be zero.\n * </pre></p>\n *\n * <p>Currently Commons Compress doesn't support encrypting the\n * central directory so the note about masking doesn't apply.</p>\n *\n * <p>The implementation relies on data being read from the local file\n * header and assumes that both size values are always present.</p>\n *\n * @since 1.2\n * @NotThreadSafe\n */\npublic class Zip64ExtendedInformationExtraField implements ZipExtraField {\n\n    static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\n    private static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n        \"Zip64 extended information must contain\"\n        + \" both size values in the local file header.\";\n    private static final byte[] EMPTY = new byte[0];\n\n    private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n    private ZipLong diskStart;\n\n    /**\n     * Stored in {@link #parseFromCentralDirectoryData\n     * parseFromCentralDirectoryData} so it can be reused when ZipFile\n     * calls {@link #reparseCentralDirectoryData\n     * reparseCentralDirectoryData}.\n     *\n     * <p>Not used for anything else</p>\n     *\n     * @since 1.3\n     */\n    private byte[] rawCentralDirectoryData;\n\n    /**\n     * This constructor should only be used by the code that reads\n     * archives inside of Commons Compress.\n     */\n    public Zip64ExtendedInformationExtraField() { }\n\n    /**\n     * Creates an extra field based on the original and compressed size.\n     *\n     * @param size the entry's original size\n     * @param compressedSize the entry's compressed size\n     *\n     * @throws IllegalArgumentException if size or compressedSize is null\n     */\n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n                                              ZipEightByteInteger compressedSize) {\n        this(size, compressedSize, null, null);\n    }\n\n    /**\n     * Creates an extra field based on all four possible values.\n     *\n     * @param size the entry's original size\n     * @param compressedSize the entry's compressed size\n     *\n     * @throws IllegalArgumentException if size or compressedSize is null\n     */\n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n                                              ZipEightByteInteger compressedSize,\n                                              ZipEightByteInteger relativeHeaderOffset,\n                                              ZipLong diskStart) {\n        this.size = size;\n        this.compressedSize = compressedSize;\n        this.relativeHeaderOffset = relativeHeaderOffset;\n        this.diskStart = diskStart;\n    }\n\n    /** {@inheritDoc} */\n    public ZipShort getHeaderId() {\n        return HEADER_ID;\n    }\n\n    /** {@inheritDoc} */\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(size != null ? 2 * DWORD : 0);\n    }\n\n    /** {@inheritDoc} */\n    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort((size != null ? DWORD : 0)\n                            + (compressedSize != null ? DWORD : 0)\n                            + (relativeHeaderOffset != null ? DWORD : 0)\n                            + (diskStart != null ? WORD : 0));\n    }\n\n    /** {@inheritDoc} */\n    public byte[] getLocalFileDataData() {\n        if (size != null || compressedSize != null) {\n            if (size == null || compressedSize == null) {\n                throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n            }\n            byte[] data = new byte[2 * DWORD];\n            addSizes(data);\n            return data;\n        }\n        return EMPTY;\n    }\n\n    /** {@inheritDoc} */\n    public byte[] getCentralDirectoryData() {\n        byte[] data = new byte[getCentralDirectoryLength().getValue()];\n        int off = addSizes(data);\n        if (relativeHeaderOffset != null) {\n            System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        if (diskStart != null) {\n            System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);\n            off += WORD;\n        }\n        return data;\n    }\n\n    /** {@inheritDoc} */\n    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n        throws ZipException {\n        if (length == 0) {\n            // no local file data at all, may happen if an archive\n            // only holds a ZIP64 extended information extra field\n            // inside the central directory but not inside the local\n            // file header\n            return;\n        }\n        if (length < 2 * DWORD) {\n            throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\n        }\n        size = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        compressedSize = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        int remaining = length - 2 * DWORD;\n        if (remaining >= DWORD) {\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            remaining -= DWORD;\n        }\n        if (remaining >= WORD) {\n            diskStart = new ZipLong(buffer, offset);\n            offset += WORD;\n            remaining -= WORD;\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                              int length)\n        throws ZipException {\n        // store for processing in reparseCentralDirectoryData\n        rawCentralDirectoryData = new byte[length];\n        System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n\n        // if there is no size information in here, we are screwed and\n        // can only hope things will get resolved by LFH data later\n        // But there are some cases that can be detected\n        // * all data is there\n        // * length == 24 -> both sizes and offset\n        // * length % 8 == 4 -> at least we can identify the diskStart field\n        if (length >= 3 * DWORD + WORD) {\n            parseFromLocalFileData(buffer, offset, length);\n        } else if (length == 3 * DWORD) {\n            size = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            compressedSize = new ZipEightByteInteger(buffer, offset);\n            offset += DWORD;\n            relativeHeaderOffset = new ZipEightByteInteger(buffer, offset);\n        } else if (length % DWORD == WORD) {\n            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }\n\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public ZipEightByteInteger getSize() {\n        return size;\n    }\n\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public void setSize(ZipEightByteInteger size) {\n        this.size = size;\n    }\n\n    /**\n     * The compressed size stored in this extra field.\n     */\n    public ZipEightByteInteger getCompressedSize() {\n        return compressedSize;\n    }\n\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n        this.compressedSize = compressedSize;\n    }\n\n    /**\n     * The relative header offset stored in this extra field.\n     */\n    public ZipEightByteInteger getRelativeHeaderOffset() {\n        return relativeHeaderOffset;\n    }\n\n    /**\n     * The relative header offset stored in this extra field.\n     */\n    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n        relativeHeaderOffset = rho;\n    }\n\n    /**\n     * The disk start number stored in this extra field.\n     */\n    public ZipLong getDiskStartNumber() {\n        return diskStart;\n    }\n\n    /**\n     * The disk start number stored in this extra field.\n     */\n    public void setDiskStartNumber(ZipLong ds) {\n        diskStart = ds;\n    }\n\n    private int addSizes(byte[] data) {\n        int off = 0;\n        if (size != null) {\n            System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\n            off += DWORD;\n        }\n        if (compressedSize != null) {\n            System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\n            off += DWORD;\n        }\n        return off;\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "8",
        "class": "TarUtils",
        "fqdn": "org.apache.commons.compress.archivers.tar",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.tar;\n\n/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\n// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)\npublic class TarUtils {\n\n    private static final int BYTE_MASK = 255;\n\n    /** Private constructor to prevent instantiation of this utility class. */\n    private TarUtils(){    \n    }\n\n    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n        int     start = offset;\n\n        for (int i = start; i < end; i++){\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) {\n                break;\n            }\n\n        // Skip leading spaces\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                   continue;\n            }\n                if (currentByte == (byte) ' ') {\n                break;\n                }\n            }\n\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n\n    // Helper method to generate the exception message\n    private static String exceptionMessage(byte[] buffer, final int offset,\n            final int length, int current, final byte currentByte) {\n        String string = new String(buffer, offset, length);\n        string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { // Trailing null\n                break;\n            }\n            result.append((char) (b & 0xFF)); // Allow for sign-extension\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Copy a name (StringBuffer) into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        // copy until end of input or output is reached.\n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        // Pad any remaining output bytes with NUL\n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    /**\n     * Fill buffer with unsigned octal number, padded with leading zeroes.\n     * \n     * @param value number to convert to octal - treated as unsigned\n     * @param buffer destination buffer\n     * @param offset starting offset in buffer\n     * @param length length of buffer to fill\n     * @throws IllegalArgumentException if the value will not fit in the buffer\n     */\n    public static void formatUnsignedOctalString(final long value, byte[] buffer,\n            final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                // CheckStyle:MagicNumber OFF\n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                // CheckStyle:MagicNumber ON\n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { // leading zeros\n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    /**\n     * Write an octal integer into a buffer.\n     *\n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by space and NUL\n     * \n     * @param value The value to write\n     * @param buf The buffer to receive the output\n     * @param offset The starting offset into the buffer\n     * @param length The size of the output buffer\n     * @return The updated offset, i.e offset+length\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // For space and trailing null\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; // Trailing space\n        buf[offset + idx]   = 0; // Trailing null\n\n        return offset + length;\n    }\n\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; // For space\n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }\n\n    /**\n     * Writes an octal value into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by NUL and then space.\n     *\n     * @param value The value to convert\n     * @param buf The destination buffer\n     * @param offset The starting offset into the buffer.\n     * @param length The size of the buffer.\n     * @return The updated value of offset, i.e. offset+length\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // for NUL and space\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; // Trailing null\n        buf[offset + idx]     = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }\n\n    /**\n     * Compute the checksum of a tar entry header.\n     *\n     * @param buf The tar entry's header buffer.\n     * @return The computed checksum.\n     */\n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "29",
        "class": "ArchiveStreamFactory",
        "fqdn": "org.apache.commons.compress.archivers",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;\nimport org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.sevenz.SevenZFile;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\nimport org.apache.commons.compress.utils.IOUtils;\n\n/**\n * Factory to create Archive[In|Out]putStreams from names or the first bytes of\n * the InputStream. In order to add other implementations, you should extend\n * ArchiveStreamFactory and override the appropriate methods (and call their\n * implementation from super of course).\n * \n * Compressing a ZIP-File:\n * \n * <pre>\n * final OutputStream out = new FileOutputStream(output); \n * ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.ZIP, out);\n * \n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test1.xml\"));\n * IOUtils.copy(new FileInputStream(file1), os);\n * os.closeArchiveEntry();\n *\n * os.putArchiveEntry(new ZipArchiveEntry(\"testdata/test2.xml\"));\n * IOUtils.copy(new FileInputStream(file2), os);\n * os.closeArchiveEntry();\n * os.close();\n * </pre>\n * \n * Decompressing a ZIP-File:\n * \n * <pre>\n * final InputStream is = new FileInputStream(input); \n * ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP, is);\n * ZipArchiveEntry entry = (ZipArchiveEntry)in.getNextEntry();\n * OutputStream out = new FileOutputStream(new File(dir, entry.getName()));\n * IOUtils.copy(in, out);\n * out.close();\n * in.close();\n * </pre>\n * @Immutable provided that the deprecated method setEntryEncoding is not used.\n */\npublic class ArchiveStreamFactory {\n\n    /**\n     * Constant (value {@value}) used to identify the AR archive format.\n     * @since 1.1\n     */\n    public static final String AR = \"ar\";\n    /**\n     * Constant (value {@value}) used to identify the ARJ archive format.\n     * Not supported as an output stream type.\n     * @since 1.6\n     */\n    public static final String ARJ = \"arj\";\n    /**\n     * Constant (value {@value}) used to identify the CPIO archive format.\n     * @since 1.1\n     */\n    public static final String CPIO = \"cpio\";\n    /**\n     * Constant (value {@value}) used to identify the Unix DUMP archive format.\n     * Not supported as an output stream type.\n     * @since 1.3\n     */\n    public static final String DUMP = \"dump\";\n    /**\n     * Constant (value {@value}) used to identify the JAR archive format.\n     * @since 1.1\n     */\n    public static final String JAR = \"jar\";\n    /**\n     * Constant used to identify the TAR archive format.\n     * @since 1.1\n     */\n    public static final String TAR = \"tar\";\n    /**\n     * Constant (value {@value}) used to identify the ZIP archive format.\n     * @since 1.1\n     */\n    public static final String ZIP = \"zip\";\n    /**\n     * Constant (value {@value}) used to identify the 7z archive format.\n     * @since 1.8\n     */\n    public static final String SEVEN_Z = \"7z\";\n\n    /**\n     * Entry encoding, null for the platform default.\n     */\n    private final String encoding;\n\n    /**\n     * Entry encoding, null for the default.\n     */\n    private volatile String entryEncoding = null;\n\n    /**\n     * Create an instance using the platform default encoding.\n     */\n    public ArchiveStreamFactory() {\n        this(null);\n    }\n\n    /**\n     * Create an instance using the specified encoding.\n     *\n     * @param encoding the encoding to be used.\n     *\n     * @since 1.10\n     */\n    public ArchiveStreamFactory(String encoding) {\n        super();\n        this.encoding = encoding;\n        // Also set the original field so can continue to use it.\n        this.entryEncoding = encoding;\n    }\n\n    /**\n     * Returns the encoding to use for arj, jar, zip, dump, cpio and tar\n     * files, or null for the archiver default.\n     *\n     * @return entry encoding, or null for the archiver default\n     * @since 1.5\n     */\n    public String getEntryEncoding() {\n        return entryEncoding;\n    }\n\n    /**\n     * Sets the encoding to use for arj, jar, zip, dump, cpio and tar files. Use null for the archiver default.\n     * \n     * @param entryEncoding the entry encoding, null uses the archiver default.\n     * @since 1.5\n     * @deprecated 1.10 use {@link #ArchiveStreamFactory(String)} to specify the encoding\n     * @throws IllegalStateException if the constructor {@link #ArchiveStreamFactory(String)} \n     * was used to specify the factory encoding.\n     */\n    @Deprecated\n    public void setEntryEncoding(String entryEncoding) {\n        // Note: this does not detect new ArchiveStreamFactory(null) but that does not set the encoding anyway\n        if (encoding != null) {\n            throw new IllegalStateException(\"Cannot overide encoding set by the constructor\");\n        }\n        this.entryEncoding = entryEncoding;\n    }\n\n    /**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ARJ}, {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO}, {@value #DUMP} or {@value #SEVEN_Z}\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * read from a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException {\n\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n\n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ARJ.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new ArjArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ArjArchiveInputStream(in);\n            }\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new TarArchiveInputStream(in);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                return new DumpArchiveInputStream(in);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    /**\n     * Create an archive output stream from an archiver name and an output stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n     * @param out the output stream\n     * @return the archive output stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * written to a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */\n    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n            if (entryEncoding != null) {\n                zip.setEncoding(entryEncoding);\n            }\n            return zip;\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new TarArchiveOutputStream(out);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n                return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new CpioArchiveOutputStream(out);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }\n\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * read from a stream\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new ZipArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new ZipArchiveInputStream(in);\n                }\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new JarArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new JarArchiveInputStream(in);\n                }\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                if (entryEncoding != null) {\n                    return new CpioArchiveInputStream(in, entryEncoding);\n                } else {\n                    return new CpioArchiveInputStream(in);\n                }\n            } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n                    return new ArjArchiveInputStream(in);\n            } else if (SevenZFile.matches(signature, signatureLength)) {\n                throw new StreamingNotSupportedException(SEVEN_Z);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n                TarArchiveInputStream tais = null;\n                try {\n                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    // COMPRESS-191 - verify the header checksum\n                    if (tais.getNextTarEntry().isCheckSumOK()) {\n                        return new TarArchiveInputStream(in, encoding);\n                    }\n                } catch (Exception e) { // NOPMD\n                    // can generate IllegalArgumentException as well\n                    // as IOException\n                    // autodetection, simply not a TAR\n                    // ignored\n                } finally {\n                    IOUtils.closeQuietly(tais);\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "44",
        "class": "ChecksumCalculatingInputStream",
        "fqdn": "org.apache.commons.compress.utils",
        "source_code": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.commons.compress.utils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.zip.Checksum;\n\n/**\n * A stream that calculates the checksum of the data read.\n * @NotThreadSafe\n * @since 1.14\n */\npublic class ChecksumCalculatingInputStream extends InputStream {\n    private final InputStream in;\n    private final Checksum checksum;\n\n    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\n        this.checksum = checksum;\n        this.in = in;\n    }\n\n    /**\n     * Reads a single byte from the stream\n     * @throws IOException if the underlying stream throws or the\n     * stream is exhausted and the Checksum doesn't match the expected\n     * value\n     */\n    @Override\n    public int read() throws IOException {\n        final int ret = in.read();\n        if (ret >= 0) {\n            checksum.update(ret);\n        }\n        return ret;\n    }\n\n    /**\n     * Reads a byte array from the stream\n     * @throws IOException if the underlying stream throws or the\n     * stream is exhausted and the Checksum doesn't match the expected\n     * value\n     */\n    @Override\n    public int read(final byte[] b) throws IOException {\n        return read(b, 0, b.length);\n    }\n\n    /**\n     * Reads from the stream into a byte array.\n     * @throws IOException if the underlying stream throws or the\n     * stream is exhausted and the Checksum doesn't match the expected\n     * value\n     */\n    @Override\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        final int ret = in.read(b, off, len);\n        if (ret >= 0) {\n            checksum.update(b, off, ret);\n        }\n        return ret;\n    }\n\n    @Override\n    public long skip(final long n) throws IOException {\n        // Can't really skip, we have to hash everything to verify the checksum\n        if (read() >= 0) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * Returns the calculated checksum.\n     * @return the calculated checksum.\n     */\n    public long getValue() {\n        return checksum.getValue();\n    }\n\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "40",
        "class": "BitInputStream",
        "fqdn": "org.apache.commons.compress.utils",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.utils;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteOrder;\n\n/**\n * Reads bits from an InputStream.\n * @since 1.10\n * @NotThreadSafe\n */\npublic class BitInputStream implements Closeable {\n    private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\n    private static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\n\n    static {\n        for (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\n            MASKS[i] = (MASKS[i - 1] << 1) + 1;\n        }\n    }\n\n    private final InputStream in;\n    private final ByteOrder byteOrder;\n    private long bitsCached = 0;\n    private int bitsCachedSize = 0;\n\n    /**\n     * Constructor taking an InputStream and its bit arrangement. \n     * @param in the InputStream\n     * @param byteOrder the bit arrangement across byte boundaries,\n     *      either BIG_ENDIAN (aaaaabbb bb000000) or LITTLE_ENDIAN (bbbaaaaa 000000bb)\n     */\n    public BitInputStream(final InputStream in, final ByteOrder byteOrder) {\n        this.in = in;\n        this.byteOrder = byteOrder;\n    }\n    \n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n    \n    /**\n     * Clears the cache of bits that have been read from the\n     * underlying stream but not yet provided via {@link #readBits}.\n     */\n    public void clearBitCache() {\n        bitsCached = 0;\n        bitsCachedSize = 0;\n    }\n    \n    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        \n        final long bitsOut;\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        return bitsOut;\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "26",
        "class": "IOUtils",
        "fqdn": "org.apache.commons.compress.utils",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * Utility functions\n * @Immutable\n */\npublic final class IOUtils {\n\n    private static final int COPY_BUF_SIZE = 8024;\n    private static final int SKIP_BUF_SIZE = 4096;\n\n    /** Private constructor to prevent instantiation of this utility class. */\n    private IOUtils(){\n    }\n\n    /**\n     * Copies the content of a InputStream into an OutputStream.\n     * Uses a default buffer size of 8024 bytes.\n     *\n     * @param input\n     *            the InputStream to copy\n     * @param output\n     *            the target Stream\n     * @throws IOException\n     *             if an error occurs\n     */\n    public static long copy(final InputStream input, final OutputStream output) throws IOException {\n        return copy(input, output, COPY_BUF_SIZE);\n    }\n\n    /**\n     * Copies the content of a InputStream into an OutputStream\n     *\n     * @param input\n     *            the InputStream to copy\n     * @param output\n     *            the target Stream\n     * @param buffersize\n     *            the buffer size to use\n     * @throws IOException\n     *             if an error occurs\n     */\n    public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\n        final byte[] buffer = new byte[buffersize];\n        int n = 0;\n        long count=0;\n        while (-1 != (n = input.read(buffer))) {\n            output.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n    \n    /**\n     * Skips the given number of bytes by repeatedly invoking skip on\n     * the given input stream if necessary.\n     *\n     * <p>In a case where the stream's skip() method returns 0 before\n     * the requested number of bytes has been skip this implementation\n     * will fall back to using the read() method.</p>\n     *\n     * <p>This method will only skip less than the requested number of\n     * bytes if the end of the input stream has been reached.</p>\n     *\n     * @param input stream to skip bytes in\n     * @param numToSkip the number of bytes to skip\n     * @return the number of bytes actually skipped\n     * @throws IOException\n     */\n    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n            \n        return available - numToSkip;\n    }\n\n    /**\n     * Reads as much from input as possible to fill the given array.\n     *\n     * <p>This method may invoke read repeatedly to fill the array and\n     * only read less bytes than the length of the array if the end of\n     * the stream has been reached.</p>\n     *\n     * @param input stream to read from\n     * @param b buffer to fill\n     * @return the number of bytes actually read\n     * @throws IOException\n     */\n    public static int readFully(InputStream input, byte[] b) throws IOException {\n        return readFully(input, b, 0, b.length);\n    }\n\n    /**\n     * Reads as much from input as possible to fill the given array\n     * with the given amount of bytes.\n     *\n     * <p>This method may invoke read repeatedly to read the bytes and\n     * only read less bytes than the requested length if the end of\n     * the stream has been reached.</p>\n     *\n     * @param input stream to read from\n     * @param b buffer to fill\n     * @param offset offset into the buffer to start filling at\n     * @param len of bytes to read\n     * @return the number of bytes actually read\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public static int readFully(InputStream input, byte[] b, int offset, int len)\n        throws IOException {\n        if (len < 0 || offset < 0 || len + offset > b.length) {\n            throw new IndexOutOfBoundsException();\n        }\n        int count = 0, x = 0;\n        while (count != len) {\n            x = input.read(b, offset + count, len - count);\n            if (x == -1) {\n                break;\n            }\n            count += x;\n        }\n        return count;\n    }\n\n    // toByteArray(InputStream) copied from:\n    // commons/proper/io/trunk/src/main/java/org/apache/commons/io/IOUtils.java?revision=1428941\n    // January 8th, 2013\n    //\n    // Assuming our copy() works just as well as theirs!  :-)\n\n    /**\n     * Gets the contents of an <code>InputStream</code> as a <code>byte[]</code>.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input  the <code>InputStream</code> to read from\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException if an I/O error occurs\n     * @since 1.5\n     */\n    public static byte[] toByteArray(final InputStream input) throws IOException {\n        final ByteArrayOutputStream output = new ByteArrayOutputStream();\n        copy(input, output);\n        return output.toByteArray();\n    }\n\n    /**\n     * Closes the given Closeable and swallows any IOException that may occur.\n     * @param c Closeable to close, can be null\n     * @since 1.7\n     */\n    public static void closeQuietly(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException ignored) { // NOPMD\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "Compress",
        "bug-id": "14",
        "class": "TarUtils",
        "fqdn": "org.apache.commons.compress.archivers.tar",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.commons.compress.archivers.tar;\n\n/**\n * This class provides static utility methods to work with byte streams.\n *\n * @Immutable\n */\n// CheckStyle:HideUtilityClassConstructorCheck OFF (bc)\npublic class TarUtils {\n\n    private static final int BYTE_MASK = 255;\n\n    /** Private constructor to prevent instantiation of this utility class. */\n    private TarUtils(){    \n    }\n\n    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        boolean allNUL = true;\n        for (int i = start; i < end; i++){\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n\n    /** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since Apache Commons Compress 1.4\n     */\n    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n\n        long val = buffer[offset] & 0x7f;\n        for (int i = 1; i < length; i++) {\n            if (val >= (1L << (63 - 8))) {\n                throw new IllegalArgumentException(\n                    \"At offset \" + offset + \", \" + length + \" byte \" +\n                    \"binary number exceeds maximum signed long value\");\n            }\n            val = (val << 8) + (buffer[offset + i] & 0xff);\n        }\n        return val;\n    }\n\n    /**\n     * Parse a boolean byte from a buffer.\n     * Leading spaces and NUL are ignored.\n     * The buffer may contain trailing spaces or NULs.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @return The boolean value of the bytes.\n     * @throws IllegalArgumentException if an invalid byte is detected.\n     */\n    public static boolean parseBoolean(final byte[] buffer, final int offset) {\n        return buffer[offset] == 1;\n    }\n\n    // Helper method to generate the exception message\n    private static String exceptionMessage(byte[] buffer, final int offset,\n            final int length, int current, final byte currentByte) {\n        String string = new String(buffer, offset, length);\n        string=string.replaceAll(\"\\0\", \"{NUL}\"); // Replace NULs to allow string to be printed\n        final String s = \"Invalid byte \"+currentByte+\" at offset \"+(current-offset)+\" in '\"+string+\"' len=\"+length;\n        return s;\n    }\n\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { // Trailing null\n                break;\n            }\n            result.append((char) (b & 0xFF)); // Allow for sign-extension\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Copy a name (StringBuffer) into a buffer.\n     * Copies characters from the name into the buffer\n     * starting at the specified offset. \n     * If the buffer is longer than the name, the buffer\n     * is filled with trailing NULs.\n     * If the name is longer than the buffer,\n     * the output is truncated.\n     *\n     * @param name The header name from which to copy the characters.\n     * @param buf The buffer where the name is to be stored.\n     * @param offset The starting offset into the buffer\n     * @param length The maximum number of header bytes to copy.\n     * @return The updated offset, i.e. offset + length\n     */\n    public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\n        int i;\n\n        // copy until end of input or output is reached.\n        for (i = 0; i < length && i < name.length(); ++i) {\n            buf[offset + i] = (byte) name.charAt(i);\n        }\n\n        // Pad any remaining output bytes with NUL\n        for (; i < length; ++i) {\n            buf[offset + i] = 0;\n        }\n\n        return offset + length;\n    }\n\n    /**\n     * Fill buffer with unsigned octal number, padded with leading zeroes.\n     * \n     * @param value number to convert to octal - treated as unsigned\n     * @param buffer destination buffer\n     * @param offset starting offset in buffer\n     * @param length length of buffer to fill\n     * @throws IllegalArgumentException if the value will not fit in the buffer\n     */\n    public static void formatUnsignedOctalString(final long value, byte[] buffer,\n            final int offset, final int length) {\n        int remaining = length;\n        remaining--;\n        if (value == 0) {\n            buffer[offset + remaining--] = (byte) '0';\n        } else {\n            long val = value;\n            for (; remaining >= 0 && val != 0; --remaining) {\n                // CheckStyle:MagicNumber OFF\n                buffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\n                val = val >>> 3;\n                // CheckStyle:MagicNumber ON\n            }\n            if (val != 0){\n                throw new IllegalArgumentException\n                (value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n            }\n        }\n\n        for (; remaining >= 0; --remaining) { // leading zeros\n            buffer[offset + remaining] = (byte) '0';\n        }\n    }\n\n    /**\n     * Write an octal integer into a buffer.\n     *\n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by space and NUL\n     * \n     * @param value The value to write\n     * @param buf The buffer to receive the output\n     * @param offset The starting offset into the buffer\n     * @param length The size of the output buffer\n     * @return The updated offset, i.e offset+length\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // For space and trailing null\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++] = (byte) ' '; // Trailing space\n        buf[offset + idx]   = 0; // Trailing null\n\n        return offset + length;\n    }\n\n    /**\n     * Write an octal long integer into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write as octal\n     * @param buf The destinationbuffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer\n     * @return The updated offset\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-1; // For space\n        \n        formatUnsignedOctalString(value, buf, offset, idx);\n        buf[offset + idx] = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }\n\n    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since Apache Commons Compress 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        if (value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        long val = value;\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8;\n        }\n\n        if (val != 0 || (buf[offset] & 0x80) != 0) {\n            throw new IllegalArgumentException(\"Value \" + value +\n                \" is too large for \" + length + \" byte field.\");\n        }\n\n        buf[offset] |= 0x80;\n        return offset + length;\n    }\n\n    /**\n     * Writes an octal value into a buffer.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by NUL and then space.\n     *\n     * @param value The value to convert\n     * @param buf The destination buffer\n     * @param offset The starting offset into the buffer.\n     * @param length The size of the buffer.\n     * @return The updated value of offset, i.e. offset+length\n     * @throws IllegalArgumentException if the value (and trailer) will not fit in the buffer\n     */\n    public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\n        int idx=length-2; // for NUL and space\n        formatUnsignedOctalString(value, buf, offset, idx);\n\n        buf[offset + idx++]   = 0; // Trailing null\n        buf[offset + idx]     = (byte) ' '; // Trailing space\n\n        return offset + length;\n    }\n\n    /**\n     * Compute the checksum of a tar entry header.\n     *\n     * @param buf The tar entry's header buffer.\n     * @return The computed checksum.\n     */\n    public static long computeCheckSum(final byte[] buf) {\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;\n    }\n}\n"
    },
    {
        "project_name": "Collections",
        "bug-id": "26",
        "class": "MultiKey",
        "fqdn": "org.apache.commons.collections4.keyvalue",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.keyvalue;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\n\n/**\n * A <code>MultiKey</code> allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by\n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * <p>\n * Example usage:\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n *\n * @since 3.0\n * @version $Id$\n */\npublic class MultiKey<K> implements Serializable {\n    // This class could implement List, but that would confuse it's purpose\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 4465448607415788805L;\n\n    /** The individual keys */\n    private final K[] keys;\n    /** The cached hashCode */\n    private transient int hashCode;\n\n    /**\n     * Constructor taking two keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2) {\n        this((K[]) new Object[] { key1, key2 }, false);\n    }\n\n    /**\n     * Constructor taking three keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3) {\n        this((K[]) new Object[] {key1, key2, key3}, false);\n    }\n\n    /**\n     * Constructor taking four keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3, final K key4) {\n        this((K[]) new Object[] {key1, key2, key3, key4}, false);\n    }\n\n    /**\n     * Constructor taking five keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3, final K key4, final K key5) {\n        this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);\n    }\n\n    /**\n     * Constructor taking an array of keys which is cloned.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * <p>\n     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n     *\n     * @param keys  the array of keys, not null\n     * @throws IllegalArgumentException if the key array is null\n     */\n    public MultiKey(final K[] keys) {\n        this(keys, true);\n    }\n\n    /**\n     * Constructor taking an array of keys, optionally choosing whether to clone.\n     * <p>\n     * <b>If the array is not cloned, then it must not be modified.</b>\n     * <p>\n     * This method is public for performance reasons only, to avoid a clone.\n     * The hashcode is calculated once here in this method.\n     * Therefore, changing the array passed in would not change the hashcode but\n     * would change the equals method, which is a bug.\n     * <p>\n     * This is the only fully safe usage of this constructor, as the object array\n     * is never made available in a variable:\n     * <pre>\n     * new MultiKey(new Object[] {...}, false);\n     * </pre>\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param keys  the array of keys, not null\n     * @param makeClone  true to clone the array, false to assign it\n     * @throws IllegalArgumentException if the key array is null\n     * @since 3.1\n     */\n    public MultiKey(final K[] keys, final boolean makeClone) {\n        super();\n        if (keys == null) {\n            throw new IllegalArgumentException(\"The array of keys must not be null\");\n        }\n        if (makeClone) {\n            this.keys = keys.clone();\n        } else {\n            this.keys = keys;\n        }\n\n        calculateHashCode(keys);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a clone of the array of keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed.\n     *\n     * @return the individual keys\n     */\n    public K[] getKeys() {\n        return keys.clone();\n    }\n\n    /**\n     * Gets the key at the specified index.\n     * <p>\n     * The key should be immutable.\n     * If it is not then it must not be changed.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.1\n     */\n    public K getKey(final int index) {\n        return keys[index];\n    }\n\n    /**\n     * Gets the size of the list of keys.\n     *\n     * @return the size of the list of keys\n     * @since 3.1\n     */\n    public int size() {\n        return keys.length;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object to another.\n     * <p>\n     * To be equal, the other object must be a <code>MultiKey</code> with the\n     * same number of keys which are also equal.\n     *\n     * @param other  the other object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    private Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n}\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "21",
        "class": "ConstructorInstantiator",
        "fqdn": "org.mockito.internal.creation.instance",
        "source_code": "package org.mockito.internal.creation.instance;\n\nimport java.lang.reflect.Constructor;\n\npublic class ConstructorInstantiator implements Instantiator {\n\n    private final Object outerClassInstance;\n\n    public ConstructorInstantiator(Object outerClassInstance) {\n        this.outerClassInstance = outerClassInstance;\n    }\n\n    public <T> T newInstance(Class<T> cls) {\n        if (outerClassInstance == null) {\n            return noArgConstructor(cls);\n        }\n        return withOuterClass(cls);\n    }\n\n    private <T> T withOuterClass(Class<T> cls) {\n        try {\n            //this is kind of overengineered because we don't need to support more params\n            //however, I know we will be needing it :)\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n        } catch (Exception e) {\n            throw paramsException(cls, e);\n        }\n    }\n\n    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n        return new InstantationException(\"Unable to create mock instance of '\"\n                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n    }\n\n\n    private static <T> T noArgConstructor(Class<T> cls) {\n        try {\n            return cls.newInstance();\n        } catch (Exception e) {\n            throw new InstantationException(\"Unable to create mock instance of '\"\n                    + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n        }\n    }\n}\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "22",
        "class": "Equality",
        "fqdn": "org.mockito.internal.matchers",
        "source_code": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.matchers;\r\n\r\nimport java.lang.reflect.Array;\r\n\r\n//stolen from hamcrest because I didn't want to have more dependency than Matcher class \r\npublic class Equality {\r\n\r\n    public static boolean areEqual(Object o1, Object o2) {\r\n        if (o1 == null || o2 == null) {\r\n            return o1 == null && o2 == null;\r\n        } else if (isArray(o1)) {\r\n            return isArray(o2) && areArraysEqual(o1, o2);\r\n        } else {\r\n            return o1.equals(o2);\r\n        }\r\n    }\r\n\r\n    static boolean areArraysEqual(Object o1, Object o2) {\r\n        return areArrayLengthsEqual(o1, o2)\r\n                && areArrayElementsEqual(o1, o2);\r\n    }\r\n\r\n    static boolean areArrayLengthsEqual(Object o1, Object o2) {\r\n        return Array.getLength(o1) == Array.getLength(o2);\r\n    }\r\n\r\n    static boolean areArrayElementsEqual(Object o1, Object o2) {\r\n        for (int i = 0; i < Array.getLength(o1); i++) {\r\n            if (!areEqual(Array.get(o1, i), Array.get(o2, i))) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static boolean isArray(Object o) {\r\n        return o.getClass().isArray();\r\n    }\r\n}"
    },
    {
        "project_name": "Mockito",
        "bug-id": "12",
        "class": "GenericMaster",
        "fqdn": "org.mockito.internal.util.reflection",
        "source_code": "package org.mockito.internal.util.reflection;\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.ParameterizedType;\r\nimport java.lang.reflect.Type;\r\n\r\n@SuppressWarnings(\"unchecked\")\r\npublic class GenericMaster {\r\n\r\n    /**\r\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \r\n     * \r\n     * @param field\r\n     * @return\r\n     */\r\n    public Class getGenericType(Field field) {        \r\n        Type generic = field.getGenericType();\r\n        if (generic != null && generic instanceof ParameterizedType) {\r\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n                return (Class) actual;\r\n                //in case of nested generics we don't go deep\r\n        }\r\n        \r\n        return Object.class;\r\n    }\r\n}\r\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "19",
        "class": "TypeBasedCandidateFilter",
        "fqdn": "org.mockito.internal.configuration.injection.filter",
        "source_code": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class TypeBasedCandidateFilter implements MockCandidateFilter {\n\n    MockCandidateFilter next;\n\n    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }\n\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n        List<Object> mockTypeMatches = new ArrayList<Object>();\n        for (Object mock : mocks) {\n            if (field.getType().isAssignableFrom(mock.getClass())) {\n                mockTypeMatches.add(mock);\n            }\n        }\n\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n    }\n}\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "19",
        "class": "NameBasedCandidateFilter",
        "fqdn": "org.mockito.internal.configuration.injection.filter",
        "source_code": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport org.mockito.internal.util.MockUtil;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class NameBasedCandidateFilter implements MockCandidateFilter {\n\tprivate final MockCandidateFilter next;\n\tprivate final MockUtil mockUtil = new MockUtil();\n\n\tpublic NameBasedCandidateFilter(MockCandidateFilter next) {\n\t\tthis.next = next;\n\t}\n\n\tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, Object fieldInstance) {\n\t\tList<Object> mockNameMatches = new ArrayList<Object>();\n\t\tif (mocks.size() > 1) {\n\t\t\tfor (Object mock : mocks) {\n\t\t\t\tif (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n\t\t\t\t\tmockNameMatches.add(mock);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field,\n\t\t\t\t\tfieldInstance);\n\t\t\t/*\n\t\t\t * In this case we have to check whether we have conflicting naming\n\t\t\t * fields. E.g. 2 fields of the same type, but we have to make sure\n\t\t\t * we match on the correct name.\n\t\t\t * \n\t\t\t * Therefore we have to go through all other fields and make sure\n\t\t\t * whenever we find a field that does match its name with the mock\n\t\t\t * name, we should take that field instead.\n\t\t\t */\n\t\t}\n\t\treturn next.filterCandidate(mocks, field, fieldInstance);\n\t}\n}\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "19",
        "class": "FinalMockCandidateFilter",
        "fqdn": "org.mockito.internal.configuration.injection.filter",
        "source_code": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport org.mockito.exceptions.Reporter;\nimport org.mockito.internal.util.reflection.BeanPropertySetter;\nimport org.mockito.internal.util.reflection.FieldSetter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\n\n/**\n * This node returns an actual injecter which will be either :\n *\n * <ul>\n * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n * </ul>\n */\npublic class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n        if(mocks.size() == 1) {\n            final Object matchingMock = mocks.iterator().next();\n\n            return new OngoingInjecter() {\n                public Object thenInject() {\n                    try {\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                            new FieldSetter(fieldInstance, field).set(matchingMock);\n                        }\n                    } catch (RuntimeException e) {\n                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                    }\n                    return matchingMock;\n                }\n            };\n        }\n\n        return new OngoingInjecter() {\n            public Object thenInject() {\n                return null;\n            }\n        };\n\n    }\n}\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "19",
        "class": "MockCandidateFilter",
        "fqdn": "org.mockito.internal.configuration.injection.filter",
        "source_code": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.configuration.injection.filter;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\n\npublic interface MockCandidateFilter {\n\n    OngoingInjecter filterCandidate(\n            Collection<Object> mocks,\n            Field fieldToBeInjected,\n            Object fieldInstance\n    );\n\n}\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "2",
        "class": "Timer",
        "fqdn": "org.mockito.internal.util",
        "source_code": "package org.mockito.internal.util;\n\n\npublic class Timer {\n\n    private final long durationMillis;\n    private long startTime = -1;\n\n    public Timer(long durationMillis) {\n        this.durationMillis = durationMillis;\n    }\n\n    /**\n     * Informs whether the timer is still counting down.\n     */\n    public boolean isCounting() {\n        assert startTime != -1;\n        return System.currentTimeMillis() - startTime <= durationMillis;\n    }\n\n    /**\n     * Starts the timer count down.\n     */\n    public void start() {\n        startTime = System.currentTimeMillis();\n    }\n\n}\n"
    },
    {
        "project_name": "Mockito",
        "bug-id": "26",
        "class": "Primitives",
        "fqdn": "org.mockito.internal.util",
        "source_code": "/*\r\n * Copyright (c) 2007 Mockito contributors\r\n * This program is made available under the terms of the MIT License.\r\n */\r\npackage org.mockito.internal.util;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n@SuppressWarnings(\"unchecked\")\r\npublic class Primitives {\r\n    \r\n    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\r\n        if(clazz.isPrimitive()) {\r\n            return clazz;\r\n        }\r\n        return (Class<T>) primitiveTypes.get(clazz);\r\n    }\r\n\r\n    public static boolean isPrimitiveWrapper(Class<?> type) {\r\n        return wrapperReturnValues.containsKey(type);\r\n    }\r\n\r\n    public static <T> T primitiveWrapperOf(Class<T> type) {\r\n        return (T) wrapperReturnValues.get(type);\r\n    }\r\n\r\n    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\r\n        return (T) primitiveValues.get(primitiveType);\r\n    }\r\n    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\r\n    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\r\n    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\r\n    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\r\n\r\n    static {\r\n        primitiveTypes.put(Boolean.class, Boolean.TYPE);\r\n        primitiveTypes.put(Character.class, Character.TYPE);\r\n        primitiveTypes.put(Byte.class, Byte.TYPE);\r\n        primitiveTypes.put(Short.class, Short.TYPE);\r\n        primitiveTypes.put(Integer.class, Integer.TYPE);\r\n        primitiveTypes.put(Long.class, Long.TYPE);\r\n        primitiveTypes.put(Float.class, Float.TYPE);\r\n        primitiveTypes.put(Double.class, Double.TYPE);\r\n    }\r\n\r\n    static {\r\n        wrapperReturnValues.put(Boolean.class, false);\r\n        wrapperReturnValues.put(Character.class, '\\u0000');\r\n        wrapperReturnValues.put(Byte.class, (byte) 0);\r\n        wrapperReturnValues.put(Short.class, (short) 0);\r\n        wrapperReturnValues.put(Integer.class, 0);\r\n        wrapperReturnValues.put(Long.class, 0L);\r\n        wrapperReturnValues.put(Float.class, 0F);\r\n        wrapperReturnValues.put(Double.class, 0D);\r\n    }\r\n\r\n    static {\r\n        primitiveValues.put(boolean.class, false);\r\n        primitiveValues.put(char.class, '\\u0000');\r\n        primitiveValues.put(byte.class, (byte) 0);\r\n        primitiveValues.put(short.class, (short) 0);\r\n        primitiveValues.put(int.class, 0);\r\n        primitiveValues.put(long.class, 0L);\r\n        primitiveValues.put(float.class, 0F);\r\n        primitiveValues.put(double.class, 0);\r\n    }\r\n}"
    },
    {
        "project_name": "Math",
        "bug-id": "90",
        "class": "Frequency",
        "fqdn": "org.apache.commons.math.stat",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.stat;\n\nimport java.io.Serializable;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Comparator;\nimport java.util.TreeMap;\n\n/** \n * Maintains a frequency distribution.\n * <p>\n * Accepts int, long, char or Object values.  New values added must be \n * comparable to those that have been added, otherwise the add method will \n * throw an IllegalArgumentException.</p>\n * <p>\n * Integer values (int, long, Integer, Long) are not distinguished by type -- \n * i.e. <code>addValue(Long.valueOf(2)), addValue(2), addValue(2l)</code> all have\n * the same effect (similarly for arguments to <code>getCount,</code> etc.).</p>\n * <p>\n * char values are converted by <code>addValue</code> to Character instances.\n * As such, these values are not comparable to integral values, so attempts\n * to combine integral types with chars in a frequency distribution will fail.\n * </p>\n * <p>\n * The values are ordered using the default (natural order), unless a  \n * <code>Comparator</code> is supplied in the constructor.</p>\n *\n * @version $Revision$ $Date$\n */\npublic class Frequency implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -3845586908418844111L;\n\n    /** underlying collection */\n    private final TreeMap freqTable;\n\n    /**\n     * Default constructor.\n     */\n    public Frequency() {\n        freqTable = new TreeMap();\n    }\n    \n    /**\n     * Constructor allowing values Comparator to be specified.\n     * \n     * @param comparator Comparator used to order values\n     */\n    public Frequency(Comparator comparator) {\n        freqTable = new TreeMap(comparator);\n    }\n\n    /**\n     * Return a string representation of this frequency\n     * distribution.\n     * \n     * @return a string representation.\n     */\n    @Override\n    public String toString() {\n        NumberFormat nf = NumberFormat.getPercentInstance();\n        StringBuffer outBuffer = new StringBuffer();\n        outBuffer.append(\"Value \\t Freq. \\t Pct. \\t Cum Pct. \\n\");\n        Iterator iter = freqTable.keySet().iterator();\n        while (iter.hasNext()) {\n            Object value = iter.next();\n            outBuffer.append(value);\n            outBuffer.append('\\t');\n            outBuffer.append(getCount(value));\n            outBuffer.append('\\t');\n            outBuffer.append(nf.format(getPct(value)));\n            outBuffer.append('\\t');\n            outBuffer.append(nf.format(getCumPct(value)));\n            outBuffer.append('\\n');\n        }\n        return outBuffer.toString();\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     * @throws ClassCastException if <code>v</code> is not Comparable\n     * @deprecated use {@link #addValue(Comparable)} instead\n     */\n    @Deprecated\n    public void addValue(Object v) {\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(int v) {\n        addValue(Long.valueOf(v));\n    }\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(Integer v) {\n        addValue(Long.valueOf(v.longValue()));\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(long v) {\n        addValue(Long.valueOf(v));\n    }\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(char v) {\n        addValue(Character.valueOf(v));\n    }\n    \n    /** Clears the frequency table */\n    public void clear() {\n        freqTable.clear();\n    }\n    \n    /**\n     * Returns an Iterator over the set of values that have been added.\n     * <p>\n     * If added values are integral (i.e., integers, longs, Integers, or Longs), \n     * they are converted to Longs when they are added, so the objects returned\n     * by the Iterator will in this case be Longs.</p>\n     * \n     * @return values Iterator\n     */\n    public Iterator valuesIterator() {\n        return freqTable.keySet().iterator();\n    }\n    \n    //-------------------------------------------------------------------------\n    \n    /**\n     * Returns the sum of all frequencies.\n     * \n     * @return the total frequency count.\n     */\n    public long getSumFreq() {\n        long result = 0;\n        Iterator iterator = freqTable.values().iterator();\n        while (iterator.hasNext())  {\n            result += ((Long) iterator.next()).longValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of values = v.\n     * Returns 0 if the value is not comparable.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(Object v) {\n        if (v instanceof Integer) {\n            return getCount(((Integer) v).longValue());\n        }\n        long result = 0;\n        try { \n            Long count =  (Long) freqTable.get(v);\n            if (count != null) {\n                result = count.longValue();\n            }\n        } catch (ClassCastException ex) {\n            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(int v) {\n        return getCount(Long.valueOf(v));\n    }\n    \n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(long v) {\n        return getCount(Long.valueOf(v));\n    }\n    \n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(char v) {\n        return getCount(Character.valueOf(v));\n    }\n    \n    //-------------------------------------------------------------\n\n    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(Object v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCount(v) / (double) sumFreq;        \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(int v) {\n        return getPct(Long.valueOf(v));       \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(long v) {\n        return getPct(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(char v) {\n        return getPct(Character.valueOf(v));         \n    }\n    \n    //-----------------------------------------------------------------------------------------\n    \n    /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup.\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(Object v) {\n        if (getSumFreq() == 0) {\n            return 0;\n        }\n        if (v instanceof Integer) {\n            return getCumFreq(((Integer) v).longValue());\n        }\n        Comparator c = freqTable.comparator();\n        if (c == null) {\n            c = new NaturalComparator();\n        }\n        long result = 0;\n        \n        try {\n            Long value = (Long) freqTable.get(v);\n            if (value != null) {\n                result = value.longValue();\n            }\n        } catch (ClassCastException ex) {\n            return result;   // v is not comparable\n        }\n        \n        if (c.compare(v, freqTable.firstKey()) < 0) {\n            return 0;  // v is comparable, but less than first value\n        }\n        \n        if (c.compare(v, freqTable.lastKey()) >= 0) {\n            return getSumFreq();    // v is comparable, but greater than the last value\n        }\n        \n        Iterator values = valuesIterator();\n        while (values.hasNext()) {\n            Object nextValue = values.next();\n            if (c.compare(v, nextValue) > 0) {\n                result += getCount(nextValue);\n            } else {\n                return result;\n            }\n        }\n        return result;\n    }\n    \n     /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(int v) {\n        return getCumFreq(Long.valueOf(v));       \n    }\n    \n     /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(long v) {\n        return getCumFreq(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(char v) {\n        return getCumFreq(Character.valueOf(v));         \n    }\n    \n    //----------------------------------------------------------------------------------------------\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.\n     * Returns 0 if at least one value has been added, but v is not comparable\n     * to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(Object v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCumFreq(v) / (double) sumFreq;        \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(int v) {\n        return getCumPct(Long.valueOf(v));       \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(long v) {\n        return getCumPct(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(char v) {\n        return getCumPct(Character.valueOf(v));         \n    }\n    \n    /**\n     * A Comparator that compares comparable objects using the\n     * natural order.  Copied from Commons Collections ComparableComparator.\n     */\n    private static class NaturalComparator implements Comparator, Serializable {\n\n        /** Serializable version identifier */\n        private static final long serialVersionUID = -3852193713161395148L;\n\n        /**\n         * Compare the two {@link Comparable Comparable} arguments.\n         * This method is equivalent to:\n         * <pre>(({@link Comparable Comparable})o1).{@link Comparable#compareTo compareTo}(o2)</pre>\n         * \n         * @param  o1 the first object \n         * @param  o2 the second object\n         * @return  result of comparison\n         * @throws NullPointerException when <i>o1</i> is <code>null</code>, \n         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n         * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable}, \n         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n         */\n        public int compare(Object o1, Object o2) {\n            return ((Comparable)o1).compareTo(o2);\n        }\n    }\n}\n"
    },
    {
        "project_name": "Math",
        "bug-id": "89",
        "class": "Frequency",
        "fqdn": "org.apache.commons.math.stat",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.stat;\n\nimport java.io.Serializable;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Comparator;\nimport java.util.TreeMap;\n\n/** \n * Maintains a frequency distribution.\n * <p>\n * Accepts int, long, char or Object values.  New values added must be \n * comparable to those that have been added, otherwise the add method will \n * throw an IllegalArgumentException.</p>\n * <p>\n * Integer values (int, long, Integer, Long) are not distinguished by type -- \n * i.e. <code>addValue(Long.valueOf(2)), addValue(2), addValue(2l)</code> all have\n * the same effect (similarly for arguments to <code>getCount,</code> etc.).</p>\n * <p>\n * char values are converted by <code>addValue</code> to Character instances.\n * As such, these values are not comparable to integral values, so attempts\n * to combine integral types with chars in a frequency distribution will fail.\n * </p>\n * <p>\n * The values are ordered using the default (natural order), unless a  \n * <code>Comparator</code> is supplied in the constructor.</p>\n *\n * @version $Revision$ $Date$\n */\npublic class Frequency implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -3845586908418844111L;\n\n    /** underlying collection */\n    private final TreeMap freqTable;\n\n    /**\n     * Default constructor.\n     */\n    public Frequency() {\n        freqTable = new TreeMap();\n    }\n    \n    /**\n     * Constructor allowing values Comparator to be specified.\n     * \n     * @param comparator Comparator used to order values\n     */\n    public Frequency(Comparator comparator) {\n        freqTable = new TreeMap(comparator);\n    }\n\n    /**\n     * Return a string representation of this frequency\n     * distribution.\n     * \n     * @return a string representation.\n     */\n    @Override\n    public String toString() {\n        NumberFormat nf = NumberFormat.getPercentInstance();\n        StringBuffer outBuffer = new StringBuffer();\n        outBuffer.append(\"Value \\t Freq. \\t Pct. \\t Cum Pct. \\n\");\n        Iterator iter = freqTable.keySet().iterator();\n        while (iter.hasNext()) {\n            Object value = iter.next();\n            outBuffer.append(value);\n            outBuffer.append('\\t');\n            outBuffer.append(getCount(value));\n            outBuffer.append('\\t');\n            outBuffer.append(nf.format(getPct(value)));\n            outBuffer.append('\\t');\n            outBuffer.append(nf.format(getCumPct(value)));\n            outBuffer.append('\\n');\n        }\n        return outBuffer.toString();\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not Comparable, \n     *         or is not comparable with previous entries\n     * @deprecated use {@link #addValue(Comparable)} instead\n     */\n    @Deprecated\n    public void addValue(Object v) {\n            addValue((Comparable<?>) v);            \n    }\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?>v){\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(int v) {\n        addValue(Long.valueOf(v));\n    }\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(Integer v) {\n        addValue(Long.valueOf(v.longValue()));\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(long v) {\n        addValue(Long.valueOf(v));\n    }\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(char v) {\n        addValue(Character.valueOf(v));\n    }\n    \n    /** Clears the frequency table */\n    public void clear() {\n        freqTable.clear();\n    }\n    \n    /**\n     * Returns an Iterator over the set of values that have been added.\n     * <p>\n     * If added values are integral (i.e., integers, longs, Integers, or Longs), \n     * they are converted to Longs when they are added, so the objects returned\n     * by the Iterator will in this case be Longs.</p>\n     * \n     * @return values Iterator\n     */\n    public Iterator valuesIterator() {\n        return freqTable.keySet().iterator();\n    }\n    \n    //-------------------------------------------------------------------------\n    \n    /**\n     * Returns the sum of all frequencies.\n     * \n     * @return the total frequency count.\n     */\n    public long getSumFreq() {\n        long result = 0;\n        Iterator iterator = freqTable.values().iterator();\n        while (iterator.hasNext())  {\n            result += ((Long) iterator.next()).longValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of values = v.\n     * Returns 0 if the value is not comparable.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(Object v) {\n        if (v instanceof Integer) {\n            return getCount(((Integer) v).longValue());\n        }\n        long result = 0;\n        try { \n            Long count =  (Long) freqTable.get(v);\n            if (count != null) {\n                result = count.longValue();\n            }\n        } catch (ClassCastException ex) {\n            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(int v) {\n        return getCount(Long.valueOf(v));\n    }\n    \n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(long v) {\n        return getCount(Long.valueOf(v));\n    }\n    \n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(char v) {\n        return getCount(Character.valueOf(v));\n    }\n    \n    //-------------------------------------------------------------\n\n    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(Object v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCount(v) / (double) sumFreq;        \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(int v) {\n        return getPct(Long.valueOf(v));       \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(long v) {\n        return getPct(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(char v) {\n        return getPct(Character.valueOf(v));         \n    }\n    \n    //-----------------------------------------------------------------------------------------\n    \n    /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup.\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(Object v) {\n        if (getSumFreq() == 0) {\n            return 0;\n        }\n        if (v instanceof Integer) {\n            return getCumFreq(((Integer) v).longValue());\n        }\n        Comparator c = freqTable.comparator();\n        if (c == null) {\n            c = new NaturalComparator();\n        }\n        long result = 0;\n        \n        try {\n            Long value = (Long) freqTable.get(v);\n            if (value != null) {\n                result = value.longValue();\n            }\n        } catch (ClassCastException ex) {\n            return result;   // v is not comparable\n        }\n        \n        if (c.compare(v, freqTable.firstKey()) < 0) {\n            return 0;  // v is comparable, but less than first value\n        }\n        \n        if (c.compare(v, freqTable.lastKey()) >= 0) {\n            return getSumFreq();    // v is comparable, but greater than the last value\n        }\n        \n        Iterator values = valuesIterator();\n        while (values.hasNext()) {\n            Object nextValue = values.next();\n            if (c.compare(v, nextValue) > 0) {\n                result += getCount(nextValue);\n            } else {\n                return result;\n            }\n        }\n        return result;\n    }\n    \n     /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(int v) {\n        return getCumFreq(Long.valueOf(v));       \n    }\n    \n     /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(long v) {\n        return getCumFreq(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(char v) {\n        return getCumFreq(Character.valueOf(v));         \n    }\n    \n    //----------------------------------------------------------------------------------------------\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.\n     * Returns 0 if at least one value has been added, but v is not comparable\n     * to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(Object v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCumFreq(v) / (double) sumFreq;        \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(int v) {\n        return getCumPct(Long.valueOf(v));       \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(long v) {\n        return getCumPct(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(char v) {\n        return getCumPct(Character.valueOf(v));         \n    }\n    \n    /**\n     * A Comparator that compares comparable objects using the\n     * natural order.  Copied from Commons Collections ComparableComparator.\n     */\n    private static class NaturalComparator implements Comparator, Serializable {\n\n        /** Serializable version identifier */\n        private static final long serialVersionUID = -3852193713161395148L;\n\n        /**\n         * Compare the two {@link Comparable Comparable} arguments.\n         * This method is equivalent to:\n         * <pre>(({@link Comparable Comparable})o1).{@link Comparable#compareTo compareTo}(o2)</pre>\n         * \n         * @param  o1 the first object \n         * @param  o2 the second object\n         * @return  result of comparison\n         * @throws NullPointerException when <i>o1</i> is <code>null</code>, \n         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n         * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable}, \n         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n         */\n        public int compare(Object o1, Object o2) {\n            return ((Comparable)o1).compareTo(o2);\n        }\n    }\n}\n"
    },
    {
        "project_name": "Closure",
        "bug-id": "131",
        "class": "TokenStream",
        "fqdn": "com.google.javascript.rhino",
        "source_code": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Roger Lawrence\n *   Mike McCabe\n *   Igor Bukanov\n *   Ethan Hugg\n *   Bob Jervis\n *   Terry Lucas\n *   Milen Nankov\n *   Pascal-Louis Perez\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\n/**\n * This class implements the JavaScript scanner.\n *\n * It is based on the C source files jsscan.c and jsscan.h\n * in the jsref package.\n *\n */\n\npublic class TokenStream {\n    public static boolean isKeyword(String name) {\n        boolean id = false;\n        String s = name;\n        complete: {\n            String X = null;\n            int c;\n            partial: switch (s.length()) {\n            case 2: c=s.charAt(1);\n                if (c=='f') {\n                  if (s.charAt(0)=='i') {id=true; break complete;}\n                } else if (c=='n') {\n                  if (s.charAt(0)=='i') {id=true; break complete;}\n                } else if (c=='o') {\n                  if (s.charAt(0)=='d') {id=true; break complete;}\n                }\n                break partial;\n            case 3: switch (s.charAt(0)) {\n                case 'f':\n                  if (s.charAt(2)=='r' && s.charAt(1)=='o') {\n                    id=true; break complete;\n                  } break partial;\n                case 'i':\n                  if (s.charAt(2)=='t' && s.charAt(1)=='n') {\n                    id=true; break complete;\n                  } break partial;\n                case 'n':\n                  if (s.charAt(2)=='w' && s.charAt(1)=='e') {\n                    id=true; break complete;\n                  } break partial;\n                case 't':\n                  if (s.charAt(2)=='y' && s.charAt(1)=='r') {\n                    id=true; break complete;\n                  } break partial;\n                case 'v':\n                  if (s.charAt(2)=='r' && s.charAt(1)=='a') {\n                    id=true; break complete;\n                  } break partial;\n                } break partial;\n            case 4: switch (s.charAt(0)) {\n                case 'b': X=\"byte\";id=true; break partial;\n                case 'c': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {\n                            id=true; break complete;} }\n                    else if (c=='r') {\n                      if (s.charAt(2)=='a' && s.charAt(1)=='h') {\n                        id=true; break complete;\n                      }\n                    }\n                    break partial;\n                case 'e': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {\n                            id=true; break complete;} }\n                    else if (c=='m') {\n                      if (s.charAt(2)=='u' && s.charAt(1)=='n') {\n                            id=true; break complete;} }\n                    break partial;\n                case 'g': X=\"goto\";id=true; break partial;\n                case 'l': X=\"long\";id=true; break partial;\n                case 'n': X=\"null\";id=true; break partial;\n                case 't': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {\n                            id=true; break complete;} }\n                    else if (c=='s') {\n                      if (s.charAt(2)=='i' && s.charAt(1)=='h') {\n                            id=true; break complete;} }\n                    break partial;\n                case 'v': X=\"void\";id=true; break partial;\n                case 'w': X=\"with\";id=true; break partial;\n                } break partial;\n            case 5: switch (s.charAt(2)) {\n                case 'a': X=\"class\";id=true; break partial;\n                case 'e': X=\"break\";id=true; break partial;\n                case 'i': X=\"while\";id=true; break partial;\n                case 'l': X=\"false\";id=true; break partial;\n                case 'n': c=s.charAt(0);\n                    if (c=='c') { X=\"const\";id=true; }\n                    else if (c=='f') { X=\"final\";id=true; }\n                    break partial;\n                case 'o': c=s.charAt(0);\n                    if (c=='f') { X=\"float\";id=true; }\n                    else if (c=='s') { X=\"short\";id=true; }\n                    break partial;\n                case 'p': X=\"super\";id=true; break partial;\n                case 'r': X=\"throw\";id=true; break partial;\n                case 't': X=\"catch\";id=true; break partial;\n                } break partial;\n            case 6: switch (s.charAt(1)) {\n                case 'a': X=\"native\";id=true; break partial;\n                case 'e': c=s.charAt(0);\n                    if (c=='d') { X=\"delete\";id=true; }\n                    else if (c=='r') { X=\"return\";id=true; }\n                    break partial;\n                case 'h': X=\"throws\";id=true; break partial;\n                case 'm': X=\"import\";id=true; break partial;\n                case 'o': X=\"double\";id=true; break partial;\n                case 't': X=\"static\";id=true; break partial;\n                case 'u': X=\"public\";id=true; break partial;\n                case 'w': X=\"switch\";id=true; break partial;\n                case 'x': X=\"export\";id=true; break partial;\n                case 'y': X=\"typeof\";id=true; break partial;\n                } break partial;\n            case 7: switch (s.charAt(1)) {\n                case 'a': X=\"package\";id=true; break partial;\n                case 'e': X=\"default\";id=true; break partial;\n                case 'i': X=\"finally\";id=true; break partial;\n                case 'o': X=\"boolean\";id=true; break partial;\n                case 'r': X=\"private\";id=true; break partial;\n                case 'x': X=\"extends\";id=true; break partial;\n                } break partial;\n            case 8: switch (s.charAt(0)) {\n                case 'a': X=\"abstract\";id=true; break partial;\n                case 'c': X=\"continue\";id=true; break partial;\n                case 'd': X=\"debugger\";id=true; break partial;\n                case 'f': X=\"function\";id=true; break partial;\n                case 'v': X=\"volatile\";id=true; break partial;\n                } break partial;\n            case 9: c=s.charAt(0);\n                if (c=='i') { X=\"interface\";id=true; }\n                else if (c=='p') { X=\"protected\";id=true; }\n                else if (c=='t') { X=\"transient\";id=true; }\n                break partial;\n            case 10: c=s.charAt(1);\n                if (c=='m') { X=\"implements\";id=true; }\n                else if (c=='n') { X=\"instanceof\";id=true; }\n                break partial;\n            case 12: X=\"synchronized\";id=true; break partial;\n            }\n            // partial match validate the entire string the one possibility\n            if (X!=null && X!=s && !X.equals(s)) return false;\n        }\n        return id;\n    }\n\n    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n}\n"
    },
    {
        "project_name": "Gson",
        "bug-id": "1",
        "class": "TypeInfoFactory",
        "fqdn": "com.google.gson",
        "source_code": "/*\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\n\n/**\n * A static factory class used to construct the \"TypeInfo\" objects.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n */\nfinal class TypeInfoFactory {\n\n  private TypeInfoFactory() {\n    // Not instantiable since it provides factory methods only.\n  }\n\n  public static TypeInfoArray getTypeInfoForArray(Type type) {\n    Preconditions.checkArgument(TypeUtils.isArray(type));\n    return new TypeInfoArray(type);\n  }\n\n  /**\n   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n   *\n   * @param f the actual field object to retrieve the type from\n   * @param typeDefiningF the type that contains the field {@code f}\n   * @return the type information for the field\n   */\n  public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {\n    Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF);\n    Type type = f.getGenericType();\n    Type actualType = getActualType(type, typeDefiningF, classDefiningF);\n    return new TypeInfo(actualType);\n  }\n\n  private static Type getActualType(\n      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n    if (typeToEvaluate instanceof Class<?>) {\n      return typeToEvaluate;\n    } else if (typeToEvaluate instanceof ParameterizedType) {\n      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n      Type owner = castedType.getOwnerType();\n      Type[] actualTypeParameters =\n          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n      Type rawType = castedType.getRawType();\n      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n    } else if (typeToEvaluate instanceof GenericArrayType) {\n      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n      Type componentType = castedType.getGenericComponentType();\n      Type actualType = getActualType(componentType, parentType, rawParentClass);\n      if (componentType.equals(actualType)) {\n        return castedType;\n      }\n      return actualType instanceof Class<?> ?\n          TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n          : new GenericArrayTypeImpl(actualType);\n    } else if (typeToEvaluate instanceof TypeVariable<?>) {\n      if (parentType instanceof ParameterizedType) {\n        // The class definition has the actual types used for the type variables.\n        // Find the matching actual type for the Type Variable used for the field.\n        // For example, class Foo<A> { A a; }\n        // new Foo<Integer>(); defines the actual type of A to be Integer.\n        // So, to find the type of the field a, we will have to look at the class'\n        // actual type arguments.\n        TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n        TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n        ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n        int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n        Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n        return actualTypeArguments[indexOfActualTypeArgument];\n\n\n      }\n\n      throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n          + \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n          + \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n    } else if (typeToEvaluate instanceof WildcardType) {\n      WildcardType castedType = (WildcardType) typeToEvaluate;\n      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n    } else {\n      throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n          + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n    }\n  }\n\n\n      // Evaluate type on this type\n\n\n\n  private static Type[] extractRealTypes(\n      Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {\n    Preconditions.checkNotNull(actualTypeArguments);\n\n    Type[] retTypes = new Type[actualTypeArguments.length];\n    for (int i = 0; i < actualTypeArguments.length; ++i) {\n      retTypes[i] = getActualType(actualTypeArguments[i], parentType, rawParentClass);\n    }\n    return retTypes;\n  }\n\n  private static int getIndex(TypeVariable<?>[] types, TypeVariable<?> type) {\n    for (int i = 0; i < types.length; ++i) {\n      if (type.equals(types[i])) {\n        return i;\n      }\n    }\n    throw new IllegalStateException(\n        \"How can the type variable not be present in the class declaration!\");\n  }\n}\n"
    },
    {
        "project_name": "Gson",
        "bug-id": "5",
        "class": "ISO8601Utils",
        "fqdn": "com.google.gson.internal.bind.util",
        "source_code": "package com.google.gson.internal.bind.util;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.*;\n\n/**\n * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n * highly suitable if you (un)serialize lots of date objects.\n * \n * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]\n * \n * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\n */\n//Date parsing code from Jackson databind ISO8601Utils.java\n// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\npublic class ISO8601Utils\n{\n    /**\n     * ID to represent the 'UTC' string, default timezone since Jackson 2.7\n     * \n     * @since 2.7\n     */\n    private static final String UTC_ID = \"UTC\";\n    /**\n     * The UTC timezone, prefetched to avoid more lookups.\n     * \n     * @since 2.7\n     */\n    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n\n    /*\n    /**********************************************************\n    /* Formatting\n    /**********************************************************\n     */\n\n    /**\n     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n     * \n     * @param date the date to format\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n     */\n    public static String format(Date date) {\n        return format(date, false, TIMEZONE_UTC);\n    }\n\n    /**\n     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n     */\n    public static String format(Date date, boolean millis) {\n        return format(date, millis, TIMEZONE_UTC);\n    }\n\n    /**\n     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @param tz timezone to use for the formatting (UTC will produce 'Z')\n     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     */\n    public static String format(Date date, boolean millis, TimeZone tz) {\n        Calendar calendar = new GregorianCalendar(tz, Locale.US);\n        calendar.setTime(date);\n\n        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n        capacity += millis ? \".sss\".length() : 0;\n        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n        StringBuilder formatted = new StringBuilder(capacity);\n\n        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n        formatted.append('T');\n        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n        if (millis) {\n            formatted.append('.');\n            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n        }\n\n        int offset = tz.getOffset(calendar.getTimeInMillis());\n        if (offset != 0) {\n            int hours = Math.abs((offset / (60 * 1000)) / 60);\n            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n            formatted.append(offset < 0 ? '-' : '+');\n            padInt(formatted, hours, \"hh\".length());\n            formatted.append(':');\n            padInt(formatted, minutes, \"mm\".length());\n        } else {\n            formatted.append('Z');\n        }\n\n        return formatted.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Parsing\n    /**********************************************************\n     */\n\n    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n            \n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n\n                // extract hours, minutes, seconds and milliseconds\n                hour = parseInt(date, offset += 1, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n                         */\n                        String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                    +timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n            // If we get a ParseException it'll already have the right message/offset.\n            // Other exception types can convert here.\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + \"'\");\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\"+fail.getClass().getName()+\")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n\n    /**\n     * Check if the expected character exist at the given offset in the value.\n     * \n     * @param value the string to check at the specified offset\n     * @param offset the offset to look for the expected character\n     * @param expected the expected character\n     * @return true if the expected character exist at the given offset\n     */\n    private static boolean checkOffset(String value, int offset, char expected) {\n        return (offset < value.length()) && (value.charAt(offset) == expected);\n    }\n\n    /**\n     * Parse an integer located between 2 given offsets in a string\n     * \n     * @param value the string to parse\n     * @param beginIndex the start index for the integer in the string\n     * @param endIndex the end index for the integer in the string\n     * @return the int\n     * @throws NumberFormatException if the value is not a number\n     */\n    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n            throw new NumberFormatException(value);\n        }\n        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n        int i = beginIndex;\n        int result = 0;\n        int digit;\n        if (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result = -digit;\n        }\n        while (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result *= 10;\n            result -= digit;\n        }\n        return -result;\n    }\n\n    /**\n     * Zero pad a number to a specified length\n     * \n     * @param buffer buffer to use for padding\n     * @param value the integer value to pad if necessary.\n     * @param length the length of the string we should zero pad\n     */\n    private static void padInt(StringBuilder buffer, int value, int length) {\n        String strValue = Integer.toString(value);\n        for (int i = length - strValue.length(); i > 0; i--) {\n            buffer.append('0');\n        }\n        buffer.append(strValue);\n    }\n\n    /**\n     * Returns the index of the first character in the string that is not a digit, starting at offset.\n     */\n    private static int indexOfNonDigit(String string, int offset) {\n        for (int i = offset; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c < '0' || c > '9') return i;\n        }\n        return string.length();\n    }\n\n}\n"
    },
    {
        "project_name": "Gson",
        "bug-id": "17",
        "class": "DefaultDateTypeAdapter",
        "fqdn": "com.google.gson",
        "source_code": "/*\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson;\n\nimport java.io.IOException;\nimport java.sql.Timestamp;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport com.google.gson.internal.bind.util.ISO8601Utils;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * This type adapter supports three subclasss of date: Date, Timestamp, and\n * java.sql.Date.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n */\nfinal class DefaultDateTypeAdapter extends TypeAdapter<Date> {\n\n  private static final String SIMPLE_NAME = \"DefaultDateTypeAdapter\";\n\n  private final Class<? extends Date> dateType;\n  private final DateFormat enUsFormat;\n  private final DateFormat localFormat;\n  \n  DefaultDateTypeAdapter(Class<? extends Date> dateType) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {\n    this(dateType, new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {\n    this(dateType, DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n  }\n\n  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(Date.class,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\n    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\n      throw new IllegalArgumentException(\"Date type must be one of \" + Date.class + \", \" + Timestamp.class + \", or \" + java.sql.Date.class + \" but was \" + dateType);\n    }\n    this.dateType = dateType;\n    this.enUsFormat = enUsFormat;\n    this.localFormat = localFormat;\n  }\n\n  // These methods need to be synchronized since JDK DateFormat classs are not thread-safe\n  // See issue 162\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n      out.nullValue();\n      return;\n    }\n    synchronized (localFormat) {\n      String dateFormatAsString = enUsFormat.format(value);\n      out.value(dateFormatAsString);\n    }\n  }\n\n  @Override\n  public Date read(JsonReader in) throws IOException {\n    if (in.peek() != JsonToken.STRING) {\n      throw new JsonParseException(\"The date should be a string value\");\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }\n\n  private Date deserializeToDate(String s) {\n    synchronized (localFormat) {\n      try {\n        return localFormat.parse(s);\n      } catch (ParseException ignored) {}\n      try {\n        return enUsFormat.parse(s);\n      } catch (ParseException ignored) {}\n      try {\n        return ISO8601Utils.parse(s, new ParsePosition(0));\n      } catch (ParseException e) {\n        throw new JsonSyntaxException(s, e);\n      }\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(SIMPLE_NAME);\n    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');\n    return sb.toString();\n  }\n}\n"
    },
    {
        "project_name": "JacksonDatabind",
        "bug-id": "6",
        "class": "StdDateFormat",
        "fqdn": "com.fasterxml.jackson.databind.util",
        "source_code": "package com.fasterxml.jackson.databind.util;\n\nimport java.text.DateFormat;\nimport java.text.FieldPosition;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Default {@link DateFormat} implementation used by standard Date\n * serializers and deserializers. For serialization defaults to using\n * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n * and for deserialization, both ISO-8601 and RFC-1123.\n */\n@SuppressWarnings(\"serial\")\npublic class StdDateFormat\n    extends DateFormat\n{\n    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class:\n     * JDK date parsing is awfully brittle, and ISO-8601 is quite\n     * permissive. The two don't mix, need to write a better one.\n     */\n    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still\n    //   not really robust\n\n    /**\n     * Defines a commonly used date format that conforms\n     * to ISO-8601 date formatting standard, when it includes basic undecorated\n     * timezone definition\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n\n    /**\n     * Same as 'regular' 8601, but handles 'Z' as an alias for \"+0000\"\n     * (or \"GMT\")\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n\n    /**\n     * ISO-8601 with just the Date part, no time\n     */\n    protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n\n    /**\n     * This constant defines the date format specified by\n     * RFC 1123 / RFC 822.\n     */\n    protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n\n    /**\n     * For error messages we'll also need a list of all formats.\n     */\n    protected final static String[] ALL_FORMATS = new String[] {\n        DATE_FORMAT_STR_ISO8601,\n        DATE_FORMAT_STR_ISO8601_Z,\n        DATE_FORMAT_STR_RFC1123,\n        DATE_FORMAT_STR_PLAIN\n    };\n\n    /**\n     * By default we use GMT for everything.\n     */\n    private final static TimeZone DEFAULT_TIMEZONE;\n    static {\n        DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\");\n    }\n\n    private final static Locale DEFAULT_LOCALE = Locale.US;\n    \n    protected final static DateFormat DATE_FORMAT_RFC1123;\n\n    protected final static DateFormat DATE_FORMAT_ISO8601;\n    protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n\n    protected final static DateFormat DATE_FORMAT_PLAIN;\n\n    /* Let's construct \"blueprint\" date format instances: can not be used\n     * as is, due to thread-safety issues, but can be used for constructing\n     * actual instances more cheaply (avoids re-parsing).\n     */\n    static {\n        /* Another important thing: let's force use of GMT for\n         * baseline DataFormat objects\n         */\n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    /**\n     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.\n     */\n    public final static StdDateFormat instance = new StdDateFormat();\n    \n    /**\n     * Caller may want to explicitly override timezone to use; if so,\n     * we will have non-null value here.\n     */\n    protected transient TimeZone _timezone;\n\n    protected final Locale _locale;\n    \n    protected transient DateFormat _formatRFC1123;\n    protected transient DateFormat _formatISO8601;\n    protected transient DateFormat _formatISO8601_z;\n    protected transient DateFormat _formatPlain;\n\n    /*\n    /**********************************************************\n    /* Life cycle, accessing singleton \"standard\" formats\n    /**********************************************************\n     */\n\n    public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }\n\n    /**\n     * @deprecated Since 2.4, use variant that also takes Locale\n     */\n    @Deprecated // since 2.4\n    public StdDateFormat(TimeZone tz) {\n        this(tz, DEFAULT_LOCALE);\n    }\n    \n    public StdDateFormat(TimeZone tz, Locale loc) {\n        _timezone = tz;\n        _locale = loc;\n    }\n\n    public static TimeZone getDefaultTimeZone() {\n        return DEFAULT_TIMEZONE;\n    }\n    \n    /**\n     * Method used for creating a new instance with specified timezone;\n     * if no timezone specified, defaults to the default timezone (UTC).\n     */\n    public StdDateFormat withTimeZone(TimeZone tz) {\n        if (tz == null) {\n            tz = DEFAULT_TIMEZONE;\n        }\n        if (tz.equals(_timezone)) {\n            return this;\n        }\n        return new StdDateFormat(tz, _locale);\n    }\n\n    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc);\n    }\n    \n    @Override\n    public StdDateFormat clone() {\n        /* Although there is that much state to share, we do need to\n         * orchestrate a bit, mostly since timezones may be changed\n         */\n        return new StdDateFormat(_timezone, _locale);\n    }\n\n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintISO8601Format() {\n        return DATE_FORMAT_ISO8601;\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n        return getISO8601Format(tz, DEFAULT_LOCALE);\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specified timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);\n    }\n    \n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintRFC1123Format() {\n        return DATE_FORMAT_RFC1123;\n    }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specific timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);\n    }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public void setTimeZone(TimeZone tz)\n    {\n        /* DateFormats are timezone-specific (via Calendar contained),\n         * so need to reset instances if timezone changes:\n         */\n        if (!tz.equals(_timezone)) {\n            _formatRFC1123 = null;\n            _formatISO8601 = null;\n            _formatISO8601_z = null;\n            _formatPlain = null;\n            _timezone = tz;\n        }\n    }\n    \n    @Override\n    public Date parse(String dateStr) throws ParseException\n    {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date result = parse(dateStr, pos);\n        if (result != null) {\n            return result;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n            if (sb.length() > 0) {\n                sb.append(\"\\\", \\\"\");\n            } else {\n                sb.append('\"');\n            }\n            sb.append(f);\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                // 07-Aug-2013, tatu: And #267 points out that negative numbers should also work\n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { // all digits\n            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }\n\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }\n\n    /*\n    /**********************************************************\n    /* Std overrides\n    /**********************************************************\n     */\n    \n    @Override\n    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used to figure out which of supported\n     * formats is the likeliest match.\n     */\n    protected boolean looksLikeISO8601(String dateStr)\n    {\n        if (dateStr.length() >= 5\n            && Character.isDigit(dateStr.charAt(0))\n            && Character.isDigit(dateStr.charAt(3))\n            && dateStr.charAt(4) == '-'\n            ) {\n            return true;\n        }\n        return false;\n    }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * GMT, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                c = dateStr.charAt(len-9);\n                if (Character.isDigit(c)) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(len-5, \".000\");\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen <= 8) {\n                        sb.append(\".000\");\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n    {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }\n\n    private final static boolean hasTimeZone(String str)\n    {\n        // Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so\n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }\n}\n\n"
    }
]