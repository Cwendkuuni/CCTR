[
    {
        "project_name": "12_dsachat",
        "class": "InternalChatFrame",
        "fqdn": "dsachat.client.gui",
        "source_code": "package dsachat.client.gui;\n\nimport javax.swing.text.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport java.awt.event.*;\n\npublic class InternalChatFrame extends JInternalFrame implements ActionListener, MouseListener\n{\n    private static final long serialVersionUID = -1182316470653600880L;\n    private JList list;\n    private DefaultListModel listModel;\n    private JTextPane showTxt;\n    private JTextField txtInput;\n    private MainFrame parent;\n    private StyledDocument doc;\n    private JPopupMenu listPop;\n    private JPopupMenu txtPop;\n    \n    public InternalChatFrame(final MainFrame parent) {\n        super(\"Chat\", true, false, true, true);\n        this.listModel = new DefaultListModel();\n        this.parent = parent;\n        this.createGUI();\n        this.setLocation(0, 0);\n    }\n    \n    private void createGUI() {\n        final GridBagConstraints c = new GridBagConstraints();\n        final JSplitPane split = new JSplitPane(1);\n        (this.list = new JList(this.listModel)).setVisible(true);\n        this.list.setSelectionMode(0);\n        this.list.addMouseListener(this);\n        final JScrollPane scrList = new JScrollPane(this.list);\n        split.setLeftComponent(scrList);\n        final JPanel right = new JPanel(new GridBagLayout());\n        (this.showTxt = new JTextPane()).setEditable(false);\n        this.showTxt.addMouseListener(this);\n        this.addStylesToDocument(this.doc = this.showTxt.getStyledDocument());\n        final JScrollPane scrTxt = new JScrollPane(this.showTxt);\n        scrTxt.setHorizontalScrollBarPolicy(31);\n        c.gridx = 0;\n        c.gridy = 0;\n        c.fill = 1;\n        c.weightx = 1.0;\n        c.weighty = 0.8;\n        c.insets = new Insets(0, 0, 5, 0);\n        right.add(scrTxt, c);\n        (this.txtInput = new JTextField()).addActionListener(this.parent);\n        this.txtInput.setActionCommand(\"sendInput\");\n        c.gridx = 0;\n        c.gridy = 1;\n        c.fill = 1;\n        c.weightx = 1.0;\n        c.weighty = 0.0;\n        c.insets = new Insets(5, 0, 0, 0);\n        right.add(this.txtInput, c);\n        split.setRightComponent(right);\n        split.setDividerLocation(100);\n        this.add(split);\n        this.listPop = new JPopupMenu();\n        JMenuItem menuItem = new JMenuItem(\"Change Color\");\n        menuItem.setActionCommand(\"chooseColor\");\n        menuItem.addActionListener(this);\n        this.listPop.add(menuItem);\n        menuItem = new JMenuItem(\"whisper\");\n        menuItem.setActionCommand(\"whisper\");\n        menuItem.addActionListener(this);\n        this.listPop.add(menuItem);\n        this.txtPop = new JPopupMenu();\n        menuItem = new JMenuItem(\"Change Color\");\n        menuItem.setActionCommand(\"bgColor\");\n        menuItem.addActionListener(this);\n        this.txtPop.add(menuItem);\n        final Dimension drawSize = this.parent.getSize();\n        this.setSize(drawSize.width - 400, drawSize.height - 55);\n    }\n    \n    public void addText(String line) {\n        try {\n            if (!line.matches(\".*:.*\")) {\n                this.doc.insertString(this.doc.getLength(), line + \"\\n\", this.doc.getStyle(\"system\"));\n                return;\n            }\n            String[] a = line.split(\":\", 2);\n            String styleName = a[0];\n            if (styleName.matches(\".*whispers.*\")) {\n                a = styleName.split(\"\\\\s\");\n                styleName = a[0];\n            }\n            if (styleName.startsWith(\"You \")) {\n                styleName = this.parent.hero.getName();\n            }\n            if (styleName.startsWith(\"*\")) {\n                line = a[0] + a[1];\n                styleName = a[0].substring(1);\n            }\n            final Style s = this.doc.getStyle(styleName);\n            boolean bold = false;\n            if (line.matches(\".*\\\\*.*\") && line.matches(\".*[\\\\+_].*\")) {\n                final String[] msgAr = line.split(\"\\\\*\");\n                for (int i = 0; i < msgAr.length; ++i) {\n                    if (i % 2 == 0) {\n                        StyleConstants.setItalic(s, false);\n                    }\n                    else {\n                        StyleConstants.setItalic(s, true);\n                    }\n                    final String[] str = msgAr[i].split(\"[\\\\+_]\");\n                    if (bold) {\n                        for (int j = 0; j < str.length; ++j) {\n                            bold = (j % 2 == 0);\n                            StyleConstants.setBold(s, bold);\n                            this.doc.insertString(this.doc.getLength(), str[j], s);\n                        }\n                    }\n                    else {\n                        for (int j = 0; j < str.length; ++j) {\n                            bold = (j % 2 != 0);\n                            StyleConstants.setBold(s, bold);\n                            this.doc.insertString(this.doc.getLength(), str[j], s);\n                        }\n                    }\n                }\n                StyleConstants.setItalic(s, false);\n                StyleConstants.setBold(s, false);\n            }\n            else if (line.matches(\".*\\\\*.*\")) {\n                final String[] msgAr = line.split(\"\\\\*\");\n                for (int i = 0; i < msgAr.length; ++i) {\n                    if (i % 2 == 0) {\n                        StyleConstants.setItalic(s, false);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                    else {\n                        StyleConstants.setItalic(s, true);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                }\n                StyleConstants.setItalic(s, false);\n            }\n            else if (line.matches(\".*[\\\\+_].*\")) {\n                final String[] msgAr = line.split(\"[\\\\+_]\");\n                for (int i = 0; i < msgAr.length; ++i) {\n                    if (i % 2 == 0) {\n                        StyleConstants.setBold(s, false);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                    else {\n                        StyleConstants.setBold(s, true);\n                        this.doc.insertString(this.doc.getLength(), msgAr[i], s);\n                    }\n                }\n                StyleConstants.setBold(s, false);\n            }\n            else {\n                this.doc.insertString(this.doc.getLength(), line, s);\n            }\n            this.doc.insertString(this.doc.getLength(), \"\\n\", this.doc.getStyle(\"regular\"));\n        }\n        catch (BadLocationException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    protected void addStylesToDocument(final StyledDocument doc) {\n        final Style def = StyleContext.getDefaultStyleContext().getStyle(\"default\");\n        final Style regular = doc.addStyle(\"regular\", def);\n        StyleConstants.setFontFamily(def, \"SansSerif\");\n        Style s = doc.addStyle(\"italic\", regular);\n        StyleConstants.setItalic(s, true);\n        s = doc.addStyle(\"bold\", regular);\n        StyleConstants.setBold(s, true);\n        s = doc.addStyle(\"bold-italic\", regular);\n        StyleConstants.setBold(s, true);\n        StyleConstants.setItalic(s, true);\n        s = doc.addStyle(\"name\", regular);\n        StyleConstants.setForeground(s, Color.BLUE);\n        StyleConstants.setFontSize(s, 16);\n        s = doc.addStyle(\"system\", regular);\n        StyleConstants.setForeground(s, new Color(0.0f, 0.6f, 0.0f, 1.0f));\n        StyleConstants.setItalic(s, true);\n        StyleConstants.setFontSize(s, 14);\n        s = doc.addStyle(\"small\", regular);\n        StyleConstants.setFontSize(s, 10);\n        s = doc.addStyle(\"large\", regular);\n        StyleConstants.setFontSize(s, 16);\n    }\n    \n    private void changeStyle(final int fontSize, final Color c, final boolean isBold, final boolean isItalic, final String name) {\n        final Style s = this.doc.getStyle(name);\n        if (c != null) {\n            StyleConstants.setForeground(s, c);\n        }\n        StyleConstants.setBold(s, isBold);\n        StyleConstants.setItalic(s, isItalic);\n    }\n    \n    public void addUser(final String user) {\n        this.listModel.add(0, user);\n        this.list.ensureIndexIsVisible(0);\n        this.list.setSelectedIndex(0);\n        this.list.validate();\n        final Style parent = this.doc.getStyle(\"regular\");\n        this.doc.addStyle(user, parent);\n    }\n    \n    public void deleteUser(final String user) {\n        this.listModel.removeElement(user);\n    }\n    \n    public String[] getUserlist() {\n        final String[] uList = new String[this.listModel.size()];\n        for (int i = 0; i < this.listModel.size(); ++i) {\n            uList[i] = this.listModel.elementAt(i);\n        }\n        return uList;\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        final String name = this.list.getSelectedValue();\n        if (e.getActionCommand().equals(\"chooseColor\")) {\n            final Color newColor = JColorChooser.showDialog(this, \"Choose Color for user \" + name, Color.black);\n            if (newColor != null) {\n                this.changeStyle(12, newColor, false, false, name);\n            }\n        }\n        if (e.getActionCommand().equals(\"bgColor\")) {\n            final Color newColor = JColorChooser.showDialog(this, \"Choose Color for user \" + name, Color.black);\n            if (newColor != null) {\n                this.showTxt.setBackground(newColor);\n            }\n        }\n        if (e.getActionCommand().equals(\"whisper\")) {\n            final String wUser = \"/w \" + name + \" \";\n            this.txtInput.setText(wUser);\n        }\n    }\n    \n    @Override\n    public void mouseClicked(final MouseEvent e) {\n    }\n    \n    @Override\n    public void mouseEntered(final MouseEvent e) {\n    }\n    \n    @Override\n    public void mouseExited(final MouseEvent e) {\n    }\n    \n    @Override\n    public void mousePressed(final MouseEvent e) {\n        this.maybeShowPopup(e);\n    }\n    \n    @Override\n    public void mouseReleased(final MouseEvent e) {\n        this.maybeShowPopup(e);\n    }\n    \n    private void maybeShowPopup(final MouseEvent e) {\n        if (e.isPopupTrigger()) {\n            if (e.getSource().equals(this.list)) {\n                this.listPop.show(this.list, e.getX(), e.getY());\n            }\n            if (e.getSource().equals(this.showTxt)) {\n                this.txtPop.show(this.list, e.getX(), e.getY());\n            }\n        }\n    }\n    \n    public String getChatlog() {\n        return this.showTxt.getText();\n    }\n}\n"
    },
    {
        "project_name": "commons-collections",
        "class": "SequencesComparator",
        "fqdn": "org.apache.commons.collections4.sequence",
        "source_code": "package org.apache.commons.collections4.sequence;\n\nimport java.util.*;\nimport org.apache.commons.collections4.*;\nimport org.apache.commons.collections4.functors.*;\n\npublic class SequencesComparator<T>\n{\n    private final List<T> sequence1;\n    private final List<T> sequence2;\n    private final Equator<? super T> equator;\n    private final int[] vDown;\n    private final int[] vUp;\n    \n    public SequencesComparator(final List<T> sequence1, final List<T> sequence2) {\n        this(sequence1, sequence2, DefaultEquator.defaultEquator());\n    }\n    \n    public SequencesComparator(final List<T> sequence1, final List<T> sequence2, final Equator<? super T> equator) {\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.equator = equator;\n        final int size = sequence1.size() + sequence2.size() + 2;\n        this.vDown = new int[size];\n        this.vUp = new int[size];\n    }\n    \n    public EditScript<T> getScript() {\n        final EditScript<T> script = new EditScript<T>();\n        this.buildScript(0, this.sequence1.size(), 0, this.sequence2.size(), script);\n        return script;\n    }\n    \n    private Snake buildSnake(final int start, final int diag, final int end1, final int end2) {\n        int end3;\n        for (end3 = start; end3 - diag < end2 && end3 < end1 && this.equator.equate((Object)this.sequence1.get(end3), (Object)this.sequence2.get(end3 - diag)); ++end3) {}\n        return new Snake(start, end3, diag);\n    }\n    \n    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n        final int delta = m - n;\n        final int sum = n + m;\n        final int offset = ((sum % 2 == 0) ? sum : (sum + 1)) / 2;\n        this.vDown[1 + offset] = start1;\n        this.vUp[1 + offset] = end1 + 1;\n        for (int d = 0; d <= offset; ++d) {\n            for (int k = -d; k <= d; k += 2) {\n                final int i = k + offset;\n                if (k == -d || (k != d && this.vDown[i - 1] < this.vDown[i + 1])) {\n                    this.vDown[i] = this.vDown[i + 1];\n                }\n                else {\n                    this.vDown[i] = this.vDown[i - 1] + 1;\n                }\n                for (int x = this.vDown[i], y = x - start1 + start2 - k; x < end1 && y < end2 && this.equator.equate((Object)this.sequence1.get(x), (Object)this.sequence2.get(y)); this.vDown[i] = ++x, ++y) {}\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d && this.vUp[i - delta] <= this.vDown[i]) {\n                    return this.buildSnake(this.vUp[i - delta], k + start1 - start2, end1, end2);\n                }\n            }\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                final int i = k + offset - delta;\n                if (k == delta - d || (k != delta + d && this.vUp[i + 1] <= this.vUp[i - 1])) {\n                    this.vUp[i] = this.vUp[i + 1] - 1;\n                }\n                else {\n                    this.vUp[i] = this.vUp[i - 1];\n                }\n                for (int x = this.vUp[i] - 1, y = x - start1 + start2 - k; x >= start1 && y >= start2 && this.equator.equate((Object)this.sequence1.get(x), (Object)this.sequence2.get(y)); this.vUp[i] = x--, --y) {}\n                if (delta % 2 == 0 && -d <= k && k <= d && this.vUp[i] <= this.vDown[i + delta]) {\n                    return this.buildSnake(this.vUp[i], k + start1 - start2, end1, end2);\n                }\n            }\n        }\n        throw new RuntimeException(\"Internal Error\");\n    }\n    \n    private void buildScript(final int start1, final int end1, final int start2, final int end2, final EditScript<T> script) {\n        final Snake middle = this.getMiddleSnake(start1, end1, start2, end2);\n        if (middle == null || (middle.getStart() == end1 && middle.getDiag() == end1 - end2) || (middle.getEnd() == start1 && middle.getDiag() == start1 - start2)) {\n            int i = start1;\n            int j = start2;\n            while (i < end1 || j < end2) {\n                if (i < end1 && j < end2 && this.equator.equate((Object)this.sequence1.get(i), (Object)this.sequence2.get(j))) {\n                    script.append(new KeepCommand<T>(this.sequence1.get(i)));\n                    ++i;\n                    ++j;\n                }\n                else if (end1 - start1 > end2 - start2) {\n                    script.append(new DeleteCommand<T>(this.sequence1.get(i)));\n                    ++i;\n                }\n                else {\n                    script.append(new InsertCommand<T>(this.sequence2.get(j)));\n                    ++j;\n                }\n            }\n        }\n        else {\n            this.buildScript(start1, middle.getStart(), start2, middle.getStart() - middle.getDiag(), script);\n            for (int i = middle.getStart(); i < middle.getEnd(); ++i) {\n                script.append(new KeepCommand<T>(this.sequence1.get(i)));\n            }\n            this.buildScript(middle.getEnd(), end1, middle.getEnd() - middle.getDiag(), end2, script);\n        }\n    }\n    \n    private static class Snake\n    {\n        private final int start;\n        private final int end;\n        private final int diag;\n        \n        public Snake(final int start, final int end, final int diag) {\n            this.start = start;\n            this.end = end;\n            this.diag = diag;\n        }\n        \n        public int getStart() {\n            return this.start;\n        }\n        \n        public int getEnd() {\n            return this.end;\n        }\n        \n        public int getDiag() {\n            return this.diag;\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-collections",
        "class": "ArrayByteList",
        "fqdn": "org.apache.commons.collections.primitives",
        "source_code": "package org.apache.commons.collections.primitives;\n\nimport java.io.*;\n\npublic class ArrayByteList extends RandomAccessByteList implements ByteList, Serializable\n{\n    private transient byte[] _data;\n    private int _size;\n    \n    public ArrayByteList() {\n        this(8);\n    }\n    \n    public ArrayByteList(final int initialCapacity) {\n        this._data = null;\n        this._size = 0;\n        if (initialCapacity < 0) {\n            throw new IllegalArgumentException(\"capacity \" + initialCapacity);\n        }\n        this._data = new byte[initialCapacity];\n        this._size = 0;\n    }\n    \n    public ArrayByteList(final ByteCollection that) {\n        this(that.size());\n        this.addAll(that);\n    }\n    \n    public byte get(final int index) {\n        this.checkRange(index);\n        return this._data[index];\n    }\n    \n    public int size() {\n        return this._size;\n    }\n    \n    public byte removeElementAt(final int index) {\n        this.checkRange(index);\n        this.incrModCount();\n        final byte oldval = this._data[index];\n        final int numtomove = this._size - index - 1;\n        if (numtomove > 0) {\n            System.arraycopy(this._data, index + 1, this._data, index, numtomove);\n        }\n        --this._size;\n        return oldval;\n    }\n    \n    public byte set(final int index, final byte element) {\n        this.checkRange(index);\n        this.incrModCount();\n        final byte oldval = this._data[index];\n        this._data[index] = element;\n        return oldval;\n    }\n    \n    public void add(final int index, final byte element) {\n        this.checkRangeIncludingEndpoint(index);\n        this.incrModCount();\n        this.ensureCapacity(this._size + 1);\n        final int numtomove = this._size - index;\n        System.arraycopy(this._data, index, this._data, index + 1, numtomove);\n        this._data[index] = element;\n        ++this._size;\n    }\n    \n    public void ensureCapacity(final int mincap) {\n        this.incrModCount();\n        if (mincap > this._data.length) {\n            final int newcap = this._data.length * 3 / 2 + 1;\n            final byte[] olddata = this._data;\n            System.arraycopy(olddata, 0, this._data = new byte[(newcap < mincap) ? mincap : newcap], 0, this._size);\n        }\n    }\n    \n    public void trimToSize() {\n        this.incrModCount();\n        if (this._size < this._data.length) {\n            final byte[] olddata = this._data;\n            System.arraycopy(olddata, 0, this._data = new byte[this._size], 0, this._size);\n        }\n    }\n    \n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(this._data.length);\n        for (int i = 0; i < this._size; ++i) {\n            out.writeByte(this._data[i]);\n        }\n    }\n    \n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        this._data = new byte[in.readInt()];\n        for (int i = 0; i < this._size; ++i) {\n            this._data[i] = in.readByte();\n        }\n    }\n    \n    private final void checkRange(final int index) {\n        if (index < 0 || index >= this._size) {\n            throw new IndexOutOfBoundsException(\"Should be at least 0 and less than \" + this._size + \", found \" + index);\n        }\n    }\n    \n    private final void checkRangeIncludingEndpoint(final int index) {\n        if (index < 0 || index > this._size) {\n            throw new IndexOutOfBoundsException(\"Should be at least 0 and at most \" + this._size + \", found \" + index);\n        }\n    }\n}\n"
    },
    {
        "project_name": "61_noen",
        "class": "DaikonFormatter",
        "fqdn": "fi.vtt.noen.testgen.observations.formatter",
        "source_code": "package fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.parser.*;\nimport java.io.*;\nimport fi.vtt.noen.testgen.model.*;\nimport java.util.*;\nimport fi.vtt.noen.testgen.observations.data.*;\n\npublic class DaikonFormatter extends BasicFormatter\n{\n    private Set<String> declarations;\n    private boolean simple;\n    private final Collection<String> inputs;\n    \n    public DaikonFormatter(final String fileName, final boolean simple) throws IOException {\n        super(fileName);\n        this.declarations = new HashSet<String>();\n        this.simple = false;\n        this.simple = simple;\n        if (simple) {\n            this.inputs = null;\n            return;\n        }\n        try {\n            this.inputs = InterfaceParser.methodNames(inputs());\n            System.out.println(\"inputs:\" + this.inputs);\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\n        }\n    }\n    \n    public DaikonFormatter(final String fileName, final Collection<String> inputs) throws IOException {\n        super(fileName);\n        this.declarations = new HashSet<String>();\n        this.simple = false;\n        this.inputs = inputs;\n        System.out.println(\"inputs:\" + inputs);\n    }\n    \n    private static Class classForProperty(final String property) throws Exception {\n        final Properties configuration = new Properties();\n        configuration.load(new FileInputStream(\"testgen.properties\"));\n        final String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n    \n    private static Collection<Class> classesForMultipleProperties(final String prefix) throws Exception {\n        final Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            final Class clazz = classForProperty(prefix + index);\n            ++index;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n    \n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n    \n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n    \n    @Override\n    public String header() {\n        final OutputBuffer out = new OutputBuffer();\n        out.append(\"decl-version 2.0\");\n        out.append(\"var-comparability implicit\");\n        return out.toString();\n    }\n    \n    @Override\n    public String footer() {\n        return \"\";\n    }\n    \n    @Override\n    public String fileNameExtension() {\n        return \"dtrace\";\n    }\n    \n    @Override\n    public String observations(final ProgramRun run) {\n        final OutputBuffer out = new OutputBuffer();\n        Event previousEvent = null;\n        Event event = Const.INITIAL_STATE;\n        final Iterator<Event> ei = run.iterator();\n        while (ei.hasNext()) {\n            previousEvent = event;\n            event = ei.next();\n            if (this.simple) {\n                this.simplePoint(event, \"10\", out);\n            }\n            else {\n                if ((this.inputs.contains(previousEvent.getName()) && this.inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\n                    this.point(previousEvent.getName(), previousEvent, \"11\", out);\n                }\n                if (previousEvent.isExit()) {\n                    this.point(previousEvent.getName(), previousEvent, \"22\", out);\n                }\n                else {\n                    if (!this.inputs.contains(previousEvent.getName()) || this.inputs.contains(event.getName()) || previousEvent.isExit() || event.isExit()) {\n                        continue;\n                    }\n                    final String name = previousEvent.getName() + \",\" + event.getName();\n                    this.point(name, previousEvent, \"22\", out);\n                }\n            }\n        }\n        if (!this.simple && (this.inputs.contains(event.getName()) || event.isExit())) {\n            this.point(event.getName(), event, \"11\", out);\n        }\n        return out.toString();\n    }\n    \n    private void simplePoint(final Event event, final String comparability, final OutputBuffer out) {\n        String name = event.getName();\n        name = name.replace(' ', '_');\n        if (!event.isExit()) {\n            name += \":::ENTER\";\n        }\n        else {\n            name += \":::EXIT1\";\n        }\n        this.declarations(event, name, out, comparability);\n        out.append(\"\");\n        out.append(name);\n        this.attributes(event, out);\n    }\n    \n    private void point(String name, final Event event, final String comparability, final OutputBuffer out) {\n        name = name.replace(' ', '_');\n        name += \":::ENTER\";\n        this.declarations(event, name, out, comparability);\n        out.append(\"\");\n        out.append(name);\n        this.attributes(event, out);\n    }\n    \n    private void declarations(final Event event, final String eventName, final OutputBuffer out, final String comparability) {\n        if (this.declarations.contains(eventName)) {\n            return;\n        }\n        this.declarations.add(eventName);\n        out.append(\"\");\n        out.append(\"ppt \" + eventName);\n        if (event.isExit()) {\n            out.append(\"ppt-type exit\");\n        }\n        else {\n            out.append(\"ppt-type enter\");\n        }\n        final Iterator<EventAttribute> ai = event.attributes();\n        while (ai.hasNext()) {\n            final EventAttribute attribute = ai.next();\n            if (attribute instanceof ArrayAttribute) {\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\n                out.append(\"    var-kind array\");\n            }\n            else {\n                out.append(\"  variable \" + attribute.getName());\n                out.append(\"    var-kind variable\");\n            }\n            out.append(\"    dec-type \" + attribute.getType());\n            out.append(\"    rep-type \" + attribute.getType());\n            out.append(\"    comparability \" + comparability);\n        }\n    }\n    \n    private void attributes(final Event event, final OutputBuffer out) {\n        final Iterator<EventAttribute> ai = event.attributes();\n        while (ai.hasNext()) {\n            final EventAttribute attribute = ai.next();\n            if (attribute instanceof ArrayAttribute) {\n                out.append(attribute.getName() + \"[]\");\n            }\n            else {\n                out.append(attribute.getName());\n            }\n            if (attribute.getType().equals(\"java.lang.String\")) {\n                out.append('\\\"' + attribute.getValue() + '\\\"');\n            }\n            else {\n                out.append(attribute.getValue());\n            }\n            out.append(\"1\");\n        }\n    }\n}\n"
    },
    {
        "project_name": "61_noen",
        "class": "ProbeInformation",
        "fqdn": "fi.vtt.noen.mfw.bundle.probe.shared",
        "source_code": "package fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.*;\n\npublic class ProbeInformation\n{\n    private final String targetName;\n    private final String targetType;\n    private final String bmClass;\n    private final String bmName;\n    private final String bmDescription;\n    private final String probeName;\n    private final int precision;\n    private final String xmlRpcUrl;\n    \n    public ProbeInformation(final String targetName, final String targetType, final String bmClass, final String bmName, final String bmDescription, final String probeDescription, final int precision, final String xmlRpcUrl) {\n        this.targetName = targetName;\n        this.targetType = targetType;\n        this.bmClass = bmClass;\n        this.bmName = bmName;\n        this.bmDescription = bmDescription;\n        this.probeName = probeDescription;\n        this.precision = precision;\n        this.xmlRpcUrl = xmlRpcUrl;\n    }\n    \n    public String getTargetType() {\n        return this.targetType;\n    }\n    \n    public String getBmName() {\n        return this.bmName;\n    }\n    \n    public String getProbeName() {\n        return this.probeName;\n    }\n    \n    public String getTargetName() {\n        return this.targetName;\n    }\n    \n    public String getBmClass() {\n        return this.bmClass;\n    }\n    \n    public String getBmDescription() {\n        return this.bmDescription;\n    }\n    \n    public int getPrecision() {\n        return this.precision;\n    }\n    \n    public String getMeasureURI() {\n        return Const.createMeasureURI(this.targetType, this.targetName, this.bmClass, this.bmName);\n    }\n    \n    public String getXmlRpcUrl() {\n        return this.xmlRpcUrl;\n    }\n    \n    @Override\n    public String toString() {\n        return \"ProbeInformation{targetName='\" + this.targetName + '\\'' + \", targetType='\" + this.targetType + '\\'' + \", bmClass='\" + this.bmClass + '\\'' + \", bmName='\" + this.bmName + '\\'' + \", bmDescription='\" + this.bmDescription + '\\'' + \", probeDescription='\" + this.probeName + '\\'' + \", precision=\" + this.precision + '}';\n    }\n    \n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final ProbeInformation that = (ProbeInformation)o;\n        if (this.precision != that.precision) {\n            return false;\n        }\n        Label_0075: {\n            if (this.bmClass != null) {\n                if (this.bmClass.equals(that.bmClass)) {\n                    break Label_0075;\n                }\n            }\n            else if (that.bmClass == null) {\n                break Label_0075;\n            }\n            return false;\n        }\n        Label_0108: {\n            if (this.bmDescription != null) {\n                if (this.bmDescription.equals(that.bmDescription)) {\n                    break Label_0108;\n                }\n            }\n            else if (that.bmDescription == null) {\n                break Label_0108;\n            }\n            return false;\n        }\n        Label_0141: {\n            if (this.bmName != null) {\n                if (this.bmName.equals(that.bmName)) {\n                    break Label_0141;\n                }\n            }\n            else if (that.bmName == null) {\n                break Label_0141;\n            }\n            return false;\n        }\n        Label_0174: {\n            if (this.probeName != null) {\n                if (this.probeName.equals(that.probeName)) {\n                    break Label_0174;\n                }\n            }\n            else if (that.probeName == null) {\n                break Label_0174;\n            }\n            return false;\n        }\n        Label_0207: {\n            if (this.targetName != null) {\n                if (this.targetName.equals(that.targetName)) {\n                    break Label_0207;\n                }\n            }\n            else if (that.targetName == null) {\n                break Label_0207;\n            }\n            return false;\n        }\n        if (this.targetType != null) {\n            if (this.targetType.equals(that.targetType)) {\n                return true;\n            }\n        }\n        else if (that.targetType == null) {\n            return true;\n        }\n        return false;\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = (this.targetName != null) ? this.targetName.hashCode() : 0;\n        result = 31 * result + ((this.targetType != null) ? this.targetType.hashCode() : 0);\n        result = 31 * result + ((this.bmClass != null) ? this.bmClass.hashCode() : 0);\n        result = 31 * result + ((this.bmName != null) ? this.bmName.hashCode() : 0);\n        result = 31 * result + ((this.bmDescription != null) ? this.bmDescription.hashCode() : 0);\n        result = 31 * result + ((this.probeName != null) ? this.probeName.hashCode() : 0);\n        result = 31 * result + this.precision;\n        return result;\n    }\n}\n"
    },
    {
        "project_name": "joda",
        "class": "DateTimeFormatter",
        "fqdn": "org.joda.time.format",
        "source_code": "package org.joda.time.format;\n\nimport java.util.*;\nimport java.io.*;\nimport org.joda.time.*;\n\npublic class DateTimeFormatter\n{\n    private final DateTimePrinter iPrinter;\n    private final DateTimeParser iParser;\n    private final Locale iLocale;\n    private final boolean iOffsetParsed;\n    private final Chronology iChrono;\n    private final DateTimeZone iZone;\n    private final Integer iPivotYear;\n    private final int iDefaultYear;\n    \n    public DateTimeFormatter(final DateTimePrinter iPrinter, final DateTimeParser iParser) {\n        this.iPrinter = iPrinter;\n        this.iParser = iParser;\n        this.iLocale = null;\n        this.iOffsetParsed = false;\n        this.iChrono = null;\n        this.iZone = null;\n        this.iPivotYear = null;\n        this.iDefaultYear = 2000;\n    }\n    \n    private DateTimeFormatter(final DateTimePrinter iPrinter, final DateTimeParser iParser, final Locale iLocale, final boolean iOffsetParsed, final Chronology iChrono, final DateTimeZone iZone, final Integer iPivotYear, final int iDefaultYear) {\n        this.iPrinter = iPrinter;\n        this.iParser = iParser;\n        this.iLocale = iLocale;\n        this.iOffsetParsed = iOffsetParsed;\n        this.iChrono = iChrono;\n        this.iZone = iZone;\n        this.iPivotYear = iPivotYear;\n        this.iDefaultYear = iDefaultYear;\n    }\n    \n    public boolean isPrinter() {\n        return this.iPrinter != null;\n    }\n    \n    public DateTimePrinter getPrinter() {\n        return this.iPrinter;\n    }\n    \n    public boolean isParser() {\n        return this.iParser != null;\n    }\n    \n    public DateTimeParser getParser() {\n        return this.iParser;\n    }\n    \n    public DateTimeFormatter withLocale(final Locale locale) {\n        if (locale == this.getLocale() || (locale != null && locale.equals(this.getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, locale, this.iOffsetParsed, this.iChrono, this.iZone, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public Locale getLocale() {\n        return this.iLocale;\n    }\n    \n    public DateTimeFormatter withOffsetParsed() {\n        if (this.iOffsetParsed) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, true, this.iChrono, null, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public boolean isOffsetParsed() {\n        return this.iOffsetParsed;\n    }\n    \n    public DateTimeFormatter withChronology(final Chronology chronology) {\n        if (this.iChrono == chronology) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, chronology, this.iZone, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public Chronology getChronology() {\n        return this.iChrono;\n    }\n    \n    @Deprecated\n    public Chronology getChronolgy() {\n        return this.iChrono;\n    }\n    \n    public DateTimeFormatter withZoneUTC() {\n        return this.withZone(DateTimeZone.UTC);\n    }\n    \n    public DateTimeFormatter withZone(final DateTimeZone dateTimeZone) {\n        if (this.iZone == dateTimeZone) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, false, this.iChrono, dateTimeZone, this.iPivotYear, this.iDefaultYear);\n    }\n    \n    public DateTimeZone getZone() {\n        return this.iZone;\n    }\n    \n    public DateTimeFormatter withPivotYear(final Integer n) {\n        if (this.iPivotYear == n || (this.iPivotYear != null && this.iPivotYear.equals(n))) {\n            return this;\n        }\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, this.iChrono, this.iZone, n, this.iDefaultYear);\n    }\n    \n    public DateTimeFormatter withPivotYear(final int n) {\n        return this.withPivotYear(Integer.valueOf(n));\n    }\n    \n    public Integer getPivotYear() {\n        return this.iPivotYear;\n    }\n    \n    public DateTimeFormatter withDefaultYear(final int n) {\n        return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, this.iChrono, this.iZone, this.iPivotYear, n);\n    }\n    \n    public int getDefaultYear() {\n        return this.iDefaultYear;\n    }\n    \n    public void printTo(final StringBuffer sb, final ReadableInstant readableInstant) {\n        this.printTo(sb, DateTimeUtils.getInstantMillis(readableInstant), DateTimeUtils.getInstantChronology(readableInstant));\n    }\n    \n    public void printTo(final Writer writer, final ReadableInstant readableInstant) throws IOException {\n        this.printTo(writer, DateTimeUtils.getInstantMillis(readableInstant), DateTimeUtils.getInstantChronology(readableInstant));\n    }\n    \n    public void printTo(final Appendable appendable, final ReadableInstant readableInstant) throws IOException {\n        appendable.append(this.print(readableInstant));\n    }\n    \n    public void printTo(final StringBuffer sb, final long n) {\n        this.printTo(sb, n, null);\n    }\n    \n    public void printTo(final Writer writer, final long n) throws IOException {\n        this.printTo(writer, n, null);\n    }\n    \n    public void printTo(final Appendable appendable, final long n) throws IOException {\n        appendable.append(this.print(n));\n    }\n    \n    public void printTo(final StringBuffer sb, final ReadablePartial readablePartial) {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        requirePrinter.printTo(sb, readablePartial, this.iLocale);\n    }\n    \n    public void printTo(final Writer writer, final ReadablePartial readablePartial) throws IOException {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        requirePrinter.printTo(writer, readablePartial, this.iLocale);\n    }\n    \n    public void printTo(final Appendable appendable, final ReadablePartial readablePartial) throws IOException {\n        appendable.append(this.print(readablePartial));\n    }\n    \n    public String print(final ReadableInstant readableInstant) {\n        final StringBuffer sb = new StringBuffer(this.requirePrinter().estimatePrintedLength());\n        this.printTo(sb, readableInstant);\n        return sb.toString();\n    }\n    \n    public String print(final long n) {\n        final StringBuffer sb = new StringBuffer(this.requirePrinter().estimatePrintedLength());\n        this.printTo(sb, n);\n        return sb.toString();\n    }\n    \n    public String print(final ReadablePartial readablePartial) {\n        final StringBuffer sb = new StringBuffer(this.requirePrinter().estimatePrintedLength());\n        this.printTo(sb, readablePartial);\n        return sb.toString();\n    }\n    \n    private void printTo(final StringBuffer sb, final long n, Chronology selectChronology) {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        selectChronology = this.selectChronology(selectChronology);\n        DateTimeZone dateTimeZone = selectChronology.getZone();\n        int offset = dateTimeZone.getOffset(n);\n        long n2 = n + offset;\n        if ((n ^ n2) < 0L && (n ^ offset) >= 0L) {\n            dateTimeZone = DateTimeZone.UTC;\n            offset = 0;\n            n2 = n;\n        }\n        requirePrinter.printTo(sb, n2, selectChronology.withUTC(), offset, dateTimeZone, this.iLocale);\n    }\n    \n    private void printTo(final Writer writer, final long n, Chronology selectChronology) throws IOException {\n        final DateTimePrinter requirePrinter = this.requirePrinter();\n        selectChronology = this.selectChronology(selectChronology);\n        DateTimeZone dateTimeZone = selectChronology.getZone();\n        int offset = dateTimeZone.getOffset(n);\n        long n2 = n + offset;\n        if ((n ^ n2) < 0L && (n ^ offset) >= 0L) {\n            dateTimeZone = DateTimeZone.UTC;\n            offset = 0;\n            n2 = n;\n        }\n        requirePrinter.printTo(writer, n2, selectChronology.withUTC(), offset, dateTimeZone, this.iLocale);\n    }\n    \n    private DateTimePrinter requirePrinter() {\n        final DateTimePrinter iPrinter = this.iPrinter;\n        if (iPrinter == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return iPrinter;\n    }\n    \n    public int parseInto(final ReadWritableInstant readWritableInstant, final String s, final int n) {\n        final DateTimeParser requireParser = this.requireParser();\n        if (readWritableInstant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        final long millis = readWritableInstant.getMillis();\n        final Chronology chronology = readWritableInstant.getChronology();\n        final int value = DateTimeUtils.getChronology(chronology).year().get(millis);\n        final long n2 = millis + chronology.getZone().getOffset(millis);\n        Chronology chronology2 = this.selectChronology(chronology);\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(n2, chronology2, this.iLocale, this.iPivotYear, value);\n        final int into = requireParser.parseInto(dateTimeParserBucket, s, n);\n        readWritableInstant.setMillis(dateTimeParserBucket.computeMillis(false, s));\n        if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {\n            chronology2 = chronology2.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n        }\n        else if (dateTimeParserBucket.getZone() != null) {\n            chronology2 = chronology2.withZone(dateTimeParserBucket.getZone());\n        }\n        readWritableInstant.setChronology(chronology2);\n        if (this.iZone != null) {\n            readWritableInstant.setZone(this.iZone);\n        }\n        return into;\n    }\n    \n    public long parseMillis(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, this.selectChronology(this.iChrono), this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                return dateTimeParserBucket.computeMillis(true, s);\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    public LocalDate parseLocalDate(final String s) {\n        return this.parseLocalDateTime(s).toLocalDate();\n    }\n    \n    public LocalTime parseLocalTime(final String s) {\n        return this.parseLocalDateTime(s).toLocalTime();\n    }\n    \n    public LocalDateTime parseLocalDateTime(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        Chronology chronology = this.selectChronology(null).withUTC();\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                final long computeMillis = dateTimeParserBucket.computeMillis(true, s);\n                if (dateTimeParserBucket.getOffsetInteger() != null) {\n                    chronology = chronology.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n                }\n                else if (dateTimeParserBucket.getZone() != null) {\n                    chronology = chronology.withZone(dateTimeParserBucket.getZone());\n                }\n                return new LocalDateTime(computeMillis, chronology);\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    public DateTime parseDateTime(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        Chronology chronology = this.selectChronology(null);\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                final long computeMillis = dateTimeParserBucket.computeMillis(true, s);\n                if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {\n                    chronology = chronology.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n                }\n                else if (dateTimeParserBucket.getZone() != null) {\n                    chronology = chronology.withZone(dateTimeParserBucket.getZone());\n                }\n                DateTime withZone = new DateTime(computeMillis, chronology);\n                if (this.iZone != null) {\n                    withZone = withZone.withZone(this.iZone);\n                }\n                return withZone;\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    public MutableDateTime parseMutableDateTime(final String s) {\n        final DateTimeParser requireParser = this.requireParser();\n        Chronology chronology = this.selectChronology(null);\n        final DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);\n        int into = requireParser.parseInto(dateTimeParserBucket, s, 0);\n        if (into >= 0) {\n            if (into >= s.length()) {\n                final long computeMillis = dateTimeParserBucket.computeMillis(true, s);\n                if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {\n                    chronology = chronology.withZone(DateTimeZone.forOffsetMillis(dateTimeParserBucket.getOffsetInteger()));\n                }\n                else if (dateTimeParserBucket.getZone() != null) {\n                    chronology = chronology.withZone(dateTimeParserBucket.getZone());\n                }\n                final MutableDateTime mutableDateTime = new MutableDateTime(computeMillis, chronology);\n                if (this.iZone != null) {\n                    mutableDateTime.setZone(this.iZone);\n                }\n                return mutableDateTime;\n            }\n        }\n        else {\n            into ^= -1;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(s, into));\n    }\n    \n    private DateTimeParser requireParser() {\n        final DateTimeParser iParser = this.iParser;\n        if (iParser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return iParser;\n    }\n    \n    private Chronology selectChronology(Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        if (this.iChrono != null) {\n            chronology = this.iChrono;\n        }\n        if (this.iZone != null) {\n            chronology = chronology.withZone(this.iZone);\n        }\n        return chronology;\n    }\n}\n"
    },
    {
        "project_name": "joda",
        "class": "MutablePeriod",
        "fqdn": "org.joda.time",
        "source_code": "package org.joda.time;\n\nimport org.joda.time.base.*;\nimport java.io.*;\nimport org.joda.convert.*;\nimport org.joda.time.format.*;\nimport org.joda.time.field.*;\n\npublic class MutablePeriod extends BasePeriod implements ReadWritablePeriod, Cloneable, Serializable\n{\n    private static final long serialVersionUID = 3436451121567212165L;\n    \n    @FromString\n    public static MutablePeriod parse(final String s) {\n        return parse(s, ISOPeriodFormat.standard());\n    }\n    \n    public static MutablePeriod parse(final String s, final PeriodFormatter periodFormatter) {\n        return periodFormatter.parsePeriod(s).toMutablePeriod();\n    }\n    \n    public MutablePeriod() {\n        super(0L, null, null);\n    }\n    \n    public MutablePeriod(final PeriodType periodType) {\n        super(0L, periodType, null);\n    }\n    \n    public MutablePeriod(final int n, final int n2, final int n3, final int n4) {\n        super(0, 0, 0, 0, n, n2, n3, n4, PeriodType.standard());\n    }\n    \n    public MutablePeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        super(n, n2, n3, n4, n5, n6, n7, n8, PeriodType.standard());\n    }\n    \n    public MutablePeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, final PeriodType periodType) {\n        super(n, n2, n3, n4, n5, n6, n7, n8, periodType);\n    }\n    \n    public MutablePeriod(final long n) {\n        super(n);\n    }\n    \n    public MutablePeriod(final long n, final PeriodType periodType) {\n        super(n, periodType, null);\n    }\n    \n    public MutablePeriod(final long n, final Chronology chronology) {\n        super(n, null, chronology);\n    }\n    \n    public MutablePeriod(final long n, final PeriodType periodType, final Chronology chronology) {\n        super(n, periodType, chronology);\n    }\n    \n    public MutablePeriod(final long n, final long n2) {\n        super(n, n2, null, null);\n    }\n    \n    public MutablePeriod(final long n, final long n2, final PeriodType periodType) {\n        super(n, n2, periodType, null);\n    }\n    \n    public MutablePeriod(final long n, final long n2, final Chronology chronology) {\n        super(n, n2, null, chronology);\n    }\n    \n    public MutablePeriod(final long n, final long n2, final PeriodType periodType, final Chronology chronology) {\n        super(n, n2, periodType, chronology);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2) {\n        super(readableInstant, readableInstant2, null);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2, final PeriodType periodType) {\n        super(readableInstant, readableInstant2, periodType);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableDuration readableDuration) {\n        super(readableInstant, readableDuration, null);\n    }\n    \n    public MutablePeriod(final ReadableInstant readableInstant, final ReadableDuration readableDuration, final PeriodType periodType) {\n        super(readableInstant, readableDuration, periodType);\n    }\n    \n    public MutablePeriod(final ReadableDuration readableDuration, final ReadableInstant readableInstant) {\n        super(readableDuration, readableInstant, null);\n    }\n    \n    public MutablePeriod(final ReadableDuration readableDuration, final ReadableInstant readableInstant, final PeriodType periodType) {\n        super(readableDuration, readableInstant, periodType);\n    }\n    \n    public MutablePeriod(final Object o) {\n        super(o, null, null);\n    }\n    \n    public MutablePeriod(final Object o, final PeriodType periodType) {\n        super(o, periodType, null);\n    }\n    \n    public MutablePeriod(final Object o, final Chronology chronology) {\n        super(o, null, chronology);\n    }\n    \n    public MutablePeriod(final Object o, final PeriodType periodType, final Chronology chronology) {\n        super(o, periodType, chronology);\n    }\n    \n    public void clear() {\n        super.setValues(new int[this.size()]);\n    }\n    \n    public void setValue(final int n, final int n2) {\n        super.setValue(n, n2);\n    }\n    \n    public void set(final DurationFieldType durationFieldType, final int n) {\n        super.setField(durationFieldType, n);\n    }\n    \n    public void setPeriod(final ReadablePeriod period) {\n        super.setPeriod(period);\n    }\n    \n    public void setPeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        super.setPeriod(n, n2, n3, n4, n5, n6, n7, n8);\n    }\n    \n    public void setPeriod(final ReadableInterval readableInterval) {\n        if (readableInterval == null) {\n            this.setPeriod(0L);\n        }\n        else {\n            this.setPeriod(readableInterval.getStartMillis(), readableInterval.getEndMillis(), DateTimeUtils.getChronology(readableInterval.getChronology()));\n        }\n    }\n    \n    public void setPeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2) {\n        if (readableInstant == readableInstant2) {\n            this.setPeriod(0L);\n        }\n        else {\n            this.setPeriod(DateTimeUtils.getInstantMillis(readableInstant), DateTimeUtils.getInstantMillis(readableInstant2), DateTimeUtils.getIntervalChronology(readableInstant, readableInstant2));\n        }\n    }\n    \n    public void setPeriod(final long n, final long n2) {\n        this.setPeriod(n, n2, null);\n    }\n    \n    public void setPeriod(final long n, final long n2, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.setValues(chronology.get(this, n, n2));\n    }\n    \n    public void setPeriod(final ReadableDuration readableDuration) {\n        this.setPeriod(readableDuration, null);\n    }\n    \n    public void setPeriod(final ReadableDuration readableDuration, final Chronology chronology) {\n        this.setPeriod(DateTimeUtils.getDurationMillis(readableDuration), chronology);\n    }\n    \n    public void setPeriod(final long n) {\n        this.setPeriod(n, null);\n    }\n    \n    public void setPeriod(final long n, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.setValues(chronology.get(this, n));\n    }\n    \n    public void add(final DurationFieldType durationFieldType, final int n) {\n        super.addField(durationFieldType, n);\n    }\n    \n    public void add(final ReadablePeriod readablePeriod) {\n        super.addPeriod(readablePeriod);\n    }\n    \n    public void add(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        this.setPeriod(FieldUtils.safeAdd(this.getYears(), n), FieldUtils.safeAdd(this.getMonths(), n2), FieldUtils.safeAdd(this.getWeeks(), n3), FieldUtils.safeAdd(this.getDays(), n4), FieldUtils.safeAdd(this.getHours(), n5), FieldUtils.safeAdd(this.getMinutes(), n6), FieldUtils.safeAdd(this.getSeconds(), n7), FieldUtils.safeAdd(this.getMillis(), n8));\n    }\n    \n    public void add(final ReadableInterval readableInterval) {\n        if (readableInterval != null) {\n            this.add(readableInterval.toPeriod(this.getPeriodType()));\n        }\n    }\n    \n    public void add(final ReadableDuration readableDuration) {\n        if (readableDuration != null) {\n            this.add(new Period(readableDuration.getMillis(), this.getPeriodType()));\n        }\n    }\n    \n    public void add(final long n) {\n        this.add(new Period(n, this.getPeriodType()));\n    }\n    \n    public void add(final long n, final Chronology chronology) {\n        this.add(new Period(n, this.getPeriodType(), chronology));\n    }\n    \n    public void mergePeriod(final ReadablePeriod readablePeriod) {\n        super.mergePeriod(readablePeriod);\n    }\n    \n    public int getYears() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }\n    \n    public int getMonths() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }\n    \n    public int getWeeks() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }\n    \n    public int getDays() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }\n    \n    public int getHours() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n    }\n    \n    public int getMinutes() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n    }\n    \n    public int getSeconds() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n    }\n    \n    public int getMillis() {\n        return this.getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n    }\n    \n    public void setYears(final int n) {\n        super.setField(DurationFieldType.years(), n);\n    }\n    \n    public void addYears(final int n) {\n        super.addField(DurationFieldType.years(), n);\n    }\n    \n    public void setMonths(final int n) {\n        super.setField(DurationFieldType.months(), n);\n    }\n    \n    public void addMonths(final int n) {\n        super.addField(DurationFieldType.months(), n);\n    }\n    \n    public void setWeeks(final int n) {\n        super.setField(DurationFieldType.weeks(), n);\n    }\n    \n    public void addWeeks(final int n) {\n        super.addField(DurationFieldType.weeks(), n);\n    }\n    \n    public void setDays(final int n) {\n        super.setField(DurationFieldType.days(), n);\n    }\n    \n    public void addDays(final int n) {\n        super.addField(DurationFieldType.days(), n);\n    }\n    \n    public void setHours(final int n) {\n        super.setField(DurationFieldType.hours(), n);\n    }\n    \n    public void addHours(final int n) {\n        super.addField(DurationFieldType.hours(), n);\n    }\n    \n    public void setMinutes(final int n) {\n        super.setField(DurationFieldType.minutes(), n);\n    }\n    \n    public void addMinutes(final int n) {\n        super.addField(DurationFieldType.minutes(), n);\n    }\n    \n    public void setSeconds(final int n) {\n        super.setField(DurationFieldType.seconds(), n);\n    }\n    \n    public void addSeconds(final int n) {\n        super.addField(DurationFieldType.seconds(), n);\n    }\n    \n    public void setMillis(final int n) {\n        super.setField(DurationFieldType.millis(), n);\n    }\n    \n    public void addMillis(final int n) {\n        super.addField(DurationFieldType.millis(), n);\n    }\n    \n    public MutablePeriod copy() {\n        return (MutablePeriod)this.clone();\n    }\n    \n    public Object clone() {\n        try {\n            return super.clone();\n        }\n        catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"Clone error\");\n        }\n    }\n}\n"
    },
    {
        "project_name": "joda",
        "class": "BasePeriod",
        "fqdn": "org.joda.time.base",
        "source_code": "package org.joda.time.base;\n\nimport java.io.*;\nimport org.joda.time.field.*;\nimport org.joda.time.chrono.*;\nimport org.joda.time.convert.*;\nimport org.joda.time.*;\n\npublic abstract class BasePeriod extends AbstractPeriod implements ReadablePeriod, Serializable\n{\n    private static final long serialVersionUID = -2110953284060001145L;\n    private static final ReadablePeriod DUMMY_PERIOD;\n    private final PeriodType iType;\n    private final int[] iValues;\n    \n    protected BasePeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        this.iType = checkPeriodType;\n        this.iValues = this.setPeriodInternal(n, n2, n3, n4, n5, n6, n7, n8);\n    }\n    \n    protected BasePeriod(final long n, final long n2, PeriodType checkPeriodType, Chronology chronology) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.iType = checkPeriodType;\n        this.iValues = chronology.get(this, n, n2);\n    }\n    \n    protected BasePeriod(final ReadableInstant readableInstant, final ReadableInstant readableInstant2, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        if (readableInstant == null && readableInstant2 == null) {\n            this.iType = checkPeriodType;\n            this.iValues = new int[this.size()];\n        }\n        else {\n            final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n            final long instantMillis2 = DateTimeUtils.getInstantMillis(readableInstant2);\n            final Chronology intervalChronology = DateTimeUtils.getIntervalChronology(readableInstant, readableInstant2);\n            this.iType = checkPeriodType;\n            this.iValues = intervalChronology.get(this, instantMillis, instantMillis2);\n        }\n    }\n    \n    protected BasePeriod(final ReadablePartial readablePartial, final ReadablePartial readablePartial2, PeriodType checkPeriodType) {\n        if (readablePartial == null || readablePartial2 == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (readablePartial instanceof BaseLocal && readablePartial2 instanceof BaseLocal && readablePartial.getClass() == readablePartial2.getClass()) {\n            checkPeriodType = this.checkPeriodType(checkPeriodType);\n            final long localMillis = ((BaseLocal)readablePartial).getLocalMillis();\n            final long localMillis2 = ((BaseLocal)readablePartial2).getLocalMillis();\n            final Chronology chronology = DateTimeUtils.getChronology(readablePartial.getChronology());\n            this.iType = checkPeriodType;\n            this.iValues = chronology.get(this, localMillis, localMillis2);\n        }\n        else {\n            if (readablePartial.size() != readablePartial2.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0; i < readablePartial.size(); ++i) {\n                if (readablePartial.getFieldType(i) != readablePartial2.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            if (!DateTimeUtils.isContiguous(readablePartial)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n            }\n            this.iType = this.checkPeriodType(checkPeriodType);\n            final Chronology withUTC = DateTimeUtils.getChronology(readablePartial.getChronology()).withUTC();\n            this.iValues = withUTC.get(this, withUTC.set(readablePartial, 0L), withUTC.set(readablePartial2, 0L));\n        }\n    }\n    \n    protected BasePeriod(final ReadableInstant readableInstant, final ReadableDuration readableDuration, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        final long safeAdd = FieldUtils.safeAdd(instantMillis, DateTimeUtils.getDurationMillis(readableDuration));\n        final Chronology instantChronology = DateTimeUtils.getInstantChronology(readableInstant);\n        this.iType = checkPeriodType;\n        this.iValues = instantChronology.get(this, instantMillis, safeAdd);\n    }\n    \n    protected BasePeriod(final ReadableDuration readableDuration, final ReadableInstant readableInstant, PeriodType checkPeriodType) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        final long durationMillis = DateTimeUtils.getDurationMillis(readableDuration);\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        final long safeSubtract = FieldUtils.safeSubtract(instantMillis, durationMillis);\n        final Chronology instantChronology = DateTimeUtils.getInstantChronology(readableInstant);\n        this.iType = checkPeriodType;\n        this.iValues = instantChronology.get(this, safeSubtract, instantMillis);\n    }\n    \n    protected BasePeriod(final long n) {\n        this.iType = PeriodType.standard();\n        System.arraycopy(ISOChronology.getInstanceUTC().get(BasePeriod.DUMMY_PERIOD, n), 0, this.iValues = new int[8], 4, 4);\n    }\n    \n    protected BasePeriod(final long n, PeriodType checkPeriodType, Chronology chronology) {\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        chronology = DateTimeUtils.getChronology(chronology);\n        this.iType = checkPeriodType;\n        this.iValues = chronology.get(this, n);\n    }\n    \n    protected BasePeriod(final Object o, PeriodType checkPeriodType, Chronology chronology) {\n        final PeriodConverter periodConverter = ConverterManager.getInstance().getPeriodConverter(o);\n        checkPeriodType = ((checkPeriodType == null) ? periodConverter.getPeriodType(o) : checkPeriodType);\n        checkPeriodType = this.checkPeriodType(checkPeriodType);\n        this.iType = checkPeriodType;\n        if (this instanceof ReadWritablePeriod) {\n            this.iValues = new int[this.size()];\n            chronology = DateTimeUtils.getChronology(chronology);\n            periodConverter.setInto((ReadWritablePeriod)this, o, chronology);\n        }\n        else {\n            this.iValues = new MutablePeriod(o, checkPeriodType, chronology).getValues();\n        }\n    }\n    \n    protected BasePeriod(final int[] iValues, final PeriodType iType) {\n        this.iType = iType;\n        this.iValues = iValues;\n    }\n    \n    protected PeriodType checkPeriodType(final PeriodType periodType) {\n        return DateTimeUtils.getPeriodType(periodType);\n    }\n    \n    public PeriodType getPeriodType() {\n        return this.iType;\n    }\n    \n    public int getValue(final int n) {\n        return this.iValues[n];\n    }\n    \n    public Duration toDurationFrom(final ReadableInstant readableInstant) {\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        return new Duration(instantMillis, DateTimeUtils.getInstantChronology(readableInstant).add(this, instantMillis, 1));\n    }\n    \n    public Duration toDurationTo(final ReadableInstant readableInstant) {\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        return new Duration(DateTimeUtils.getInstantChronology(readableInstant).add(this, instantMillis, -1), instantMillis);\n    }\n    \n    private void checkAndUpdate(final DurationFieldType durationFieldType, final int[] array, final int n) {\n        final int index = this.indexOf(durationFieldType);\n        if (index == -1) {\n            if (n != 0) {\n                throw new IllegalArgumentException(\"Period does not support field '\" + durationFieldType.getName() + \"'\");\n            }\n        }\n        else {\n            array[index] = n;\n        }\n    }\n    \n    protected void setPeriod(final ReadablePeriod periodInternal) {\n        if (periodInternal == null) {\n            this.setValues(new int[this.size()]);\n        }\n        else {\n            this.setPeriodInternal(periodInternal);\n        }\n    }\n    \n    private void setPeriodInternal(final ReadablePeriod readablePeriod) {\n        final int[] values = new int[this.size()];\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            this.checkAndUpdate(readablePeriod.getFieldType(i), values, readablePeriod.getValue(i));\n        }\n        this.setValues(values);\n    }\n    \n    protected void setPeriod(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        this.setValues(this.setPeriodInternal(n, n2, n3, n4, n5, n6, n7, n8));\n    }\n    \n    private int[] setPeriodInternal(final int n, final int n2, final int n3, final int n4, final int n5, final int n6, final int n7, final int n8) {\n        final int[] array = new int[this.size()];\n        this.checkAndUpdate(DurationFieldType.years(), array, n);\n        this.checkAndUpdate(DurationFieldType.months(), array, n2);\n        this.checkAndUpdate(DurationFieldType.weeks(), array, n3);\n        this.checkAndUpdate(DurationFieldType.days(), array, n4);\n        this.checkAndUpdate(DurationFieldType.hours(), array, n5);\n        this.checkAndUpdate(DurationFieldType.minutes(), array, n6);\n        this.checkAndUpdate(DurationFieldType.seconds(), array, n7);\n        this.checkAndUpdate(DurationFieldType.millis(), array, n8);\n        return array;\n    }\n    \n    protected void setField(final DurationFieldType durationFieldType, final int n) {\n        this.setFieldInto(this.iValues, durationFieldType, n);\n    }\n    \n    protected void setFieldInto(final int[] array, final DurationFieldType durationFieldType, final int n) {\n        final int index = this.indexOf(durationFieldType);\n        if (index == -1) {\n            if (n != 0 || durationFieldType == null) {\n                throw new IllegalArgumentException(\"Period does not support field '\" + durationFieldType + \"'\");\n            }\n        }\n        else {\n            array[index] = n;\n        }\n    }\n    \n    protected void addField(final DurationFieldType durationFieldType, final int n) {\n        this.addFieldInto(this.iValues, durationFieldType, n);\n    }\n    \n    protected void addFieldInto(final int[] array, final DurationFieldType durationFieldType, final int n) {\n        final int index = this.indexOf(durationFieldType);\n        if (index == -1) {\n            if (n != 0 || durationFieldType == null) {\n                throw new IllegalArgumentException(\"Period does not support field '\" + durationFieldType + \"'\");\n            }\n        }\n        else {\n            array[index] = FieldUtils.safeAdd(array[index], n);\n        }\n    }\n    \n    protected void mergePeriod(final ReadablePeriod readablePeriod) {\n        if (readablePeriod != null) {\n            this.setValues(this.mergePeriodInto(this.getValues(), readablePeriod));\n        }\n    }\n    \n    protected int[] mergePeriodInto(final int[] array, final ReadablePeriod readablePeriod) {\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            this.checkAndUpdate(readablePeriod.getFieldType(i), array, readablePeriod.getValue(i));\n        }\n        return array;\n    }\n    \n    protected void addPeriod(final ReadablePeriod readablePeriod) {\n        if (readablePeriod != null) {\n            this.setValues(this.addPeriodInto(this.getValues(), readablePeriod));\n        }\n    }\n    \n    protected int[] addPeriodInto(final int[] array, final ReadablePeriod readablePeriod) {\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            final DurationFieldType fieldType = readablePeriod.getFieldType(i);\n            final int value = readablePeriod.getValue(i);\n            if (value != 0) {\n                final int index = this.indexOf(fieldType);\n                if (index == -1) {\n                    throw new IllegalArgumentException(\"Period does not support field '\" + fieldType.getName() + \"'\");\n                }\n                array[index] = FieldUtils.safeAdd(this.getValue(index), value);\n            }\n        }\n        return array;\n    }\n    \n    protected void setValue(final int n, final int n2) {\n        this.iValues[n] = n2;\n    }\n    \n    protected void setValues(final int[] array) {\n        System.arraycopy(array, 0, this.iValues, 0, this.iValues.length);\n    }\n    \n    static {\n        DUMMY_PERIOD = new AbstractPeriod() {\n            public int getValue(final int n) {\n                return 0;\n            }\n            \n            public PeriodType getPeriodType() {\n                return PeriodType.time();\n            }\n        };\n    }\n}\n"
    },
    {
        "project_name": "joda",
        "class": "Partial",
        "fqdn": "org.joda.time",
        "source_code": "package org.joda.time;\n\nimport org.joda.time.base.*;\nimport java.io.*;\nimport org.joda.time.format.*;\nimport java.util.*;\nimport org.joda.time.field.*;\n\npublic final class Partial extends AbstractPartial implements ReadablePartial, Serializable\n{\n    private static final long serialVersionUID = 12324121189002L;\n    private final Chronology iChronology;\n    private final DateTimeFieldType[] iTypes;\n    private final int[] iValues;\n    private transient DateTimeFormatter[] iFormatter;\n    \n    public Partial() {\n        this((Chronology)null);\n    }\n    \n    public Partial(final Chronology chronology) {\n        this.iChronology = DateTimeUtils.getChronology(chronology).withUTC();\n        this.iTypes = new DateTimeFieldType[0];\n        this.iValues = new int[0];\n    }\n    \n    public Partial(final DateTimeFieldType dateTimeFieldType, final int n) {\n        this(dateTimeFieldType, n, null);\n    }\n    \n    public Partial(final DateTimeFieldType dateTimeFieldType, final int n, Chronology withUTC) {\n        withUTC = DateTimeUtils.getChronology(withUTC).withUTC();\n        this.iChronology = withUTC;\n        if (dateTimeFieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        this.iTypes = new DateTimeFieldType[] { dateTimeFieldType };\n        withUTC.validate(this, this.iValues = new int[] { n });\n    }\n    \n    public Partial(final DateTimeFieldType[] array, final int[] array2) {\n        this(array, array2, null);\n    }\n    \n    public Partial(final DateTimeFieldType[] iTypes, final int[] iValues, Chronology withUTC) {\n        withUTC = DateTimeUtils.getChronology(withUTC).withUTC();\n        this.iChronology = withUTC;\n        if (iTypes == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (iValues == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (iValues.length != iTypes.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (iTypes.length == 0) {\n            this.iTypes = iTypes;\n            this.iValues = iValues;\n            return;\n        }\n        for (int i = 0; i < iTypes.length; ++i) {\n            if (iTypes[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        Comparable<DurationField> comparable = null;\n        for (int j = 0; j < iTypes.length; ++j) {\n            final DateTimeFieldType dateTimeFieldType = iTypes[j];\n            final DurationField field = dateTimeFieldType.getDurationType().getField(this.iChronology);\n            if (j > 0) {\n                final int compareTo = comparable.compareTo(field);\n                if (compareTo < 0 || (compareTo != 0 && !field.isSupported())) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + iTypes[j - 1].getName() + \" < \" + dateTimeFieldType.getName());\n                }\n                if (compareTo == 0) {\n                    if (iTypes[j - 1].getRangeDurationType() == null) {\n                        if (dateTimeFieldType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + dateTimeFieldType.getName());\n                        }\n                    }\n                    else {\n                        if (dateTimeFieldType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + iTypes[j - 1].getName() + \" < \" + dateTimeFieldType.getName());\n                        }\n                        final DurationField field2 = iTypes[j - 1].getRangeDurationType().getField(this.iChronology);\n                        final DurationField field3 = dateTimeFieldType.getRangeDurationType().getField(this.iChronology);\n                        if (field2.compareTo(field3) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" + iTypes[j - 1].getName() + \" < \" + dateTimeFieldType.getName());\n                        }\n                        if (field2.compareTo(field3) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + dateTimeFieldType.getName());\n                        }\n                    }\n                }\n            }\n            comparable = field;\n        }\n        this.iTypes = iTypes.clone();\n        withUTC.validate(this, iValues);\n        this.iValues = iValues.clone();\n    }\n    \n    public Partial(final ReadablePartial readablePartial) {\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        this.iChronology = DateTimeUtils.getChronology(readablePartial.getChronology()).withUTC();\n        this.iTypes = new DateTimeFieldType[readablePartial.size()];\n        this.iValues = new int[readablePartial.size()];\n        for (int i = 0; i < readablePartial.size(); ++i) {\n            this.iTypes[i] = readablePartial.getFieldType(i);\n            this.iValues[i] = readablePartial.getValue(i);\n        }\n    }\n    \n    Partial(final Partial partial, final int[] iValues) {\n        this.iChronology = partial.iChronology;\n        this.iTypes = partial.iTypes;\n        this.iValues = iValues;\n    }\n    \n    Partial(final Chronology iChronology, final DateTimeFieldType[] iTypes, final int[] iValues) {\n        this.iChronology = iChronology;\n        this.iTypes = iTypes;\n        this.iValues = iValues;\n    }\n    \n    public int size() {\n        return this.iTypes.length;\n    }\n    \n    public Chronology getChronology() {\n        return this.iChronology;\n    }\n    \n    protected DateTimeField getField(final int n, final Chronology chronology) {\n        return this.iTypes[n].getField(chronology);\n    }\n    \n    public DateTimeFieldType getFieldType(final int n) {\n        return this.iTypes[n];\n    }\n    \n    public DateTimeFieldType[] getFieldTypes() {\n        return this.iTypes.clone();\n    }\n    \n    public int getValue(final int n) {\n        return this.iValues[n];\n    }\n    \n    public int[] getValues() {\n        return this.iValues.clone();\n    }\n    \n    public Partial withChronologyRetainFields(Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        chronology = chronology.withUTC();\n        if (chronology == this.getChronology()) {\n            return this;\n        }\n        final Partial partial = new Partial(chronology, this.iTypes, this.iValues);\n        chronology.validate(partial, this.iValues);\n        return partial;\n    }\n    \n    public Partial with(final DateTimeFieldType dateTimeFieldType, final int n) {\n        if (dateTimeFieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        final int index = this.indexOf(dateTimeFieldType);\n        if (index == -1) {\n            final DateTimeFieldType[] array = new DateTimeFieldType[this.iTypes.length + 1];\n            final int[] array2 = new int[array.length];\n            int i = 0;\n            final DurationField field = dateTimeFieldType.getDurationType().getField(this.iChronology);\n            if (field.isSupported()) {\n                while (i < this.iTypes.length) {\n                    final DateTimeFieldType dateTimeFieldType2 = this.iTypes[i];\n                    final DurationField field2 = dateTimeFieldType2.getDurationType().getField(this.iChronology);\n                    if (field2.isSupported()) {\n                        final int compareTo = field.compareTo(field2);\n                        if (compareTo > 0) {\n                            break;\n                        }\n                        if (compareTo == 0 && dateTimeFieldType.getRangeDurationType().getField(this.iChronology).compareTo(dateTimeFieldType2.getRangeDurationType().getField(this.iChronology)) > 0) {\n                            break;\n                        }\n                    }\n                    ++i;\n                }\n            }\n            System.arraycopy(this.iTypes, 0, array, 0, i);\n            System.arraycopy(this.iValues, 0, array2, 0, i);\n            array[i] = dateTimeFieldType;\n            array2[i] = n;\n            System.arraycopy(this.iTypes, i, array, i + 1, array.length - i - 1);\n            System.arraycopy(this.iValues, i, array2, i + 1, array2.length - i - 1);\n            final Partial partial = new Partial(this.iChronology, array, array2);\n            this.iChronology.validate(partial, array2);\n            return partial;\n        }\n        if (n == this.getValue(index)) {\n            return this;\n        }\n        return new Partial(this, this.getField(index).set(this, index, this.getValues(), n));\n    }\n    \n    public Partial without(final DateTimeFieldType dateTimeFieldType) {\n        final int index = this.indexOf(dateTimeFieldType);\n        if (index != -1) {\n            final DateTimeFieldType[] array = new DateTimeFieldType[this.size() - 1];\n            final int[] array2 = new int[this.size() - 1];\n            System.arraycopy(this.iTypes, 0, array, 0, index);\n            System.arraycopy(this.iTypes, index + 1, array, index, array.length - index);\n            System.arraycopy(this.iValues, 0, array2, 0, index);\n            System.arraycopy(this.iValues, index + 1, array2, index, array2.length - index);\n            final Partial partial = new Partial(this.iChronology, array, array2);\n            this.iChronology.validate(partial, array2);\n            return partial;\n        }\n        return this;\n    }\n    \n    public Partial withField(final DateTimeFieldType dateTimeFieldType, final int n) {\n        final int indexOfSupported = this.indexOfSupported(dateTimeFieldType);\n        if (n == this.getValue(indexOfSupported)) {\n            return this;\n        }\n        return new Partial(this, this.getField(indexOfSupported).set(this, indexOfSupported, this.getValues(), n));\n    }\n    \n    public Partial withFieldAdded(final DurationFieldType durationFieldType, final int n) {\n        final int indexOfSupported = this.indexOfSupported(durationFieldType);\n        if (n == 0) {\n            return this;\n        }\n        return new Partial(this, this.getField(indexOfSupported).add(this, indexOfSupported, this.getValues(), n));\n    }\n    \n    public Partial withFieldAddWrapped(final DurationFieldType durationFieldType, final int n) {\n        final int indexOfSupported = this.indexOfSupported(durationFieldType);\n        if (n == 0) {\n            return this;\n        }\n        return new Partial(this, this.getField(indexOfSupported).addWrapPartial(this, indexOfSupported, this.getValues(), n));\n    }\n    \n    public Partial withPeriodAdded(final ReadablePeriod readablePeriod, final int n) {\n        if (readablePeriod == null || n == 0) {\n            return this;\n        }\n        int[] array = this.getValues();\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            final int index = this.indexOf(readablePeriod.getFieldType(i));\n            if (index >= 0) {\n                array = this.getField(index).add(this, index, array, FieldUtils.safeMultiply(readablePeriod.getValue(i), n));\n            }\n        }\n        return new Partial(this, array);\n    }\n    \n    public Partial plus(final ReadablePeriod readablePeriod) {\n        return this.withPeriodAdded(readablePeriod, 1);\n    }\n    \n    public Partial minus(final ReadablePeriod readablePeriod) {\n        return this.withPeriodAdded(readablePeriod, -1);\n    }\n    \n    public Property property(final DateTimeFieldType dateTimeFieldType) {\n        return new Property(this, this.indexOfSupported(dateTimeFieldType));\n    }\n    \n    public boolean isMatch(final ReadableInstant readableInstant) {\n        final long instantMillis = DateTimeUtils.getInstantMillis(readableInstant);\n        final Chronology instantChronology = DateTimeUtils.getInstantChronology(readableInstant);\n        for (int i = 0; i < this.iTypes.length; ++i) {\n            if (this.iTypes[i].getField(instantChronology).get(instantMillis) != this.iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public boolean isMatch(final ReadablePartial readablePartial) {\n        if (readablePartial == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        for (int i = 0; i < this.iTypes.length; ++i) {\n            if (readablePartial.get(this.iTypes[i]) != this.iValues[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public DateTimeFormatter getFormatter() {\n        DateTimeFormatter[] iFormatter = this.iFormatter;\n        if (iFormatter == null) {\n            if (this.size() == 0) {\n                return null;\n            }\n            iFormatter = new DateTimeFormatter[2];\n            try {\n                final ArrayList<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(this.iTypes));\n                iFormatter[0] = ISODateTimeFormat.forFields(list, true, false);\n                if (list.size() == 0) {\n                    iFormatter[1] = iFormatter[0];\n                }\n            }\n            catch (IllegalArgumentException ex) {}\n            this.iFormatter = iFormatter;\n        }\n        return iFormatter[0];\n    }\n    \n    public String toString() {\n        DateTimeFormatter[] array = this.iFormatter;\n        if (array == null) {\n            this.getFormatter();\n            array = this.iFormatter;\n            if (array == null) {\n                return this.toStringList();\n            }\n        }\n        final DateTimeFormatter dateTimeFormatter = array[1];\n        if (dateTimeFormatter == null) {\n            return this.toStringList();\n        }\n        return dateTimeFormatter.print(this);\n    }\n    \n    public String toStringList() {\n        final int size = this.size();\n        final StringBuilder sb = new StringBuilder(20 * size);\n        sb.append('[');\n        for (int i = 0; i < size; ++i) {\n            if (i > 0) {\n                sb.append(',').append(' ');\n            }\n            sb.append(this.iTypes[i].getName());\n            sb.append('=');\n            sb.append(this.iValues[i]);\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n    \n    public String toString(final String s) {\n        if (s == null) {\n            return this.toString();\n        }\n        return DateTimeFormat.forPattern(s).print(this);\n    }\n    \n    public String toString(final String s, final Locale locale) {\n        if (s == null) {\n            return this.toString();\n        }\n        return DateTimeFormat.forPattern(s).withLocale(locale).print(this);\n    }\n    \n    public static class Property extends AbstractPartialFieldProperty implements Serializable\n    {\n        private static final long serialVersionUID = 53278362873888L;\n        private final Partial iPartial;\n        private final int iFieldIndex;\n        \n        Property(final Partial iPartial, final int iFieldIndex) {\n            this.iPartial = iPartial;\n            this.iFieldIndex = iFieldIndex;\n        }\n        \n        public DateTimeField getField() {\n            return this.iPartial.getField(this.iFieldIndex);\n        }\n        \n        protected ReadablePartial getReadablePartial() {\n            return this.iPartial;\n        }\n        \n        public Partial getPartial() {\n            return this.iPartial;\n        }\n        \n        public int get() {\n            return this.iPartial.getValue(this.iFieldIndex);\n        }\n        \n        public Partial addToCopy(final int n) {\n            return new Partial(this.iPartial, this.getField().add(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), n));\n        }\n        \n        public Partial addWrapFieldToCopy(final int n) {\n            return new Partial(this.iPartial, this.getField().addWrapField(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), n));\n        }\n        \n        public Partial setCopy(final int n) {\n            return new Partial(this.iPartial, this.getField().set(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), n));\n        }\n        \n        public Partial setCopy(final String s, final Locale locale) {\n            return new Partial(this.iPartial, this.getField().set(this.iPartial, this.iFieldIndex, this.iPartial.getValues(), s, locale));\n        }\n        \n        public Partial setCopy(final String s) {\n            return this.setCopy(s, null);\n        }\n        \n        public Partial withMaximumValue() {\n            return this.setCopy(this.getMaximumValue());\n        }\n        \n        public Partial withMinimumValue() {\n            return this.setCopy(this.getMinimumValue());\n        }\n    }\n}\n"
    },
    {
        "project_name": "joda",
        "class": "BasicMonthOfYearDateTimeField",
        "fqdn": "org.joda.time.chrono",
        "source_code": "package org.joda.time.chrono;\n\nimport org.joda.time.field.*;\nimport org.joda.time.*;\n\nclass BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField\n{\n    private static final long serialVersionUID = -8258715387168736L;\n    private static final int MIN = 1;\n    private final BasicChronology iChronology;\n    private final int iMax;\n    private final int iLeapMonth;\n    \n    BasicMonthOfYearDateTimeField(final BasicChronology iChronology, final int iLeapMonth) {\n        super(DateTimeFieldType.monthOfYear(), iChronology.getAverageMillisPerMonth());\n        this.iChronology = iChronology;\n        this.iMax = this.iChronology.getMaxMonth();\n        this.iLeapMonth = iLeapMonth;\n    }\n    \n    public boolean isLenient() {\n        return false;\n    }\n    \n    public int get(final long n) {\n        return this.iChronology.getMonthOfYear(n);\n    }\n    \n    public long add(final long n, final int n2) {\n        if (n2 == 0) {\n            return n;\n        }\n        final long n3 = this.iChronology.getMillisOfDay(n);\n        final int year = this.iChronology.getYear(n);\n        final int monthOfYear = this.iChronology.getMonthOfYear(n, year);\n        final int n4 = monthOfYear - 1 + n2;\n        int n5;\n        int n6;\n        if (n4 >= 0) {\n            n5 = year + n4 / this.iMax;\n            n6 = n4 % this.iMax + 1;\n        }\n        else {\n            n5 = year + n4 / this.iMax - 1;\n            int iMax = Math.abs(n4) % this.iMax;\n            if (iMax == 0) {\n                iMax = this.iMax;\n            }\n            n6 = this.iMax - iMax + 1;\n            if (n6 == 1) {\n                ++n5;\n            }\n        }\n        int dayOfMonth = this.iChronology.getDayOfMonth(n, year, monthOfYear);\n        final int daysInYearMonth = this.iChronology.getDaysInYearMonth(n5, n6);\n        if (dayOfMonth > daysInYearMonth) {\n            dayOfMonth = daysInYearMonth;\n        }\n        return this.iChronology.getYearMonthDayMillis(n5, n6, dayOfMonth) + n3;\n    }\n    \n    public long add(final long n, final long n2) {\n        final int n3 = (int)n2;\n        if (n3 == n2) {\n            return this.add(n, n3);\n        }\n        final long n4 = this.iChronology.getMillisOfDay(n);\n        final int year = this.iChronology.getYear(n);\n        final int monthOfYear = this.iChronology.getMonthOfYear(n, year);\n        final long n5 = monthOfYear - 1 + n2;\n        long n6;\n        long n7;\n        if (n5 >= 0L) {\n            n6 = year + n5 / this.iMax;\n            n7 = n5 % this.iMax + 1L;\n        }\n        else {\n            n6 = year + n5 / this.iMax - 1L;\n            int iMax = (int)(Math.abs(n5) % this.iMax);\n            if (iMax == 0) {\n                iMax = this.iMax;\n            }\n            n7 = this.iMax - iMax + 1;\n            if (n7 == 1L) {\n                ++n6;\n            }\n        }\n        if (n6 < this.iChronology.getMinYear() || n6 > this.iChronology.getMaxYear()) {\n            throw new IllegalArgumentException(\"Magnitude of add amount is too large: \" + n2);\n        }\n        final int n8 = (int)n6;\n        final int n9 = (int)n7;\n        int dayOfMonth = this.iChronology.getDayOfMonth(n, year, monthOfYear);\n        final int daysInYearMonth = this.iChronology.getDaysInYearMonth(n8, n9);\n        if (dayOfMonth > daysInYearMonth) {\n            dayOfMonth = daysInYearMonth;\n        }\n        return this.iChronology.getYearMonthDayMillis(n8, n9, dayOfMonth) + n4;\n    }\n    \n    public int[] add(final ReadablePartial readablePartial, final int n, final int[] array, final int n2) {\n        if (n2 == 0) {\n            return array;\n        }\n        if (readablePartial.size() > 0 && readablePartial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && n == 0) {\n            return this.set(readablePartial, 0, array, (readablePartial.getValue(0) - 1 + n2 % 12 + 12) % 12 + 1);\n        }\n        if (DateTimeUtils.isContiguous(readablePartial)) {\n            long set = 0L;\n            for (int i = 0; i < readablePartial.size(); ++i) {\n                set = readablePartial.getFieldType(i).getField(this.iChronology).set(set, array[i]);\n            }\n            return this.iChronology.get(readablePartial, this.add(set, n2));\n        }\n        return super.add(readablePartial, n, array, n2);\n    }\n    \n    public long addWrapField(final long n, final int n2) {\n        return this.set(n, FieldUtils.getWrappedValue(this.get(n), n2, 1, this.iMax));\n    }\n    \n    public long getDifferenceAsLong(final long n, long set) {\n        if (n < set) {\n            return -this.getDifference(set, n);\n        }\n        final int year = this.iChronology.getYear(n);\n        final int monthOfYear = this.iChronology.getMonthOfYear(n, year);\n        final int year2 = this.iChronology.getYear(set);\n        final int monthOfYear2 = this.iChronology.getMonthOfYear(set, year2);\n        long n2 = (year - year2) * this.iMax + monthOfYear - monthOfYear2;\n        final int dayOfMonth = this.iChronology.getDayOfMonth(n, year, monthOfYear);\n        if (dayOfMonth == this.iChronology.getDaysInYearMonth(year, monthOfYear) && this.iChronology.getDayOfMonth(set, year2, monthOfYear2) > dayOfMonth) {\n            set = this.iChronology.dayOfMonth().set(set, dayOfMonth);\n        }\n        if (n - this.iChronology.getYearMonthMillis(year, monthOfYear) < set - this.iChronology.getYearMonthMillis(year2, monthOfYear2)) {\n            --n2;\n        }\n        return n2;\n    }\n    \n    public long set(final long n, final int n2) {\n        FieldUtils.verifyValueBounds(this, n2, 1, this.iMax);\n        final int year = this.iChronology.getYear(n);\n        int dayOfMonth = this.iChronology.getDayOfMonth(n, year);\n        final int daysInYearMonth = this.iChronology.getDaysInYearMonth(year, n2);\n        if (dayOfMonth > daysInYearMonth) {\n            dayOfMonth = daysInYearMonth;\n        }\n        return this.iChronology.getYearMonthDayMillis(year, n2, dayOfMonth) + this.iChronology.getMillisOfDay(n);\n    }\n    \n    public DurationField getRangeDurationField() {\n        return this.iChronology.years();\n    }\n    \n    public boolean isLeap(final long n) {\n        final int year = this.iChronology.getYear(n);\n        return this.iChronology.isLeapYear(year) && this.iChronology.getMonthOfYear(n, year) == this.iLeapMonth;\n    }\n    \n    public int getLeapAmount(final long n) {\n        return this.isLeap(n) ? 1 : 0;\n    }\n    \n    public DurationField getLeapDurationField() {\n        return this.iChronology.days();\n    }\n    \n    public int getMinimumValue() {\n        return 1;\n    }\n    \n    public int getMaximumValue() {\n        return this.iMax;\n    }\n    \n    public long roundFloor(final long n) {\n        final int year = this.iChronology.getYear(n);\n        return this.iChronology.getYearMonthMillis(year, this.iChronology.getMonthOfYear(n, year));\n    }\n    \n    public long remainder(final long n) {\n        return n - this.roundFloor(n);\n    }\n    \n    private Object readResolve() {\n        return this.iChronology.monthOfYear();\n    }\n}\n"
    },
    {
        "project_name": "joda",
        "class": "BaseSingleFieldPeriod",
        "fqdn": "org.joda.time.base",
        "source_code": "package org.joda.time.base;\n\nimport java.io.*;\nimport org.joda.time.chrono.*;\nimport org.joda.time.field.*;\nimport org.joda.time.*;\n\npublic abstract class BaseSingleFieldPeriod implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable\n{\n    private static final long serialVersionUID = 9386874258972L;\n    private static final long START_1972 = 63072000000L;\n    private volatile int iPeriod;\n    \n    protected static int between(final ReadableInstant readableInstant, final ReadableInstant readableInstant2, final DurationFieldType durationFieldType) {\n        if (readableInstant == null || readableInstant2 == null) {\n            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n        }\n        return durationFieldType.getField(DateTimeUtils.getInstantChronology(readableInstant)).getDifference(readableInstant2.getMillis(), readableInstant.getMillis());\n    }\n    \n    protected static int between(final ReadablePartial readablePartial, final ReadablePartial readablePartial2, final ReadablePeriod readablePeriod) {\n        if (readablePartial == null || readablePartial2 == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (readablePartial.size() != readablePartial2.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0; i < readablePartial.size(); ++i) {\n            if (readablePartial.getFieldType(i) != readablePartial2.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (!DateTimeUtils.isContiguous(readablePartial)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        final Chronology withUTC = DateTimeUtils.getChronology(readablePartial.getChronology()).withUTC();\n        return withUTC.get(readablePeriod, withUTC.set(readablePartial, 63072000000L), withUTC.set(readablePartial2, 63072000000L))[0];\n    }\n    \n    protected static int standardPeriodIn(final ReadablePeriod readablePeriod, final long n) {\n        if (readablePeriod == null) {\n            return 0;\n        }\n        final ISOChronology instanceUTC = ISOChronology.getInstanceUTC();\n        long safeAdd = 0L;\n        for (int i = 0; i < readablePeriod.size(); ++i) {\n            final int value = readablePeriod.getValue(i);\n            if (value != 0) {\n                final DurationField field = readablePeriod.getFieldType(i).getField(instanceUTC);\n                if (!field.isPrecise()) {\n                    throw new IllegalArgumentException(\"Cannot convert period to duration as \" + field.getName() + \" is not precise in the period \" + readablePeriod);\n                }\n                safeAdd = FieldUtils.safeAdd(safeAdd, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n            }\n        }\n        return FieldUtils.safeToInt(safeAdd / n);\n    }\n    \n    protected BaseSingleFieldPeriod(final int iPeriod) {\n        this.iPeriod = iPeriod;\n    }\n    \n    protected int getValue() {\n        return this.iPeriod;\n    }\n    \n    protected void setValue(final int iPeriod) {\n        this.iPeriod = iPeriod;\n    }\n    \n    public abstract DurationFieldType getFieldType();\n    \n    public abstract PeriodType getPeriodType();\n    \n    public int size() {\n        return 1;\n    }\n    \n    public DurationFieldType getFieldType(final int n) {\n        if (n != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(n));\n        }\n        return this.getFieldType();\n    }\n    \n    public int getValue(final int n) {\n        if (n != 0) {\n            throw new IndexOutOfBoundsException(String.valueOf(n));\n        }\n        return this.getValue();\n    }\n    \n    public int get(final DurationFieldType durationFieldType) {\n        if (durationFieldType == this.getFieldType()) {\n            return this.getValue();\n        }\n        return 0;\n    }\n    \n    public boolean isSupported(final DurationFieldType durationFieldType) {\n        return durationFieldType == this.getFieldType();\n    }\n    \n    public Period toPeriod() {\n        return Period.ZERO.withFields(this);\n    }\n    \n    public MutablePeriod toMutablePeriod() {\n        final MutablePeriod mutablePeriod = new MutablePeriod();\n        mutablePeriod.add(this);\n        return mutablePeriod;\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof ReadablePeriod)) {\n            return false;\n        }\n        final ReadablePeriod readablePeriod = (ReadablePeriod)o;\n        return readablePeriod.getPeriodType() == this.getPeriodType() && readablePeriod.getValue(0) == this.getValue();\n    }\n    \n    public int hashCode() {\n        return 27 * (27 * 17 + this.getValue()) + this.getFieldType().hashCode();\n    }\n    \n    public int compareTo(final BaseSingleFieldPeriod baseSingleFieldPeriod) {\n        if (baseSingleFieldPeriod.getClass() != this.getClass()) {\n            throw new ClassCastException(this.getClass() + \" cannot be compared to \" + baseSingleFieldPeriod.getClass());\n        }\n        final int value = baseSingleFieldPeriod.getValue();\n        final int value2 = this.getValue();\n        if (value2 > value) {\n            return 1;\n        }\n        if (value2 < value) {\n            return -1;\n        }\n        return 0;\n    }\n}\n"
    },
    {
        "project_name": "83_xbus",
        "class": "XBUSClassLoader",
        "fqdn": "net.sf.xbus.base.core.reflection",
        "source_code": "package net.sf.xbus.base.core.reflection;\n\nimport net.sf.xbus.base.core.*;\nimport net.sf.xbus.base.core.trace.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\n\npublic class XBUSClassLoader extends URLClassLoader\n{\n    private static XBUSClassLoader mClassLoader;\n    private static final Object classLock;\n    \n    private XBUSClassLoader(final URL[] urlArray, final ClassLoader parent) {\n        super(urlArray, parent);\n    }\n    \n    public static XBUSClassLoader getInstance(final ClassLoader parent) {\n        return createClassLoader(parent);\n    }\n    \n    private static XBUSClassLoader createClassLoader(final ClassLoader parent) {\n        synchronized (XBUSClassLoader.classLock) {\n            if (XBUSClassLoader.mClassLoader == null) {\n                if (Constants.XBUS_HOME == null) {\n                    Trace.error(\"XBUS_HOME has not been set!\");\n                    System.exit(1);\n                }\n                final Vector urls = new Vector();\n                addUrls(urls, Constants.XBUS_HOME + \"/lib\");\n                addUrls(urls, Constants.XBUS_HOME + \"/lib/runtime\");\n                addUrls(urls, Constants.XBUS_HOME + \"/plugin/lib\");\n                addUrls(urls, Constants.XBUS_HOME + \"/test/lib\");\n                final URL[] urlArray = new URL[urls.size()];\n                for (int i = 0; i < urls.size(); ++i) {\n                    urlArray[i] = urls.elementAt(i);\n                }\n                XBUSClassLoader.mClassLoader = new XBUSClassLoader(urlArray, parent);\n            }\n        }\n        return XBUSClassLoader.mClassLoader;\n    }\n    \n    private static void addUrls(final Vector urls, final String dirName) {\n        final File libPath = new File(dirName);\n        final File[] jars = libPath.listFiles();\n        for (int i = 0; jars != null && i < jars.length; ++i) {\n            if (jars[i].isFile()) {\n                if (!jars[i].getName().endsWith(\"jar\")) {\n                    if (!jars[i].getName().endsWith(\"zip\")) {\n                        continue;\n                    }\n                }\n                try {\n                    urls.add(jars[i].toURL());\n                }\n                catch (MalformedURLException e) {\n                    Trace.error(e);\n                    System.exit(1);\n                }\n            }\n        }\n    }\n    \n    static {\n        XBUSClassLoader.mClassLoader = null;\n        classLock = XBUSClassLoader.class;\n    }\n}\n"
    },
    {
        "project_name": "83_xbus",
        "class": "MessageHandler",
        "fqdn": "net.sf.xbus.base.core",
        "source_code": "package net.sf.xbus.base.core;\n\nimport net.sf.xbus.base.core.trace.*;\nimport net.sf.xbus.base.core.strings.*;\nimport java.io.*;\nimport java.util.*;\nimport net.sf.xbus.base.core.config.*;\n\npublic class MessageHandler\n{\n    private static Hashtable mInstances;\n    private static final Object classLock;\n    private Hashtable mMessages;\n    \n    public String getMessage(final String key, final List params) {\n        String messageText = null;\n        messageText = this.getMessageOptional(key, params);\n        if (messageText == null) {\n            messageText = \"Key: \" + key + \" not found in message file\";\n            Trace.error(messageText);\n        }\n        return messageText;\n    }\n    \n    public String getMessageOptional(final String key, final List params) {\n        String messageText = null;\n        if (this.mMessages == null) {\n            return null;\n        }\n        messageText = this.mMessages.get(key);\n        if (messageText == null) {\n            return null;\n        }\n        int counter = 1;\n        if (params != null) {\n            String paramText = null;\n            Object paramObject = null;\n            final Iterator it = params.iterator();\n            while (it.hasNext()) {\n                paramObject = it.next();\n                if (paramObject != null) {\n                    paramText = paramObject.toString();\n                }\n                else {\n                    paramText = \"<null>\";\n                }\n                final String paramCounter = \"$\" + counter + \"$\";\n                if (messageText.indexOf(paramCounter) >= 0) {\n                    messageText = XStringSupport.replaceAll(messageText, paramCounter, paramText);\n                    ++counter;\n                }\n            }\n        }\n        return messageText;\n    }\n    \n    public static MessageHandler getInstance(final String basename) {\n        synchronized (MessageHandler.classLock) {\n            MessageHandler instance = MessageHandler.mInstances.get(basename);\n            if (instance == null) {\n                instance = new MessageHandler(basename);\n                MessageHandler.mInstances.put(basename, instance);\n            }\n            return instance;\n        }\n    }\n    \n    private MessageHandler(final String basename) {\n        this.mMessages = null;\n        this.mMessages = new Hashtable();\n        this.addMessages(basename, Constants.XBUS_ETC);\n        this.addMessages(basename, Constants.XBUS_PLUGIN_ETC);\n    }\n    \n    private void addMessages(final String basename, final String dir) {\n        final Locale locale = Locale.ENGLISH;\n        final String postfix = \"_\" + locale.toString() + \".properties\";\n        final File dirFile = new File(dir);\n        final String[] messagesFiles = dirFile.list(new MessagesFilter(basename, postfix));\n        for (int i = 0; messagesFiles != null && i < messagesFiles.length; ++i) {\n            final Properties newProps = new Properties();\n            try {\n                final FileInputStream instream = new FileInputStream(dir + messagesFiles[i]);\n                newProps.load(instream);\n                instream.close();\n            }\n            catch (FileNotFoundException e) {\n                System.out.println(\"Cannot find messagefile\");\n                System.exit(1);\n            }\n            catch (IOException e2) {\n                System.out.println(\"Cannot find messagefile\");\n                System.exit(1);\n            }\n            String key = null;\n            final Enumeration keys = newProps.keys();\n            while (keys.hasMoreElements()) {\n                key = keys.nextElement();\n                this.mMessages.put(key, ((Hashtable<K, Object>)newProps).get(key));\n            }\n        }\n    }\n    \n    static {\n        MessageHandler.mInstances = new Hashtable();\n        classLock = Configuration.class;\n    }\n    \n    private static class MessagesFilter implements FilenameFilter\n    {\n        private String mPrefix;\n        private String mPostfix;\n        \n        public MessagesFilter(final String prefix, final String postfix) {\n            this.mPrefix = null;\n            this.mPostfix = null;\n            this.mPrefix = prefix;\n            this.mPostfix = postfix;\n        }\n        \n        @Override\n        public boolean accept(final File dir, final String filename) {\n            return filename.startsWith(this.mPrefix) && filename.endsWith(this.mPostfix);\n        }\n    }\n}\n"
    },
    {
        "project_name": "55_lavalamp",
        "class": "TimeOfDay",
        "fqdn": "net.sf.lavalamp.device",
        "source_code": "package net.sf.lavalamp.device;\n\npublic class TimeOfDay implements Comparable<TimeOfDay>\n{\n    private Integer hours;\n    private Integer minutes;\n    \n    public TimeOfDay(final int hours, final int minutes) {\n        this.hours = hours;\n        this.minutes = minutes;\n    }\n    \n    public TimeOfDay(final String time) {\n        this.hours = new Integer(time.substring(0, 2));\n        this.minutes = new Integer(time.substring(3, 5));\n    }\n    \n    @Override\n    public int compareTo(final TimeOfDay that) {\n        final int hourComparison = this.hours.compareTo(that.hours);\n        if (hourComparison != 0) {\n            return hourComparison;\n        }\n        return this.minutes.compareTo(that.minutes);\n    }\n    \n    public Integer getHours() {\n        return this.hours;\n    }\n    \n    public Integer getMinutes() {\n        return this.minutes;\n    }\n    \n    @Override\n    public String toString() {\n        return this.hours + \":\" + this.minutes;\n    }\n    \n    @Override\n    public int hashCode() {\n        return new Integer(100 * this.hours + this.minutes).hashCode();\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final TimeOfDay other = (TimeOfDay)obj;\n        return this.hours.equals(other.hours) && this.minutes.equals(other.minutes);\n    }\n}\n"
    },
    {
        "project_name": "94_jclo",
        "class": "JCLO",
        "fqdn": "edu.mscd.cs.jclo",
        "source_code": "package edu.mscd.cs.jclo;\n\nimport java.util.*;\nimport java.lang.reflect.*;\n\npublic class JCLO\n{\n    private Field[] fields;\n    private Object object;\n    private boolean doubleDashes;\n    private boolean hasEquals;\n    private String prefix;\n    private String[][] aliases;\n    \n    public JCLO(final Object object) {\n        this(null, object, null);\n    }\n    \n    public JCLO(final Object object, final String[][] aliases) {\n        this(null, object, aliases);\n    }\n    \n    public JCLO(final String prefix, final Object object) {\n        this(prefix, object, null);\n    }\n    \n    public JCLO(final String prefix, final Object object, final String[][] aliases) {\n        this.prefix = \"\";\n        this.object = object;\n        this.prefix = prefix;\n        this.aliases = aliases;\n        this.fields = object.getClass().getDeclaredFields();\n        for (int i = 0; i < this.fields.length; ++i) {\n            this.fields[i].setAccessible(true);\n        }\n    }\n    \n    private Object getObject(final Field f) {\n        try {\n            return f.get(this.object);\n        }\n        catch (IllegalAccessException iae) {\n            iae.printStackTrace();\n            System.exit(1);\n            return null;\n        }\n    }\n    \n    private Field getField(String key) {\n        final Field f = null;\n        if (this.prefix != null) {\n            key = this.prefix + key;\n        }\n        for (int i = 0; i < this.fields.length; ++i) {\n            final String name = this.fields[i].getName();\n            if (name.equals(key)) {\n                return this.fields[i];\n            }\n        }\n        return null;\n    }\n    \n    public Object getValue(final String key) {\n        final Field f = this.getField(key);\n        if (f == null) {\n            System.out.println(\"Field not found: \" + key);\n            return null;\n        }\n        return this.getObject(f);\n    }\n    \n    private void setObject(final Field f, final Object o) {\n        try {\n            f.set(this.object, o);\n        }\n        catch (IllegalAccessException iae) {\n            iae.printStackTrace();\n        }\n    }\n    \n    private String getArrayType(final Class type) {\n        return type.getComponentType().toString().replaceFirst(\"class.*\\\\.\", \"\");\n    }\n    \n    @Override\n    public String toString() {\n        String r = \"\";\n        boolean first = true;\n        for (int i = 0; i < this.fields.length; ++i) {\n            final Field field = this.fields[i];\n            final String key = field.getName();\n            final Class type = field.getType();\n            final Object object = this.getObject(field);\n            if (!first) {\n                r += \"\\n\";\n            }\n            first = false;\n            if (type.isArray()) {\n                r = r + this.getArrayType(type) + \"[]\" + \": \" + key + \" = \";\n                r += Arrays.toString((Object[])object);\n            }\n            else {\n                r = r + type.toString().replaceFirst(\"class java.lang.\", \"\") + \": \" + key + \" = \" + object;\n            }\n        }\n        return r;\n    }\n    \n    private String getUsageType(final Class type) {\n        if (type.getName().equals(\"boolean\")) {\n            return this.doubleDashes ? \"[=boolean]\" : \"\";\n        }\n        if (type.isArray()) {\n            return (this.doubleDashes ? \"=\" : \" \") + this.getArrayType(type) + \"...\";\n        }\n        return (this.doubleDashes ? \"=\" : \" \") + type.getName().replaceFirst(\"java.lang.\", \"\");\n    }\n    \n    public String usage() {\n        final boolean additional = false;\n        final String[] a = new String[this.fields.length];\n        int count = 0;\n        for (int i = 0; i < this.fields.length; ++i) {\n            final Field field = this.fields[i];\n            String key = field.getName();\n            final Class type = field.getType();\n            if (!key.equals(\"additional\")) {\n                if (this.prefix != null) {\n                    if (!key.startsWith(this.prefix)) {\n                        continue;\n                    }\n                    key = key.replaceFirst(\"^\" + this.prefix, \"\");\n                }\n                if (!Modifier.isFinal(field.getModifiers())) {\n                    key = key.replaceFirst(\"^_([0-9])\", \"$1\");\n                    key = key.replaceAll(\"__\", \"-\");\n                    key = key.replaceAll(\"_\\\\$\", \".\");\n                    a[count++] = (this.doubleDashes ? \"--\" : \"-\") + key + this.getUsageType(type) + \"\\n\";\n                }\n            }\n        }\n        String r = \"\";\n        Arrays.sort(a, 0, count);\n        for (int j = 0; j < a.length; ++j) {\n            if (a[j] != null) {\n                r += a[j];\n            }\n        }\n        return r;\n    }\n    \n    private void parseAdditional(final String[] args, int i) {\n        final int number = args.length - i;\n        final String[] add = new String[number];\n        for (int j = 0; j < number; ++j, ++i) {\n            add[j] = args[i];\n        }\n        final Field f = this.getField(\"additional\");\n        if (f != null) {\n            this.setObject(f, add);\n        }\n        else {\n            System.err.println(\"No varible 'additional' found\");\n        }\n    }\n    \n    private Object addToArray(final Field field, final Object o) {\n        final Object orig = this.getObject(field);\n        final Class componentType = field.getType().getComponentType();\n        Object ret;\n        if (orig == null) {\n            ret = Array.newInstance(componentType, 1);\n            Array.set(ret, 0, o);\n        }\n        else {\n            final int length = Array.getLength(orig);\n            ret = Array.newInstance(componentType, length + 1);\n            int j;\n            for (j = 0; j < length; ++j) {\n                Array.set(ret, j, Array.get(orig, j));\n            }\n            Array.set(ret, j, o);\n        }\n        return ret;\n    }\n    \n    private String getKey(String arg) {\n        if (this.hasEquals) {\n            arg = arg.replaceFirst(\"=.*\", \"\");\n        }\n        if (this.doubleDashes) {\n            arg = arg.substring(2);\n        }\n        else {\n            arg = arg.substring(1);\n        }\n        arg = arg.replaceAll(\"^([0-9])\", \"_$1\");\n        arg = arg.replaceAll(\"-\", \"__\");\n        arg = arg.replaceAll(\"\\\\.\", \"_\\\\$\");\n        if (this.aliases != null) {\n            for (int i = 0; i < this.aliases.length; ++i) {\n                if (this.aliases[i][0].equals(arg)) {\n                    arg = this.aliases[i][1];\n                }\n            }\n        }\n        return arg;\n    }\n    \n    private String getBooleanValue(String arg) {\n        if (!this.hasEquals) {\n            return \"true\";\n        }\n        arg = arg.replaceFirst(\"[^=]*=\", \"\");\n        if (arg.equalsIgnoreCase(\"true\") || arg.equalsIgnoreCase(\"yes\")) {\n            return \"true\";\n        }\n        return \"false\";\n    }\n    \n    private Object makeObject(final String type, final String val) {\n        if (type.equals(\"boolean\")) {\n            return new Boolean(val);\n        }\n        if (type.equals(\"byte\")) {\n            return new Byte(val);\n        }\n        if (type.equals(\"short\")) {\n            return new Short(val);\n        }\n        if (type.equals(\"int\")) {\n            return new Integer(val);\n        }\n        if (type.equals(\"float\")) {\n            return new Float(val);\n        }\n        if (type.equals(\"double\")) {\n            return new Double(val);\n        }\n        if (type.equals(\"long\")) {\n            return new Long(val);\n        }\n        if (type.equals(\"java.lang.String\")) {\n            return val;\n        }\n        if (type.equals(\"char\")) {\n            return new Character(val.charAt(0));\n        }\n        return null;\n    }\n    \n    private String getEqualsValue(final String arg) {\n        if (arg.indexOf(\"=\") == -1) {\n            throw new IllegalArgumentException(\"'\" + arg + \"' requires '=VALUE'\");\n        }\n        return arg.replaceFirst(\"[^=]*=\", \"\");\n    }\n    \n    public void parse(final String[] args) {\n        for (int i = 0; i < args.length; ++i) {\n            if (!args[i].startsWith(\"-\")) {\n                this.parseAdditional(args, i);\n                return;\n            }\n            this.doubleDashes = args[i].startsWith(\"--\");\n            this.hasEquals = (args[i].indexOf(\"=\") != -1);\n            final String key = this.getKey(args[i]);\n            final Field field = this.getField(key);\n            if (field == null) {\n                throw new IllegalArgumentException(\"No such option: \\\"\" + key + \"\\\"\");\n            }\n            final Class type = field.getType();\n            String name = type.getName();\n            if (type.isArray()) {\n                name = type.getComponentType().getName();\n            }\n            String value = null;\n            if (name.equals(\"boolean\")) {\n                value = this.getBooleanValue(args[i]);\n            }\n            else if (this.doubleDashes || this.hasEquals) {\n                value = this.getEqualsValue(args[i]);\n            }\n            else {\n                value = args[++i];\n            }\n            Object o = this.makeObject(name, value);\n            if (o != null) {\n                if (type.isArray()) {\n                    o = this.addToArray(field, o);\n                }\n                this.setObject(field, o);\n            }\n        }\n    }\n    \n    public boolean getBoolean(final String key) {\n        return (boolean)this.getValue(key);\n    }\n    \n    public byte getByte(final String key) {\n        return (byte)this.getValue(key);\n    }\n    \n    public char getChar(final String key) {\n        return (char)this.getValue(key);\n    }\n    \n    public short getShort(final String key) {\n        return (short)this.getValue(key);\n    }\n    \n    public int getInt(final String key) {\n        return (int)this.getValue(key);\n    }\n    \n    public float getFloat(final String key) {\n        return (float)this.getValue(key);\n    }\n    \n    public double getDouble(final String key) {\n        return (double)this.getValue(key);\n    }\n    \n    public long getLong(final String key) {\n        return (long)this.getValue(key);\n    }\n    \n    public String getString(final String key) {\n        return (String)this.getValue(key);\n    }\n    \n    public byte[] getBytes(final String key) {\n        return (byte[])this.getValue(key);\n    }\n    \n    public char[] getChars(final String key) {\n        return (char[])this.getValue(key);\n    }\n    \n    public short[] getShorts(final String key) {\n        return (short[])this.getValue(key);\n    }\n    \n    public int[] getInts(final String key) {\n        return (int[])this.getValue(key);\n    }\n    \n    public float[] getFloats(final String key) {\n        return (float[])this.getValue(key);\n    }\n    \n    public double[] getDoubles(final String key) {\n        return (double[])this.getValue(key);\n    }\n    \n    public long[] getLongs(final String key) {\n        return (long[])this.getValue(key);\n    }\n    \n    public String[] getStrings(final String key) {\n        return (String[])this.getValue(key);\n    }\n    \n    public static void main(final String[] args) {\n        if (args.length == 1 && args[0].equalsIgnoreCase(\"--version\")) {\n            System.out.println(\"1.3.4\");\n        }\n    }\n}\n"
    },
    {
        "project_name": "compiler",
        "class": "ExploitAssigns",
        "fqdn": "com.google.javascript.jscomp",
        "source_code": "/*\n * Copyright 2006 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\n/**\n * Tries to chain assignments together.\n *\n * @author nicksantos@google.com (Nick Santos)\n * @author acleung@google.com (Alan Leung)\n *\n */\npublic class ExploitAssigns extends AbstractPeepholeOptimization {\n\n  @Override\n  public Node optimizeSubtree(Node subtree) {\n    for (Node child = subtree.getFirstChild(); child != null;) {\n      Node next = child.getNext();\n      if (NodeUtil.isExprAssign(child)) {\n        collapseAssign(child.getFirstChild(), child, subtree);\n      }\n      child = next;\n    }\n    return subtree;\n  }\n\n  /**\n   * Try to collapse the given assign into subsequent expressions.\n   */\n  private void collapseAssign(Node assign, Node expr,\n      Node exprParent) {\n    Node leftValue = assign.getFirstChild();\n    Node rightValue = leftValue.getNext();\n    if (isCollapsibleValue(leftValue, true) &&\n        collapseAssignEqualTo(expr, exprParent, leftValue)) {\n      reportCodeChange();\n    } else if (isCollapsibleValue(rightValue, false) &&\n        collapseAssignEqualTo(expr, exprParent, rightValue)) {\n      reportCodeChange();\n    } else if (rightValue.isAssign()) {\n      // Recursively deal with nested assigns.\n      collapseAssign(rightValue, expr, exprParent);\n    }\n  }\n\n  /**\n   * Determines whether we know enough about the given value to be able\n   * to collapse it into subsequent expressions.\n   *\n   * For example, we can collapse booleans and variable names:\n   * <code>\n   * x = 3; y = x; // y = x = 3;\n   * a = true; b = true; // b = a = true;\n   * <code>\n   * But we won't try to collapse complex expressions.\n   *\n   * @param value The value node.\n   * @param isLValue Whether it's on the left-hand side of an expr.\n   */\n  private boolean isCollapsibleValue(Node value, boolean isLValue) {\n    switch (value.getType()) {\n      case Token.GETPROP:\n        // Do not collapse GETPROPs on arbitrary objects, because\n        // they may be implemented setter functions, and oftentimes\n        // setter functions fail on native objects. This is OK for \"THIS\"\n        // objects, because we assume that they are non-native.\n        return !isLValue || value.getFirstChild().isThis();\n\n      case Token.NAME:\n        return true;\n\n      default:\n        return NodeUtil.isImmutableValue(value);\n    }\n  }\n\n  /**\n   * Collapse the given assign expression into the expression directly\n   * following it, if possible.\n   *\n   * @param expr The expression that may be moved.\n   * @param exprParent The parent of {@code expr}.\n   * @param value The value of this expression, expressed as a node. Each\n   *     expression may have multiple values, so this function may be called\n   *     multiple times for the same expression. For example,\n   *     <code>\n   *     a = true;\n   *     </code>\n   *     is equal to the name \"a\" and the boolean \"true\".\n   * @return Whether the expression was collapsed successfully.\n   */\n  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n    Node name = node.getFirstChild();\n    if (name.isName()\n        && isNameAssignedTo(name.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @return Whether name is assigned in the expression rooted at node.\n   */\n\n  private boolean isNameAssignedTo(String name, Node node) {\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (isNameAssignedTo(name, c)) {\n        return true;\n      }\n    }\n\n    if (node.isName()) {\n      Node parent = node.getParent();\n      if (parent.isAssign() && parent.getFirstChild() == node) {\n        if (name.equals(node.getString())) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}"
    },
    {
        "project_name": "compiler",
        "class": "ScopedAliases",
        "fqdn": "com.google.javascript.jscomp",
        "source_code": "/*\n * Copyright 2010 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.SourcePosition;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\n\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\npublic class ScopedAliases implements HotSwapCompilerPass {\n  /** Name used to denote an scoped function block used for aliasing. */\n  static final String SCOPING_METHOD_NAME = \"goog.scope\";\n\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n\n  // Errors\n  static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n      \"The call to goog.scope must be alone in a single statement.\");\n\n  static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS =\n      DiagnosticType.error(\n          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n          \"The call to goog.scope must take only a single parameter.  It must\" +\n              \" be an anonymous function that itself takes no parameters.\");\n\n  static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n      \"The body of a goog.scope function cannot reference 'this'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_RETURN\",\n      \"The body of a goog.scope function cannot use 'return'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_THROW\",\n      \"The body of a goog.scope function cannot use 'throw'.\");\n\n  static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n      \"The alias {0} is assigned a value more than once.\");\n\n  static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n      \"The local variable {0} is in a goog.scope and is not an alias.\");\n\n  public ScopedAliases(AbstractCompiler compiler,\n                       @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n                       AliasTransformationHandler transformationHandler) {\n    this.compiler = compiler;\n    this.preprocessorSymbolTable = preprocessorSymbolTable;\n    this.transformationHandler = transformationHandler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }\n\n  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  private interface AliasUsage {\n    public void applyAlias();\n  }\n\n  private class AliasedNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final Node aliasDefinition;\n\n    AliasedNode(Node aliasReference, Node aliasDefinition) {\n      this.aliasReference = aliasReference;\n      this.aliasDefinition = aliasDefinition;\n    }\n\n    @Override\n    public void applyAlias() {\n      aliasReference.getParent().replaceChild(\n          aliasReference, aliasDefinition.cloneTree());\n    }\n  }\n\n  private class AliasedTypeNode implements AliasUsage {\n    private final Node typeReference;\n    private final Node aliasDefinition;\n    private final String aliasName;\n\n    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n        String aliasName) {\n      this.typeReference = typeReference;\n      this.aliasDefinition = aliasDefinition;\n      this.aliasName = aliasName;\n    }\n\n    @Override\n    public void applyAlias() {\n      String typeName = typeReference.getString();\n      String aliasExpanded =\n          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n      Preconditions.checkState(typeName.startsWith(aliasName));\n      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n    }\n  }\n\n\n  private class Traversal implements NodeTraversal.ScopedCallback {\n    // The job of this class is to collect these three data sets.\n\n    // The order of this list determines the order that aliases are applied.\n    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();\n\n    private final List<Node> scopeCalls = Lists.newArrayList();\n\n    private final List<AliasUsage> aliasUsages = Lists.newArrayList();\n\n    // This map is temporary and cleared for each scope.\n    private final Map<String, Var> aliases = Maps.newHashMap();\n\n    // Suppose you create an alias.\n    // var x = goog.x;\n    // As a side-effect, this means you can shadow the namespace 'goog'\n    // in inner scopes. When we inline the namespaces, we have to rename\n    // these shadows.\n    //\n    // Fortunately, we already have a name uniquifier that runs during tree\n    // normalization (before optimizations). We run it here on a limited\n    // set of variables, but only as a last resort (because this will screw\n    // up warning messages downstream).\n    private final Set<String> forbiddenLocals = Sets.newHashSet();\n    private boolean hasNamespaceShadows = false;\n\n    private boolean hasErrors = false;\n\n    private AliasTransformation transformation = null;\n\n    Collection<Node> getAliasDefinitionsInOrder() {\n      return aliasDefinitionsInOrder;\n    }\n\n    private List<AliasUsage> getAliasUsages() {\n      return aliasUsages;\n    }\n\n    List<Node> getScopeCalls() {\n      return scopeCalls;\n    }\n\n    boolean hasErrors() {\n      return hasErrors;\n    }\n\n    private boolean isCallToScopeMethod(Node n) {\n      return n.isCall() &&\n          SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n    }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n      }\n\n      if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n      }\n    }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isFunction() && t.inGlobalScope()) {\n        // Do not traverse in to functions except for goog.scope functions.\n        if (parent == null || !isCallToScopeMethod(parent)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n      Node testNode = n;\n      Node next = null;\n      for (; next != null || testNode.isScript();) {\n        next = testNode.getNext();\n        testNode = testNode.getParent();\n      }\n\n      int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();\n      int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();\n      SourcePosition<AliasTransformation> pos =\n          new SourcePosition<AliasTransformation>() {};\n      pos.setPositionInformation(\n          n.getLineno(), n.getCharno(), endLine, endChar);\n      return pos;\n    }\n\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n      compiler.report(t.makeError(n, error, arguments));\n      hasErrors = true;\n    }\n\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        if (parent.isVar() &&\n            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n\n          int rootIndex = qualifiedName.indexOf(\".\");\n          if (rootIndex != -1) {\n            String qNameRoot = qualifiedName.substring(0, rootIndex);\n            if (!aliases.containsKey(qNameRoot)) {\n              forbiddenLocals.add(qNameRoot);\n            }\n          }\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n\n    /** Find out if there are any local shadows of namespaces. */\n    private void findNamespaceShadows(NodeTraversal t) {\n      if (hasNamespaceShadows) {\n        return;\n      }\n\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        if (forbiddenLocals.contains(v.getName())) {\n          hasNamespaceShadows = true;\n          return;\n        }\n      }\n    }\n\n    /**\n     * Rename any local shadows of namespaces.\n     * This should be a very rare occurrence, so only do this traversal\n     * if we know that we need it.\n     */\n    private void renameNamespaceShadows(NodeTraversal t) {\n      if (hasNamespaceShadows) {\n        MakeDeclaredNamesUnique.Renamer renamer =\n            new MakeDeclaredNamesUnique.WhitelistedRenamer(\n                new MakeDeclaredNamesUnique.ContextualRenamer(),\n                forbiddenLocals);\n        for (String s : forbiddenLocals) {\n          renamer.addDeclaredName(s);\n        }\n        MakeDeclaredNamesUnique uniquifier =\n            new MakeDeclaredNamesUnique(renamer);\n        NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier);\n      }\n    }\n\n    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n      if (preprocessorSymbolTable != null) {\n        preprocessorSymbolTable.addReference(n.getFirstChild());\n      }\n      if (!parent.isExprResult()) {\n        report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n      }\n      if (n.getChildCount() != 2) {\n        // The goog.scope call should have exactly 1 parameter.  The first\n        // child is the \"goog.scope\" and the second should be the parameter.\n        report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n      } else {\n        Node anonymousFnNode = n.getChildAtIndex(1);\n        if (!anonymousFnNode.isFunction() ||\n            NodeUtil.getFunctionName(anonymousFnNode) != null ||\n            NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n          report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n        } else {\n          scopeCalls.add(n);\n        }\n      }\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }\n\n    private void fixTypeNode(Node typeNode) {\n      if (typeNode.isString()) {\n        String name = typeNode.getString();\n        int endIndex = name.indexOf('.');\n        if (endIndex == -1) {\n          endIndex = name.length();\n        }\n        String baseName = name.substring(0, endIndex);\n        Var aliasVar = aliases.get(baseName);\n        if (aliasVar != null) {\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n        }\n      }\n\n      for (Node child = typeNode.getFirstChild(); child != null;\n           child = child.getNext()) {\n        fixTypeNode(child);\n      }\n    }\n  }\n}\n"
    },
    {
        "project_name": "100_jgaap",
        "class": "jgaapGUI",
        "fqdn": "",
        "source_code": "import java.awt.*;\nimport javax.swing.*;\nimport java.awt.event.*;\nimport java.io.*;\n\npublic class jgaapGUI extends JPanel implements ActionListener\n{\n    guiDriver driver;\n    private JTextField currentAuthor;\n    private ButtonGroup buttonGroup1;\n    private ButtonGroup buttonGroup2;\n    private JFileChooser chooseFile;\n    private JButton buttonEvSet;\n    private JPanel paneEvProgress;\n    private JLabel labelev;\n    private JProgressBar progressEventSet;\n    private JMenuBar menuBar;\n    private JMenu menuFile;\n    private JMenuItem menuFileExit;\n    private JMenuItem menuFileDemo;\n    private JMenu menuHelp;\n    private JMenuItem menuHelpContents;\n    private JMenuItem menuHelpAbout;\n    private JTabbedPane paneOpts;\n    private JPanel panelAcquire;\n    private JPanel panelDocs;\n    private JLabel labelKnown;\n    private JScrollPane scrollPane1;\n    private JTextArea listKnown;\n    private JLabel labelUnknown;\n    private JScrollPane scrollPane2;\n    private JTextArea listUnknown;\n    private JPanel panelOpts;\n    private JRadioButton radioKnown;\n    private JRadioButton radioUnknown;\n    private JButton buttonLocal;\n    private JPanel panelCanonicize;\n    private JPanel panelCOpts;\n    private JCheckBox[] canonicizers;\n    private JRadioButton[] eventifiers;\n    private ButtonGroup esButtonGroup;\n    private JPanel panelProgress;\n    private JButton buttonCanonicize;\n    private JLabel label1;\n    private JProgressBar progressCanonicize;\n    private JLabel labelCanon;\n    private JPanel panelAnalyze;\n    private JLabel labelStatInf;\n    private JPanel panelMethods;\n    private JRadioButton radioCrossEnt;\n    private JRadioButton radioLZW;\n    private JPanel panelAnalProg;\n    private JButton buttonAnalyze;\n    private JLabel labelAnalProg;\n    private JProgressBar progressAnalysis;\n    private JScrollPane scrollPane3;\n    private JTextArea listResults;\n    private JPanel panelEventSet;\n    private JPanel panelEOpts;\n    private JPanel panelEvProgress;\n    private JButton buttonEventSet;\n    private JLabel labelevSet;\n    \n    public jgaapGUI() {\n        this.driver = new guiDriver();\n        this.initComponents();\n    }\n    \n    private void initComponents() {\n        this.currentAuthor = new JTextField();\n        this.chooseFile = new JFileChooser();\n        this.menuBar = new JMenuBar();\n        this.menuFile = new JMenu();\n        this.menuFileExit = new JMenuItem();\n        this.menuFileDemo = new JMenuItem();\n        this.menuHelp = new JMenu();\n        this.menuHelpContents = new JMenuItem();\n        this.menuHelpAbout = new JMenuItem();\n        this.paneOpts = new JTabbedPane();\n        this.panelAcquire = new JPanel();\n        this.panelDocs = new JPanel();\n        this.labelKnown = new JLabel();\n        this.scrollPane1 = new JScrollPane();\n        this.listKnown = new JTextArea(10, 30);\n        this.labelUnknown = new JLabel();\n        this.scrollPane2 = new JScrollPane();\n        this.listUnknown = new JTextArea(10, 30);\n        this.panelOpts = new JPanel();\n        this.radioKnown = new JRadioButton();\n        this.radioUnknown = new JRadioButton();\n        this.buttonLocal = new JButton();\n        this.panelCanonicize = new JPanel();\n        this.panelCOpts = new JPanel();\n        this.canonicizers = new JCheckBox[3];\n        this.eventifiers = new JRadioButton[2];\n        this.esButtonGroup = new ButtonGroup();\n        this.panelProgress = new JPanel();\n        this.buttonCanonicize = new JButton();\n        this.label1 = new JLabel();\n        this.progressCanonicize = new JProgressBar();\n        this.labelCanon = new JLabel();\n        this.panelAnalyze = new JPanel();\n        this.labelStatInf = new JLabel();\n        this.panelMethods = new JPanel();\n        this.radioCrossEnt = new JRadioButton();\n        this.radioLZW = new JRadioButton();\n        this.panelAnalProg = new JPanel();\n        this.buttonAnalyze = new JButton();\n        this.labelAnalProg = new JLabel();\n        this.progressAnalysis = new JProgressBar();\n        this.scrollPane3 = new JScrollPane();\n        this.listResults = new JTextArea(20, 30);\n        this.buttonEventSet = new JButton();\n        this.paneEvProgress = new JPanel();\n        this.labelevSet = new JLabel();\n        this.progressEventSet = new JProgressBar();\n        this.panelEventSet = new JPanel();\n        this.panelEOpts = new JPanel();\n        this.panelEvProgress = new JPanel();\n        this.setMinimumSize(new Dimension(400, 600));\n        this.setPreferredSize(new Dimension(600, 400));\n        this.setLayout(new BorderLayout());\n        this.menuFile.setText(\"File\");\n        this.menuFileExit.setText(\"Exit\");\n        this.menuFile.add(this.menuFileExit);\n        this.menuFileExit.addActionListener(this);\n        this.menuFileDemo.setText(\"Load Demo\");\n        this.menuFileDemo.setActionCommand(\"demo\");\n        this.menuFileDemo.addActionListener(this);\n        this.menuFile.add(this.menuFileDemo);\n        this.menuBar.add(this.menuFile);\n        this.menuHelp.setText(\"Help\");\n        this.menuHelpContents.setText(\"Contents (F1)\");\n        this.menuHelp.add(this.menuHelpContents);\n        this.menuHelpAbout.setText(\"About\");\n        this.menuHelp.add(this.menuHelpAbout);\n        this.menuBar.add(this.menuHelp);\n        this.add(this.menuBar, \"North\");\n        this.paneOpts.setFont(new Font(\"Garamond\", 0, 14));\n        this.panelAcquire.setLayout(new FlowLayout());\n        this.panelDocs.setLayout(new BoxLayout(this.panelDocs, 1));\n        this.labelKnown.setText(\"Registered Known Documents\");\n        this.labelKnown.setHorizontalAlignment(0);\n        this.labelKnown.setHorizontalTextPosition(0);\n        this.panelDocs.add(this.labelKnown);\n        this.listKnown.setEnabled(false);\n        this.scrollPane1.setViewportView(this.listKnown);\n        this.panelDocs.add(this.scrollPane1);\n        this.labelUnknown.setText(\"Registered Unknown Documents\");\n        this.labelUnknown.setHorizontalAlignment(0);\n        this.labelUnknown.setHorizontalTextPosition(0);\n        this.panelDocs.add(this.labelUnknown);\n        this.listUnknown.setEnabled(false);\n        this.scrollPane2.setViewportView(this.listUnknown);\n        this.panelDocs.add(this.scrollPane2);\n        this.panelAcquire.add(this.panelDocs);\n        this.panelOpts.setLayout(new BoxLayout(this.panelOpts, 1));\n        this.radioUnknown.setText(\"Unknown Author\");\n        this.radioUnknown.setActionCommand(\"unknownauthor\");\n        this.radioUnknown.addActionListener(this);\n        this.panelOpts.add(this.radioUnknown);\n        this.radioKnown.setText(\"Known Author\");\n        this.radioKnown.setActionCommand(\"knownauthor\");\n        this.radioKnown.addActionListener(this);\n        this.radioKnown.setSelected(true);\n        this.panelOpts.add(this.radioKnown);\n        this.panelOpts.add(new JLabel(\"Author:\"));\n        this.panelOpts.add(this.currentAuthor);\n        this.buttonLocal.setText(\"Local Document\");\n        this.panelOpts.add(this.buttonLocal);\n        this.buttonLocal.setActionCommand(\"Import\");\n        this.buttonLocal.addActionListener(this);\n        this.panelAcquire.add(this.panelOpts);\n        this.paneOpts.addTab(\"Acquire\", this.panelAcquire);\n        this.panelCanonicize.setLayout(new BorderLayout());\n        this.panelCOpts.setLayout(new GridLayout(12, 5));\n        (this.canonicizers[0] = new JCheckBox()).setText(\"Smash Case\");\n        this.canonicizers[0].setToolTipText(\"Converts all text to lower case\");\n        this.panelCOpts.add(this.canonicizers[0]);\n        (this.canonicizers[1] = new JCheckBox()).setText(\"Normalize Whitespace\");\n        this.canonicizers[1].setToolTipText(\"Converts all whitespace characters (newline, space and tab) to a single space\");\n        this.panelCOpts.add(this.canonicizers[1]);\n        (this.canonicizers[2] = new JCheckBox()).setText(\"Strip HTML\");\n        this.canonicizers[2].setToolTipText(\"Removes all HTML tags and converts hexidecimal representations to actual character representations\");\n        this.panelCOpts.add(this.canonicizers[2]);\n        this.panelCanonicize.add(this.panelCOpts, \"Center\");\n        this.panelProgress.setLayout(new BoxLayout(this.panelProgress, 0));\n        this.buttonCanonicize.setText(\"Canonicize\");\n        this.buttonCanonicize.addActionListener(this);\n        this.panelProgress.add(this.buttonCanonicize);\n        this.label1.setText(\"  Progress:  \");\n        this.label1.setHorizontalAlignment(0);\n        this.label1.setHorizontalTextPosition(0);\n        this.panelProgress.add(this.label1);\n        this.panelProgress.add(this.progressCanonicize);\n        this.panelCanonicize.add(this.panelProgress, \"South\");\n        this.labelCanon.setText(\"Document Canonicization\");\n        this.labelCanon.setHorizontalAlignment(0);\n        this.panelCanonicize.add(this.labelCanon, \"North\");\n        this.paneOpts.addTab(\"Canonicize\", this.panelCanonicize);\n        this.panelEventSet.setLayout(new BorderLayout());\n        this.panelEOpts.setLayout(new GridLayout(12, 5));\n        (this.eventifiers[0] = new JRadioButton()).setText(\"Individual Characters\");\n        this.eventifiers[0].setActionCommand(\"characters\");\n        this.esButtonGroup.add(this.eventifiers[0]);\n        this.panelEOpts.add(this.eventifiers[0]);\n        (this.eventifiers[1] = new JRadioButton()).setText(\"Entire Words\");\n        this.eventifiers[1].setActionCommand(\"words\");\n        this.esButtonGroup.add(this.eventifiers[1]);\n        this.panelEOpts.add(this.eventifiers[1]);\n        this.panelEventSet.add(this.panelEOpts, \"Center\");\n        this.panelEvProgress.setLayout(new BoxLayout(this.panelEvProgress, 0));\n        this.buttonEventSet.setText(\"Create Event Set\");\n        this.buttonEventSet.setActionCommand(\"CreateEventSet\");\n        this.buttonEventSet.addActionListener(this);\n        this.panelEvProgress.add(this.buttonEventSet);\n        this.labelevSet.setText(\"  Progress:  \");\n        this.labelevSet.setHorizontalAlignment(0);\n        this.labelevSet.setHorizontalTextPosition(0);\n        this.panelEvProgress.add(this.labelevSet);\n        this.panelEvProgress.add(this.progressEventSet);\n        this.panelEventSet.add(this.panelEvProgress, \"South\");\n        this.paneOpts.addTab(\"Event Set\", this.panelEventSet);\n        this.panelAnalyze.setLayout(new BorderLayout());\n        this.labelStatInf.setText(\"Statistical Inference\");\n        this.labelStatInf.setHorizontalAlignment(0);\n        this.panelAnalyze.add(this.labelStatInf, \"North\");\n        this.panelMethods.setLayout(new BoxLayout(this.panelMethods, 1));\n        this.radioCrossEnt.setText(\"Cross Entropy\");\n        this.radioCrossEnt.setActionCommand(\"crossentropy\");\n        this.panelMethods.add(this.radioCrossEnt);\n        this.radioLZW.setText(\"LZW\");\n        this.radioLZW.setActionCommand(\"lzw\");\n        this.panelMethods.add(this.radioLZW);\n        this.panelAnalyze.add(this.panelMethods, \"West\");\n        this.panelAnalProg.setLayout(new BoxLayout(this.panelAnalProg, 0));\n        this.buttonAnalyze.setText(\"Analyze\");\n        this.buttonAnalyze.addActionListener(this);\n        this.panelAnalProg.add(this.buttonAnalyze);\n        this.labelAnalProg.setText(\"  Progress:  \");\n        this.labelAnalProg.setHorizontalAlignment(0);\n        this.labelAnalProg.setHorizontalTextPosition(0);\n        this.panelAnalProg.add(this.labelAnalProg);\n        this.panelAnalProg.add(this.progressAnalysis);\n        this.panelAnalyze.add(this.panelAnalProg, \"South\");\n        this.listResults.setEnabled(false);\n        this.scrollPane3.setViewportView(this.listResults);\n        this.panelAnalyze.add(this.scrollPane3, \"Center\");\n        this.paneOpts.addTab(\"Analyze\", this.panelAnalyze);\n        this.add(this.paneOpts, \"Center\");\n        (this.buttonGroup1 = new ButtonGroup()).add(this.radioKnown);\n        this.buttonGroup1.add(this.radioUnknown);\n        (this.buttonGroup2 = new ButtonGroup()).add(this.radioCrossEnt);\n        this.buttonGroup2.add(this.radioLZW);\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        final String command = e.getActionCommand();\n        if (command.equals(\"Exit\")) {\n            System.exit(-1);\n        }\n        else if (command.equals(\"knownauthor\")) {\n            this.currentAuthor.setText(\"\");\n            this.currentAuthor.setEnabled(true);\n        }\n        else if (command.equals(\"unknownauthor\")) {\n            this.currentAuthor.setText(\"\");\n            this.currentAuthor.setEnabled(false);\n        }\n        else if (command.equals(\"Import\")) {\n            final String fcomp = new String();\n            System.out.println(this.buttonGroup1.getSelection().getActionCommand());\n            final int returnVal = this.chooseFile.showOpenDialog(this);\n            if (returnVal == 0) {\n                final File file = this.chooseFile.getSelectedFile();\n                this.driver.addDocument(file.toString(), this.currentAuthor.getText());\n                if (!this.currentAuthor.getText().equals(\"\")) {\n                    this.listKnown.append(this.currentAuthor.getText() + \" - \" + file.getName() + \"\\n\");\n                }\n                else {\n                    this.listUnknown.append(file.getName() + \"\\n\");\n                }\n                System.out.println(file);\n            }\n        }\n        else if (command.equals(\"Canonicize\")) {\n            final guiDriver.preprocessEngineDriver pe = this.driver.preprocessEngineDriver(this.canonicizers, this.paneOpts, this.progressCanonicize);\n            pe.start();\n        }\n        else if (command.equals(\"CreateEventSet\")) {\n            final guiDriver.createEventSetDriver esd = this.driver.createEventSetDriver(this.esButtonGroup.getSelection().getActionCommand(), this.paneOpts, this.progressEventSet);\n            esd.start();\n        }\n        else if (command.equals(\"Analyze\")) {\n            final guiDriver.runStatisticalAnalysisDriver rsad = this.driver.runStatisticalAnalysisDriver(this.buttonGroup2.getSelection().getActionCommand(), this.paneOpts, this.progressAnalysis);\n            rsad.start();\n            this.listResults.append(rsad.getResults());\n        }\n        else if (command.equals(\"demo\")) {\n            this.loadDemo();\n        }\n        else {\n            System.out.println(command);\n        }\n    }\n    \n    public void loadDemo() {\n        System.out.println(\"Need to Demo\");\n    }\n}\n"
    },
    {
        "project_name": "24_saxpath",
        "class": "XPathLexer",
        "fqdn": "com.werken.saxpath",
        "source_code": "package com.werken.saxpath;\n\nclass XPathLexer\n{\n    private String xpath;\n    private int currentPosition;\n    private int endPosition;\n    private Token previousToken;\n    \n    public XPathLexer(final String xpath) {\n        this.setXPath(xpath);\n    }\n    \n    XPathLexer() {\n    }\n    \n    void setXPath(final String xpath) {\n        this.xpath = xpath;\n        this.currentPosition = 0;\n        this.endPosition = xpath.length();\n    }\n    \n    public String getXPath() {\n        return this.xpath;\n    }\n    \n    public Token nextToken() {\n        Token token = null;\n        do {\n            token = null;\n            Label_0769: {\n                switch (this.LA(1)) {\n                    case '$': {\n                        token = this.dollar();\n                        break;\n                    }\n                    case '\\\"':\n                    case '\\'': {\n                        token = this.literal();\n                        break;\n                    }\n                    case '/': {\n                        token = this.slashes();\n                        break;\n                    }\n                    case ',': {\n                        token = this.comma();\n                        break;\n                    }\n                    case '(': {\n                        token = this.leftParen();\n                        break;\n                    }\n                    case ')': {\n                        token = this.rightParen();\n                        break;\n                    }\n                    case '[': {\n                        token = this.leftBracket();\n                        break;\n                    }\n                    case ']': {\n                        token = this.rightBracket();\n                        break;\n                    }\n                    case '+': {\n                        token = this.plus();\n                        break;\n                    }\n                    case '-': {\n                        token = this.minus();\n                        break;\n                    }\n                    case '<':\n                    case '>': {\n                        token = this.relationalOperator();\n                        break;\n                    }\n                    case '=': {\n                        token = this.equals();\n                        break;\n                    }\n                    case '!': {\n                        if (this.LA(2) == '=') {\n                            token = this.notEquals();\n                            break;\n                        }\n                        token = this.not();\n                        break;\n                    }\n                    case '|': {\n                        token = this.pipe();\n                        break;\n                    }\n                    case '@': {\n                        token = this.at();\n                        break;\n                    }\n                    case ':': {\n                        if (this.LA(2) == ':') {\n                            token = this.doubleColon();\n                            break;\n                        }\n                        token = this.colon();\n                        break;\n                    }\n                    case '*': {\n                        token = this.star();\n                        break;\n                    }\n                    case '.': {\n                        switch (this.LA(2)) {\n                            case '0':\n                            case '1':\n                            case '2':\n                            case '3':\n                            case '4':\n                            case '5':\n                            case '6':\n                            case '7':\n                            case '8':\n                            case '9': {\n                                token = this.number();\n                                break Label_0769;\n                            }\n                            default: {\n                                token = this.dots();\n                                break Label_0769;\n                            }\n                        }\n                        break;\n                    }\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9': {\n                        token = this.number();\n                        break;\n                    }\n                    case '\\t':\n                    case '\\n':\n                    case '\\r':\n                    case ' ': {\n                        token = this.whitespace();\n                        break;\n                    }\n                    default: {\n                        if (this.isIdentifierStartChar(this.LA(1))) {\n                            token = this.identifierOrOperatorName();\n                            break;\n                        }\n                        break;\n                    }\n                }\n            }\n            if (token == null) {\n                token = new Token(-1, this.getXPath(), this.currentPosition(), this.endPosition());\n            }\n        } while (token.getTokenType() == -2);\n        this.setPreviousToken(token);\n        return token;\n    }\n    \n    Token identifierOrOperatorName() {\n        Token token = null;\n        final Token previousToken = this.getPreviousToken();\n        if (previousToken != null) {\n            switch (previousToken.getTokenType()) {\n                case 1:\n                case 3:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                case 10:\n                case 11:\n                case 12:\n                case 16:\n                case 17:\n                case 18:\n                case 19:\n                case 20:\n                case 21:\n                case 22:\n                case 24:\n                case 25:\n                case 26:\n                case 28:\n                case 29:\n                case 32: {\n                    token = this.identifier();\n                    break;\n                }\n                default: {\n                    token = this.operatorName();\n                    break;\n                }\n            }\n        }\n        else {\n            token = this.identifier();\n        }\n        return token;\n    }\n    \n    Token identifier() {\n        Token token = null;\n        final int start = this.currentPosition();\n        while (this.hasMoreChars() && this.isIdentifierChar(this.LA(1))) {\n            this.consume();\n        }\n        token = new Token(15, this.getXPath(), start, this.currentPosition());\n        return token;\n    }\n    \n    Token operatorName() {\n        Token token = null;\n        switch (this.LA(1)) {\n            case 'a': {\n                token = this.and();\n                break;\n            }\n            case 'o': {\n                token = this.or();\n                break;\n            }\n            case 'm': {\n                token = this.mod();\n                break;\n            }\n            case 'd': {\n                token = this.div();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    Token mod() {\n        Token token = null;\n        if (this.LA(1) == 'm' && this.LA(2) == 'o' && this.LA(3) == 'd' && !this.isIdentifierChar(this.LA(4))) {\n            token = new Token(25, this.getXPath(), this.currentPosition(), this.currentPosition() + 3);\n            this.consume();\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token div() {\n        Token token = null;\n        if (this.LA(1) == 'd' && this.LA(2) == 'i' && this.LA(3) == 'v' && !this.isIdentifierChar(this.LA(4))) {\n            token = new Token(24, this.getXPath(), this.currentPosition(), this.currentPosition() + 3);\n            this.consume();\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token and() {\n        Token token = null;\n        if (this.LA(1) == 'a' && this.LA(2) == 'n' && this.LA(3) == 'd' && !this.isIdentifierChar(this.LA(4))) {\n            token = new Token(28, this.getXPath(), this.currentPosition(), this.currentPosition() + 3);\n            this.consume();\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token or() {\n        Token token = null;\n        if (this.LA(1) == 'o' && this.LA(2) == 'r' && !this.isIdentifierChar(this.LA(3))) {\n            token = new Token(29, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n            this.consume();\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token number() {\n        final int start = this.currentPosition();\n        boolean periodAllowed = true;\n    Label_0099:\n        while (true) {\n            switch (this.LA(1)) {\n                case '.': {\n                    if (periodAllowed) {\n                        periodAllowed = false;\n                        this.consume();\n                        continue;\n                    }\n                    break Label_0099;\n                }\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9': {\n                    this.consume();\n                    continue;\n                }\n                default: {\n                    break Label_0099;\n                }\n            }\n        }\n        Token token = null;\n        if (periodAllowed) {\n            token = new Token(30, this.getXPath(), start, this.currentPosition());\n        }\n        else {\n            token = new Token(31, this.getXPath(), start, this.currentPosition());\n        }\n        return token;\n    }\n    \n    Token whitespace() {\n        this.consume();\n    Label_0070:\n        while (this.hasMoreChars()) {\n            switch (this.LA(1)) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case ' ': {\n                    this.consume();\n                    continue;\n                }\n                default: {\n                    break Label_0070;\n                }\n            }\n        }\n        return new Token(-2, this.getXPath(), 0, 0);\n    }\n    \n    Token comma() {\n        final Token token = new Token(32, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token equals() {\n        final Token token = new Token(21, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token minus() {\n        final Token token = new Token(6, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token plus() {\n        final Token token = new Token(5, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token dollar() {\n        final Token token = new Token(26, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token pipe() {\n        final Token token = new Token(17, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token at() {\n        final Token token = new Token(16, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token colon() {\n        final Token token = new Token(18, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token doubleColon() {\n        final Token token = new Token(19, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n        this.consume();\n        this.consume();\n        return token;\n    }\n    \n    Token not() {\n        final Token token = new Token(23, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token notEquals() {\n        final Token token = new Token(22, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n        this.consume();\n        this.consume();\n        return token;\n    }\n    \n    Token relationalOperator() {\n        Token token = null;\n        switch (this.LA(1)) {\n            case '<': {\n                if (this.LA(2) == '=') {\n                    token = new Token(8, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                    this.consume();\n                }\n                else {\n                    token = new Token(7, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                }\n                this.consume();\n                break;\n            }\n            case '>': {\n                if (this.LA(2) == '=') {\n                    token = new Token(10, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                    this.consume();\n                }\n                else {\n                    token = new Token(9, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                }\n                this.consume();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    Token star() {\n        final Token token = new Token(20, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token literal() {\n        Token token = null;\n        final char match = this.LA(1);\n        this.consume();\n        final int start = this.currentPosition();\n        while (token == null && this.hasMoreChars()) {\n            if (this.LA(1) == match) {\n                token = new Token(27, this.getXPath(), start, this.currentPosition());\n            }\n            this.consume();\n        }\n        return token;\n    }\n    \n    Token dots() {\n        Token token = null;\n        switch (this.LA(2)) {\n            case '.': {\n                token = new Token(14, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                this.consume();\n                this.consume();\n                break;\n            }\n            default: {\n                token = new Token(13, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                this.consume();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    Token leftBracket() {\n        final Token token = new Token(3, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token rightBracket() {\n        final Token token = new Token(4, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token leftParen() {\n        final Token token = new Token(1, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token rightParen() {\n        final Token token = new Token(2, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n        this.consume();\n        return token;\n    }\n    \n    Token slashes() {\n        Token token = null;\n        switch (this.LA(2)) {\n            case '/': {\n                token = new Token(12, this.getXPath(), this.currentPosition(), this.currentPosition() + 2);\n                this.consume();\n                this.consume();\n                break;\n            }\n            default: {\n                token = new Token(11, this.getXPath(), this.currentPosition(), this.currentPosition() + 1);\n                this.consume();\n                break;\n            }\n        }\n        return token;\n    }\n    \n    char LA(final int i) {\n        if (this.currentPosition + (i - 1) >= this.endPosition()) {\n            return '\\uffff';\n        }\n        return this.getXPath().charAt(this.currentPosition() + (i - 1));\n    }\n    \n    void consume() {\n        ++this.currentPosition;\n    }\n    \n    void consume(final int i) {\n        this.currentPosition += i;\n    }\n    \n    int currentPosition() {\n        return this.currentPosition;\n    }\n    \n    int endPosition() {\n        return this.endPosition;\n    }\n    \n    Token getPreviousToken() {\n        return this.previousToken;\n    }\n    \n    void setPreviousToken(final Token previousToken) {\n        this.previousToken = previousToken;\n    }\n    \n    boolean hasMoreChars() {\n        return this.currentPosition() < this.endPosition();\n    }\n    \n    boolean isIdentifierChar(final char c) {\n        switch (c) {\n            case '-':\n            case '.': {\n                return true;\n            }\n            default: {\n                return Character.isUnicodeIdentifierPart(c);\n            }\n        }\n    }\n    \n    boolean isIdentifierStartChar(final char c) {\n        return c == '_' || Character.isUnicodeIdentifierStart(c);\n    }\n}\n"
    },
    {
        "project_name": "107_weka",
        "class": "Memory",
        "fqdn": "weka.core",
        "source_code": "package weka.core;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class Memory implements RevisionHandler\n{\n    protected static boolean m_Enabled;\n    protected boolean m_UseGUI;\n    protected static long m_Initial;\n    protected long m_Total;\n    protected long m_Max;\n    protected Runtime m_Runtime;\n    \n    public Memory() {\n        this(false);\n    }\n    \n    public Memory(final boolean useGUI) {\n        this.m_UseGUI = false;\n        this.m_UseGUI = useGUI;\n        this.m_Runtime = Runtime.getRuntime();\n        this.m_Max = this.m_Runtime.maxMemory();\n        this.m_Total = this.m_Runtime.totalMemory();\n    }\n    \n    public boolean isEnabled() {\n        return Memory.m_Enabled;\n    }\n    \n    public void setEnabled(final boolean value) {\n        Memory.m_Enabled = value;\n    }\n    \n    public boolean getUseGUI() {\n        return this.m_UseGUI;\n    }\n    \n    public long getInitial() {\n        return Memory.m_Initial;\n    }\n    \n    public long getCurrent() {\n        this.m_Runtime = Runtime.getRuntime();\n        return this.m_Total = this.m_Runtime.totalMemory();\n    }\n    \n    public long getMax() {\n        return this.m_Max;\n    }\n    \n    public boolean isOutOfMemory() {\n        return this.isEnabled() && this.getMax() - this.getCurrent() < this.getInitial() + 200000L;\n    }\n    \n    public static double toMegaByte(final long bytes) {\n        return bytes / 1048576.0;\n    }\n    \n    public void showOutOfMemory() {\n        if (!this.isEnabled()) {\n            return;\n        }\n        System.gc();\n        final String msg = \"Not enough memory. Please load a smaller dataset or use larger heap size.\\n- initial JVM size:   \" + Utils.doubleToString(toMegaByte(Memory.m_Initial), 1) + \"MB\\n\" + \"- total memory used:  \" + Utils.doubleToString(toMegaByte(this.m_Total), 1) + \"MB\\n\" + \"- max. memory avail.: \" + Utils.doubleToString(toMegaByte(this.m_Max), 1) + \"MB\\n\" + \"\\n\" + \"Note:\\n\" + \"The Java heap size can be specified with the -Xmx option.\\n\" + \"E.g., to use 128MB as heap size, the command line looks like this:\\n\" + \"   java -Xmx128m -classpath ...\\n\" + \"This does NOT work in the SimpleCLI, the java command refers\\n\" + \"to the one with which Weka is started.\";\n        System.err.println(msg);\n        if (this.getUseGUI()) {\n            JOptionPane.showMessageDialog(null, msg, \"OutOfMemory\", 2);\n        }\n    }\n    \n    public void stopThreads() {\n        Thread[] thGroup = new Thread[Thread.activeCount()];\n        Thread.enumerate(thGroup);\n        for (int i = 0; i < thGroup.length; ++i) {\n            final Thread t = thGroup[i];\n            if (t != null && t != Thread.currentThread()) {\n                if (t.getName().startsWith(\"Thread\")) {\n                    t.stop();\n                }\n                else if (t.getName().startsWith(\"AWT-EventQueue\")) {\n                    t.stop();\n                }\n            }\n        }\n        thGroup = null;\n        System.gc();\n    }\n    \n    @Override\n    public String getRevision() {\n        return RevisionUtils.extract(\"$Revision: 8034 $\");\n    }\n    \n    public static void main(final String[] args) {\n        final Memory mem = new Memory();\n        System.out.println(\"Initial memory: \" + Utils.doubleToString(toMegaByte(mem.getInitial()), 1) + \"MB\" + \" (\" + mem.getInitial() + \")\");\n        System.out.println(\"Max memory: \" + Utils.doubleToString(toMegaByte(mem.getMax()), 1) + \"MB\" + \" (\" + mem.getMax() + \")\");\n    }\n    \n    static {\n        Memory.m_Enabled = true;\n        Memory.m_Initial = Runtime.getRuntime().totalMemory();\n    }\n}\n"
    },
    {
        "project_name": "107_weka",
        "class": "ICSSearchAlgorithm",
        "fqdn": "weka.classifiers.bayes.net.search.ci",
        "source_code": "package weka.classifiers.bayes.net.search.ci;\n\nimport weka.classifiers.bayes.*;\nimport weka.classifiers.bayes.net.*;\nimport java.util.*;\nimport weka.classifiers.bayes.net.search.*;\nimport java.io.*;\nimport weka.core.*;\n\npublic class ICSSearchAlgorithm extends CISearchAlgorithm\n{\n    static final long serialVersionUID = -2510985917284798576L;\n    private int m_nMaxCardinality;\n    \n    public ICSSearchAlgorithm() {\n        this.m_nMaxCardinality = 2;\n    }\n    \n    String name(final int iAttribute) {\n        return this.m_instances.attribute(iAttribute).name();\n    }\n    \n    int maxn() {\n        return this.m_instances.numAttributes();\n    }\n    \n    public void setMaxCardinality(final int nMaxCardinality) {\n        this.m_nMaxCardinality = nMaxCardinality;\n    }\n    \n    public int getMaxCardinality() {\n        return this.m_nMaxCardinality;\n    }\n    \n    @Override\n    protected void search(final BayesNet bayesNet, final Instances instances) throws Exception {\n        this.m_BayesNet = bayesNet;\n        this.m_instances = instances;\n        final boolean[][] edges = new boolean[this.maxn() + 1][];\n        final boolean[][] arrows = new boolean[this.maxn() + 1][];\n        final SeparationSet[][] sepsets = new SeparationSet[this.maxn() + 1][];\n        for (int iNode = 0; iNode < this.maxn() + 1; ++iNode) {\n            edges[iNode] = new boolean[this.maxn()];\n            arrows[iNode] = new boolean[this.maxn()];\n            sepsets[iNode] = new SeparationSet[this.maxn()];\n        }\n        this.calcDependencyGraph(edges, sepsets);\n        this.calcVeeNodes(edges, arrows, sepsets);\n        this.calcArcDirections(edges, arrows);\n        for (int iNode = 0; iNode < this.maxn(); ++iNode) {\n            final ParentSet oParentSet = this.m_BayesNet.getParentSet(iNode);\n            while (oParentSet.getNrOfParents() > 0) {\n                oParentSet.deleteLastParent(this.m_instances);\n            }\n            for (int iParent = 0; iParent < this.maxn(); ++iParent) {\n                if (arrows[iParent][iNode]) {\n                    oParentSet.addParent(iParent, this.m_instances);\n                }\n            }\n        }\n    }\n    \n    void calcDependencyGraph(final boolean[][] edges, final SeparationSet[][] sepsets) {\n        for (int iNode1 = 0; iNode1 < this.maxn(); ++iNode1) {\n            for (int iNode2 = 0; iNode2 < this.maxn(); ++iNode2) {\n                edges[iNode1][iNode2] = true;\n            }\n        }\n        for (int iNode1 = 0; iNode1 < this.maxn(); ++iNode1) {\n            edges[iNode1][iNode1] = false;\n        }\n        for (int iCardinality = 0; iCardinality <= this.getMaxCardinality(); ++iCardinality) {\n            for (int iNode3 = 0; iNode3 <= this.maxn() - 2; ++iNode3) {\n                for (int iNode4 = iNode3 + 1; iNode4 < this.maxn(); ++iNode4) {\n                    if (edges[iNode3][iNode4]) {\n                        final SeparationSet oSepSet = this.existsSepSet(iNode3, iNode4, iCardinality, edges);\n                        if (oSepSet != null) {\n                            edges[iNode3][iNode4] = false;\n                            edges[iNode4][iNode3] = false;\n                            sepsets[iNode3][iNode4] = oSepSet;\n                            sepsets[iNode4][iNode3] = oSepSet;\n                            System.err.print(\"I(\" + this.name(iNode3) + \", {\");\n                            for (int iNode5 = 0; iNode5 < iCardinality; ++iNode5) {\n                                System.err.print(this.name(oSepSet.m_set[iNode5]) + \" \");\n                            }\n                            System.err.print(\"} ,\" + this.name(iNode4) + \")\\n\");\n                        }\n                    }\n                }\n            }\n            System.err.print(iCardinality + \" \");\n            for (int iNode3 = 0; iNode3 < this.maxn(); ++iNode3) {\n                System.err.print(this.name(iNode3) + \" \");\n            }\n            System.err.print('\\n');\n            for (int iNode3 = 0; iNode3 < this.maxn(); ++iNode3) {\n                for (int iNode4 = 0; iNode4 < this.maxn(); ++iNode4) {\n                    if (edges[iNode3][iNode4]) {\n                        System.err.print(\"X \");\n                    }\n                    else {\n                        System.err.print(\". \");\n                    }\n                }\n                System.err.print(this.name(iNode3) + \" \");\n                System.err.print('\\n');\n            }\n        }\n    }\n    \n    SeparationSet existsSepSet(final int iNode1, final int iNode2, final int nCardinality, final boolean[][] edges) {\n        final SeparationSet Z = new SeparationSet();\n        Z.m_set[nCardinality] = -1;\n        if (nCardinality > 0) {\n            Z.m_set[0] = this.next(-1, iNode1, iNode2, edges);\n            for (int iNode3 = 1; iNode3 < nCardinality; ++iNode3) {\n                Z.m_set[iNode3] = this.next(Z.m_set[iNode3 - 1], iNode1, iNode2, edges);\n            }\n        }\n        int iZ;\n        if (nCardinality > 0) {\n            iZ = this.maxn() - Z.m_set[nCardinality - 1] - 1;\n        }\n        else {\n            iZ = 0;\n        }\n        while (iZ >= 0) {\n            if (this.isConditionalIndependent(iNode2, iNode1, Z.m_set, nCardinality)) {\n                return Z;\n            }\n            if (nCardinality > 0) {\n                Z.m_set[nCardinality - 1] = this.next(Z.m_set[nCardinality - 1], iNode1, iNode2, edges);\n            }\n            for (iZ = nCardinality - 1; iZ >= 0 && Z.m_set[iZ] >= this.maxn(); iZ = nCardinality - 1) {\n                for (iZ = nCardinality - 1; iZ >= 0 && Z.m_set[iZ] >= this.maxn(); --iZ) {}\n                if (iZ < 0) {\n                    break;\n                }\n                Z.m_set[iZ] = this.next(Z.m_set[iZ], iNode1, iNode2, edges);\n                for (int iNode3 = iZ + 1; iNode3 < nCardinality; ++iNode3) {\n                    Z.m_set[iNode3] = this.next(Z.m_set[iNode3 - 1], iNode1, iNode2, edges);\n                }\n            }\n        }\n        return null;\n    }\n    \n    int next(int x, final int iNode1, final int iNode2, final boolean[][] edges) {\n        ++x;\n        while (x < this.maxn() && (!edges[iNode1][x] || !edges[iNode2][x] || x == iNode2)) {\n            ++x;\n        }\n        return x;\n    }\n    \n    void calcVeeNodes(final boolean[][] edges, final boolean[][] arrows, final SeparationSet[][] sepsets) {\n        for (int iNode1 = 0; iNode1 < this.maxn(); ++iNode1) {\n            for (int iNode2 = 0; iNode2 < this.maxn(); ++iNode2) {\n                arrows[iNode1][iNode2] = false;\n            }\n        }\n        for (int iNode1 = 0; iNode1 < this.maxn() - 1; ++iNode1) {\n            for (int iNode2 = iNode1 + 1; iNode2 < this.maxn(); ++iNode2) {\n                if (!edges[iNode1][iNode2]) {\n                    for (int iNode3 = 0; iNode3 < this.maxn(); ++iNode3) {\n                        if ((iNode3 != iNode1 && iNode3 != iNode2 && edges[iNode1][iNode3] && edges[iNode2][iNode3]) & !sepsets[iNode1][iNode2].contains(iNode3)) {\n                            arrows[iNode1][iNode3] = true;\n                            arrows[iNode2][iNode3] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    void calcArcDirections(final boolean[][] edges, final boolean[][] arrows) {\n        boolean bFound;\n        do {\n            bFound = false;\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[i][j]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (i != k && j != k && edges[j][k] && !edges[i][k] && !arrows[j][k] && !arrows[k][j]) {\n                                arrows[j][k] = true;\n                                bFound = true;\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[i][j]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (i != k && j != k && edges[i][k] && arrows[j][k] && !arrows[i][k] && !arrows[k][i]) {\n                                arrows[i][k] = true;\n                                bFound = true;\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[i][j]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (k != i && k != j && arrows[k][j] && !edges[k][i]) {\n                                for (int m = 0; m < this.maxn(); ++m) {\n                                    if (m != i && m != j && m != k && edges[m][i] && !arrows[m][i] && !arrows[i][m] && edges[m][j] && !arrows[m][j] && !arrows[j][m] && edges[m][k] && !arrows[m][k] && !arrows[k][m]) {\n                                        arrows[m][j] = true;\n                                        bFound = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < this.maxn(); ++i) {\n                for (int j = 0; j < this.maxn(); ++j) {\n                    if (i != j && arrows[j][i]) {\n                        for (int k = 0; k < this.maxn(); ++k) {\n                            if (k != i && k != j && edges[k][j] && !arrows[k][j] && !arrows[j][k] && edges[k][i] && !arrows[k][i] && !arrows[i][k]) {\n                                for (int m = 0; m < this.maxn(); ++m) {\n                                    if (m != i && m != j && m != k && edges[m][i] && !arrows[m][i] && !arrows[i][m] && edges[m][k] && !arrows[m][k] && !arrows[k][m]) {\n                                        arrows[i][m] = true;\n                                        arrows[k][m] = true;\n                                        bFound = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (!bFound) {\n                for (int i = 0; !bFound && i < this.maxn(); ++i) {\n                    for (int j = 0; !bFound && j < this.maxn(); ++j) {\n                        if (edges[i][j] && !arrows[i][j] && !arrows[j][i]) {\n                            arrows[i][j] = true;\n                            bFound = true;\n                        }\n                    }\n                }\n            }\n        } while (bFound);\n    }\n    \n    @Override\n    public Enumeration listOptions() {\n        final Vector result = new Vector();\n        result.addElement(new Option(\"\\tWhen determining whether an edge exists a search is performed \\n\\tfor a set Z that separates the nodes. MaxCardinality determines \\n\\tthe maximum size of the set Z. This greatly influences the \\n\\tlength of the search. (default 2)\", \"cardinality\", 1, \"-cardinality <num>\"));\n        final Enumeration en = super.listOptions();\n        while (en.hasMoreElements()) {\n            result.addElement(en.nextElement());\n        }\n        return result.elements();\n    }\n    \n    @Override\n    public void setOptions(final String[] options) throws Exception {\n        final String tmpStr = Utils.getOption(\"cardinality\", options);\n        if (tmpStr.length() != 0) {\n            this.setMaxCardinality(Integer.parseInt(tmpStr));\n        }\n        else {\n            this.setMaxCardinality(2);\n        }\n        super.setOptions(options);\n    }\n    \n    @Override\n    public String[] getOptions() {\n        final Vector result = new Vector();\n        final String[] options = super.getOptions();\n        for (int i = 0; i < options.length; ++i) {\n            result.add(options[i]);\n        }\n        result.add(\"-cardinality\");\n        result.add(\"\" + this.getMaxCardinality());\n        return result.toArray(new String[result.size()]);\n    }\n    \n    public String maxCardinalityTipText() {\n        return \"When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.\";\n    }\n    \n    @Override\n    public String globalInfo() {\n        return \"This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.\";\n    }\n    \n    @Override\n    public String getRevision() {\n        return RevisionUtils.extract(\"$Revision: 8034 $\");\n    }\n    \n    public static void main(final String[] argv) {\n        try {\n            final BayesNet b = new BayesNet();\n            b.setSearchAlgorithm(new ICSSearchAlgorithm());\n            final Instances instances = new Instances(new FileReader(\"C:\\\\eclipse\\\\workspace\\\\weka\\\\data\\\\contact-lenses.arff\"));\n            instances.setClassIndex(instances.numAttributes() - 1);\n            b.buildClassifier(instances);\n            System.out.println(b.toString());\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    class SeparationSet implements RevisionHandler\n    {\n        public int[] m_set;\n        \n        public SeparationSet() {\n            this.m_set = new int[ICSSearchAlgorithm.this.getMaxCardinality() + 1];\n        }\n        \n        public boolean contains(final int nItem) {\n            for (int iItem = 0; iItem < ICSSearchAlgorithm.this.getMaxCardinality() && this.m_set[iItem] != -1; ++iItem) {\n                if (this.m_set[iItem] == nItem) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        @Override\n        public String getRevision() {\n            return RevisionUtils.extract(\"$Revision: 8034 $\");\n        }\n    }\n}\n"
    },
    {
        "project_name": "45_lotus",
        "class": "Phase",
        "fqdn": "lotus.core.phases",
        "source_code": "package lotus.core.phases;\n\nimport lotus.core.*;\nimport lotus.core.effect.*;\n\npublic abstract class Phase\n{\n    public abstract void doPhase();\n    \n    private static void changePhase(final Phase p) {\n        Game.currentPhase = p;\n        final ChangePhase effect = new ChangePhase(p);\n        effect.resolve();\n    }\n    \n    public static void nextPhase() {\n        if (Game.currentPhase instanceof UntapPhase) {\n            changePhase(new UpkeepPhase());\n        }\n        else if (Game.currentPhase instanceof UpkeepPhase) {\n            changePhase(new DrawPhase());\n        }\n        else if (Game.currentPhase instanceof DrawPhase) {\n            changePhase(new Main1Phase());\n        }\n        else if (Game.currentPhase instanceof Main1Phase) {\n            changePhase(new CombatBeginningPhase());\n        }\n        else if (Game.currentPhase instanceof CombatBeginningPhase) {\n            changePhase(new DeclareAttackersPhase());\n        }\n        else if (Game.currentPhase instanceof DeclareAttackersPhase) {\n            changePhase(new DeclareBlockersPhase());\n        }\n        else if (Game.currentPhase instanceof DeclareBlockersPhase) {\n            changePhase(new CombatDamagePhase());\n        }\n        else if (Game.currentPhase instanceof CombatDamagePhase) {\n            changePhase(new CombatEndPhase());\n        }\n        else if (Game.currentPhase instanceof CombatEndPhase) {\n            changePhase(new Main2Phase());\n        }\n        else if (Game.currentPhase instanceof Main2Phase) {\n            changePhase(new EndOfTurnPhase());\n        }\n        else if (Game.currentPhase instanceof EndOfTurnPhase) {\n            changePhase(new CleanupPhase());\n        }\n        else if (Game.currentPhase instanceof CleanupPhase) {\n            changePhase(new PlayerChangePhase());\n        }\n        else if (Game.currentPhase instanceof PlayerChangePhase) {\n            Game.playingPlayer = Game.playingPlayer % 2 + 1;\n            changePhase(new UntapPhase());\n        }\n    }\n}\n"
    },
    {
        "project_name": "45_lotus",
        "class": "Game",
        "fqdn": "lotus.core",
        "source_code": "package lotus.core;\n\nimport lotus.core.stack.*;\nimport lotus.core.interfaces.*;\nimport lotus.core.phases.*;\nimport lotus.core.card.*;\nimport java.util.*;\n\npublic class Game\n{\n    public static Combat combat;\n    public static Phase currentPhase;\n    public static int playingPlayer;\n    public static Player player1;\n    public static Player player2;\n    public static Stack stack;\n    \n    public static Player getPlayingPlayer() {\n        if (Game.playingPlayer == 1) {\n            return Game.player1;\n        }\n        return Game.player2;\n    }\n    \n    public static Player getNonPlayingPlayer() {\n        return getOtherPlayer(getPlayingPlayer());\n    }\n    \n    public static Player getOtherPlayer(final Player p) {\n        if (p == Game.player1) {\n            return Game.player2;\n        }\n        return Game.player1;\n    }\n    \n    public static void init(final UserInterface IP1, final UserInterface IP2, final String n1, final String n2, final CardCollection deck1, final CardCollection deck2) {\n        Game.player1 = new Player(IP1, n1, deck1);\n        Game.player2 = new Player(IP2, n2, deck2);\n        IP1.init(Game.player1);\n        IP2.init(Game.player2);\n        Game.playingPlayer = 1;\n        Game.currentPhase = new UntapPhase();\n        for (final Card c : deck1) {\n            c.owner = Game.player1;\n            c.zone = Game.player1.library;\n        }\n        for (final Card c : deck2) {\n            c.owner = Game.player2;\n            c.zone = Game.player2.library;\n        }\n    }\n    \n    public static void givePriorityToCurrentPlayer() {\n        boolean APdone = false;\n        boolean NAPdone = false;\n        do {\n            APdone = !getPlayingPlayer().letPlayerSpeak();\n            if (NAPdone && APdone) {\n                break;\n            }\n            NAPdone = !getNonPlayingPlayer().letPlayerSpeak();\n        } while (!NAPdone || !APdone);\n        if (!Game.stack.empty()) {\n            Game.stack.resolveLast();\n            givePriorityToCurrentPlayer();\n        }\n    }\n    \n    static {\n        Game.stack = new Stack();\n    }\n}\n"
    },
    {
        "project_name": "39_diffi",
        "class": "IndexedString",
        "fqdn": "de.beiri22.stringincrementor.helper",
        "source_code": "package de.beiri22.stringincrementor.helper;\n\npublic final class IndexedString\n{\n    private char[] values;\n    private int[][] index;\n    \n    private int count(final char c) {\n        int result = 0;\n        for (int i = 0; i < this.values.length; ++i) {\n            if (this.values[i] == c) {\n                ++result;\n            }\n        }\n        return result;\n    }\n    \n    public IndexedString(final String s) {\n        this.values = new char[s.length()];\n        s.getChars(0, s.length(), this.values, 0);\n        this.index = new int[256][];\n        for (char c = '\\0'; c < '\\u0100'; ++c) {\n            this.index[c] = new int[this.count(c)];\n            int idx = 0;\n            for (int i = 0; i < this.values.length; ++i) {\n                if (this.values[i] == c) {\n                    this.index[c][idx++] = i;\n                }\n            }\n        }\n    }\n    \n    public int indexOf(final char[] target) {\n        final char first = target[0];\n        final int tl = target.length;\n        final int max = this.values.length - tl;\n        for (final int i : this.index[first]) {\n            if (i <= max) {\n                int j = i + 1;\n                final int end = i + tl;\n                for (int k = 1; j < end && this.values[j] == target[k]; ++j, ++k) {}\n                if (j == end) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}\n"
    },
    {
        "project_name": "39_diffi",
        "class": "StringIncrementor",
        "fqdn": "de.beiri22.stringincrementor",
        "source_code": "package de.beiri22.stringincrementor;\n\nimport de.beiri22.stringincrementor.helper.*;\nimport de.beiri22.stringincrementor.relativestring.*;\nimport java.io.*;\n\npublic class StringIncrementor\n{\n    public static RelativeString diff(final String a, final String b) {\n        return diff(a, b, false);\n    }\n    \n    public static RelativeString diff(final String a, final String b, final boolean verbose) {\n        final RelativeString result = new RelativeString();\n        final ExtBoolArray vergeben = new ExtBoolArray(b.length());\n        System.out.println(\"Creating index...\");\n        final IndexedString ai = new IndexedString(a);\n        System.out.println(\"Searching links...\");\n        final char[] target = new char[13];\n        for (int posB = 0; posB < b.length() - 12; ++posB) {\n            int l = 13;\n            b.getChars(posB, posB + 13, target, 0);\n            int posA = ai.indexOf(target);\n            if (posA == -1) {\n                if (verbose && posB % (b.length() / 1000) == 0) {\n                    System.out.println(\"@ \" + Math.round(posB / b.length() * 1000.0) / 10.0 + \"%\");\n                }\n            }\n            else {\n                int posALast = posA;\n                while (posA != -1 && posB + l < b.length() && posA + l < a.length()) {\n                    ++l;\n                    if (a.charAt(posA + l - 1) != b.charAt(posB + l - 1)) {\n                        posALast = posA;\n                        final char[] target2 = new char[l];\n                        b.getChars(posB, posB + l, target2, 0);\n                        posA = ai.indexOf(target2);\n                    }\n                }\n                if (posA == -1) {\n                    --l;\n                    posA = posALast;\n                }\n                vergeben.setTrue(posB, posB + l - 1);\n                final StringLink sl = new StringLink(posA, posB, l);\n                if (verbose) {\n                    System.out.println(sl + \" @ \" + Math.round(posB / b.length() * 1000.0) / 10.0 + \"%\");\n                }\n                result.addLink(sl);\n                posB += l - 1;\n            }\n        }\n        final StringBuilder rest = new StringBuilder();\n        synchronized (rest) {\n            for (int i = 0; i < b.length(); ++i) {\n                if (vergeben.isFalse(i, i)) {\n                    rest.append(b.charAt(i));\n                }\n            }\n        }\n        result.setAbsolute(rest.toString());\n        return result;\n    }\n    \n    public static String patch(final String a, final RelativeString r) {\n        return patch(a, r, false);\n    }\n    \n    public static String patch(final String a, final RelativeString r, final boolean verbose) {\n        final StringBuilder result = new StringBuilder(r.getLength());\n        int posAbs = 0;\n        for (int i = 0; i < r.linksCount(); ++i) {\n            final StringLink si = r.getLink(i);\n            if (result.length() != si.getPosNew()) {\n                final int diff = si.getPosNew() - result.length();\n                if (verbose) {\n                    System.out.println(\"Adding \" + diff + \" absolute Bytes from pos#\" + posAbs);\n                }\n                result.append(r.getAbsolute().substring(posAbs, posAbs + diff));\n                posAbs += diff;\n            }\n            if (verbose) {\n                System.out.println(\"Adding Link: \" + si);\n            }\n            result.append(a.substring(si.getPosOrig(), si.getPosOrig() + si.getLen()));\n        }\n        result.append(r.getAbsolute().substring(posAbs));\n        return result.toString();\n    }\n}\n"
    },
    {
        "project_name": "105_freemind",
        "class": "ExportHook",
        "fqdn": "freemind.extensions",
        "source_code": "package freemind.extensions;\n\nimport freemind.view.mindmapview.*;\nimport javax.swing.filechooser.*;\nimport java.text.*;\nimport javax.swing.*;\nimport freemind.modes.*;\nimport java.awt.image.*;\nimport java.awt.*;\nimport freemind.main.*;\nimport java.net.*;\nimport java.io.*;\n\npublic class ExportHook extends ModeControllerHookAdapter\n{\n    private MapView view;\n    \n    protected File chooseFile(final String type, final String description, final String nameExtension) {\n        final ModeController controller = this.getController();\n        return chooseImageFile(type, description, nameExtension, controller);\n    }\n    \n    public static File chooseImageFile(final String type, final String description, final String nameExtension, final ModeController controller) {\n        final Container component = controller.getFrame().getContentPane();\n        final ImageFilter filter = new ImageFilter(type, description);\n        FreeMindFileDialog chooser = null;\n        chooser = controller.getFileChooser(filter);\n        final File mmFile = controller.getMap().getFile();\n        if (mmFile != null) {\n            final String proposedName = mmFile.getAbsolutePath().replaceFirst(\"\\\\.[^.]*?$\", \"\") + ((nameExtension != null) ? nameExtension : \"\") + \".\" + type;\n            chooser.setSelectedFile(new File(proposedName));\n        }\n        final int returnVal = chooser.showSaveDialog(component);\n        if (returnVal != 0) {\n            return null;\n        }\n        File chosenFile = chooser.getSelectedFile();\n        final String ext = Tools.getExtension(chosenFile.getName());\n        if (!Tools.safeEqualsIgnoreCase(ext, type)) {\n            chosenFile = new File(chosenFile.getParent(), chosenFile.getName() + \".\" + type);\n        }\n        if (chosenFile.exists()) {\n            final String overwriteText = MessageFormat.format(controller.getText(\"file_already_exists\"), chosenFile.toString());\n            final int overwriteMap = JOptionPane.showConfirmDialog(component, overwriteText, overwriteText, 0);\n            if (overwriteMap != 0) {\n                return null;\n            }\n        }\n        return chosenFile;\n    }\n    \n    protected String getTranslatableResourceString(final String resourceName) {\n        final String returnValue = this.getResourceString(resourceName);\n        if (returnValue != null && returnValue.startsWith(\"%\")) {\n            return this.getController().getText(returnValue.substring(1));\n        }\n        return returnValue;\n    }\n    \n    public BufferedImage createBufferedImage() {\n        this.view = this.getController().getView();\n        if (this.view == null) {\n            return null;\n        }\n        this.view.preparePrinting();\n        final Rectangle innerBounds = this.view.getInnerBounds();\n        BufferedImage myImage = (BufferedImage)this.view.createImage(this.view.getWidth(), this.view.getHeight());\n        final Graphics g = myImage.getGraphics();\n        g.clipRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height);\n        this.view.print(g);\n        myImage = myImage.getSubimage(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height);\n        this.view.endPrinting();\n        return myImage;\n    }\n    \n    protected void copyFromResource(final String prefix, final String fileName, final String destinationDirectory) {\n        try {\n            this.logger.finest(\"searching for \" + prefix + fileName);\n            final URL resource = this.getResource(prefix + fileName);\n            if (resource == null) {\n                this.logger.severe(\"Cannot find resource: \" + prefix + fileName);\n                return;\n            }\n            final InputStream in = resource.openStream();\n            final OutputStream out = new FileOutputStream(destinationDirectory + \"/\" + fileName);\n            Tools.copyStream(in, out, true);\n        }\n        catch (Exception e) {\n            this.logger.severe(\"File not found or could not be copied. Was earching for \" + prefix + fileName + \" and should go to \" + destinationDirectory);\n            Resources.getInstance().logException(e);\n        }\n    }\n    \n    protected void copyFromFile(final String dir, final String fileName, final String destinationDirectory) {\n        try {\n            this.logger.finest(\"searching for \" + dir + fileName);\n            final File resource = new File(dir, fileName);\n            if (resource == null) {\n                this.logger.severe(\"Cannot find resource: \" + dir + fileName);\n                return;\n            }\n            final InputStream in = new FileInputStream(resource);\n            final OutputStream out = new FileOutputStream(destinationDirectory + \"/\" + fileName);\n            Tools.copyStream(in, out, true);\n        }\n        catch (Exception e) {\n            this.logger.severe(\"File not found or could not be copied. Was earching for \" + dir + fileName + \" and should go to \" + destinationDirectory);\n            Resources.getInstance().logException(e);\n        }\n    }\n    \n    public static class ImageFilter extends FileFilter\n    {\n        private String type;\n        private final String description;\n        \n        public ImageFilter(final String type, final String description) {\n            this.type = type;\n            this.description = description;\n        }\n        \n        @Override\n        public boolean accept(final File f) {\n            if (f.isDirectory()) {\n                return true;\n            }\n            final String extension = Tools.getExtension(f.getName());\n            return Tools.safeEqualsIgnoreCase(extension, this.type);\n        }\n        \n        @Override\n        public String getDescription() {\n            return (this.description == null) ? this.type : this.description;\n        }\n    }\n}\n"
    },
    {
        "project_name": "11_imsmart",
        "class": "HTMLFilter",
        "fqdn": "com.imsmart.servlet",
        "source_code": "package com.imsmart.servlet;\n\npublic final class HTMLFilter\n{\n    public static String filter(final String message) {\n        if (message == null) {\n            return null;\n        }\n        final char[] content = new char[message.length()];\n        message.getChars(0, message.length(), content, 0);\n        final StringBuffer result = new StringBuffer(content.length + 50);\n        for (int i = 0; i < content.length; ++i) {\n            switch (content[i]) {\n                case '<': {\n                    result.append(\"&lt;\");\n                    break;\n                }\n                case '>': {\n                    result.append(\"&gt;\");\n                    break;\n                }\n                case '&': {\n                    result.append(\"&amp;\");\n                    break;\n                }\n                case '\\\"': {\n                    result.append(\"&quot;\");\n                    break;\n                }\n                default: {\n                    result.append(content[i]);\n                    break;\n                }\n            }\n        }\n        return result.toString();\n    }\n}\n"
    },
    {
        "project_name": "7_sfmis",
        "class": "Base64",
        "fqdn": "com.hf.sfm.crypt",
        "source_code": "package com.hf.sfm.crypt;\n\npublic class Base64\n{\n    private static final byte[] _$23169;\n    private static final byte[] _$23168;\n    private static final char[] _$23167;\n    private static final char[] _$23166;\n    \n    public static byte[] altBase64ToByteArray(final String s) {\n        return _$23180(s, true);\n    }\n    \n    private static byte[] _$23180(final String s, final boolean flag) {\n        final byte[] bb = flag ? Base64._$23169 : Base64._$23168;\n        final int i = s.length();\n        final int j = i / 4;\n        if (4 * j != i) {\n            throw new IllegalArgumentException(\"String length must be a multiple of four.\");\n        }\n        int k = 0;\n        int l = j;\n        if (i != 0) {\n            if (s.charAt(i - 1) == '=') {\n                ++k;\n                --l;\n            }\n            if (s.charAt(i - 2) == '=') {\n                ++k;\n            }\n        }\n        final byte[] bc = new byte[3 * j - k];\n        int i2 = 0;\n        int j2 = 0;\n        for (int k2 = 0; k2 < l; ++k2) {\n            final int l2 = _$23183(s.charAt(i2++), bb);\n            final int j3 = _$23183(s.charAt(i2++), bb);\n            final int l3 = _$23183(s.charAt(i2++), bb);\n            final int j4 = _$23183(s.charAt(i2++), bb);\n            bc[j2++] = (byte)(l2 << 2 | j3 >> 4);\n            bc[j2++] = (byte)(j3 << 4 | l3 >> 2);\n            bc[j2++] = (byte)(l3 << 6 | j4);\n        }\n        if (k != 0) {\n            final int i3 = _$23183(s.charAt(i2++), bb);\n            final int k3 = _$23183(s.charAt(i2++), bb);\n            bc[j2++] = (byte)(i3 << 2 | k3 >> 4);\n            if (k == 1) {\n                final int i4 = _$23183(s.charAt(i2++), bb);\n                bc[j2++] = (byte)(k3 << 4 | i4 >> 2);\n            }\n        }\n        return bc;\n    }\n    \n    public static byte[] base64ToByteArray(final String s) {\n        return _$23180(s, false);\n    }\n    \n    private static int _$23183(final char c, final byte[] bb) {\n        final byte b = bb[c];\n        if (b < 0) {\n            throw new IllegalArgumentException(\"Illegal character \" + c);\n        }\n        return b;\n    }\n    \n    public static String byteArrayToAltBase64(final byte[] bb) {\n        return _$23170(bb, true);\n    }\n    \n    private static String _$23170(final byte[] bb, final boolean flag) {\n        final int i = bb.length;\n        final int j = i / 3;\n        final int k = i - 3 * j;\n        final int l = 4 * ((i + 2) / 3);\n        final StringBuffer stringbuffer = new StringBuffer(l);\n        final char[] ac = flag ? Base64._$23167 : Base64._$23166;\n        int i2 = 0;\n        for (int j2 = 0; j2 < j; ++j2) {\n            final int k2 = bb[i2++] & 0xFF;\n            final int i3 = bb[i2++] & 0xFF;\n            final int k3 = bb[i2++] & 0xFF;\n            stringbuffer.append(ac[k2 >> 2]);\n            stringbuffer.append(ac[(k2 << 4 & 0x3F) | i3 >> 4]);\n            stringbuffer.append(ac[(i3 << 2 & 0x3F) | k3 >> 6]);\n            stringbuffer.append(ac[k3 & 0x3F]);\n        }\n        if (k != 0) {\n            final int l2 = bb[i2++] & 0xFF;\n            stringbuffer.append(ac[l2 >> 2]);\n            if (k == 1) {\n                stringbuffer.append(ac[l2 << 4 & 0x3F]);\n                stringbuffer.append(\"==\");\n            }\n            else {\n                final int j3 = bb[i2++] & 0xFF;\n                stringbuffer.append(ac[(l2 << 4 & 0x3F) | j3 >> 4]);\n                stringbuffer.append(ac[j3 << 2 & 0x3F]);\n                stringbuffer.append('=');\n            }\n        }\n        return stringbuffer.toString();\n    }\n    \n    public static String byteArrayToBase64(final byte[] bb) {\n        return _$23170(bb, false);\n    }\n    \n    public static void main(final String[] args) {\n        String s = \"0123456789\";\n        byte[] b = s.getBytes();\n        s = byteArrayToBase64(b);\n        System.out.println(s);\n        b = base64ToByteArray(s);\n        System.out.println(new String(b));\n    }\n    \n    static {\n        _$23169 = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1, 62, 9, 10, 11, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 12, 13, 14, -1, 15, 63, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 18, 19, 21, 20, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 22, 23, 24, 25 };\n        _$23168 = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 };\n        _$23167 = new char[] { '!', '\\\"', '#', '$', '%', '&', '\\'', '(', ')', ',', '-', '.', ':', ';', '<', '>', '@', '[', ']', '^', '`', '_', '{', '|', '}', '~', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '?' };\n        _$23166 = new char[] { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };\n    }\n}\n"
    },
    {
        "project_name": "80_wheelwebtool",
        "class": "DynamicSelectModel",
        "fqdn": "wheel.util",
        "source_code": "package wheel.util;\n\nimport wheel.components.*;\nimport wheel.*;\nimport java.util.*;\n\npublic class DynamicSelectModel implements ISelectModel\n{\n    private Component component;\n    private StandaloneComponent topLevelComponent;\n    private ElExpression label;\n    private ElExpression value;\n    private ElExpression collection;\n    private ElExpression translator;\n    private Collection objects;\n    private Object emptyObject;\n    \n    public DynamicSelectModel(final ElExpression collection, final ElExpression label, final ElExpression value) {\n        this.validate();\n        this.label = label;\n        this.value = value;\n        this.collection = collection;\n    }\n    \n    public DynamicSelectModel() {\n    }\n    \n    public DynamicSelectModel collection(final String collection) {\n        this.collection = new ElExpression(collection);\n        return this;\n    }\n    \n    public DynamicSelectModel label(final String label) {\n        this.label = new ElExpression(label);\n        return this;\n    }\n    \n    public DynamicSelectModel value(final String value) {\n        this.value = new ElExpression(value);\n        return this;\n    }\n    \n    public DynamicSelectModel enumeration(final String enumeration) {\n        this.collection = new ElExpression(enumeration + \".values()\");\n        this.label = new ElExpression(\"toString()\");\n        this.value = new ElExpression(\"ordinal()\");\n        return this;\n    }\n    \n    public DynamicSelectModel translator(final String translator) {\n        this.translator = new ElExpression(translator);\n        return this;\n    }\n    \n    public DynamicSelectModel empty(final Object o) {\n        this.emptyObject = o;\n        return this;\n    }\n    \n    @Override\n    public int getOptionCount() {\n        return this.getObjects().size();\n    }\n    \n    @Override\n    public String getLabel(final int index) {\n        this.label.errorMessage(\"Could not evaluate expression \" + this.label.getExpression() + \" to create a label for dynamic ISelectModel. Index was \" + index);\n        final Object obj = this.label.eval(this.getObjects().toArray()[index], this.component);\n        return obj.toString();\n    }\n    \n    @Override\n    public String getValue(final int index) {\n        this.value.errorMessage(\"Could not evaluate expression \" + (Object)this.value + \" to create a value for dynamic ISelectModel. Index was \" + index);\n        final Object obj = this.value.eval(this.getObjects().toArray()[index], this.component);\n        return obj.toString();\n    }\n    \n    @Override\n    public Object translateValue(final String value) {\n        final Object[] array = this.getObjects().toArray();\n        int i = 0;\n        while (i < array.length) {\n            final String compareTo = this.getValue(i);\n            if (compareTo.equals(value)) {\n                if (this.translator != null) {\n                    this.translator.errorMessage(\"Could not evaluate expression \" + (Object)this.translator + \" to translate value ' \" + value + \"'\");\n                    return this.translator.eval(array[i], this.component);\n                }\n                return array[i];\n            }\n            else {\n                ++i;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public Collection getObjects() {\n        if (this.objects != null) {\n            return this.objects;\n        }\n        this.collection.errorMessage(\"Could not evaluate expression \" + (Object)this.collection + \" to create a dynamic ISelectModel.\");\n        final Object obj = this.collection.eval(this.topLevelComponent, this.component);\n        if (obj == null) {\n            throw new WheelException(\"Expression \" + (Object)this.collection + \" evaluated to null. Can't build a dynamic ISelectModel\", this.component);\n        }\n        if (obj instanceof Collection) {\n            this.objects = (Collection)obj;\n        }\n        else {\n            if (!(obj instanceof Object[])) {\n                throw new WheelException(\"Expression \" + (Object)this.collection + \" evaluated to an object that is not an instance of Collection or Object[]. Can't build a dynamic ISelectModel\", this.component);\n            }\n            final Object[] array = (Object[])obj;\n            final Collection col = new ArrayList();\n            for (int i = 0; i < array.length; ++i) {\n                col.add(array[i]);\n            }\n            this.objects = col;\n        }\n        if (this.emptyObject != null) {\n            final Collection newCollection = new LinkedList();\n            newCollection.add(this.emptyObject);\n            newCollection.addAll(this.objects);\n            this.objects = newCollection;\n        }\n        return this.objects;\n    }\n    \n    public Component getComponent() {\n        return this.component;\n    }\n    \n    public void setComponent(final Component component) {\n        this.component = component;\n    }\n    \n    public StandaloneComponent getTopLevelComponent() {\n        return this.topLevelComponent;\n    }\n    \n    public void setTopLevelComponent(final StandaloneComponent topLevelComponent) {\n        this.topLevelComponent = topLevelComponent;\n    }\n    \n    public void validate() {\n        if (this.collection == null) {\n            throw new WheelException(\"Could not create DynamicSelection model. Collection attribute was null or not an el-expression.\", (Component)null);\n        }\n        if (this.label == null) {\n            throw new WheelException(\"Could not create DynamicSelection model. Label attribute was null or not an el-expression.\", (Component)null);\n        }\n        if (this.value == null) {\n            throw new WheelException(\"Could not create DynamicSelection model. Value attribute was null or not an el-expression.\", (Component)null);\n        }\n    }\n    \n    public void reset() {\n        this.objects = null;\n    }\n}\n"
    },
    {
        "project_name": "jdom",
        "class": "JDOMResult",
        "fqdn": "org.jdom2.transform",
        "source_code": "package org.jdom2.transform;\n\nimport javax.xml.transform.sax.*;\nimport org.xml.sax.ext.*;\nimport org.jdom2.*;\nimport java.util.*;\nimport org.jdom2.input.sax.*;\nimport org.xml.sax.helpers.*;\nimport org.xml.sax.*;\n\npublic class JDOMResult extends SAXResult\n{\n    public static final String JDOM_FEATURE = \"http://jdom.org/jdom2/transform/JDOMResult/feature\";\n    private List<Content> resultlist;\n    private Document resultdoc;\n    private boolean queried;\n    private JDOMFactory factory;\n    \n    public JDOMResult() {\n        this.resultlist = null;\n        this.resultdoc = null;\n        this.queried = false;\n        this.factory = null;\n        final DocumentBuilder builder = new DocumentBuilder();\n        super.setHandler(builder);\n        super.setLexicalHandler(builder);\n    }\n    \n    public void setResult(final List<Content> result) {\n        this.resultlist = result;\n        this.queried = false;\n    }\n    \n    public List<Content> getResult() {\n        List<Content> nodes = Collections.emptyList();\n        this.retrieveResult();\n        if (this.resultlist != null) {\n            nodes = this.resultlist;\n        }\n        else if (this.resultdoc != null && !this.queried) {\n            final List<Content> content = this.resultdoc.getContent();\n            nodes = new ArrayList<Content>(content.size());\n            while (content.size() != 0) {\n                final Content o = content.remove(0);\n                nodes.add(o);\n            }\n            this.resultlist = nodes;\n            this.resultdoc = null;\n        }\n        this.queried = true;\n        return nodes;\n    }\n    \n    public void setDocument(final Document document) {\n        this.resultdoc = document;\n        this.resultlist = null;\n        this.queried = false;\n    }\n    \n    public Document getDocument() {\n        Document doc = null;\n        this.retrieveResult();\n        if (this.resultdoc != null) {\n            doc = this.resultdoc;\n        }\n        else if (this.resultlist != null && !this.queried) {\n            try {\n                JDOMFactory f = this.getFactory();\n                if (f == null) {\n                    f = new DefaultJDOMFactory();\n                }\n                doc = f.document(null);\n                doc.setContent(this.resultlist);\n                this.resultdoc = doc;\n                this.resultlist = null;\n            }\n            catch (RuntimeException ex1) {\n                return null;\n            }\n        }\n        this.queried = true;\n        return doc;\n    }\n    \n    public void setFactory(final JDOMFactory factory) {\n        this.factory = factory;\n    }\n    \n    public JDOMFactory getFactory() {\n        return this.factory;\n    }\n    \n    private void retrieveResult() {\n        if (this.resultlist == null && this.resultdoc == null) {\n            this.setResult(((DocumentBuilder)this.getHandler()).getResult());\n        }\n    }\n    \n    public void setHandler(final ContentHandler handler) {\n    }\n    \n    public void setLexicalHandler(final LexicalHandler handler) {\n    }\n    \n    private static class FragmentHandler extends SAXHandler\n    {\n        private Element dummyRoot;\n        \n        public FragmentHandler(final JDOMFactory factory) {\n            super(factory);\n            this.pushElement(this.dummyRoot = new Element(\"root\", null, null));\n        }\n        \n        public List<Content> getResult() {\n            try {\n                this.flushCharacters();\n            }\n            catch (SAXException ex) {}\n            return this.getDetachedContent(this.dummyRoot);\n        }\n        \n        private List<Content> getDetachedContent(final Element elt) {\n            final List<Content> content = elt.getContent();\n            final List<Content> nodes = new ArrayList<Content>(content.size());\n            while (content.size() != 0) {\n                final Content o = content.remove(0);\n                nodes.add(o);\n            }\n            return nodes;\n        }\n    }\n    \n    private class DocumentBuilder extends XMLFilterImpl implements LexicalHandler\n    {\n        private FragmentHandler saxHandler;\n        private boolean startDocumentReceived;\n        \n        public DocumentBuilder() {\n            this.saxHandler = null;\n            this.startDocumentReceived = false;\n        }\n        \n        public List<Content> getResult() {\n            List<Content> mresult = null;\n            if (this.saxHandler != null) {\n                mresult = this.saxHandler.getResult();\n                this.saxHandler = null;\n                this.startDocumentReceived = false;\n            }\n            return mresult;\n        }\n        \n        private void ensureInitialization() throws SAXException {\n            if (!this.startDocumentReceived) {\n                this.startDocument();\n            }\n        }\n        \n        public void startDocument() throws SAXException {\n            this.startDocumentReceived = true;\n            JDOMResult.this.setResult(null);\n            super.setContentHandler(this.saxHandler = new FragmentHandler(JDOMResult.this.getFactory()));\n            super.startDocument();\n        }\n        \n        public void startElement(final String nsURI, final String localName, final String qName, final Attributes atts) throws SAXException {\n            this.ensureInitialization();\n            super.startElement(nsURI, localName, qName, atts);\n        }\n        \n        public void startPrefixMapping(final String prefix, final String uri) throws SAXException {\n            this.ensureInitialization();\n            super.startPrefixMapping(prefix, uri);\n        }\n        \n        public void characters(final char[] ch, final int start, final int length) throws SAXException {\n            this.ensureInitialization();\n            super.characters(ch, start, length);\n        }\n        \n        public void ignorableWhitespace(final char[] ch, final int start, final int length) throws SAXException {\n            this.ensureInitialization();\n            super.ignorableWhitespace(ch, start, length);\n        }\n        \n        public void processingInstruction(final String target, final String data) throws SAXException {\n            this.ensureInitialization();\n            super.processingInstruction(target, data);\n        }\n        \n        public void skippedEntity(final String name) throws SAXException {\n            this.ensureInitialization();\n            super.skippedEntity(name);\n        }\n        \n        public void startDTD(final String name, final String publicId, final String systemId) throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.startDTD(name, publicId, systemId);\n        }\n        \n        public void endDTD() throws SAXException {\n            this.saxHandler.endDTD();\n        }\n        \n        public void startEntity(final String name) throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.startEntity(name);\n        }\n        \n        public void endEntity(final String name) throws SAXException {\n            this.saxHandler.endEntity(name);\n        }\n        \n        public void startCDATA() throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.startCDATA();\n        }\n        \n        public void endCDATA() throws SAXException {\n            this.saxHandler.endCDATA();\n        }\n        \n        public void comment(final char[] ch, final int start, final int length) throws SAXException {\n            this.ensureInitialization();\n            this.saxHandler.comment(ch, start, length);\n        }\n    }\n}\n"
    },
    {
        "project_name": "jdom",
        "class": "NamespaceStack",
        "fqdn": "org.jdom2.util",
        "source_code": "package org.jdom2.util;\n\nimport org.jdom2.internal.*;\nimport org.jdom2.*;\nimport java.util.*;\n\npublic final class NamespaceStack implements Iterable<Namespace>\n{\n    private static final Namespace[] EMPTY;\n    private static final Iterable<Namespace> EMPTYITER;\n    private static final Comparator<Namespace> NSCOMP;\n    private static final Namespace[] DEFAULTSEED;\n    private Namespace[][] added;\n    private Namespace[][] scope;\n    private int depth;\n    \n    private static final int binarySearch(final Namespace[] data, int left, int right, final Namespace key) {\n        --right;\n        while (left <= right) {\n            final int mid = left + right >>> 1;\n            if (data[mid] == key) {\n                return mid;\n            }\n            final int cmp = NamespaceStack.NSCOMP.compare(data[mid], key);\n            if (cmp < 0) {\n                left = mid + 1;\n            }\n            else {\n                if (cmp <= 0) {\n                    return mid;\n                }\n                right = mid - 1;\n            }\n        }\n        return -left - 1;\n    }\n    \n    public NamespaceStack() {\n        this(NamespaceStack.DEFAULTSEED);\n    }\n    \n    public NamespaceStack(final Namespace[] seed) {\n        this.added = new Namespace[10][];\n        this.scope = new Namespace[10][];\n        this.depth = -1;\n        ++this.depth;\n        this.added[this.depth] = seed;\n        this.scope[this.depth] = this.added[this.depth];\n    }\n    \n    private static final Namespace[] checkNamespace(final List<Namespace> store, final Namespace namespace, final Namespace[] scope) {\n        if (namespace == scope[0]) {\n            return scope;\n        }\n        if (namespace.getPrefix().equals(scope[0].getPrefix())) {\n            store.add(namespace);\n            final Namespace[] nscope = ArrayCopy.copyOf(scope, scope.length);\n            nscope[0] = namespace;\n            return nscope;\n        }\n        int ip = binarySearch(scope, 1, scope.length, namespace);\n        if (ip >= 0 && namespace == scope[ip]) {\n            return scope;\n        }\n        store.add(namespace);\n        if (ip >= 0) {\n            final Namespace[] nscope2 = ArrayCopy.copyOf(scope, scope.length);\n            nscope2[ip] = namespace;\n            return nscope2;\n        }\n        final Namespace[] nscope2 = ArrayCopy.copyOf(scope, scope.length + 1);\n        ip = -ip - 1;\n        System.arraycopy(nscope2, ip, nscope2, ip + 1, nscope2.length - ip - 1);\n        nscope2[ip] = namespace;\n        return nscope2;\n    }\n    \n    public void push(final Element element) {\n        final List<Namespace> toadd = new ArrayList<Namespace>(8);\n        final Namespace mns = element.getNamespace();\n        Namespace[] newscope = checkNamespace(toadd, mns, this.scope[this.depth]);\n        if (element.hasAdditionalNamespaces()) {\n            for (final Namespace ns : element.getAdditionalNamespaces()) {\n                if (ns == mns) {\n                    continue;\n                }\n                newscope = checkNamespace(toadd, ns, newscope);\n            }\n        }\n        if (element.hasAttributes()) {\n            for (final Attribute a : element.getAttributes()) {\n                final Namespace ns2 = a.getNamespace();\n                if (ns2 == Namespace.NO_NAMESPACE) {\n                    continue;\n                }\n                if (ns2 == mns) {\n                    continue;\n                }\n                newscope = checkNamespace(toadd, ns2, newscope);\n            }\n        }\n        this.pushStack(mns, newscope, toadd);\n    }\n    \n    public void push(final Attribute att) {\n        final List<Namespace> toadd = new ArrayList<Namespace>(1);\n        final Namespace mns = att.getNamespace();\n        final Namespace[] newscope = checkNamespace(toadd, mns, this.scope[this.depth]);\n        this.pushStack(mns, newscope, toadd);\n    }\n    \n    private final void pushStack(final Namespace mns, Namespace[] newscope, final List<Namespace> toadd) {\n        ++this.depth;\n        if (this.depth >= this.scope.length) {\n            this.scope = ArrayCopy.copyOf(this.scope, this.scope.length * 2);\n            this.added = ArrayCopy.copyOf(this.added, this.scope.length);\n        }\n        if (toadd.isEmpty()) {\n            this.added[this.depth] = NamespaceStack.EMPTY;\n        }\n        else {\n            this.added[this.depth] = toadd.toArray(new Namespace[toadd.size()]);\n            if (this.added[this.depth][0] == mns) {\n                Arrays.sort(this.added[this.depth], 1, this.added[this.depth].length, NamespaceStack.NSCOMP);\n            }\n            else {\n                Arrays.sort(this.added[this.depth], NamespaceStack.NSCOMP);\n            }\n        }\n        if (mns != newscope[0]) {\n            if (toadd.isEmpty()) {\n                newscope = ArrayCopy.copyOf(newscope, newscope.length);\n            }\n            final Namespace tmp = newscope[0];\n            int ip = -binarySearch(newscope, 1, newscope.length, tmp) - 1;\n            --ip;\n            System.arraycopy(newscope, 1, newscope, 0, ip);\n            newscope[ip] = tmp;\n            ip = binarySearch(newscope, 0, newscope.length, mns);\n            System.arraycopy(newscope, 0, newscope, 1, ip);\n            newscope[0] = mns;\n        }\n        this.scope[this.depth] = newscope;\n    }\n    \n    public void pop() {\n        if (this.depth <= 0) {\n            throw new IllegalStateException(\"Cannot over-pop the stack.\");\n        }\n        this.scope[this.depth] = null;\n        this.added[this.depth] = null;\n        --this.depth;\n    }\n    \n    public Iterable<Namespace> addedForward() {\n        if (this.added[this.depth].length == 0) {\n            return NamespaceStack.EMPTYITER;\n        }\n        return new NamespaceIterable(this.added[this.depth], true);\n    }\n    \n    public Iterable<Namespace> addedReverse() {\n        if (this.added[this.depth].length == 0) {\n            return NamespaceStack.EMPTYITER;\n        }\n        return new NamespaceIterable(this.added[this.depth], false);\n    }\n    \n    public Iterator<Namespace> iterator() {\n        return new ForwardWalker(this.scope[this.depth]);\n    }\n    \n    public Namespace[] getScope() {\n        return ArrayCopy.copyOf(this.scope[this.depth], this.scope[this.depth].length);\n    }\n    \n    public boolean isInScope(final Namespace ns) {\n        if (ns == this.scope[this.depth][0]) {\n            return true;\n        }\n        final int ip = binarySearch(this.scope[this.depth], 1, this.scope[this.depth].length, ns);\n        return ip >= 0 && ns == this.scope[this.depth][ip];\n    }\n    \n    static {\n        EMPTY = new Namespace[0];\n        EMPTYITER = new EmptyIterable();\n        NSCOMP = new Comparator<Namespace>() {\n            public int compare(final Namespace ns1, final Namespace ns2) {\n                return ns1.getPrefix().compareTo(ns2.getPrefix());\n            }\n        };\n        DEFAULTSEED = new Namespace[] { Namespace.NO_NAMESPACE, Namespace.XML_NAMESPACE };\n    }\n    \n    private static final class ForwardWalker implements Iterator<Namespace>\n    {\n        private final Namespace[] namespaces;\n        int cursor;\n        \n        public ForwardWalker(final Namespace[] namespaces) {\n            this.cursor = 0;\n            this.namespaces = namespaces;\n        }\n        \n        public boolean hasNext() {\n            return this.cursor < this.namespaces.length;\n        }\n        \n        public Namespace next() {\n            if (this.cursor >= this.namespaces.length) {\n                throw new NoSuchElementException(\"Cannot over-iterate...\");\n            }\n            return this.namespaces[this.cursor++];\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove Namespaces from iterator\");\n        }\n    }\n    \n    private static final class BackwardWalker implements Iterator<Namespace>\n    {\n        private final Namespace[] namespaces;\n        int cursor;\n        \n        public BackwardWalker(final Namespace[] namespaces) {\n            this.cursor = -1;\n            this.namespaces = namespaces;\n            this.cursor = namespaces.length - 1;\n        }\n        \n        public boolean hasNext() {\n            return this.cursor >= 0;\n        }\n        \n        public Namespace next() {\n            if (this.cursor < 0) {\n                throw new NoSuchElementException(\"Cannot over-iterate...\");\n            }\n            return this.namespaces[this.cursor--];\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove Namespaces from iterator\");\n        }\n    }\n    \n    private static final class NamespaceIterable implements Iterable<Namespace>\n    {\n        private final boolean forward;\n        private final Namespace[] namespaces;\n        \n        public NamespaceIterable(final Namespace[] data, final boolean forward) {\n            this.forward = forward;\n            this.namespaces = data;\n        }\n        \n        public Iterator<Namespace> iterator() {\n            return this.forward ? new ForwardWalker(this.namespaces) : new BackwardWalker(this.namespaces);\n        }\n    }\n    \n    private static final class EmptyIterable implements Iterable<Namespace>, Iterator<Namespace>\n    {\n        public Iterator<Namespace> iterator() {\n            return this;\n        }\n        \n        public boolean hasNext() {\n            return false;\n        }\n        \n        public Namespace next() {\n            throw new NoSuchElementException(\"Can not call next() on an empty Iterator.\");\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove Namespaces from iterator\");\n        }\n    }\n}\n"
    },
    {
        "project_name": "jdom",
        "class": "XMLOutputter",
        "fqdn": "org.jdom2.output",
        "source_code": "package org.jdom2.output;\n\nimport java.util.*;\nimport org.jdom2.*;\nimport java.io.*;\nimport org.jdom2.output.support.*;\n\npublic final class XMLOutputter implements Cloneable\n{\n    private static final DefaultXMLProcessor DEFAULTPROCESSOR;\n    private Format myFormat;\n    private XMLOutputProcessor myProcessor;\n    \n    private static final Writer makeWriter(final OutputStream out, final Format format) throws UnsupportedEncodingException {\n        return new BufferedWriter(new OutputStreamWriter(new BufferedOutputStream(out), format.getEncoding()));\n    }\n    \n    public XMLOutputter(final Format format, final XMLOutputProcessor processor) {\n        this.myFormat = null;\n        this.myProcessor = null;\n        this.myFormat = ((format == null) ? Format.getRawFormat() : format.clone());\n        this.myProcessor = ((processor == null) ? XMLOutputter.DEFAULTPROCESSOR : processor);\n    }\n    \n    public XMLOutputter() {\n        this(null, null);\n    }\n    \n    public XMLOutputter(final XMLOutputter that) {\n        this(that.myFormat, null);\n    }\n    \n    public XMLOutputter(final Format format) {\n        this(format, null);\n    }\n    \n    public XMLOutputter(final XMLOutputProcessor processor) {\n        this(null, processor);\n    }\n    \n    public void setFormat(final Format newFormat) {\n        this.myFormat = newFormat.clone();\n    }\n    \n    public Format getFormat() {\n        return this.myFormat;\n    }\n    \n    public XMLOutputProcessor getXMLOutputProcessor() {\n        return this.myProcessor;\n    }\n    \n    public void setXMLOutputProcessor(final XMLOutputProcessor processor) {\n        this.myProcessor = processor;\n    }\n    \n    public final void output(final Document doc, final OutputStream out) throws IOException {\n        this.output(doc, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final DocType doctype, final OutputStream out) throws IOException {\n        this.output(doctype, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final Element element, final OutputStream out) throws IOException {\n        this.output(element, makeWriter(out, this.myFormat));\n    }\n    \n    public final void outputElementContent(final Element element, final OutputStream out) throws IOException {\n        this.outputElementContent(element, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final List<? extends Content> list, final OutputStream out) throws IOException {\n        this.output(list, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final CDATA cdata, final OutputStream out) throws IOException {\n        this.output(cdata, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final Text text, final OutputStream out) throws IOException {\n        this.output(text, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final Comment comment, final OutputStream out) throws IOException {\n        this.output(comment, makeWriter(out, this.myFormat));\n    }\n    \n    public final void output(final ProcessingInstruction pi, final OutputStream out) throws IOException {\n        this.output(pi, makeWriter(out, this.myFormat));\n    }\n    \n    public void output(final EntityRef entity, final OutputStream out) throws IOException {\n        this.output(entity, makeWriter(out, this.myFormat));\n    }\n    \n    public final String outputString(final Document doc) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(doc, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final DocType doctype) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(doctype, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final Element element) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(element, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final List<? extends Content> list) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(list, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final CDATA cdata) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(cdata, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final Text text) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(text, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final Comment comment) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(comment, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final ProcessingInstruction pi) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(pi, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputString(final EntityRef entity) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.output(entity, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final String outputElementContentString(final Element element) {\n        final StringWriter out = new StringWriter();\n        try {\n            this.outputElementContent(element, out);\n        }\n        catch (IOException ex) {}\n        return out.toString();\n    }\n    \n    public final void output(final Document doc, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, doc);\n        out.flush();\n    }\n    \n    public final void output(final DocType doctype, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, doctype);\n        out.flush();\n    }\n    \n    public final void output(final Element element, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, element);\n        out.flush();\n    }\n    \n    public final void outputElementContent(final Element element, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, element.getContent());\n        out.flush();\n    }\n    \n    public final void output(final List<? extends Content> list, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, list);\n        out.flush();\n    }\n    \n    public final void output(final CDATA cdata, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, cdata);\n        out.flush();\n    }\n    \n    public final void output(final Text text, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, text);\n        out.flush();\n    }\n    \n    public final void output(final Comment comment, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, comment);\n        out.flush();\n    }\n    \n    public final void output(final ProcessingInstruction pi, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, pi);\n        out.flush();\n    }\n    \n    public final void output(final EntityRef entity, final Writer out) throws IOException {\n        this.myProcessor.process(out, this.myFormat, entity);\n        out.flush();\n    }\n    \n    public String escapeAttributeEntities(final String str) {\n        return XMLOutputter.DEFAULTPROCESSOR.escapeAttributeEntities(str, this.myFormat);\n    }\n    \n    public String escapeElementEntities(final String str) {\n        return XMLOutputter.DEFAULTPROCESSOR.escapeElementEntities(str, this.myFormat);\n    }\n    \n    public XMLOutputter clone() {\n        try {\n            return (XMLOutputter)super.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e.toString());\n        }\n    }\n    \n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(\"XMLOutputter[omitDeclaration = \");\n        buffer.append(this.myFormat.omitDeclaration);\n        buffer.append(\", \");\n        buffer.append(\"encoding = \");\n        buffer.append(this.myFormat.encoding);\n        buffer.append(\", \");\n        buffer.append(\"omitEncoding = \");\n        buffer.append(this.myFormat.omitEncoding);\n        buffer.append(\", \");\n        buffer.append(\"indent = '\");\n        buffer.append(this.myFormat.indent);\n        buffer.append(\"'\");\n        buffer.append(\", \");\n        buffer.append(\"expandEmptyElements = \");\n        buffer.append(this.myFormat.expandEmptyElements);\n        buffer.append(\", \");\n        buffer.append(\"lineSeparator = '\");\n        for (final char ch : this.myFormat.lineSeparator.toCharArray()) {\n            switch (ch) {\n                case '\\r': {\n                    buffer.append(\"\\\\r\");\n                    break;\n                }\n                case '\\n': {\n                    buffer.append(\"\\\\n\");\n                    break;\n                }\n                case '\\t': {\n                    buffer.append(\"\\\\t\");\n                    break;\n                }\n                default: {\n                    buffer.append(\"[\" + (int)ch + \"]\");\n                    break;\n                }\n            }\n        }\n        buffer.append(\"', \");\n        buffer.append(\"textMode = \");\n        buffer.append(this.myFormat.mode + \"]\");\n        return buffer.toString();\n    }\n    \n    static {\n        DEFAULTPROCESSOR = new DefaultXMLProcessor();\n    }\n    \n    private static final class DefaultXMLProcessor extends AbstractXMLOutputProcessor\n    {\n        public String escapeAttributeEntities(final String str, final Format format) {\n            final StringWriter sw = new StringWriter();\n            try {\n                super.attributeEscapedEntitiesFilter(sw, new FormatStack(format), str);\n            }\n            catch (IOException ex) {}\n            return sw.toString();\n        }\n        \n        public final String escapeElementEntities(final String str, final Format format) {\n            return Format.escapeText(format.getEscapeStrategy(), format.getLineSeparator(), str);\n        }\n    }\n}\n"
    },
    {
        "project_name": "jdom",
        "class": "SAXOutputter",
        "fqdn": "org.jdom2.output",
        "source_code": "package org.jdom2.output;\n\nimport org.xml.sax.ext.*;\nimport java.util.*;\nimport org.jdom2.*;\nimport org.xml.sax.*;\nimport org.jdom2.output.support.*;\n\npublic class SAXOutputter\n{\n    private static final SAXOutputProcessor DEFAULT_PROCESSOR;\n    private ContentHandler contentHandler;\n    private ErrorHandler errorHandler;\n    private DTDHandler dtdHandler;\n    private EntityResolver entityResolver;\n    private LexicalHandler lexicalHandler;\n    private DeclHandler declHandler;\n    private boolean declareNamespaces;\n    private boolean reportDtdEvents;\n    private SAXOutputProcessor processor;\n    private Format format;\n    \n    public SAXOutputter() {\n        this.declareNamespaces = false;\n        this.reportDtdEvents = true;\n        this.processor = SAXOutputter.DEFAULT_PROCESSOR;\n        this.format = Format.getRawFormat();\n    }\n    \n    public SAXOutputter(final ContentHandler contentHandler) {\n        this(contentHandler, null, null, null, null);\n    }\n    \n    public SAXOutputter(final ContentHandler contentHandler, final ErrorHandler errorHandler, final DTDHandler dtdHandler, final EntityResolver entityResolver) {\n        this(contentHandler, errorHandler, dtdHandler, entityResolver, null);\n    }\n    \n    public SAXOutputter(final ContentHandler contentHandler, final ErrorHandler errorHandler, final DTDHandler dtdHandler, final EntityResolver entityResolver, final LexicalHandler lexicalHandler) {\n        this.declareNamespaces = false;\n        this.reportDtdEvents = true;\n        this.processor = SAXOutputter.DEFAULT_PROCESSOR;\n        this.format = Format.getRawFormat();\n        this.contentHandler = contentHandler;\n        this.errorHandler = errorHandler;\n        this.dtdHandler = dtdHandler;\n        this.entityResolver = entityResolver;\n        this.lexicalHandler = lexicalHandler;\n    }\n    \n    public SAXOutputter(final SAXOutputProcessor processor, final Format format, final ContentHandler contentHandler, final ErrorHandler errorHandler, final DTDHandler dtdHandler, final EntityResolver entityResolver, final LexicalHandler lexicalHandler) {\n        this.declareNamespaces = false;\n        this.reportDtdEvents = true;\n        this.processor = SAXOutputter.DEFAULT_PROCESSOR;\n        this.format = Format.getRawFormat();\n        this.processor = ((processor == null) ? SAXOutputter.DEFAULT_PROCESSOR : processor);\n        this.format = ((format == null) ? Format.getRawFormat() : format);\n        this.contentHandler = contentHandler;\n        this.errorHandler = errorHandler;\n        this.dtdHandler = dtdHandler;\n        this.entityResolver = entityResolver;\n        this.lexicalHandler = lexicalHandler;\n    }\n    \n    public void setContentHandler(final ContentHandler contentHandler) {\n        this.contentHandler = contentHandler;\n    }\n    \n    public ContentHandler getContentHandler() {\n        return this.contentHandler;\n    }\n    \n    public void setErrorHandler(final ErrorHandler errorHandler) {\n        this.errorHandler = errorHandler;\n    }\n    \n    public ErrorHandler getErrorHandler() {\n        return this.errorHandler;\n    }\n    \n    public void setDTDHandler(final DTDHandler dtdHandler) {\n        this.dtdHandler = dtdHandler;\n    }\n    \n    public DTDHandler getDTDHandler() {\n        return this.dtdHandler;\n    }\n    \n    public void setEntityResolver(final EntityResolver entityResolver) {\n        this.entityResolver = entityResolver;\n    }\n    \n    public EntityResolver getEntityResolver() {\n        return this.entityResolver;\n    }\n    \n    public void setLexicalHandler(final LexicalHandler lexicalHandler) {\n        this.lexicalHandler = lexicalHandler;\n    }\n    \n    public LexicalHandler getLexicalHandler() {\n        return this.lexicalHandler;\n    }\n    \n    public void setDeclHandler(final DeclHandler declHandler) {\n        this.declHandler = declHandler;\n    }\n    \n    public DeclHandler getDeclHandler() {\n        return this.declHandler;\n    }\n    \n    public boolean getReportNamespaceDeclarations() {\n        return this.declareNamespaces;\n    }\n    \n    public void setReportNamespaceDeclarations(final boolean declareNamespaces) {\n        this.declareNamespaces = declareNamespaces;\n    }\n    \n    public boolean getReportDTDEvents() {\n        return this.reportDtdEvents;\n    }\n    \n    public void setReportDTDEvents(final boolean reportDtdEvents) {\n        this.reportDtdEvents = reportDtdEvents;\n    }\n    \n    public void setFeature(final String name, final boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/features/namespace-prefixes\".equals(name)) {\n            this.setReportNamespaceDeclarations(value);\n        }\n        else if (\"http://xml.org/sax/features/namespaces\".equals(name)) {\n            if (!value) {\n                throw new SAXNotSupportedException(name);\n            }\n        }\n        else {\n            if (!\"http://xml.org/sax/features/validation\".equals(name)) {\n                throw new SAXNotRecognizedException(name);\n            }\n            this.setReportDTDEvents(value);\n        }\n    }\n    \n    public boolean getFeature(final String name) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/features/namespace-prefixes\".equals(name)) {\n            return this.declareNamespaces;\n        }\n        if (\"http://xml.org/sax/features/namespaces\".equals(name)) {\n            return true;\n        }\n        if (\"http://xml.org/sax/features/validation\".equals(name)) {\n            return this.reportDtdEvents;\n        }\n        throw new SAXNotRecognizedException(name);\n    }\n    \n    public void setProperty(final String name, final Object value) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/properties/lexical-handler\".equals(name) || \"http://xml.org/sax/handlers/LexicalHandler\".equals(name)) {\n            this.setLexicalHandler((LexicalHandler)value);\n        }\n        else {\n            if (!\"http://xml.org/sax/properties/declaration-handler\".equals(name) && !\"http://xml.org/sax/handlers/DeclHandler\".equals(name)) {\n                throw new SAXNotRecognizedException(name);\n            }\n            this.setDeclHandler((DeclHandler)value);\n        }\n    }\n    \n    public Object getProperty(final String name) throws SAXNotRecognizedException, SAXNotSupportedException {\n        if (\"http://xml.org/sax/properties/lexical-handler\".equals(name) || \"http://xml.org/sax/handlers/LexicalHandler\".equals(name)) {\n            return this.getLexicalHandler();\n        }\n        if (\"http://xml.org/sax/properties/declaration-handler\".equals(name) || \"http://xml.org/sax/handlers/DeclHandler\".equals(name)) {\n            return this.getDeclHandler();\n        }\n        throw new SAXNotRecognizedException(name);\n    }\n    \n    public SAXOutputProcessor getSAXOutputProcessor() {\n        return this.processor;\n    }\n    \n    public void setSAXOutputProcessor(final SAXOutputProcessor processor) {\n        this.processor = ((processor == null) ? SAXOutputter.DEFAULT_PROCESSOR : processor);\n    }\n    \n    public Format getFormat() {\n        return this.format;\n    }\n    \n    public void setFormat(final Format format) {\n        this.format = ((format == null) ? Format.getRawFormat() : format);\n    }\n    \n    private final SAXTarget buildTarget(final Document doc) {\n        String publicID = null;\n        String systemID = null;\n        if (doc != null) {\n            final DocType dt = doc.getDocType();\n            if (dt != null) {\n                publicID = dt.getPublicID();\n                systemID = dt.getSystemID();\n            }\n        }\n        return new SAXTarget(this.contentHandler, this.errorHandler, this.dtdHandler, this.entityResolver, this.lexicalHandler, this.declHandler, this.declareNamespaces, this.reportDtdEvents, publicID, systemID);\n    }\n    \n    public void output(final Document document) throws JDOMException {\n        this.processor.process(this.buildTarget(document), this.format, document);\n    }\n    \n    public void output(final List<? extends Content> nodes) throws JDOMException {\n        this.processor.processAsDocument(this.buildTarget(null), this.format, nodes);\n    }\n    \n    public void output(final Element node) throws JDOMException {\n        this.processor.processAsDocument(this.buildTarget(null), this.format, node);\n    }\n    \n    public void outputFragment(final List<? extends Content> nodes) throws JDOMException {\n        if (nodes == null) {\n            return;\n        }\n        this.processor.process(this.buildTarget(null), this.format, nodes);\n    }\n    \n    public void outputFragment(final Content node) throws JDOMException {\n        if (node == null) {\n            return;\n        }\n        final SAXTarget out = this.buildTarget(null);\n        switch (node.getCType()) {\n            case CDATA: {\n                this.processor.process(out, this.format, (CDATA)node);\n                break;\n            }\n            case Comment: {\n                this.processor.process(out, this.format, (Comment)node);\n                break;\n            }\n            case Element: {\n                this.processor.process(out, this.format, (Element)node);\n                break;\n            }\n            case EntityRef: {\n                this.processor.process(out, this.format, (EntityRef)node);\n                break;\n            }\n            case ProcessingInstruction: {\n                this.processor.process(out, this.format, (ProcessingInstruction)node);\n                break;\n            }\n            case Text: {\n                this.processor.process(out, this.format, (Text)node);\n                break;\n            }\n            default: {\n                this.handleError(new JDOMException(\"Invalid element content: \" + node));\n                break;\n            }\n        }\n    }\n    \n    private void handleError(final JDOMException exception) throws JDOMException {\n        if (this.errorHandler != null) {\n            try {\n                this.errorHandler.error(new SAXParseException(exception.getMessage(), null, exception));\n                return;\n            }\n            catch (SAXException se) {\n                if (se.getException() instanceof JDOMException) {\n                    throw (JDOMException)se.getException();\n                }\n                throw new JDOMException(se.getMessage(), se);\n            }\n            throw exception;\n        }\n        throw exception;\n    }\n    \n    @Deprecated\n    public JDOMLocator getLocator() {\n        return null;\n    }\n    \n    static {\n        DEFAULT_PROCESSOR = new DefaultSAXOutputProcessor();\n    }\n    \n    private static final class DefaultSAXOutputProcessor extends AbstractSAXOutputProcessor\n    {\n    }\n}\n"
    },
    {
        "project_name": "92_jcvi-javacommon",
        "class": "DefaultPhdReadTag",
        "fqdn": "org.jcvi.jillion.assembly.consed.phd",
        "source_code": "package org.jcvi.jillion.assembly.consed.phd;\n\nimport org.jcvi.jillion.core.*;\nimport java.util.*;\n\nclass DefaultPhdReadTag implements PhdReadTag\n{\n    private final String type;\n    private final String source;\n    private final Range ungappedRange;\n    private final Date date;\n    private final String comment;\n    private final String freeFormData;\n    \n    public DefaultPhdReadTag(final String type, final String source, final Range ungappedRange, final Date date, final String comment, final String freeFormData) {\n        this.type = type;\n        this.source = source;\n        this.ungappedRange = ungappedRange;\n        this.date = date;\n        this.comment = comment;\n        this.freeFormData = freeFormData;\n    }\n    \n    @Override\n    public final String getType() {\n        return this.type;\n    }\n    \n    @Override\n    public final String getSource() {\n        return this.source;\n    }\n    \n    @Override\n    public final Range getUngappedRange() {\n        return this.ungappedRange;\n    }\n    \n    @Override\n    public final Date getDate() {\n        return this.date;\n    }\n    \n    @Override\n    public final String getComment() {\n        return this.comment;\n    }\n    \n    @Override\n    public final String getFreeFormData() {\n        return this.freeFormData;\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + ((this.comment == null) ? 0 : this.comment.hashCode());\n        result = 31 * result + ((this.date == null) ? 0 : this.date.hashCode());\n        result = 31 * result + ((this.freeFormData == null) ? 0 : this.freeFormData.hashCode());\n        result = 31 * result + ((this.source == null) ? 0 : this.source.hashCode());\n        result = 31 * result + ((this.type == null) ? 0 : this.type.hashCode());\n        result = 31 * result + ((this.ungappedRange == null) ? 0 : this.ungappedRange.hashCode());\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof DefaultPhdReadTag)) {\n            return false;\n        }\n        final DefaultPhdReadTag other = (DefaultPhdReadTag)obj;\n        if (this.comment == null) {\n            if (other.comment != null) {\n                return false;\n            }\n        }\n        else if (!this.comment.equals(other.comment)) {\n            return false;\n        }\n        if (this.date == null) {\n            if (other.date != null) {\n                return false;\n            }\n        }\n        else if (!this.date.equals(other.date)) {\n            return false;\n        }\n        if (this.freeFormData == null) {\n            if (other.freeFormData != null) {\n                return false;\n            }\n        }\n        else if (!this.freeFormData.equals(other.freeFormData)) {\n            return false;\n        }\n        if (this.source == null) {\n            if (other.source != null) {\n                return false;\n            }\n        }\n        else if (!this.source.equals(other.source)) {\n            return false;\n        }\n        if (this.type == null) {\n            if (other.type != null) {\n                return false;\n            }\n        }\n        else if (!this.type.equals(other.type)) {\n            return false;\n        }\n        if (this.ungappedRange == null) {\n            if (other.ungappedRange != null) {\n                return false;\n            }\n        }\n        else if (!this.ungappedRange.equals(other.ungappedRange)) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    {
        "project_name": "92_jcvi-javacommon",
        "class": "Distance",
        "fqdn": "org.jcvi.jillion.assembly.ca.frg",
        "source_code": "package org.jcvi.jillion.assembly.ca.frg;\n\npublic final class Distance\n{\n    private static final float SIX = 6.0f;\n    private static final int CA_GATEKEEPER_STDDEV_LIMIT = 3;\n    private static final float MAX_ROUNDING_ERROR = 1.015f;\n    private final int min;\n    private final int max;\n    private final float mean;\n    private final float stdDev;\n    \n    public static Distance buildDistance(final int min, final int max, final float mean, final float stdDev) {\n        return new Distance(min, max, mean, stdDev);\n    }\n    \n    public static Distance buildDistance(final float mean, final float stdDev) {\n        final float delta = calculateDelta(stdDev);\n        final int plusDelta = (int)(mean + delta);\n        final int minusDelta = (int)(mean - delta);\n        return new Distance(Math.min(plusDelta, minusDelta), Math.max(plusDelta, minusDelta), mean, stdDev);\n    }\n    \n    private static float calculateDelta(final float stdDev) {\n        return 3.0f * stdDev;\n    }\n    \n    public static Distance buildDistance(final int min, final int max) {\n        final float mean = computeMean(min, max);\n        final float stdDev = computeStandardDeviation(min, max);\n        return new Distance(min, max, mean, stdDev);\n    }\n    \n    private static float computeStandardDeviation(final int min, final int max) {\n        return (max - min) / 6.0f;\n    }\n    \n    private static float computeMean(final int min, final int max) {\n        return min / 2.0f + max / 2.0f;\n    }\n    \n    public static Distance transformIntoCeleraAssemblerDistance(final Distance distance) {\n        final float mean = distance.getMean();\n        final float stdDev = distance.getStdDev();\n        if (mean < calculateDelta(stdDev)) {\n            final float correctedStdDev = (mean - 1.015f) / 3.0f;\n            return new Distance(distance.getMin(), distance.getMax(), mean, correctedStdDev);\n        }\n        return distance;\n    }\n    \n    private Distance(final int min, final int max, final float mean, final float stdDev) {\n        this.min = min;\n        this.max = max;\n        this.mean = mean;\n        this.stdDev = stdDev;\n    }\n    \n    public float getMean() {\n        return this.mean;\n    }\n    \n    public float getStdDev() {\n        return this.stdDev;\n    }\n    \n    public int getMin() {\n        return this.min;\n    }\n    \n    public int getMax() {\n        return this.max;\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + this.max;\n        result = 31 * result + Float.floatToIntBits(this.mean);\n        result = 31 * result + this.min;\n        result = 31 * result + Float.floatToIntBits(this.stdDev);\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof Distance)) {\n            return false;\n        }\n        final Distance other = (Distance)obj;\n        return this.max == other.max && Float.floatToIntBits(this.mean) == Float.floatToIntBits(other.mean) && this.min == other.min && Float.floatToIntBits(this.stdDev) == Float.floatToIntBits(other.stdDev);\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"%.3f, std: %.3f\", this.mean, this.stdDev);\n    }\n}\n"
    },
    {
        "project_name": "javaml",
        "class": "Complex",
        "fqdn": "net.sf.javaml.core",
        "source_code": "package net.sf.javaml.core;\n\npublic class Complex\n{\n    public double im;\n    public double re;\n    public static final Complex I;\n    \n    public Complex(final double re, final double im) {\n        this.im = 0.0;\n        this.re = 0.0;\n        this.re = re;\n        this.im = im;\n    }\n    \n    public Complex() {\n        this(0.0, 0.0);\n    }\n    \n    @Override\n    public String toString() {\n        return this.re + \" + \" + this.im + \"i\";\n    }\n    \n    public double abs() {\n        return Math.sqrt(this.re * this.re + this.im * this.im);\n    }\n    \n    public void plus(final Complex b) {\n        this.re += b.re;\n        this.im += b.re;\n    }\n    \n    public void minus(final Complex b) {\n        this.re -= b.re;\n        this.im -= b.im;\n    }\n    \n    public void times(final Complex b) {\n        final double real = this.re * b.re - this.im * b.im;\n        final double imag = this.re * b.im + this.im * b.re;\n        this.re = real;\n        this.im = imag;\n    }\n    \n    public void times(final double alpha) {\n        this.re *= alpha;\n        this.im *= alpha;\n    }\n    \n    public void conjugate() {\n        this.im = -this.im;\n    }\n    \n    public static Complex plus(final Complex a, final Complex b) {\n        final double real = a.re + b.re;\n        final double imag = a.im + b.im;\n        return new Complex(real, imag);\n    }\n    \n    public static Complex multiply(final Complex a, final double d) {\n        return new Complex(a.re * d, a.im * d);\n    }\n    \n    public static Complex multiply(final Complex a, final Complex b) {\n        final double real = a.re * b.re - a.im * b.im;\n        final double imag = a.re * b.im + a.im * b.re;\n        return new Complex(real, imag);\n    }\n    \n    static {\n        I = new Complex(0.0, 1.0);\n    }\n}\n"
    },
    {
        "project_name": "javaml",
        "class": "DefaultDataset",
        "fqdn": "net.sf.javaml.core",
        "source_code": "package net.sf.javaml.core;\n\nimport net.sf.javaml.distance.*;\nimport java.util.*;\n\npublic class DefaultDataset extends Vector<Instance> implements Dataset\n{\n    private int maxAttributes;\n    private static final long serialVersionUID = 8586030444860912681L;\n    private TreeSet<Object> classes;\n    \n    public DefaultDataset(final Collection<Instance> coll) {\n        this.maxAttributes = 0;\n        this.classes = new TreeSet<Object>();\n        this.addAll(coll);\n    }\n    \n    public DefaultDataset() {\n        this.maxAttributes = 0;\n        this.classes = new TreeSet<Object>();\n    }\n    \n    private void check(final Collection<? extends Instance> c) {\n        for (final Instance i : c) {\n            this.check(i);\n        }\n    }\n    \n    private void check(final Instance i) {\n        if (i.classValue() != null) {\n            this.classes.add(i.classValue());\n        }\n        if (i.noAttributes() > this.maxAttributes) {\n            this.maxAttributes = i.noAttributes();\n        }\n    }\n    \n    @Override\n    public synchronized boolean addAll(final Collection<? extends Instance> c) {\n        this.check(c);\n        return super.addAll(c);\n    }\n    \n    @Override\n    public synchronized boolean addAll(final int index, final Collection<? extends Instance> c) {\n        this.check(c);\n        return super.addAll(index, c);\n    }\n    \n    @Override\n    public void clear() {\n        this.classes.clear();\n        super.clear();\n    }\n    \n    @Override\n    public synchronized boolean add(final Instance e) {\n        this.check(e);\n        return super.add(e);\n    }\n    \n    @Override\n    public void add(final int index, final Instance e) {\n        this.check(e);\n        super.add(index, e);\n    }\n    \n    @Override\n    public synchronized void addElement(final Instance e) {\n        this.check(e);\n        super.addElement(e);\n    }\n    \n    @Override\n    public synchronized void insertElementAt(final Instance e, final int index) {\n        this.check(e);\n        super.insertElementAt(e, index);\n    }\n    \n    @Override\n    public synchronized void setElementAt(final Instance e, final int index) {\n        this.check(e);\n        super.setElementAt(e, index);\n    }\n    \n    @Override\n    public Instance instance(final int index) {\n        return super.get(index);\n    }\n    \n    @Override\n    public SortedSet<Object> classes() {\n        return this.classes;\n    }\n    \n    @Override\n    public Set<Instance> kNearest(final int k, final Instance inst, final DistanceMeasure dm) {\n        final Map<Instance, Double> closest = new HashMap<Instance, Double>();\n        double max = Double.POSITIVE_INFINITY;\n        for (final Instance tmp : this) {\n            final double d = dm.measure(inst, tmp);\n            if (dm.compare(d, max) && !inst.equals(tmp)) {\n                closest.put(tmp, d);\n                if (closest.size() <= k) {\n                    continue;\n                }\n                max = this.removeFarthest(closest);\n            }\n        }\n        return closest.keySet();\n    }\n    \n    private double removeFarthest(final Map<Instance, Double> vector) {\n        Instance tmp = null;\n        double max = 0.0;\n        for (final Instance inst : vector.keySet()) {\n            final double d = vector.get(inst);\n            if (d > max) {\n                max = d;\n                tmp = inst;\n            }\n        }\n        vector.remove(tmp);\n        return max;\n    }\n    \n    @Override\n    public Dataset[] folds(final int numFolds, final Random rg) {\n        final Dataset[] out = new Dataset[numFolds];\n        final List<Integer> indices = new Vector<Integer>();\n        for (int i = 0; i < this.size(); ++i) {\n            indices.add(i);\n        }\n        final int size = this.size() / numFolds + 1;\n        final int[][] array = new int[numFolds][size];\n        for (int j = 0; j < size; ++j) {\n            for (int k = 0; k < numFolds; ++k) {\n                if (indices.size() > 0) {\n                    array[k][j] = indices.remove(rg.nextInt(indices.size()));\n                }\n                else {\n                    array[k][j] = -1;\n                }\n            }\n        }\n        for (int j = 0; j < numFolds; ++j) {\n            int[] indi;\n            if (array[j][size - 1] == -1) {\n                indi = new int[size - 1];\n                System.arraycopy(array[j], 0, indi, 0, size - 1);\n            }\n            else {\n                indi = new int[size];\n                System.arraycopy(array[j], 0, indi, 0, size);\n            }\n            out[j] = new Fold(this, indi);\n        }\n        return out;\n    }\n    \n    @Override\n    public int noAttributes() {\n        if (this.size() == 0) {\n            return 0;\n        }\n        return this.get(0).noAttributes();\n    }\n    \n    @Override\n    public int classIndex(final Object clazz) {\n        if (clazz != null) {\n            return this.classes().headSet(clazz).size();\n        }\n        return -1;\n    }\n    \n    @Override\n    public Object classValue(final int index) {\n        int i = 0;\n        for (final Object o : this.classes) {\n            if (i == index) {\n                return o;\n            }\n            ++i;\n        }\n        return null;\n    }\n    \n    @Override\n    public Dataset copy() {\n        final DefaultDataset out = new DefaultDataset();\n        for (final Instance i : this) {\n            out.add(i.copy());\n        }\n        return out;\n    }\n}\n"
    },
    {
        "project_name": "javaml",
        "class": "ARFFHandler",
        "fqdn": "net.sf.javaml.tools.data",
        "source_code": "package net.sf.javaml.tools.data;\n\nimport java.io.*;\nimport be.abeel.util.*;\nimport net.sf.javaml.core.*;\nimport java.util.*;\n\npublic class ARFFHandler\n{\n    public static Dataset loadARFF(final File file) throws FileNotFoundException {\n        return loadARFF(file, -1);\n    }\n    \n    public static Dataset loadARFF(final File file, final int classIndex) throws FileNotFoundException {\n        final LineIterator it = new LineIterator(file);\n        it.setSkipBlanks(true);\n        it.setCommentIdentifier(\"%\");\n        it.setSkipComments(true);\n        final Dataset out = new DefaultDataset();\n        boolean dataMode = false;\n        for (final String line : it) {\n            if (dataMode) {\n                final String[] arr = line.split(\",\");\n                double[] values;\n                if (classIndex == -1) {\n                    values = new double[arr.length];\n                }\n                else {\n                    values = new double[arr.length - 1];\n                }\n                String classValue = null;\n                for (int i = 0; i < arr.length; ++i) {\n                    if (i == classIndex) {\n                        classValue = arr[i];\n                    }\n                    else {\n                        double val;\n                        try {\n                            val = Double.parseDouble(arr[i]);\n                        }\n                        catch (NumberFormatException e) {\n                            val = Double.NaN;\n                        }\n                        if (i > classIndex) {\n                            values[i - 1] = val;\n                        }\n                        else {\n                            values[i] = val;\n                        }\n                    }\n                }\n                out.add((Instance)new DenseInstance(values, classValue));\n            }\n            if (line.equalsIgnoreCase(\"@data\")) {\n                dataMode = true;\n            }\n        }\n        return out;\n    }\n}\n"
    },
    {
        "project_name": "javaml",
        "class": "SparseInstance",
        "fqdn": "net.sf.javaml.core",
        "source_code": "package net.sf.javaml.core;\n\nimport java.util.*;\n\npublic class SparseInstance extends AbstractInstance implements Instance\n{\n    private HashMap<Integer, Double> data;\n    private double defaultValue;\n    private int noAttributes;\n    private static final long serialVersionUID = -7642462956857985858L;\n    \n    public void setNoAttributes(final int noAttributes) {\n        this.noAttributes = noAttributes;\n    }\n    \n    public SparseInstance() {\n        this(-1);\n    }\n    \n    public SparseInstance(final int noAttributes) {\n        this(noAttributes, 0.0, null);\n    }\n    \n    public SparseInstance(final int noAttributes, final double defaultValue) {\n        this(noAttributes, defaultValue, null);\n    }\n    \n    public SparseInstance(final int noAttributes, final Object classValue) {\n        this(noAttributes, 0.0, classValue);\n    }\n    \n    public SparseInstance(final int noAttributes, final double defaultValue, final Object classValue) {\n        super(classValue);\n        this.data = new HashMap<Integer, Double>();\n        this.noAttributes = -1;\n        this.defaultValue = defaultValue;\n        this.noAttributes = noAttributes;\n    }\n    \n    public SparseInstance(final double[] datavector) {\n        this(datavector, 0.0, null);\n    }\n    \n    public SparseInstance(final double[] datavector, final double defaultValue) {\n        this(datavector, defaultValue, null);\n    }\n    \n    public SparseInstance(final double[] datavector, final Object classValue) {\n        this(datavector, 0.0, classValue);\n    }\n    \n    public SparseInstance(final double[] datavector, final double defaultValue, final Object classValue) {\n        super(classValue);\n        this.data = new HashMap<Integer, Double>();\n        this.noAttributes = -1;\n        this.defaultValue = defaultValue;\n        this.initiate(datavector);\n    }\n    \n    private void initiate(final double[] datavector) {\n        this.data.clear();\n        this.noAttributes = datavector.length;\n        for (int i = 0; i < datavector.length; ++i) {\n            if (datavector[i] != this.defaultValue) {\n                this.put(Integer.valueOf(i), Double.valueOf(datavector[i]));\n            }\n        }\n    }\n    \n    @Override\n    public double value(final int pos) {\n        return this.get(pos);\n    }\n    \n    @Override\n    public void clear() {\n        this.data.clear();\n    }\n    \n    @Override\n    public boolean containsKey(final Object key) {\n        return this.data.containsKey(key);\n    }\n    \n    @Override\n    public boolean containsValue(final Object value) {\n        return this.data.containsValue(value);\n    }\n    \n    @Override\n    public Set<Map.Entry<Integer, Double>> entrySet() {\n        return this.data.entrySet();\n    }\n    \n    @Override\n    public Double get(final Object key) {\n        if (this.data.containsKey(key)) {\n            return this.data.get(key);\n        }\n        return this.defaultValue;\n    }\n    \n    @Override\n    public boolean isEmpty() {\n        return this.data.isEmpty();\n    }\n    \n    @Override\n    public TreeSet<Integer> keySet() {\n        final TreeSet<Integer> set = new TreeSet<Integer>();\n        set.addAll(this.data.keySet());\n        return set;\n    }\n    \n    @Override\n    public Double put(final Integer key, final Double value) {\n        return this.data.put(key, value);\n    }\n    \n    @Override\n    public void putAll(final Map<? extends Integer, ? extends Double> m) {\n        this.data.putAll(m);\n    }\n    \n    @Override\n    public Double remove(final Object key) {\n        return this.data.remove(key);\n    }\n    \n    @Deprecated\n    @Override\n    public int size() {\n        return this.data.size();\n    }\n    \n    @Override\n    public Collection<Double> values() {\n        return this.data.values();\n    }\n    \n    @Override\n    public int noAttributes() {\n        if (this.noAttributes >= 0) {\n            return this.noAttributes;\n        }\n        if (this.data.keySet().size() == 0) {\n            return 0;\n        }\n        return Collections.max((Collection<? extends Integer>)this.data.keySet()) + 1;\n    }\n    \n    @Override\n    public void removeAttribute(final int remove) {\n        this.data.remove(remove);\n        final List<Integer> indices = new Vector<Integer>();\n        indices.addAll(this.data.keySet());\n        Collections.sort(indices);\n        for (int i = 0; i < indices.size(); ++i) {\n            final int index = indices.get(i);\n            if (index > remove) {\n                this.data.put(index - 1, this.data.get(index));\n                this.data.remove(index);\n            }\n        }\n        --this.noAttributes;\n    }\n    \n    @Override\n    public String toString() {\n        return \"{\" + this.data.toString() + \";\" + this.classValue() + \"}\";\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + ((this.data == null) ? 0 : this.data.hashCode());\n        final long temp = Double.doubleToLongBits(this.defaultValue);\n        result = 31 * result + (int)(temp ^ temp >>> 32);\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final SparseInstance other = (SparseInstance)obj;\n        if (this.data == null) {\n            if (other.data != null) {\n                return false;\n            }\n        }\n        else if (!this.data.equals(other.data)) {\n            return false;\n        }\n        return Double.doubleToLongBits(this.defaultValue) == Double.doubleToLongBits(other.defaultValue);\n    }\n    \n    @Override\n    public Instance copy() {\n        final SparseInstance out = new SparseInstance();\n        (out.data = new HashMap<Integer, Double>()).putAll(this.data);\n        out.defaultValue = this.defaultValue;\n        out.noAttributes = this.noAttributes;\n        out.setClassValue(this.classValue());\n        return out;\n    }\n    \n    @Override\n    public void removeAttributes(final Set<Integer> indices) {\n        final List<Integer> indix = new Vector<Integer>();\n        indix.addAll(indices);\n        Collections.sort(indix);\n        for (int i = indix.size() - 1; i >= 0; --i) {\n            this.removeAttribute(indix.get(i));\n        }\n    }\n}\n"
    },
    {
        "project_name": "javaml",
        "class": "DenseInstance",
        "fqdn": "net.sf.javaml.core",
        "source_code": "package net.sf.javaml.core;\n\nimport java.util.*;\n\npublic class DenseInstance extends AbstractInstance implements Instance\n{\n    private static final long serialVersionUID = 3284511291715269081L;\n    private double[] attributes;\n    \n    public DenseInstance(final double[] att) {\n        this(att, null);\n    }\n    \n    public DenseInstance(final double[] att, final Object classValue) {\n        super(classValue);\n        this.attributes = att.clone();\n    }\n    \n    private DenseInstance() {\n    }\n    \n    public DenseInstance(final int size) {\n        this(new double[size]);\n    }\n    \n    @Override\n    public double value(final int pos) {\n        return this.attributes[pos];\n    }\n    \n    @Override\n    public void clear() {\n        this.attributes = new double[this.attributes.length];\n    }\n    \n    @Override\n    public boolean containsKey(final Object key) {\n        if (key instanceof Integer) {\n            final int i = (int)key;\n            return i >= 0 && i < this.attributes.length;\n        }\n        return false;\n    }\n    \n    @Override\n    public boolean containsValue(final Object value) {\n        if (value instanceof Number) {\n            final double val = ((Number)value).doubleValue();\n            for (int i = 0; i < this.attributes.length; ++i) {\n                if (Math.abs(val - this.attributes[i]) < 1.0E-8) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    @Override\n    public Set<Map.Entry<Integer, Double>> entrySet() {\n        final HashMap<Integer, Double> map = new HashMap<Integer, Double>();\n        for (int i = 0; i < this.attributes.length; ++i) {\n            map.put(i, this.attributes[i]);\n        }\n        return map.entrySet();\n    }\n    \n    @Override\n    public Double get(final Object key) {\n        return this.attributes[(int)key];\n    }\n    \n    @Override\n    public boolean isEmpty() {\n        return false;\n    }\n    \n    @Override\n    public SortedSet<Integer> keySet() {\n        final TreeSet<Integer> keys = new TreeSet<Integer>();\n        for (int i = 0; i < this.attributes.length; ++i) {\n            keys.add(i);\n        }\n        return keys;\n    }\n    \n    @Override\n    public Double put(final Integer key, final Double value) {\n        final double val = this.attributes[key];\n        this.attributes[key] = value;\n        return val;\n    }\n    \n    @Override\n    public void putAll(final Map<? extends Integer, ? extends Double> m) {\n        for (final Integer key : m.keySet()) {\n            this.attributes[key] = (double)m.get(key);\n        }\n    }\n    \n    @Override\n    public Double remove(final Object key) {\n        throw new UnsupportedOperationException(\"Cannot unset values from a dense instance.\");\n    }\n    \n    @Deprecated\n    @Override\n    public int size() {\n        return this.attributes.length;\n    }\n    \n    @Override\n    public Collection<Double> values() {\n        final Collection<Double> vals = new ArrayList<Double>();\n        for (final double v : this.attributes) {\n            vals.add(v);\n        }\n        return vals;\n    }\n    \n    @Override\n    public int noAttributes() {\n        return this.attributes.length;\n    }\n    \n    @Override\n    public String toString() {\n        return \"{\" + Arrays.toString(this.attributes) + \";\" + this.classValue() + \"}\";\n    }\n    \n    @Override\n    public void removeAttribute(final int i) {\n        final double[] tmp = this.attributes.clone();\n        System.arraycopy(tmp, 0, this.attributes = new double[tmp.length - 1], 0, i);\n        System.arraycopy(tmp, i + 1, this.attributes, i, tmp.length - i - 1);\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + Arrays.hashCode(this.attributes);\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final DenseInstance other = (DenseInstance)obj;\n        return Arrays.equals(this.attributes, other.attributes);\n    }\n    \n    @Override\n    public Instance copy() {\n        final DenseInstance out = new DenseInstance();\n        out.attributes = this.attributes.clone();\n        out.setClassValue(this.classValue());\n        return out;\n    }\n    \n    @Override\n    public void removeAttributes(final Set<Integer> indices) {\n        final double[] tmp = this.attributes.clone();\n        this.attributes = new double[tmp.length - indices.size()];\n        int index = 0;\n        for (int i = 0; i < tmp.length; ++i) {\n            if (!indices.contains(i)) {\n                this.attributes[index++] = tmp[i];\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "javaml",
        "class": "AbstractInstance",
        "fqdn": "net.sf.javaml.core",
        "source_code": "package net.sf.javaml.core;\n\nimport java.util.*;\n\npublic abstract class AbstractInstance implements Instance\n{\n    private static final long serialVersionUID = -1712202124913999825L;\n    static int nextID;\n    private final int ID;\n    private Object classValue;\n    \n    @Override\n    public int getID() {\n        return this.ID;\n    }\n    \n    @Override\n    public Iterator<Double> iterator() {\n        return new InstanceValueIterator();\n    }\n    \n    protected AbstractInstance() {\n        this(null);\n    }\n    \n    protected AbstractInstance(final Object classValue) {\n        this.ID = AbstractInstance.nextID;\n        ++AbstractInstance.nextID;\n        this.classValue = classValue;\n    }\n    \n    @Override\n    public Object classValue() {\n        return this.classValue;\n    }\n    \n    @Override\n    public void setClassValue(final Object classValue) {\n        this.classValue = classValue;\n    }\n    \n    @Override\n    public Instance minus(final Instance min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) - ((Map<K, Double>)min).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance minus(final double min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) - min);\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance divide(final double min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) / min);\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance multiply(final double value) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) * value);\n        }\n        return out;\n    }\n    \n    @Override\n    public int hashCode() {\n        return this.ID;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final AbstractInstance other = (AbstractInstance)obj;\n        return this.ID == other.ID;\n    }\n    \n    @Override\n    public Instance multiply(final Instance value) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) * ((Map<K, Double>)value).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance divide(final Instance min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) / ((Map<K, Double>)min).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance add(final double min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) + min);\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance add(final Instance min) {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, ((Map<K, Double>)this).get(i) + ((Map<K, Double>)min).get(i));\n        }\n        return out;\n    }\n    \n    @Override\n    public Instance sqrt() {\n        final Instance out = new DenseInstance(new double[this.noAttributes()]);\n        for (int i = 0; i < this.noAttributes(); ++i) {\n            out.put(i, Math.sqrt(((Map<K, Double>)this).get(i)));\n        }\n        return out;\n    }\n    \n    static {\n        AbstractInstance.nextID = 0;\n    }\n    \n    class InstanceValueIterator implements Iterator<Double>\n    {\n        private int index;\n        \n        InstanceValueIterator() {\n            this.index = 0;\n        }\n        \n        @Override\n        public boolean hasNext() {\n            return this.index < AbstractInstance.this.noAttributes() - 1;\n        }\n        \n        @Override\n        public Double next() {\n            ++this.index;\n            return AbstractInstance.this.value(this.index - 1);\n        }\n        \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove from instance using the iterator.\");\n        }\n    }\n}\n"
    },
    {
        "project_name": "javaml",
        "class": "Fold",
        "fqdn": "net.sf.javaml.core",
        "source_code": "package net.sf.javaml.core;\n\nimport net.sf.javaml.distance.*;\nimport java.util.*;\n\nclass Fold implements Dataset\n{\n    private int[] indices;\n    private Dataset parent;\n    \n    public Fold(final Dataset parent, final int[] indices) {\n        this.indices = indices;\n        this.parent = parent;\n    }\n    \n    @Override\n    public boolean add(final Instance i) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public SortedSet<Object> classes() {\n        return this.parent.classes();\n    }\n    \n    @Override\n    public Dataset[] folds(final int numFolds, final Random rg) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public Instance instance(final int index) {\n        return this.parent.instance(this.indices[index]);\n    }\n    \n    @Override\n    public Set<Instance> kNearest(final int k, final Instance inst, final DistanceMeasure dm) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public void add(final int index, final Instance element) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public boolean addAll(final Collection<? extends Instance> c) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public boolean addAll(final int index, final Collection<? extends Instance> c) {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException(\"Cannot do this on a fold of a dataset\");\n    }\n    \n    @Override\n    public boolean contains(final Object o) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public boolean containsAll(final Collection<?> c) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public Instance get(final int index) {\n        return this.instance(index);\n    }\n    \n    @Override\n    public int indexOf(final Object o) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public boolean isEmpty() {\n        return false;\n    }\n    \n    @Override\n    public Iterator<Instance> iterator() {\n        return new FoldIterator();\n    }\n    \n    @Override\n    public int lastIndexOf(final Object o) {\n        throw new UnsupportedOperationException(\"Method is not yet implemented\");\n    }\n    \n    @Override\n    public ListIterator<Instance> listIterator() {\n        return new FoldIterator();\n    }\n    \n    @Override\n    public ListIterator<Instance> listIterator(final int index) {\n        return new FoldIterator(index);\n    }\n    \n    @Override\n    public boolean remove(final Object o) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public Instance remove(final int index) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public boolean removeAll(final Collection<?> c) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public boolean retainAll(final Collection<?> c) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public Instance set(final int index, final Instance element) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public int size() {\n        return this.indices.length;\n    }\n    \n    @Override\n    public List<Instance> subList(final int fromIndex, final int toIndex) {\n        throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n    }\n    \n    @Override\n    public Object[] toArray() {\n        final Object[] out = new Object[this.indices.length];\n        for (int i = 0; i < this.size(); ++i) {\n            out[i] = this.instance(i);\n        }\n        return out;\n    }\n    \n    @Override\n    public <T> T[] toArray(final T[] a) {\n        final Vector<T> tmp = new Vector<T>();\n        for (final Instance i : this) {\n            tmp.add((T)i);\n        }\n        return tmp.toArray(a);\n    }\n    \n    @Override\n    public int noAttributes() {\n        return this.parent.noAttributes();\n    }\n    \n    @Override\n    public int classIndex(final Object clazz) {\n        return this.parent.classIndex(clazz);\n    }\n    \n    @Override\n    public Object classValue(final int index) {\n        return this.parent.classValue(index);\n    }\n    \n    @Override\n    public Dataset copy() {\n        final Dataset out = new DefaultDataset();\n        for (final Instance i : this) {\n            out.add(i.copy());\n        }\n        return out;\n    }\n    \n    class FoldIterator implements ListIterator<Instance>\n    {\n        private int currentIndex;\n        \n        public FoldIterator(final int index) {\n            this.currentIndex = 0;\n            this.currentIndex = index;\n        }\n        \n        public FoldIterator(final Fold fold) {\n            this(fold, 0);\n        }\n        \n        @Override\n        public boolean hasNext() {\n            return this.currentIndex < Fold.this.indices.length;\n        }\n        \n        @Override\n        public Instance next() {\n            ++this.currentIndex;\n            return Fold.this.instance(this.currentIndex - 1);\n        }\n        \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n        }\n        \n        @Override\n        public void add(final Instance arg0) {\n            throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n        }\n        \n        @Override\n        public boolean hasPrevious() {\n            return this.currentIndex > 0;\n        }\n        \n        @Override\n        public int nextIndex() {\n            return this.currentIndex;\n        }\n        \n        @Override\n        public Instance previous() {\n            --this.currentIndex;\n            return Fold.this.instance(this.currentIndex);\n        }\n        \n        @Override\n        public int previousIndex() {\n            return this.currentIndex;\n        }\n        \n        @Override\n        public void set(final Instance arg0) {\n            throw new UnsupportedOperationException(\"You cannot do this on a fold.\");\n        }\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "CacheBuilderSpec",
        "fqdn": "com.google.common.cache",
        "source_code": "package com.google.common.cache;\n\nimport com.google.common.annotations.*;\nimport java.util.concurrent.*;\nimport com.google.common.collect.*;\nimport java.util.*;\nimport com.google.common.base.*;\nimport javax.annotation.*;\n\n@Beta\npublic final class CacheBuilderSpec\n{\n    private static final Splitter KEYS_SPLITTER;\n    private static final Splitter KEY_VALUE_SPLITTER;\n    private static final ImmutableMap<String, ValueParser> VALUE_PARSERS;\n    @VisibleForTesting\n    Integer initialCapacity;\n    @VisibleForTesting\n    Long maximumSize;\n    @VisibleForTesting\n    Long maximumWeight;\n    @VisibleForTesting\n    Integer concurrencyLevel;\n    @VisibleForTesting\n    LocalCache.Strength keyStrength;\n    @VisibleForTesting\n    LocalCache.Strength valueStrength;\n    @VisibleForTesting\n    Boolean recordStats;\n    @VisibleForTesting\n    long writeExpirationDuration;\n    @VisibleForTesting\n    TimeUnit writeExpirationTimeUnit;\n    @VisibleForTesting\n    long accessExpirationDuration;\n    @VisibleForTesting\n    TimeUnit accessExpirationTimeUnit;\n    @VisibleForTesting\n    long refreshDuration;\n    @VisibleForTesting\n    TimeUnit refreshTimeUnit;\n    private final String specification;\n    \n    private CacheBuilderSpec(final String specification) {\n        this.specification = specification;\n    }\n    \n    public static CacheBuilderSpec parse(final String cacheBuilderSpecification) {\n        final CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);\n        if (!cacheBuilderSpecification.isEmpty()) {\n            for (final String keyValuePair : CacheBuilderSpec.KEYS_SPLITTER.split(cacheBuilderSpecification)) {\n                final List<String> keyAndValue = (List<String>)ImmutableList.copyOf((Iterable<?>)CacheBuilderSpec.KEY_VALUE_SPLITTER.split(keyValuePair));\n                Preconditions.checkArgument(!keyAndValue.isEmpty(), (Object)\"blank key-value pair\");\n                Preconditions.checkArgument(keyAndValue.size() <= 2, \"key-value pair %s with more than one equals sign\", keyValuePair);\n                final String key = keyAndValue.get(0);\n                final ValueParser valueParser = CacheBuilderSpec.VALUE_PARSERS.get(key);\n                Preconditions.checkArgument(valueParser != null, \"unknown key %s\", key);\n                final String value = (keyAndValue.size() == 1) ? null : keyAndValue.get(1);\n                valueParser.parse(spec, key, value);\n            }\n        }\n        return spec;\n    }\n    \n    public static CacheBuilderSpec disableCaching() {\n        return parse(\"maximumSize=0\");\n    }\n    \n    CacheBuilder<Object, Object> toCacheBuilder() {\n        final CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();\n        if (this.initialCapacity != null) {\n            builder.initialCapacity(this.initialCapacity);\n        }\n        if (this.maximumSize != null) {\n            builder.maximumSize(this.maximumSize);\n        }\n        if (this.maximumWeight != null) {\n            builder.maximumWeight(this.maximumWeight);\n        }\n        if (this.concurrencyLevel != null) {\n            builder.concurrencyLevel(this.concurrencyLevel);\n        }\n        if (this.keyStrength != null) {\n            switch (this.keyStrength) {\n                case WEAK: {\n                    builder.weakKeys();\n                    break;\n                }\n                default: {\n                    throw new AssertionError();\n                }\n            }\n        }\n        if (this.valueStrength != null) {\n            switch (this.valueStrength) {\n                case SOFT: {\n                    builder.softValues();\n                    break;\n                }\n                case WEAK: {\n                    builder.weakValues();\n                    break;\n                }\n                default: {\n                    throw new AssertionError();\n                }\n            }\n        }\n        if (this.recordStats != null && this.recordStats) {\n            builder.recordStats();\n        }\n        if (this.writeExpirationTimeUnit != null) {\n            builder.expireAfterWrite(this.writeExpirationDuration, this.writeExpirationTimeUnit);\n        }\n        if (this.accessExpirationTimeUnit != null) {\n            builder.expireAfterAccess(this.accessExpirationDuration, this.accessExpirationTimeUnit);\n        }\n        if (this.refreshTimeUnit != null) {\n            builder.refreshAfterWrite(this.refreshDuration, this.refreshTimeUnit);\n        }\n        return builder;\n    }\n    \n    public String toParsableString() {\n        return this.specification;\n    }\n    \n    @Override\n    public String toString() {\n        return MoreObjects.toStringHelper(this).addValue(this.toParsableString()).toString();\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hashCode(this.initialCapacity, this.maximumSize, this.maximumWeight, this.concurrencyLevel, this.keyStrength, this.valueStrength, this.recordStats, durationInNanos(this.writeExpirationDuration, this.writeExpirationTimeUnit), durationInNanos(this.accessExpirationDuration, this.accessExpirationTimeUnit), durationInNanos(this.refreshDuration, this.refreshTimeUnit));\n    }\n    \n    @Override\n    public boolean equals(@Nullable final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof CacheBuilderSpec)) {\n            return false;\n        }\n        final CacheBuilderSpec that = (CacheBuilderSpec)obj;\n        return Objects.equal(this.initialCapacity, that.initialCapacity) && Objects.equal(this.maximumSize, that.maximumSize) && Objects.equal(this.maximumWeight, that.maximumWeight) && Objects.equal(this.concurrencyLevel, that.concurrencyLevel) && Objects.equal(this.keyStrength, that.keyStrength) && Objects.equal(this.valueStrength, that.valueStrength) && Objects.equal(this.recordStats, that.recordStats) && Objects.equal(durationInNanos(this.writeExpirationDuration, this.writeExpirationTimeUnit), durationInNanos(that.writeExpirationDuration, that.writeExpirationTimeUnit)) && Objects.equal(durationInNanos(this.accessExpirationDuration, this.accessExpirationTimeUnit), durationInNanos(that.accessExpirationDuration, that.accessExpirationTimeUnit)) && Objects.equal(durationInNanos(this.refreshDuration, this.refreshTimeUnit), durationInNanos(that.refreshDuration, that.refreshTimeUnit));\n    }\n    \n    @Nullable\n    private static Long durationInNanos(final long duration, @Nullable final TimeUnit unit) {\n        return (unit == null) ? null : unit.toNanos(duration);\n    }\n    \n    static {\n        KEYS_SPLITTER = Splitter.on(',').trimResults();\n        KEY_VALUE_SPLITTER = Splitter.on('=').trimResults();\n        VALUE_PARSERS = ImmutableMap.builder().put(\"initialCapacity\", new InitialCapacityParser()).put(\"maximumSize\", (InitialCapacityParser)new MaximumSizeParser()).put(\"maximumWeight\", (InitialCapacityParser)new MaximumWeightParser()).put(\"concurrencyLevel\", (InitialCapacityParser)new ConcurrencyLevelParser()).put(\"weakKeys\", (InitialCapacityParser)new KeyStrengthParser(LocalCache.Strength.WEAK)).put(\"softValues\", (InitialCapacityParser)new ValueStrengthParser(LocalCache.Strength.SOFT)).put(\"weakValues\", (InitialCapacityParser)new ValueStrengthParser(LocalCache.Strength.WEAK)).put(\"recordStats\", (InitialCapacityParser)new RecordStatsParser()).put(\"expireAfterAccess\", (InitialCapacityParser)new AccessDurationParser()).put(\"expireAfterWrite\", (InitialCapacityParser)new WriteDurationParser()).put(\"refreshAfterWrite\", (InitialCapacityParser)new RefreshDurationParser()).put(\"refreshInterval\", (InitialCapacityParser)new RefreshDurationParser()).build();\n    }\n    \n    abstract static class IntegerParser implements ValueParser\n    {\n        protected abstract void parseInteger(final CacheBuilderSpec p0, final int p1);\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, final String value) {\n            Preconditions.checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try {\n                this.parseInteger(spec, Integer.parseInt(value));\n            }\n            catch (NumberFormatException e) {\n                throw new IllegalArgumentException(String.format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n    \n    abstract static class LongParser implements ValueParser\n    {\n        protected abstract void parseLong(final CacheBuilderSpec p0, final long p1);\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, final String value) {\n            Preconditions.checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try {\n                this.parseLong(spec, Long.parseLong(value));\n            }\n            catch (NumberFormatException e) {\n                throw new IllegalArgumentException(String.format(\"key %s value set to %s, must be integer\", key, value), e);\n            }\n        }\n    }\n    \n    static class InitialCapacityParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(final CacheBuilderSpec spec, final int value) {\n            Preconditions.checkArgument(spec.initialCapacity == null, \"initial capacity was already set to \", spec.initialCapacity);\n            spec.initialCapacity = value;\n        }\n    }\n    \n    static class MaximumSizeParser extends LongParser\n    {\n        @Override\n        protected void parseLong(final CacheBuilderSpec spec, final long value) {\n            Preconditions.checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            Preconditions.checkArgument(spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            spec.maximumSize = value;\n        }\n    }\n    \n    static class MaximumWeightParser extends LongParser\n    {\n        @Override\n        protected void parseLong(final CacheBuilderSpec spec, final long value) {\n            Preconditions.checkArgument(spec.maximumWeight == null, \"maximum weight was already set to \", spec.maximumWeight);\n            Preconditions.checkArgument(spec.maximumSize == null, \"maximum size was already set to \", spec.maximumSize);\n            spec.maximumWeight = value;\n        }\n    }\n    \n    static class ConcurrencyLevelParser extends IntegerParser\n    {\n        @Override\n        protected void parseInteger(final CacheBuilderSpec spec, final int value) {\n            Preconditions.checkArgument(spec.concurrencyLevel == null, \"concurrency level was already set to \", spec.concurrencyLevel);\n            spec.concurrencyLevel = value;\n        }\n    }\n    \n    static class KeyStrengthParser implements ValueParser\n    {\n        private final LocalCache.Strength strength;\n        \n        public KeyStrengthParser(final LocalCache.Strength strength) {\n            this.strength = strength;\n        }\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, @Nullable final String value) {\n            Preconditions.checkArgument(value == null, \"key %s does not take values\", key);\n            Preconditions.checkArgument(spec.keyStrength == null, \"%s was already set to %s\", key, spec.keyStrength);\n            spec.keyStrength = this.strength;\n        }\n    }\n    \n    static class ValueStrengthParser implements ValueParser\n    {\n        private final LocalCache.Strength strength;\n        \n        public ValueStrengthParser(final LocalCache.Strength strength) {\n            this.strength = strength;\n        }\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, @Nullable final String value) {\n            Preconditions.checkArgument(value == null, \"key %s does not take values\", key);\n            Preconditions.checkArgument(spec.valueStrength == null, \"%s was already set to %s\", key, spec.valueStrength);\n            spec.valueStrength = this.strength;\n        }\n    }\n    \n    static class RecordStatsParser implements ValueParser\n    {\n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, @Nullable final String value) {\n            Preconditions.checkArgument(value == null, (Object)\"recordStats does not take values\");\n            Preconditions.checkArgument(spec.recordStats == null, (Object)\"recordStats already set\");\n            spec.recordStats = true;\n        }\n    }\n    \n    abstract static class DurationParser implements ValueParser\n    {\n        protected abstract void parseDuration(final CacheBuilderSpec p0, final long p1, final TimeUnit p2);\n        \n        @Override\n        public void parse(final CacheBuilderSpec spec, final String key, final String value) {\n            Preconditions.checkArgument(value != null && !value.isEmpty(), \"value of key %s omitted\", key);\n            try {\n                final char lastChar = value.charAt(value.length() - 1);\n                TimeUnit timeUnit = null;\n                switch (lastChar) {\n                    case 'd': {\n                        timeUnit = TimeUnit.DAYS;\n                        break;\n                    }\n                    case 'h': {\n                        timeUnit = TimeUnit.HOURS;\n                        break;\n                    }\n                    case 'm': {\n                        timeUnit = TimeUnit.MINUTES;\n                        break;\n                    }\n                    case 's': {\n                        timeUnit = TimeUnit.SECONDS;\n                        break;\n                    }\n                    default: {\n                        throw new IllegalArgumentException(String.format(\"key %s invalid format.  was %s, must end with one of [dDhHmMsS]\", key, value));\n                    }\n                }\n                final long duration = Long.parseLong(value.substring(0, value.length() - 1));\n                this.parseDuration(spec, duration, timeUnit);\n            }\n            catch (NumberFormatException e) {\n                throw new IllegalArgumentException(String.format(\"key %s value set to %s, must be integer\", key, value));\n            }\n        }\n    }\n    \n    static class AccessDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(final CacheBuilderSpec spec, final long duration, final TimeUnit unit) {\n            Preconditions.checkArgument(spec.accessExpirationTimeUnit == null, (Object)\"expireAfterAccess already set\");\n            spec.accessExpirationDuration = duration;\n            spec.accessExpirationTimeUnit = unit;\n        }\n    }\n    \n    static class WriteDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(final CacheBuilderSpec spec, final long duration, final TimeUnit unit) {\n            Preconditions.checkArgument(spec.writeExpirationTimeUnit == null, (Object)\"expireAfterWrite already set\");\n            spec.writeExpirationDuration = duration;\n            spec.writeExpirationTimeUnit = unit;\n        }\n    }\n    \n    static class RefreshDurationParser extends DurationParser\n    {\n        @Override\n        protected void parseDuration(final CacheBuilderSpec spec, final long duration, final TimeUnit unit) {\n            Preconditions.checkArgument(spec.refreshTimeUnit == null, (Object)\"refreshAfterWrite already set\");\n            spec.refreshDuration = duration;\n            spec.refreshTimeUnit = unit;\n        }\n    }\n    \n    private interface ValueParser\n    {\n        void parse(final CacheBuilderSpec p0, final String p1, @Nullable final String p2);\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "Utf8",
        "fqdn": "com.google.common.base",
        "source_code": "package com.google.common.base;\n\nimport com.google.common.annotations.*;\n\n@Beta\n@GwtCompatible\npublic final class Utf8\n{\n    public static int encodedLength(final CharSequence sequence) {\n        int utf8Length;\n        int utf16Length;\n        int i;\n        for (utf16Length = (utf8Length = sequence.length()), i = 0; i < utf16Length && sequence.charAt(i) < '\\u0080'; ++i) {}\n        while (i < utf16Length) {\n            final char c = sequence.charAt(i);\n            if (c >= '\\u0800') {\n                utf8Length += encodedLengthGeneral(sequence, i);\n                break;\n            }\n            utf8Length += '\\u007f' - c >>> 31;\n            ++i;\n        }\n        if (utf8Length < utf16Length) {\n            throw new IllegalArgumentException(new StringBuilder(54).append(\"UTF-8 length does not fit in int: \").append(utf8Length + 4294967296L).toString());\n        }\n        return utf8Length;\n    }\n    \n    private static int encodedLengthGeneral(final CharSequence sequence, final int start) {\n        final int utf16Length = sequence.length();\n        int utf8Length = 0;\n        for (int i = start; i < utf16Length; ++i) {\n            final char c = sequence.charAt(i);\n            if (c < '\\u0800') {\n                utf8Length += '\\u007f' - c >>> 31;\n            }\n            else {\n                utf8Length += 2;\n                if ('\\ud800' <= c && c <= '\\udfff') {\n                    final int cp = Character.codePointAt(sequence, i);\n                    if (cp < 65536) {\n                        throw new IllegalArgumentException(new StringBuilder(39).append(\"Unpaired surrogate at index \").append(i).toString());\n                    }\n                    ++i;\n                }\n            }\n        }\n        return utf8Length;\n    }\n    \n    public static boolean isWellFormed(final byte[] bytes) {\n        return isWellFormed(bytes, 0, bytes.length);\n    }\n    \n    public static boolean isWellFormed(final byte[] bytes, final int off, final int len) {\n        final int end = off + len;\n        Preconditions.checkPositionIndexes(off, end, bytes.length);\n        for (int i = off; i < end; ++i) {\n            if (bytes[i] < 0) {\n                return isWellFormedSlowPath(bytes, i, end);\n            }\n        }\n        return true;\n    }\n    \n    private static boolean isWellFormedSlowPath(final byte[] bytes, final int off, final int end) {\n        int index = off;\n        while (index < end) {\n            final int byte1;\n            if ((byte1 = bytes[index++]) < 0) {\n                if (byte1 < -32) {\n                    if (index == end) {\n                        return false;\n                    }\n                    if (byte1 < -62 || bytes[index++] > -65) {\n                        return false;\n                    }\n                    continue;\n                }\n                else if (byte1 < -16) {\n                    if (index + 1 >= end) {\n                        return false;\n                    }\n                    final int byte2 = bytes[index++];\n                    if (byte2 > -65 || (byte1 == -32 && byte2 < -96) || (byte1 == -19 && -96 <= byte2) || bytes[index++] > -65) {\n                        return false;\n                    }\n                    continue;\n                }\n                else {\n                    if (index + 2 >= end) {\n                        return false;\n                    }\n                    final int byte2 = bytes[index++];\n                    if (byte2 > -65 || (byte1 << 28) + (byte2 + 112) >> 30 != 0 || bytes[index++] > -65 || bytes[index++] > -65) {\n                        return false;\n                    }\n                    continue;\n                }\n            }\n        }\n        return true;\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "Joiner",
        "fqdn": "com.google.common.base",
        "source_code": "package com.google.common.base;\n\nimport java.io.*;\nimport javax.annotation.*;\nimport java.util.*;\nimport com.google.common.annotations.*;\n\n@GwtCompatible\npublic class Joiner\n{\n    private final String separator;\n    \n    public static Joiner on(final String separator) {\n        return new Joiner(separator);\n    }\n    \n    public static Joiner on(final char separator) {\n        return new Joiner(String.valueOf(separator));\n    }\n    \n    private Joiner(final String separator) {\n        this.separator = Preconditions.checkNotNull(separator);\n    }\n    \n    private Joiner(final Joiner prototype) {\n        this.separator = prototype.separator;\n    }\n    \n    public <A extends Appendable> A appendTo(final A appendable, final Iterable<?> parts) throws IOException {\n        return this.appendTo(appendable, parts.iterator());\n    }\n    \n    public <A extends Appendable> A appendTo(final A appendable, final Iterator<?> parts) throws IOException {\n        Preconditions.checkNotNull(appendable);\n        if (parts.hasNext()) {\n            appendable.append(this.toString(parts.next()));\n            while (parts.hasNext()) {\n                appendable.append(this.separator);\n                appendable.append(this.toString(parts.next()));\n            }\n        }\n        return appendable;\n    }\n    \n    public final <A extends Appendable> A appendTo(final A appendable, final Object[] parts) throws IOException {\n        return this.appendTo(appendable, Arrays.asList(parts));\n    }\n    \n    public final <A extends Appendable> A appendTo(final A appendable, @Nullable final Object first, @Nullable final Object second, final Object... rest) throws IOException {\n        return this.appendTo(appendable, iterable(first, second, rest));\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, final Iterable<?> parts) {\n        return this.appendTo(builder, parts.iterator());\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, final Iterator<?> parts) {\n        try {\n            this.appendTo(builder, parts);\n        }\n        catch (IOException impossible) {\n            throw new AssertionError((Object)impossible);\n        }\n        return builder;\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, final Object[] parts) {\n        return this.appendTo(builder, (Iterable<?>)Arrays.asList(parts));\n    }\n    \n    public final StringBuilder appendTo(final StringBuilder builder, @Nullable final Object first, @Nullable final Object second, final Object... rest) {\n        return this.appendTo(builder, (Iterable<?>)iterable(first, second, rest));\n    }\n    \n    public final String join(final Iterable<?> parts) {\n        return this.join(parts.iterator());\n    }\n    \n    public final String join(final Iterator<?> parts) {\n        return this.appendTo(new StringBuilder(), parts).toString();\n    }\n    \n    public final String join(final Object[] parts) {\n        return this.join(Arrays.asList(parts));\n    }\n    \n    public final String join(@Nullable final Object first, @Nullable final Object second, final Object... rest) {\n        return this.join(iterable(first, second, rest));\n    }\n    \n    @CheckReturnValue\n    public Joiner useForNull(final String nullText) {\n        Preconditions.checkNotNull(nullText);\n        return new Joiner(this) {\n            @Override\n            CharSequence toString(@Nullable final Object part) {\n                return (part == null) ? nullText : Joiner.this.toString(part);\n            }\n            \n            @Override\n            public Joiner useForNull(final String nullText) {\n                throw new UnsupportedOperationException(\"already specified useForNull\");\n            }\n            \n            @Override\n            public Joiner skipNulls() {\n                throw new UnsupportedOperationException(\"already specified useForNull\");\n            }\n        };\n    }\n    \n    @CheckReturnValue\n    public Joiner skipNulls() {\n        return new Joiner(this) {\n            @Override\n            public <A extends Appendable> A appendTo(final A appendable, final Iterator<?> parts) throws IOException {\n                Preconditions.checkNotNull(appendable, (Object)\"appendable\");\n                Preconditions.checkNotNull(parts, (Object)\"parts\");\n                while (parts.hasNext()) {\n                    final Object part = parts.next();\n                    if (part != null) {\n                        appendable.append(Joiner.this.toString(part));\n                        break;\n                    }\n                }\n                while (parts.hasNext()) {\n                    final Object part = parts.next();\n                    if (part != null) {\n                        appendable.append(Joiner.this.separator);\n                        appendable.append(Joiner.this.toString(part));\n                    }\n                }\n                return appendable;\n            }\n            \n            @Override\n            public Joiner useForNull(final String nullText) {\n                throw new UnsupportedOperationException(\"already specified skipNulls\");\n            }\n            \n            @Override\n            public MapJoiner withKeyValueSeparator(final String kvs) {\n                throw new UnsupportedOperationException(\"can't use .skipNulls() with maps\");\n            }\n        };\n    }\n    \n    @CheckReturnValue\n    public MapJoiner withKeyValueSeparator(final String keyValueSeparator) {\n        return new MapJoiner(this, keyValueSeparator);\n    }\n    \n    CharSequence toString(final Object part) {\n        Preconditions.checkNotNull(part);\n        return (part instanceof CharSequence) ? ((CharSequence)part) : part.toString();\n    }\n    \n    private static Iterable<Object> iterable(final Object first, final Object second, final Object[] rest) {\n        Preconditions.checkNotNull(rest);\n        return new AbstractList<Object>() {\n            @Override\n            public int size() {\n                return rest.length + 2;\n            }\n            \n            @Override\n            public Object get(final int index) {\n                switch (index) {\n                    case 0: {\n                        return first;\n                    }\n                    case 1: {\n                        return second;\n                    }\n                    default: {\n                        return rest[index - 2];\n                    }\n                }\n            }\n        };\n    }\n    \n    public static final class MapJoiner\n    {\n        private final Joiner joiner;\n        private final String keyValueSeparator;\n        \n        private MapJoiner(final Joiner joiner, final String keyValueSeparator) {\n            this.joiner = joiner;\n            this.keyValueSeparator = Preconditions.checkNotNull(keyValueSeparator);\n        }\n        \n        public <A extends Appendable> A appendTo(final A appendable, final Map<?, ?> map) throws IOException {\n            return this.appendTo(appendable, map.entrySet());\n        }\n        \n        public StringBuilder appendTo(final StringBuilder builder, final Map<?, ?> map) {\n            return this.appendTo(builder, (Iterable<? extends Map.Entry<?, ?>>)map.entrySet());\n        }\n        \n        public String join(final Map<?, ?> map) {\n            return this.join(map.entrySet());\n        }\n        \n        @Beta\n        public <A extends Appendable> A appendTo(final A appendable, final Iterable<? extends Map.Entry<?, ?>> entries) throws IOException {\n            return this.appendTo(appendable, entries.iterator());\n        }\n        \n        @Beta\n        public <A extends Appendable> A appendTo(final A appendable, final Iterator<? extends Map.Entry<?, ?>> parts) throws IOException {\n            Preconditions.checkNotNull(appendable);\n            if (parts.hasNext()) {\n                final Map.Entry<?, ?> entry = (Map.Entry<?, ?>)parts.next();\n                appendable.append(this.joiner.toString(entry.getKey()));\n                appendable.append(this.keyValueSeparator);\n                appendable.append(this.joiner.toString(entry.getValue()));\n                while (parts.hasNext()) {\n                    appendable.append(this.joiner.separator);\n                    final Map.Entry<?, ?> e = (Map.Entry<?, ?>)parts.next();\n                    appendable.append(this.joiner.toString(e.getKey()));\n                    appendable.append(this.keyValueSeparator);\n                    appendable.append(this.joiner.toString(e.getValue()));\n                }\n            }\n            return appendable;\n        }\n        \n        @Beta\n        public StringBuilder appendTo(final StringBuilder builder, final Iterable<? extends Map.Entry<?, ?>> entries) {\n            return this.appendTo(builder, entries.iterator());\n        }\n        \n        @Beta\n        public StringBuilder appendTo(final StringBuilder builder, final Iterator<? extends Map.Entry<?, ?>> entries) {\n            try {\n                this.appendTo(builder, entries);\n            }\n            catch (IOException impossible) {\n                throw new AssertionError((Object)impossible);\n            }\n            return builder;\n        }\n        \n        @Beta\n        public String join(final Iterable<? extends Map.Entry<?, ?>> entries) {\n            return this.join(entries.iterator());\n        }\n        \n        @Beta\n        public String join(final Iterator<? extends Map.Entry<?, ?>> entries) {\n            return this.appendTo(new StringBuilder(), entries).toString();\n        }\n        \n        @CheckReturnValue\n        public MapJoiner useForNull(final String nullText) {\n            return new MapJoiner(this.joiner.useForNull(nullText), this.keyValueSeparator);\n        }\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "Predicates",
        "fqdn": "com.google.common.base",
        "source_code": "package com.google.common.base;\n\nimport javax.annotation.*;\nimport com.google.common.annotations.*;\nimport java.util.regex.*;\nimport java.util.*;\nimport java.io.*;\n\n@GwtCompatible(emulated = true)\npublic final class Predicates\n{\n    private static final Joiner COMMA_JOINER;\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> alwaysTrue() {\n        return ObjectPredicate.ALWAYS_TRUE.withNarrowedType();\n    }\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> alwaysFalse() {\n        return ObjectPredicate.ALWAYS_FALSE.withNarrowedType();\n    }\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> isNull() {\n        return ObjectPredicate.IS_NULL.withNarrowedType();\n    }\n    \n    @GwtCompatible(serializable = true)\n    public static <T> Predicate<T> notNull() {\n        return ObjectPredicate.NOT_NULL.withNarrowedType();\n    }\n    \n    public static <T> Predicate<T> not(final Predicate<T> predicate) {\n        return new NotPredicate<T>(predicate);\n    }\n    \n    public static <T> Predicate<T> and(final Iterable<? extends Predicate<? super T>> components) {\n        return new AndPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> and(final Predicate<? super T>... components) {\n        return new AndPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> and(final Predicate<? super T> first, final Predicate<? super T> second) {\n        return new AndPredicate<T>((List)asList(Preconditions.checkNotNull(first), Preconditions.checkNotNull(second)));\n    }\n    \n    public static <T> Predicate<T> or(final Iterable<? extends Predicate<? super T>> components) {\n        return new OrPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> or(final Predicate<? super T>... components) {\n        return new OrPredicate<T>((List)defensiveCopy(components));\n    }\n    \n    public static <T> Predicate<T> or(final Predicate<? super T> first, final Predicate<? super T> second) {\n        return new OrPredicate<T>((List)asList(Preconditions.checkNotNull(first), Preconditions.checkNotNull(second)));\n    }\n    \n    public static <T> Predicate<T> equalTo(@Nullable final T target) {\n        return (target == null) ? isNull() : new IsEqualToPredicate<T>((Object)target);\n    }\n    \n    @GwtIncompatible(\"Class.isInstance\")\n    public static Predicate<Object> instanceOf(final Class<?> clazz) {\n        return new InstanceOfPredicate((Class)clazz);\n    }\n    \n    @GwtIncompatible(\"Class.isAssignableFrom\")\n    @Beta\n    public static Predicate<Class<?>> assignableFrom(final Class<?> clazz) {\n        return new AssignableFromPredicate((Class)clazz);\n    }\n    \n    public static <T> Predicate<T> in(final Collection<? extends T> target) {\n        return new InPredicate<T>((Collection)target);\n    }\n    \n    public static <A, B> Predicate<A> compose(final Predicate<B> predicate, final Function<A, ? extends B> function) {\n        return new CompositionPredicate<A, Object>((Predicate)predicate, (Function)function);\n    }\n    \n    @GwtIncompatible(\"java.util.regex.Pattern\")\n    public static Predicate<CharSequence> containsPattern(final String pattern) {\n        return new ContainsPatternFromStringPredicate(pattern);\n    }\n    \n    @GwtIncompatible(\"java.util.regex.Pattern\")\n    public static Predicate<CharSequence> contains(final Pattern pattern) {\n        return new ContainsPatternPredicate(pattern);\n    }\n    \n    private static <T> List<Predicate<? super T>> asList(final Predicate<? super T> first, final Predicate<? super T> second) {\n        return Arrays.asList(first, second);\n    }\n    \n    private static <T> List<T> defensiveCopy(final T... array) {\n        return defensiveCopy(Arrays.asList(array));\n    }\n    \n    static <T> List<T> defensiveCopy(final Iterable<T> iterable) {\n        final ArrayList<T> list = new ArrayList<T>();\n        for (final T element : iterable) {\n            list.add(Preconditions.checkNotNull(element));\n        }\n        return list;\n    }\n    \n    static {\n        COMMA_JOINER = Joiner.on(',');\n    }\n    \n    enum ObjectPredicate implements Predicate<Object>\n    {\n        ALWAYS_TRUE {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return true;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.alwaysTrue()\";\n            }\n        }, \n        ALWAYS_FALSE {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return false;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.alwaysFalse()\";\n            }\n        }, \n        IS_NULL {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return o == null;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.isNull()\";\n            }\n        }, \n        NOT_NULL {\n            @Override\n            public boolean apply(@Nullable final Object o) {\n                return o != null;\n            }\n            \n            @Override\n            public String toString() {\n                return \"Predicates.notNull()\";\n            }\n        };\n        \n         <T> Predicate<T> withNarrowedType() {\n            return (Predicate<T>)this;\n        }\n    }\n    \n    private static class NotPredicate<T> implements Predicate<T>, Serializable\n    {\n        final Predicate<T> predicate;\n        private static final long serialVersionUID = 0L;\n        \n        NotPredicate(final Predicate<T> predicate) {\n            this.predicate = Preconditions.checkNotNull(predicate);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            return !this.predicate.apply(t);\n        }\n        \n        @Override\n        public int hashCode() {\n            return ~this.predicate.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof NotPredicate) {\n                final NotPredicate<?> that = (NotPredicate<?>)obj;\n                return this.predicate.equals(that.predicate);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.predicate.toString()));\n            return new StringBuilder(16 + value.length()).append(\"Predicates.not(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class AndPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final List<? extends Predicate<? super T>> components;\n        private static final long serialVersionUID = 0L;\n        \n        private AndPredicate(final List<? extends Predicate<? super T>> components) {\n            this.components = components;\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            for (int i = 0; i < this.components.size(); ++i) {\n                if (!((Predicate)this.components.get(i)).apply(t)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.components.hashCode() + 306654252;\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof AndPredicate) {\n                final AndPredicate<?> that = (AndPredicate<?>)obj;\n                return this.components.equals(that.components);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(Predicates.COMMA_JOINER.join(this.components)));\n            return new StringBuilder(16 + value.length()).append(\"Predicates.and(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class OrPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final List<? extends Predicate<? super T>> components;\n        private static final long serialVersionUID = 0L;\n        \n        private OrPredicate(final List<? extends Predicate<? super T>> components) {\n            this.components = components;\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            for (int i = 0; i < this.components.size(); ++i) {\n                if (((Predicate)this.components.get(i)).apply(t)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.components.hashCode() + 87855567;\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof OrPredicate) {\n                final OrPredicate<?> that = (OrPredicate<?>)obj;\n                return this.components.equals(that.components);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(Predicates.COMMA_JOINER.join(this.components)));\n            return new StringBuilder(15 + value.length()).append(\"Predicates.or(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class IsEqualToPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final T target;\n        private static final long serialVersionUID = 0L;\n        \n        private IsEqualToPredicate(final T target) {\n            this.target = target;\n        }\n        \n        @Override\n        public boolean apply(final T t) {\n            return this.target.equals(t);\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.target.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof IsEqualToPredicate) {\n                final IsEqualToPredicate<?> that = (IsEqualToPredicate<?>)obj;\n                return this.target.equals(that.target);\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.target));\n            return new StringBuilder(20 + value.length()).append(\"Predicates.equalTo(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Class.isInstance\")\n    private static class InstanceOfPredicate implements Predicate<Object>, Serializable\n    {\n        private final Class<?> clazz;\n        private static final long serialVersionUID = 0L;\n        \n        private InstanceOfPredicate(final Class<?> clazz) {\n            this.clazz = Preconditions.checkNotNull(clazz);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final Object o) {\n            return this.clazz.isInstance(o);\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.clazz.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof InstanceOfPredicate) {\n                final InstanceOfPredicate that = (InstanceOfPredicate)obj;\n                return this.clazz == that.clazz;\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.clazz.getName()));\n            return new StringBuilder(23 + value.length()).append(\"Predicates.instanceOf(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Class.isAssignableFrom\")\n    private static class AssignableFromPredicate implements Predicate<Class<?>>, Serializable\n    {\n        private final Class<?> clazz;\n        private static final long serialVersionUID = 0L;\n        \n        private AssignableFromPredicate(final Class<?> clazz) {\n            this.clazz = Preconditions.checkNotNull(clazz);\n        }\n        \n        @Override\n        public boolean apply(final Class<?> input) {\n            return this.clazz.isAssignableFrom(input);\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.clazz.hashCode();\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof AssignableFromPredicate) {\n                final AssignableFromPredicate that = (AssignableFromPredicate)obj;\n                return this.clazz == that.clazz;\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.clazz.getName()));\n            return new StringBuilder(27 + value.length()).append(\"Predicates.assignableFrom(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class InPredicate<T> implements Predicate<T>, Serializable\n    {\n        private final Collection<?> target;\n        private static final long serialVersionUID = 0L;\n        \n        private InPredicate(final Collection<?> target) {\n            this.target = Preconditions.checkNotNull(target);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final T t) {\n            try {\n                return this.target.contains(t);\n            }\n            catch (NullPointerException e) {\n                return false;\n            }\n            catch (ClassCastException e2) {\n                return false;\n            }\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof InPredicate) {\n                final InPredicate<?> that = (InPredicate<?>)obj;\n                return this.target.equals(that.target);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.target.hashCode();\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.target));\n            return new StringBuilder(15 + value.length()).append(\"Predicates.in(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class CompositionPredicate<A, B> implements Predicate<A>, Serializable\n    {\n        final Predicate<B> p;\n        final Function<A, ? extends B> f;\n        private static final long serialVersionUID = 0L;\n        \n        private CompositionPredicate(final Predicate<B> p, final Function<A, ? extends B> f) {\n            this.p = Preconditions.checkNotNull(p);\n            this.f = Preconditions.checkNotNull(f);\n        }\n        \n        @Override\n        public boolean apply(@Nullable final A a) {\n            return this.p.apply((B)this.f.apply(a));\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof CompositionPredicate) {\n                final CompositionPredicate<?, ?> that = (CompositionPredicate<?, ?>)obj;\n                return this.f.equals(that.f) && this.p.equals(that.p);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.f.hashCode() ^ this.p.hashCode();\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.p.toString()));\n            final String value2 = String.valueOf(String.valueOf(this.f.toString()));\n            return new StringBuilder(2 + value.length() + value2.length()).append(value).append(\"(\").append(value2).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Only used by other GWT-incompatible code.\")\n    private static class ContainsPatternPredicate implements Predicate<CharSequence>, Serializable\n    {\n        final Pattern pattern;\n        private static final long serialVersionUID = 0L;\n        \n        ContainsPatternPredicate(final Pattern pattern) {\n            this.pattern = Preconditions.checkNotNull(pattern);\n        }\n        \n        @Override\n        public boolean apply(final CharSequence t) {\n            return this.pattern.matcher(t).find();\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hashCode(this.pattern.pattern(), this.pattern.flags());\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof ContainsPatternPredicate) {\n                final ContainsPatternPredicate that = (ContainsPatternPredicate)obj;\n                return Objects.equal(this.pattern.pattern(), that.pattern.pattern()) && Objects.equal(this.pattern.flags(), that.pattern.flags());\n            }\n            return false;\n        }\n        \n        @Override\n        public String toString() {\n            final String patternString = Objects.toStringHelper(this.pattern).add(\"pattern\", this.pattern.pattern()).add(\"pattern.flags\", this.pattern.flags()).toString();\n            final String value = String.valueOf(String.valueOf(patternString));\n            return new StringBuilder(21 + value.length()).append(\"Predicates.contains(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @GwtIncompatible(\"Only used by other GWT-incompatible code.\")\n    private static class ContainsPatternFromStringPredicate extends ContainsPatternPredicate\n    {\n        private static final long serialVersionUID = 0L;\n        \n        ContainsPatternFromStringPredicate(final String string) {\n            super(Pattern.compile(string));\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.pattern.pattern()));\n            return new StringBuilder(28 + value.length()).append(\"Predicates.containsPattern(\").append(value).append(\")\").toString();\n        }\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "Splitter",
        "fqdn": "com.google.common.base",
        "source_code": "package com.google.common.base;\n\nimport java.util.regex.*;\nimport javax.annotation.*;\nimport com.google.common.annotations.*;\nimport java.util.*;\n\n@GwtCompatible(emulated = true)\npublic final class Splitter\n{\n    private final CharMatcher trimmer;\n    private final boolean omitEmptyStrings;\n    private final Strategy strategy;\n    private final int limit;\n    \n    private Splitter(final Strategy strategy) {\n        this(strategy, false, CharMatcher.NONE, Integer.MAX_VALUE);\n    }\n    \n    private Splitter(final Strategy strategy, final boolean omitEmptyStrings, final CharMatcher trimmer, final int limit) {\n        this.strategy = strategy;\n        this.omitEmptyStrings = omitEmptyStrings;\n        this.trimmer = trimmer;\n        this.limit = limit;\n    }\n    \n    public static Splitter on(final char separator) {\n        return on(CharMatcher.is(separator));\n    }\n    \n    public static Splitter on(final CharMatcher separatorMatcher) {\n        Preconditions.checkNotNull(separatorMatcher);\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                return new SplittingIterator(splitter, toSplit) {\n                    @Override\n                    int separatorStart(final int start) {\n                        return separatorMatcher.indexIn(this.toSplit, start);\n                    }\n                    \n                    @Override\n                    int separatorEnd(final int separatorPosition) {\n                        return separatorPosition + 1;\n                    }\n                };\n            }\n        });\n    }\n    \n    public static Splitter on(final String separator) {\n        Preconditions.checkArgument(separator.length() != 0, (Object)\"The separator may not be the empty string.\");\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                return new SplittingIterator(splitter, toSplit) {\n                    public int separatorStart(final int start) {\n                        final int separatorLength = separator.length();\n                        int p = start;\n                        final int last = this.toSplit.length() - separatorLength;\n                    Label_0026:\n                        while (p <= last) {\n                            for (int i = 0; i < separatorLength; ++i) {\n                                if (this.toSplit.charAt(i + p) != separator.charAt(i)) {\n                                    ++p;\n                                    continue Label_0026;\n                                }\n                            }\n                            return p;\n                        }\n                        return -1;\n                    }\n                    \n                    public int separatorEnd(final int separatorPosition) {\n                        return separatorPosition + separator.length();\n                    }\n                };\n            }\n        });\n    }\n    \n    @GwtIncompatible(\"java.util.regex\")\n    public static Splitter on(final Pattern separatorPattern) {\n        Preconditions.checkNotNull(separatorPattern);\n        Preconditions.checkArgument(!separatorPattern.matcher(\"\").matches(), \"The pattern may not match the empty string: %s\", separatorPattern);\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                final Matcher matcher = separatorPattern.matcher(toSplit);\n                return new SplittingIterator(splitter, toSplit) {\n                    public int separatorStart(final int start) {\n                        return matcher.find(start) ? matcher.start() : -1;\n                    }\n                    \n                    public int separatorEnd(final int separatorPosition) {\n                        return matcher.end();\n                    }\n                };\n            }\n        });\n    }\n    \n    @GwtIncompatible(\"java.util.regex\")\n    public static Splitter onPattern(final String separatorPattern) {\n        return on(Pattern.compile(separatorPattern));\n    }\n    \n    public static Splitter fixedLength(final int length) {\n        Preconditions.checkArgument(length > 0, (Object)\"The length may not be less than 1\");\n        return new Splitter(new Strategy() {\n            @Override\n            public SplittingIterator iterator(final Splitter splitter, final CharSequence toSplit) {\n                return new SplittingIterator(splitter, toSplit) {\n                    public int separatorStart(final int start) {\n                        final int nextChunkStart = start + length;\n                        return (nextChunkStart < this.toSplit.length()) ? nextChunkStart : -1;\n                    }\n                    \n                    public int separatorEnd(final int separatorPosition) {\n                        return separatorPosition;\n                    }\n                };\n            }\n        });\n    }\n    \n    @CheckReturnValue\n    public Splitter omitEmptyStrings() {\n        return new Splitter(this.strategy, true, this.trimmer, this.limit);\n    }\n    \n    @CheckReturnValue\n    public Splitter limit(final int limit) {\n        Preconditions.checkArgument(limit > 0, \"must be greater than zero: %s\", limit);\n        return new Splitter(this.strategy, this.omitEmptyStrings, this.trimmer, limit);\n    }\n    \n    @CheckReturnValue\n    public Splitter trimResults() {\n        return this.trimResults(CharMatcher.WHITESPACE);\n    }\n    \n    @CheckReturnValue\n    public Splitter trimResults(final CharMatcher trimmer) {\n        Preconditions.checkNotNull(trimmer);\n        return new Splitter(this.strategy, this.omitEmptyStrings, trimmer, this.limit);\n    }\n    \n    public Iterable<String> split(final CharSequence sequence) {\n        Preconditions.checkNotNull(sequence);\n        return new Iterable<String>() {\n            @Override\n            public Iterator<String> iterator() {\n                return Splitter.this.splittingIterator(sequence);\n            }\n            \n            @Override\n            public String toString() {\n                return Joiner.on(\", \").appendTo(new StringBuilder().append('['), (Iterable<?>)this).append(']').toString();\n            }\n        };\n    }\n    \n    private Iterator<String> splittingIterator(final CharSequence sequence) {\n        return this.strategy.iterator(this, sequence);\n    }\n    \n    @Beta\n    public List<String> splitToList(final CharSequence sequence) {\n        Preconditions.checkNotNull(sequence);\n        final Iterator<String> iterator = this.splittingIterator(sequence);\n        final List<String> result = new ArrayList<String>();\n        while (iterator.hasNext()) {\n            result.add(iterator.next());\n        }\n        return Collections.unmodifiableList((List<? extends String>)result);\n    }\n    \n    @CheckReturnValue\n    @Beta\n    public MapSplitter withKeyValueSeparator(final String separator) {\n        return this.withKeyValueSeparator(on(separator));\n    }\n    \n    @CheckReturnValue\n    @Beta\n    public MapSplitter withKeyValueSeparator(final char separator) {\n        return this.withKeyValueSeparator(on(separator));\n    }\n    \n    @CheckReturnValue\n    @Beta\n    public MapSplitter withKeyValueSeparator(final Splitter keyValueSplitter) {\n        return new MapSplitter(this, keyValueSplitter);\n    }\n    \n    @Beta\n    public static final class MapSplitter\n    {\n        private static final String INVALID_ENTRY_MESSAGE = \"Chunk [%s] is not a valid entry\";\n        private final Splitter outerSplitter;\n        private final Splitter entrySplitter;\n        \n        private MapSplitter(final Splitter outerSplitter, final Splitter entrySplitter) {\n            this.outerSplitter = outerSplitter;\n            this.entrySplitter = Preconditions.checkNotNull(entrySplitter);\n        }\n        \n        public Map<String, String> split(final CharSequence sequence) {\n            final Map<String, String> map = new LinkedHashMap<String, String>();\n            for (final String entry : this.outerSplitter.split(sequence)) {\n                final Iterator<String> entryFields = this.entrySplitter.splittingIterator(entry);\n                Preconditions.checkArgument(entryFields.hasNext(), \"Chunk [%s] is not a valid entry\", entry);\n                final String key = entryFields.next();\n                Preconditions.checkArgument(!map.containsKey(key), \"Duplicate key [%s] found.\", key);\n                Preconditions.checkArgument(entryFields.hasNext(), \"Chunk [%s] is not a valid entry\", entry);\n                final String value = entryFields.next();\n                map.put(key, value);\n                Preconditions.checkArgument(!entryFields.hasNext(), \"Chunk [%s] is not a valid entry\", entry);\n            }\n            return Collections.unmodifiableMap((Map<? extends String, ? extends String>)map);\n        }\n    }\n    \n    private abstract static class SplittingIterator extends AbstractIterator<String>\n    {\n        final CharSequence toSplit;\n        final CharMatcher trimmer;\n        final boolean omitEmptyStrings;\n        int offset;\n        int limit;\n        \n        abstract int separatorStart(final int p0);\n        \n        abstract int separatorEnd(final int p0);\n        \n        protected SplittingIterator(final Splitter splitter, final CharSequence toSplit) {\n            this.offset = 0;\n            this.trimmer = splitter.trimmer;\n            this.omitEmptyStrings = splitter.omitEmptyStrings;\n            this.limit = splitter.limit;\n            this.toSplit = toSplit;\n        }\n        \n        @Override\n        protected String computeNext() {\n            int nextStart = this.offset;\n            while (this.offset != -1) {\n                int start = nextStart;\n                final int separatorPosition = this.separatorStart(this.offset);\n                int end;\n                if (separatorPosition == -1) {\n                    end = this.toSplit.length();\n                    this.offset = -1;\n                }\n                else {\n                    end = separatorPosition;\n                    this.offset = this.separatorEnd(separatorPosition);\n                }\n                if (this.offset == nextStart) {\n                    ++this.offset;\n                    if (this.offset < this.toSplit.length()) {\n                        continue;\n                    }\n                    this.offset = -1;\n                }\n                else {\n                    while (start < end && this.trimmer.matches(this.toSplit.charAt(start))) {\n                        ++start;\n                    }\n                    while (end > start && this.trimmer.matches(this.toSplit.charAt(end - 1))) {\n                        --end;\n                    }\n                    if (!this.omitEmptyStrings || start != end) {\n                        if (this.limit == 1) {\n                            end = this.toSplit.length();\n                            this.offset = -1;\n                            while (end > start && this.trimmer.matches(this.toSplit.charAt(end - 1))) {\n                                --end;\n                            }\n                        }\n                        else {\n                            --this.limit;\n                        }\n                        return this.toSplit.subSequence(start, end).toString();\n                    }\n                    nextStart = this.offset;\n                }\n            }\n            return this.endOfData();\n        }\n    }\n    \n    private interface Strategy\n    {\n        Iterator<String> iterator(final Splitter p0, final CharSequence p1);\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "SmallCharMatcher",
        "fqdn": "com.google.common.base",
        "source_code": "package com.google.common.base;\n\nimport com.google.common.annotations.*;\nimport java.util.*;\n\n@GwtIncompatible(\"no precomputation is done in GWT\")\nfinal class SmallCharMatcher extends FastMatcher\n{\n    static final int MAX_SIZE = 1023;\n    private final char[] table;\n    private final boolean containsZero;\n    private final long filter;\n    private static final int C1 = -862048943;\n    private static final int C2 = 461845907;\n    private static final double DESIRED_LOAD_FACTOR = 0.5;\n    \n    private SmallCharMatcher(final char[] table, final long filter, final boolean containsZero, final String description) {\n        super(description);\n        this.table = table;\n        this.filter = filter;\n        this.containsZero = containsZero;\n    }\n    \n    static int smear(final int hashCode) {\n        return 461845907 * Integer.rotateLeft(hashCode * -862048943, 15);\n    }\n    \n    private boolean checkFilter(final int c) {\n        return 0x1L == (0x1L & this.filter >> c);\n    }\n    \n    @VisibleForTesting\n    static int chooseTableSize(final int setSize) {\n        if (setSize == 1) {\n            return 2;\n        }\n        int tableSize;\n        for (tableSize = Integer.highestOneBit(setSize - 1) << 1; tableSize * 0.5 < setSize; tableSize <<= 1) {}\n        return tableSize;\n    }\n    \n    static CharMatcher from(final BitSet chars, final String description) {\n        long filter = 0L;\n        final int size = chars.cardinality();\n        final boolean containsZero = chars.get(0);\n        final char[] table = new char[chooseTableSize(size)];\n        final int mask = table.length - 1;\n        for (int c = chars.nextSetBit(0); c != -1; c = chars.nextSetBit(c + 1)) {\n            filter |= 1L << c;\n            int index;\n            for (index = (smear(c) & mask); table[index] != '\\0'; index = (index + 1 & mask)) {}\n            table[index] = (char)c;\n        }\n        return new SmallCharMatcher(table, filter, containsZero, description);\n    }\n    \n    @Override\n    public boolean matches(final char c) {\n        if (c == '\\0') {\n            return this.containsZero;\n        }\n        if (!this.checkFilter(c)) {\n            return false;\n        }\n        final int mask = this.table.length - 1;\n        int index;\n        final int startingIndex = index = (smear(c) & mask);\n        while (this.table[index] != '\\0') {\n            if (this.table[index] == c) {\n                return true;\n            }\n            index = (index + 1 & mask);\n            if (index == startingIndex) {\n                return false;\n            }\n        }\n        return false;\n    }\n    \n    @Override\n    void setBits(final BitSet table) {\n        if (this.containsZero) {\n            table.set(0);\n        }\n        for (final char c : this.table) {\n            if (c != '\\0') {\n                table.set(c);\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "Suppliers",
        "fqdn": "com.google.common.base",
        "source_code": "package com.google.common.base;\n\nimport java.util.concurrent.*;\nimport javax.annotation.*;\nimport java.io.*;\nimport com.google.common.annotations.*;\n\n@GwtCompatible\npublic final class Suppliers\n{\n    public static <F, T> Supplier<T> compose(final Function<? super F, T> function, final Supplier<F> supplier) {\n        Preconditions.checkNotNull(function);\n        Preconditions.checkNotNull(supplier);\n        return new SupplierComposition<Object, T>(function, supplier);\n    }\n    \n    public static <T> Supplier<T> memoize(final Supplier<T> delegate) {\n        return (delegate instanceof MemoizingSupplier) ? delegate : new MemoizingSupplier<T>(Preconditions.checkNotNull(delegate));\n    }\n    \n    public static <T> Supplier<T> memoizeWithExpiration(final Supplier<T> delegate, final long duration, final TimeUnit unit) {\n        return new ExpiringMemoizingSupplier<T>(delegate, duration, unit);\n    }\n    \n    public static <T> Supplier<T> ofInstance(@Nullable final T instance) {\n        return new SupplierOfInstance<T>(instance);\n    }\n    \n    public static <T> Supplier<T> synchronizedSupplier(final Supplier<T> delegate) {\n        return new ThreadSafeSupplier<T>(Preconditions.checkNotNull(delegate));\n    }\n    \n    @Beta\n    public static <T> Function<Supplier<T>, T> supplierFunction() {\n        final SupplierFunction<T> sf = (SupplierFunction<T>)SupplierFunctionImpl.INSTANCE;\n        return sf;\n    }\n    \n    private static class SupplierComposition<F, T> implements Supplier<T>, Serializable\n    {\n        final Function<? super F, T> function;\n        final Supplier<F> supplier;\n        private static final long serialVersionUID = 0L;\n        \n        SupplierComposition(final Function<? super F, T> function, final Supplier<F> supplier) {\n            this.function = function;\n            this.supplier = supplier;\n        }\n        \n        @Override\n        public T get() {\n            return this.function.apply((Object)this.supplier.get());\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof SupplierComposition) {\n                final SupplierComposition<?, ?> that = (SupplierComposition<?, ?>)obj;\n                return this.function.equals(that.function) && this.supplier.equals(that.supplier);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hashCode(this.function, this.supplier);\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.function));\n            final String value2 = String.valueOf(String.valueOf(this.supplier));\n            return new StringBuilder(21 + value.length() + value2.length()).append(\"Suppliers.compose(\").append(value).append(\", \").append(value2).append(\")\").toString();\n        }\n    }\n    \n    @VisibleForTesting\n    static class MemoizingSupplier<T> implements Supplier<T>, Serializable\n    {\n        final Supplier<T> delegate;\n        transient volatile boolean initialized;\n        transient T value;\n        private static final long serialVersionUID = 0L;\n        \n        MemoizingSupplier(final Supplier<T> delegate) {\n            this.delegate = delegate;\n        }\n        \n        @Override\n        public T get() {\n            if (!this.initialized) {\n                synchronized (this) {\n                    if (!this.initialized) {\n                        final T t = this.delegate.get();\n                        this.value = t;\n                        this.initialized = true;\n                        return t;\n                    }\n                }\n            }\n            return this.value;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.delegate));\n            return new StringBuilder(19 + value.length()).append(\"Suppliers.memoize(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    @VisibleForTesting\n    static class ExpiringMemoizingSupplier<T> implements Supplier<T>, Serializable\n    {\n        final Supplier<T> delegate;\n        final long durationNanos;\n        transient volatile T value;\n        transient volatile long expirationNanos;\n        private static final long serialVersionUID = 0L;\n        \n        ExpiringMemoizingSupplier(final Supplier<T> delegate, final long duration, final TimeUnit unit) {\n            this.delegate = Preconditions.checkNotNull(delegate);\n            this.durationNanos = unit.toNanos(duration);\n            Preconditions.checkArgument(duration > 0L);\n        }\n        \n        @Override\n        public T get() {\n            long nanos = this.expirationNanos;\n            final long now = Platform.systemNanoTime();\n            if (nanos == 0L || now - nanos >= 0L) {\n                synchronized (this) {\n                    if (nanos == this.expirationNanos) {\n                        final T t = this.delegate.get();\n                        this.value = t;\n                        nanos = now + this.durationNanos;\n                        this.expirationNanos = ((nanos == 0L) ? 1L : nanos);\n                        return t;\n                    }\n                }\n            }\n            return this.value;\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.delegate));\n            return new StringBuilder(62 + value.length()).append(\"Suppliers.memoizeWithExpiration(\").append(value).append(\", \").append(this.durationNanos).append(\", NANOS)\").toString();\n        }\n    }\n    \n    private static class SupplierOfInstance<T> implements Supplier<T>, Serializable\n    {\n        final T instance;\n        private static final long serialVersionUID = 0L;\n        \n        SupplierOfInstance(@Nullable final T instance) {\n            this.instance = instance;\n        }\n        \n        @Override\n        public T get() {\n            return this.instance;\n        }\n        \n        @Override\n        public boolean equals(@Nullable final Object obj) {\n            if (obj instanceof SupplierOfInstance) {\n                final SupplierOfInstance<?> that = (SupplierOfInstance<?>)obj;\n                return Objects.equal(this.instance, that.instance);\n            }\n            return false;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hashCode(this.instance);\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.instance));\n            return new StringBuilder(22 + value.length()).append(\"Suppliers.ofInstance(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private static class ThreadSafeSupplier<T> implements Supplier<T>, Serializable\n    {\n        final Supplier<T> delegate;\n        private static final long serialVersionUID = 0L;\n        \n        ThreadSafeSupplier(final Supplier<T> delegate) {\n            this.delegate = delegate;\n        }\n        \n        @Override\n        public T get() {\n            synchronized (this.delegate) {\n                return this.delegate.get();\n            }\n        }\n        \n        @Override\n        public String toString() {\n            final String value = String.valueOf(String.valueOf(this.delegate));\n            return new StringBuilder(32 + value.length()).append(\"Suppliers.synchronizedSupplier(\").append(value).append(\")\").toString();\n        }\n    }\n    \n    private enum SupplierFunctionImpl implements SupplierFunction<Object>\n    {\n        INSTANCE;\n        \n        @Override\n        public Object apply(final Supplier<Object> input) {\n            return input.get();\n        }\n        \n        @Override\n        public String toString() {\n            return \"Suppliers.supplierFunction()\";\n        }\n    }\n    \n    private interface SupplierFunction<T> extends Function<Supplier<T>, T>\n    {\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "Monitor",
        "fqdn": "com.google.common.util.concurrent",
        "source_code": "package com.google.common.util.concurrent;\n\nimport com.google.common.annotations.*;\nimport javax.annotation.concurrent.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\nimport com.google.common.base.*;\n\n@Beta\npublic final class Monitor\n{\n    private final boolean fair;\n    private final ReentrantLock lock;\n    @GuardedBy(\"lock\")\n    private Guard activeGuards;\n    \n    public Monitor() {\n        this(false);\n    }\n    \n    public Monitor(final boolean fair) {\n        this.activeGuards = null;\n        this.fair = fair;\n        this.lock = new ReentrantLock(fair);\n    }\n    \n    public void enter() {\n        this.lock.lock();\n    }\n    \n    public void enterInterruptibly() throws InterruptedException {\n        this.lock.lockInterruptibly();\n    }\n    \n    public boolean enter(final long time, final TimeUnit unit) {\n        long timeoutNanos = unit.toNanos(time);\n        final ReentrantLock lock = this.lock;\n        if (!this.fair && lock.tryLock()) {\n            return true;\n        }\n        final long deadline = System.nanoTime() + timeoutNanos;\n        boolean interrupted = Thread.interrupted();\n        try {\n            return lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n        }\n        catch (InterruptedException interrupt) {\n            interrupted = true;\n            timeoutNanos = deadline - System.nanoTime();\n            return lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n        }\n        finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    public boolean enterInterruptibly(final long time, final TimeUnit unit) throws InterruptedException {\n        return this.lock.tryLock(time, unit);\n    }\n    \n    public boolean tryEnter() {\n        return this.lock.tryLock();\n    }\n    \n    public void enterWhen(final Guard guard) throws InterruptedException {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lockInterruptibly();\n        boolean satisfied = false;\n        try {\n            if (!guard.isSatisfied()) {\n                this.await(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally {\n            if (!satisfied) {\n                this.leave();\n            }\n        }\n    }\n    \n    public void enterWhenUninterruptibly(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        lock.lock();\n        boolean satisfied = false;\n        try {\n            if (!guard.isSatisfied()) {\n                this.awaitUninterruptibly(guard, signalBeforeWaiting);\n            }\n            satisfied = true;\n        }\n        finally {\n            if (!satisfied) {\n                this.leave();\n            }\n        }\n    }\n    \n    public boolean enterWhen(final Guard guard, final long time, final TimeUnit unit) throws InterruptedException {\n        long timeoutNanos = unit.toNanos(time);\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final boolean reentrant = lock.isHeldByCurrentThread();\n        if (this.fair || !lock.tryLock()) {\n            final long deadline = System.nanoTime() + timeoutNanos;\n            if (!lock.tryLock(time, unit)) {\n                return false;\n            }\n            timeoutNanos = deadline - System.nanoTime();\n        }\n        boolean satisfied = false;\n        boolean threw = true;\n        try {\n            satisfied = (guard.isSatisfied() || this.awaitNanos(guard, timeoutNanos, reentrant));\n            threw = false;\n            return satisfied;\n        }\n        finally {\n            if (!satisfied) {\n                try {\n                    if (threw && !reentrant) {\n                        this.signalNextWaiter();\n                    }\n                }\n                finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n    \n    public boolean enterWhenUninterruptibly(final Guard guard, final long time, final TimeUnit unit) {\n        long timeoutNanos = unit.toNanos(time);\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        final long deadline = System.nanoTime() + timeoutNanos;\n        boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n        boolean interrupted = Thread.interrupted();\n        try {\n            if (this.fair || !lock.tryLock()) {\n                boolean locked = false;\n                do {\n                    try {\n                        locked = lock.tryLock(timeoutNanos, TimeUnit.NANOSECONDS);\n                        if (!locked) {\n                            return false;\n                        }\n                    }\n                    catch (InterruptedException interrupt) {\n                        interrupted = true;\n                    }\n                    timeoutNanos = deadline - System.nanoTime();\n                } while (!locked);\n            }\n            boolean satisfied = false;\n            try {\n                return satisfied = (guard.isSatisfied() || this.awaitNanos(guard, timeoutNanos, signalBeforeWaiting));\n            }\n            catch (InterruptedException interrupt) {\n                interrupted = true;\n                signalBeforeWaiting = false;\n                timeoutNanos = deadline - System.nanoTime();\n            }\n            finally {\n                if (!satisfied) {\n                    lock.unlock();\n                }\n            }\n        }\n        finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    public boolean enterIf(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public boolean enterIfInterruptibly(final Guard guard) throws InterruptedException {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public boolean enterIf(final Guard guard, final long time, final TimeUnit unit) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        if (!this.enter(time, unit)) {\n            return false;\n        }\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                this.lock.unlock();\n            }\n        }\n    }\n    \n    public boolean enterIfInterruptibly(final Guard guard, final long time, final TimeUnit unit) throws InterruptedException {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock(time, unit)) {\n            return false;\n        }\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public boolean tryEnterIf(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        final ReentrantLock lock = this.lock;\n        if (!lock.tryLock()) {\n            return false;\n        }\n        boolean satisfied = false;\n        try {\n            return satisfied = guard.isSatisfied();\n        }\n        finally {\n            if (!satisfied) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    public void waitFor(final Guard guard) throws InterruptedException {\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied()) {\n            this.await(guard, true);\n        }\n    }\n    \n    public void waitForUninterruptibly(final Guard guard) {\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        if (!guard.isSatisfied()) {\n            this.awaitUninterruptibly(guard, true);\n        }\n    }\n    \n    public boolean waitFor(final Guard guard, final long time, final TimeUnit unit) throws InterruptedException {\n        final long timeoutNanos = unit.toNanos(time);\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        return guard.isSatisfied() || this.awaitNanos(guard, timeoutNanos, true);\n    }\n    \n    public boolean waitForUninterruptibly(final Guard guard, final long time, final TimeUnit unit) {\n        long timeoutNanos = unit.toNanos(time);\n        if (!(guard.monitor == this & this.lock.isHeldByCurrentThread())) {\n            throw new IllegalMonitorStateException();\n        }\n        if (guard.isSatisfied()) {\n            return true;\n        }\n        boolean signalBeforeWaiting = true;\n        final long deadline = System.nanoTime() + timeoutNanos;\n        boolean interrupted = Thread.interrupted();\n        try {\n            return this.awaitNanos(guard, timeoutNanos, signalBeforeWaiting);\n        }\n        catch (InterruptedException interrupt) {\n            interrupted = true;\n            if (guard.isSatisfied()) {\n                return true;\n            }\n            signalBeforeWaiting = false;\n            timeoutNanos = deadline - System.nanoTime();\n            return this.awaitNanos(guard, timeoutNanos, signalBeforeWaiting);\n        }\n        finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    public void leave() {\n        final ReentrantLock lock = this.lock;\n        try {\n            if (lock.getHoldCount() == 1) {\n                this.signalNextWaiter();\n            }\n        }\n        finally {\n            lock.unlock();\n        }\n    }\n    \n    public boolean isFair() {\n        return this.fair;\n    }\n    \n    public boolean isOccupied() {\n        return this.lock.isLocked();\n    }\n    \n    public boolean isOccupiedByCurrentThread() {\n        return this.lock.isHeldByCurrentThread();\n    }\n    \n    public int getOccupiedDepth() {\n        return this.lock.getHoldCount();\n    }\n    \n    public int getQueueLength() {\n        return this.lock.getQueueLength();\n    }\n    \n    public boolean hasQueuedThreads() {\n        return this.lock.hasQueuedThreads();\n    }\n    \n    public boolean hasQueuedThread(final Thread thread) {\n        return this.lock.hasQueuedThread(thread);\n    }\n    \n    public boolean hasWaiters(final Guard guard) {\n        return this.getWaitQueueLength(guard) > 0;\n    }\n    \n    public int getWaitQueueLength(final Guard guard) {\n        if (guard.monitor != this) {\n            throw new IllegalMonitorStateException();\n        }\n        this.lock.lock();\n        try {\n            return guard.waiterCount;\n        }\n        finally {\n            this.lock.unlock();\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void signalNextWaiter() {\n        for (Guard guard = this.activeGuards; guard != null; guard = guard.next) {\n            if (this.isSatisfied(guard)) {\n                guard.condition.signal();\n                break;\n            }\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private boolean isSatisfied(final Guard guard) {\n        try {\n            return guard.isSatisfied();\n        }\n        catch (Throwable throwable) {\n            this.signalAllWaiters();\n            throw Throwables.propagate(throwable);\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void signalAllWaiters() {\n        for (Guard guard = this.activeGuards; guard != null; guard = guard.next) {\n            guard.condition.signalAll();\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void beginWaitingFor(final Guard guard) {\n        final int waiters = guard.waiterCount++;\n        if (waiters == 0) {\n            guard.next = this.activeGuards;\n            this.activeGuards = guard;\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void endWaitingFor(final Guard guard) {\n        final int waiterCount = guard.waiterCount - 1;\n        guard.waiterCount = waiterCount;\n        final int waiters = waiterCount;\n        if (waiters == 0) {\n            Guard p = this.activeGuards;\n            Guard pred = null;\n            while (p != guard) {\n                pred = p;\n                p = p.next;\n            }\n            if (pred == null) {\n                this.activeGuards = p.next;\n            }\n            else {\n                pred.next = p.next;\n            }\n            p.next = null;\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void await(final Guard guard, final boolean signalBeforeWaiting) throws InterruptedException {\n        if (signalBeforeWaiting) {\n            this.signalNextWaiter();\n        }\n        this.beginWaitingFor(guard);\n        try {\n            do {\n                guard.condition.await();\n            } while (!guard.isSatisfied());\n        }\n        finally {\n            this.endWaitingFor(guard);\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private void awaitUninterruptibly(final Guard guard, final boolean signalBeforeWaiting) {\n        if (signalBeforeWaiting) {\n            this.signalNextWaiter();\n        }\n        this.beginWaitingFor(guard);\n        try {\n            do {\n                guard.condition.awaitUninterruptibly();\n            } while (!guard.isSatisfied());\n        }\n        finally {\n            this.endWaitingFor(guard);\n        }\n    }\n    \n    @GuardedBy(\"lock\")\n    private boolean awaitNanos(final Guard guard, long nanos, final boolean signalBeforeWaiting) throws InterruptedException {\n        if (signalBeforeWaiting) {\n            this.signalNextWaiter();\n        }\n        this.beginWaitingFor(guard);\n        try {\n            while (nanos >= 0L) {\n                nanos = guard.condition.awaitNanos(nanos);\n                if (guard.isSatisfied()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        finally {\n            this.endWaitingFor(guard);\n        }\n    }\n    \n    @Beta\n    public abstract static class Guard\n    {\n        final Monitor monitor;\n        final Condition condition;\n        @GuardedBy(\"monitor.lock\")\n        int waiterCount;\n        @GuardedBy(\"monitor.lock\")\n        Guard next;\n        \n        protected Guard(final Monitor monitor) {\n            this.waiterCount = 0;\n            this.monitor = Preconditions.checkNotNull(monitor, (Object)\"monitor\");\n            this.condition = monitor.lock.newCondition();\n        }\n        \n        public abstract boolean isSatisfied();\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "Objects",
        "fqdn": "com.google.common.base",
        "source_code": "package com.google.common.base;\n\nimport com.google.common.annotations.*;\nimport javax.annotation.*;\nimport java.util.*;\n\n@GwtCompatible\npublic final class Objects\n{\n    @CheckReturnValue\n    public static boolean equal(@Nullable final Object a, @Nullable final Object b) {\n        return a == b || (a != null && a.equals(b));\n    }\n    \n    public static int hashCode(@Nullable final Object... objects) {\n        return Arrays.hashCode(objects);\n    }\n    \n    @Deprecated\n    public static ToStringHelper toStringHelper(final Object self) {\n        return new ToStringHelper(MoreObjects.simpleName(self.getClass()));\n    }\n    \n    @Deprecated\n    public static ToStringHelper toStringHelper(final Class<?> clazz) {\n        return new ToStringHelper(MoreObjects.simpleName(clazz));\n    }\n    \n    @Deprecated\n    public static ToStringHelper toStringHelper(final String className) {\n        return new ToStringHelper(className);\n    }\n    \n    @Deprecated\n    public static <T> T firstNonNull(@Nullable final T first, @Nullable final T second) {\n        return MoreObjects.firstNonNull(first, second);\n    }\n    \n    @Deprecated\n    public static final class ToStringHelper\n    {\n        private final String className;\n        private ValueHolder holderHead;\n        private ValueHolder holderTail;\n        private boolean omitNullValues;\n        \n        private ToStringHelper(final String className) {\n            this.holderHead = new ValueHolder();\n            this.holderTail = this.holderHead;\n            this.omitNullValues = false;\n            this.className = Preconditions.checkNotNull(className);\n        }\n        \n        public ToStringHelper omitNullValues() {\n            this.omitNullValues = true;\n            return this;\n        }\n        \n        public ToStringHelper add(final String name, @Nullable final Object value) {\n            return this.addHolder(name, value);\n        }\n        \n        public ToStringHelper add(final String name, final boolean value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final char value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final double value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final float value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final int value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper add(final String name, final long value) {\n            return this.addHolder(name, String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(@Nullable final Object value) {\n            return this.addHolder(value);\n        }\n        \n        public ToStringHelper addValue(final boolean value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final char value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final double value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final float value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final int value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        public ToStringHelper addValue(final long value) {\n            return this.addHolder(String.valueOf(value));\n        }\n        \n        @Override\n        public String toString() {\n            final boolean omitNullValuesSnapshot = this.omitNullValues;\n            String nextSeparator = \"\";\n            final StringBuilder builder = new StringBuilder(32).append(this.className).append('{');\n            for (ValueHolder valueHolder = this.holderHead.next; valueHolder != null; valueHolder = valueHolder.next) {\n                if (!omitNullValuesSnapshot || valueHolder.value != null) {\n                    builder.append(nextSeparator);\n                    nextSeparator = \", \";\n                    if (valueHolder.name != null) {\n                        builder.append(valueHolder.name).append('=');\n                    }\n                    builder.append(valueHolder.value);\n                }\n            }\n            return builder.append('}').toString();\n        }\n        \n        private ValueHolder addHolder() {\n            final ValueHolder valueHolder = new ValueHolder();\n            final ValueHolder holderTail = this.holderTail;\n            final ValueHolder valueHolder2 = valueHolder;\n            holderTail.next = valueHolder2;\n            this.holderTail = valueHolder2;\n            return valueHolder;\n        }\n        \n        private ToStringHelper addHolder(@Nullable final Object value) {\n            final ValueHolder valueHolder = this.addHolder();\n            valueHolder.value = value;\n            return this;\n        }\n        \n        private ToStringHelper addHolder(final String name, @Nullable final Object value) {\n            final ValueHolder valueHolder = this.addHolder();\n            valueHolder.value = value;\n            valueHolder.name = Preconditions.checkNotNull(name);\n            return this;\n        }\n        \n        private static final class ValueHolder\n        {\n            String name;\n            Object value;\n            ValueHolder next;\n        }\n    }\n}\n"
    },
    {
        "project_name": "guava",
        "class": "BigIntegerMath",
        "fqdn": "com.google.common.math",
        "source_code": "package com.google.common.math;\n\nimport com.google.common.base.*;\nimport com.google.common.annotations.*;\nimport java.math.*;\nimport java.util.*;\n\n@GwtCompatible(emulated = true)\npublic final class BigIntegerMath\n{\n    @VisibleForTesting\n    static final int SQRT2_PRECOMPUTE_THRESHOLD = 256;\n    @VisibleForTesting\n    static final BigInteger SQRT2_PRECOMPUTED_BITS;\n    private static final double LN_10;\n    private static final double LN_2;\n    \n    public static boolean isPowerOfTwo(final BigInteger x) {\n        Preconditions.checkNotNull(x);\n        return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;\n    }\n    \n    public static int log2(final BigInteger x, final RoundingMode mode) {\n        MathPreconditions.checkPositive(\"x\", Preconditions.checkNotNull(x));\n        final int logFloor = x.bitLength() - 1;\n        switch (mode) {\n            case UNNECESSARY: {\n                MathPreconditions.checkRoundingUnnecessary(isPowerOfTwo(x));\n            }\n            case DOWN:\n            case FLOOR: {\n                return logFloor;\n            }\n            case UP:\n            case CEILING: {\n                return isPowerOfTwo(x) ? logFloor : (logFloor + 1);\n            }\n            case HALF_DOWN:\n            case HALF_UP:\n            case HALF_EVEN: {\n                if (logFloor >= 256) {\n                    final BigInteger x2 = x.pow(2);\n                    final int logX2Floor = x2.bitLength() - 1;\n                    return (logX2Floor < 2 * logFloor + 1) ? logFloor : (logFloor + 1);\n                }\n                final BigInteger halfPower = BigIntegerMath.SQRT2_PRECOMPUTED_BITS.shiftRight(256 - logFloor);\n                if (x.compareTo(halfPower) <= 0) {\n                    return logFloor;\n                }\n                return logFloor + 1;\n            }\n            default: {\n                throw new AssertionError();\n            }\n        }\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    public static int log10(final BigInteger x, final RoundingMode mode) {\n        MathPreconditions.checkPositive(\"x\", x);\n        if (fitsInLong(x)) {\n            return LongMath.log10(x.longValue(), mode);\n        }\n        int approxLog10 = (int)(log2(x, RoundingMode.FLOOR) * BigIntegerMath.LN_2 / BigIntegerMath.LN_10);\n        BigInteger approxPow = BigInteger.TEN.pow(approxLog10);\n        int approxCmp = approxPow.compareTo(x);\n        if (approxCmp > 0) {\n            do {\n                --approxLog10;\n                approxPow = approxPow.divide(BigInteger.TEN);\n                approxCmp = approxPow.compareTo(x);\n            } while (approxCmp > 0);\n        }\n        else {\n            BigInteger nextPow = BigInteger.TEN.multiply(approxPow);\n            for (int nextCmp = nextPow.compareTo(x); nextCmp <= 0; nextCmp = nextPow.compareTo(x)) {\n                ++approxLog10;\n                approxPow = nextPow;\n                approxCmp = nextCmp;\n                nextPow = BigInteger.TEN.multiply(approxPow);\n            }\n        }\n        final int floorLog = approxLog10;\n        final BigInteger floorPow = approxPow;\n        final int floorCmp = approxCmp;\n        switch (mode) {\n            case UNNECESSARY: {\n                MathPreconditions.checkRoundingUnnecessary(floorCmp == 0);\n            }\n            case DOWN:\n            case FLOOR: {\n                return floorLog;\n            }\n            case UP:\n            case CEILING: {\n                return floorPow.equals(x) ? floorLog : (floorLog + 1);\n            }\n            case HALF_DOWN:\n            case HALF_UP:\n            case HALF_EVEN: {\n                final BigInteger x2 = x.pow(2);\n                final BigInteger halfPowerSquared = floorPow.pow(2).multiply(BigInteger.TEN);\n                return (x2.compareTo(halfPowerSquared) <= 0) ? floorLog : (floorLog + 1);\n            }\n            default: {\n                throw new AssertionError();\n            }\n        }\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    public static BigInteger sqrt(final BigInteger x, final RoundingMode mode) {\n        MathPreconditions.checkNonNegative(\"x\", x);\n        if (fitsInLong(x)) {\n            return BigInteger.valueOf(LongMath.sqrt(x.longValue(), mode));\n        }\n        final BigInteger sqrtFloor = sqrtFloor(x);\n        switch (mode) {\n            case UNNECESSARY: {\n                MathPreconditions.checkRoundingUnnecessary(sqrtFloor.pow(2).equals(x));\n            }\n            case DOWN:\n            case FLOOR: {\n                return sqrtFloor;\n            }\n            case UP:\n            case CEILING: {\n                final int sqrtFloorInt = sqrtFloor.intValue();\n                final boolean sqrtFloorIsExact = sqrtFloorInt * sqrtFloorInt == x.intValue() && sqrtFloor.pow(2).equals(x);\n                return sqrtFloorIsExact ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n            }\n            case HALF_DOWN:\n            case HALF_UP:\n            case HALF_EVEN: {\n                final BigInteger halfSquare = sqrtFloor.pow(2).add(sqrtFloor);\n                return (halfSquare.compareTo(x) >= 0) ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n            }\n            default: {\n                throw new AssertionError();\n            }\n        }\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    private static BigInteger sqrtFloor(final BigInteger x) {\n        final int log2 = log2(x, RoundingMode.FLOOR);\n        BigInteger sqrt0;\n        if (log2 < 1023) {\n            sqrt0 = sqrtApproxWithDoubles(x);\n        }\n        else {\n            final int shift = log2 - 52 & 0xFFFFFFFE;\n            sqrt0 = sqrtApproxWithDoubles(x.shiftRight(shift)).shiftLeft(shift >> 1);\n        }\n        BigInteger sqrt2 = sqrt0.add(x.divide(sqrt0)).shiftRight(1);\n        if (sqrt0.equals(sqrt2)) {\n            return sqrt0;\n        }\n        do {\n            sqrt0 = sqrt2;\n            sqrt2 = sqrt0.add(x.divide(sqrt0)).shiftRight(1);\n        } while (sqrt2.compareTo(sqrt0) < 0);\n        return sqrt0;\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    private static BigInteger sqrtApproxWithDoubles(final BigInteger x) {\n        return DoubleMath.roundToBigInteger(Math.sqrt(DoubleUtils.bigToDouble(x)), RoundingMode.HALF_EVEN);\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    public static BigInteger divide(final BigInteger p, final BigInteger q, final RoundingMode mode) {\n        final BigDecimal pDec = new BigDecimal(p);\n        final BigDecimal qDec = new BigDecimal(q);\n        return pDec.divide(qDec, 0, mode).toBigIntegerExact();\n    }\n    \n    public static BigInteger factorial(final int n) {\n        MathPreconditions.checkNonNegative(\"n\", n);\n        if (n < LongMath.factorials.length) {\n            return BigInteger.valueOf(LongMath.factorials[n]);\n        }\n        final int approxSize = IntMath.divide(n * IntMath.log2(n, RoundingMode.CEILING), 64, RoundingMode.CEILING);\n        final ArrayList<BigInteger> bignums = new ArrayList<BigInteger>(approxSize);\n        final int startingNumber = LongMath.factorials.length;\n        long product = LongMath.factorials[startingNumber - 1];\n        int shift = Long.numberOfTrailingZeros(product);\n        product >>= shift;\n        int productBits = LongMath.log2(product, RoundingMode.FLOOR) + 1;\n        int bits = LongMath.log2(startingNumber, RoundingMode.FLOOR) + 1;\n        int nextPowerOfTwo = 1 << bits - 1;\n        for (long num = startingNumber; num <= n; ++num) {\n            if ((num & nextPowerOfTwo) != 0x0L) {\n                nextPowerOfTwo <<= 1;\n                ++bits;\n            }\n            final int tz = Long.numberOfTrailingZeros(num);\n            final long normalizedNum = num >> tz;\n            shift += tz;\n            final int normalizedBits = bits - tz;\n            if (normalizedBits + productBits >= 64) {\n                bignums.add(BigInteger.valueOf(product));\n                product = 1L;\n                productBits = 0;\n            }\n            product *= normalizedNum;\n            productBits = LongMath.log2(product, RoundingMode.FLOOR) + 1;\n        }\n        if (product > 1L) {\n            bignums.add(BigInteger.valueOf(product));\n        }\n        return listProduct(bignums).shiftLeft(shift);\n    }\n    \n    static BigInteger listProduct(final List<BigInteger> nums) {\n        return listProduct(nums, 0, nums.size());\n    }\n    \n    static BigInteger listProduct(final List<BigInteger> nums, final int start, final int end) {\n        switch (end - start) {\n            case 0: {\n                return BigInteger.ONE;\n            }\n            case 1: {\n                return nums.get(start);\n            }\n            case 2: {\n                return nums.get(start).multiply(nums.get(start + 1));\n            }\n            case 3: {\n                return nums.get(start).multiply(nums.get(start + 1)).multiply(nums.get(start + 2));\n            }\n            default: {\n                final int m = end + start >>> 1;\n                return listProduct(nums, start, m).multiply(listProduct(nums, m, end));\n            }\n        }\n    }\n    \n    public static BigInteger binomial(final int n, int k) {\n        MathPreconditions.checkNonNegative(\"n\", n);\n        MathPreconditions.checkNonNegative(\"k\", k);\n        Preconditions.checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n        if (k > n >> 1) {\n            k = n - k;\n        }\n        if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {\n            return BigInteger.valueOf(LongMath.binomial(n, k));\n        }\n        BigInteger accum = BigInteger.ONE;\n        long numeratorAccum = n;\n        long denominatorAccum = 1L;\n        int numeratorBits;\n        final int bits = numeratorBits = LongMath.log2(n, RoundingMode.CEILING);\n        for (int i = 1; i < k; ++i) {\n            final int p = n - i;\n            final int q = i + 1;\n            if (numeratorBits + bits >= 63) {\n                accum = accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));\n                numeratorAccum = p;\n                denominatorAccum = q;\n                numeratorBits = bits;\n            }\n            else {\n                numeratorAccum *= p;\n                denominatorAccum *= q;\n                numeratorBits += bits;\n            }\n        }\n        return accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));\n    }\n    \n    @GwtIncompatible(\"TODO\")\n    static boolean fitsInLong(final BigInteger x) {\n        return x.bitLength() <= 63;\n    }\n    \n    static {\n        SQRT2_PRECOMPUTED_BITS = new BigInteger(\"16a09e667f3bcc908b2fb1366ea957d3e3adec17512775099da2f590b0667322a\", 16);\n        LN_10 = Math.log(10.0);\n        LN_2 = Math.log(2.0);\n    }\n}\n"
    }
]