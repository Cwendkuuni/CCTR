[
    {
        "project_name": "trove",
        "class": "TCharHash",
        "fqdn": "gnu.trove.impl.hash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport java.util.*;\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\n\npublic abstract class TCharHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient char[] _set;\n    protected char no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TCharHash() {\n        this.no_entry_value = Constants.DEFAULT_CHAR_NO_ENTRY_VALUE;\n        if (this.no_entry_value != '\\0') {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TCharHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_value = Constants.DEFAULT_CHAR_NO_ENTRY_VALUE;\n        if (this.no_entry_value != '\\0') {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TCharHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = Constants.DEFAULT_CHAR_NO_ENTRY_VALUE;\n        if (this.no_entry_value != '\\0') {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TCharHash(final int initialCapacity, final float loadFactor, final char no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = no_entry_value;\n        if (no_entry_value != '\\0') {\n            Arrays.fill(this._set, no_entry_value);\n        }\n    }\n    \n    public char getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new char[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final char val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TCharProcedure procedure) {\n        final byte[] states = this._states;\n        final char[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_value;\n        super.removeAt(index);\n    }\n    \n    protected int index(final char val) {\n        final byte[] states = this._states;\n        final char[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == val) {\n            return index;\n        }\n        return this.indexRehashed(val, index, hash, state);\n    }\n    \n    int indexRehashed(final char key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final char val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final char val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final char val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n}\n"
    },
    {
        "project_name": "trove",
        "class": "TShortByteMapDecorator",
        "fqdn": "gnu.trove.decorator",
        "source_code": "package gnu.trove.decorator;\n\nimport gnu.trove.map.*;\nimport gnu.trove.iterator.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class TShortByteMapDecorator extends AbstractMap<Short, Byte> implements Map<Short, Byte>, Externalizable, Cloneable\n{\n    static final long serialVersionUID = 1L;\n    protected TShortByteMap _map;\n    \n    public TShortByteMapDecorator() {\n    }\n    \n    public TShortByteMapDecorator(final TShortByteMap map) {\n        this._map = map;\n    }\n    \n    public TShortByteMap getMap() {\n        return this._map;\n    }\n    \n    public Byte put(final Short key, final Byte value) {\n        short k;\n        if (key == null) {\n            k = this._map.getNoEntryKey();\n        }\n        else {\n            k = this.unwrapKey(key);\n        }\n        byte v;\n        if (value == null) {\n            v = this._map.getNoEntryValue();\n        }\n        else {\n            v = this.unwrapValue(value);\n        }\n        final byte retval = this._map.put(k, v);\n        if (retval == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(retval);\n    }\n    \n    public Byte get(final Object key) {\n        short k;\n        if (key != null) {\n            if (!(key instanceof Short)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final byte v = this._map.get(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public void clear() {\n        this._map.clear();\n    }\n    \n    public Byte remove(final Object key) {\n        short k;\n        if (key != null) {\n            if (!(key instanceof Short)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final byte v = this._map.remove(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public Set<Entry<Short, Byte>> entrySet() {\n        return new AbstractSet<Entry<Short, Byte>>() {\n            public int size() {\n                return TShortByteMapDecorator.this._map.size();\n            }\n            \n            public boolean isEmpty() {\n                return TShortByteMapDecorator.this.isEmpty();\n            }\n            \n            public boolean contains(final Object o) {\n                if (o instanceof Entry) {\n                    final Object k = ((Entry)o).getKey();\n                    final Object v = ((Entry)o).getValue();\n                    return TShortByteMapDecorator.this.containsKey(k) && TShortByteMapDecorator.this.get(k).equals(v);\n                }\n                return false;\n            }\n            \n            public Iterator<Entry<Short, Byte>> iterator() {\n                return new Iterator<Entry<Short, Byte>>() {\n                    private final TShortByteIterator it = TShortByteMapDecorator.this._map.iterator();\n                    \n                    public Entry<Short, Byte> next() {\n                        this.it.advance();\n                        final short ik = this.it.key();\n                        final Short key = (ik == TShortByteMapDecorator.this._map.getNoEntryKey()) ? null : TShortByteMapDecorator.this.wrapKey(ik);\n                        final byte iv = this.it.value();\n                        final Byte v = (iv == TShortByteMapDecorator.this._map.getNoEntryValue()) ? null : TShortByteMapDecorator.this.wrapValue(iv);\n                        return new Entry<Short, Byte>() {\n                            private Byte val = v;\n                            \n                            public boolean equals(final Object o) {\n                                return o instanceof Entry && ((Entry)o).getKey().equals(key) && ((Entry)o).getValue().equals(this.val);\n                            }\n                            \n                            public Short getKey() {\n                                return key;\n                            }\n                            \n                            public Byte getValue() {\n                                return this.val;\n                            }\n                            \n                            public int hashCode() {\n                                return key.hashCode() + this.val.hashCode();\n                            }\n                            \n                            public Byte setValue(final Byte value) {\n                                this.val = value;\n                                return TShortByteMapDecorator.this.put(key, value);\n                            }\n                        };\n                    }\n                    \n                    public boolean hasNext() {\n                        return this.it.hasNext();\n                    }\n                    \n                    public void remove() {\n                        this.it.remove();\n                    }\n                };\n            }\n            \n            public boolean add(final Entry<Short, Byte> o) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public boolean remove(final Object o) {\n                boolean modified = false;\n                if (this.contains(o)) {\n                    final Short key = ((Entry)o).getKey();\n                    TShortByteMapDecorator.this._map.remove(TShortByteMapDecorator.this.unwrapKey(key));\n                    modified = true;\n                }\n                return modified;\n            }\n            \n            public boolean addAll(final Collection<? extends Entry<Short, Byte>> c) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public void clear() {\n                TShortByteMapDecorator.this.clear();\n            }\n        };\n    }\n    \n    public boolean containsValue(final Object val) {\n        return val instanceof Byte && this._map.containsValue(this.unwrapValue(val));\n    }\n    \n    public boolean containsKey(final Object key) {\n        if (key == null) {\n            return this._map.containsKey(this._map.getNoEntryKey());\n        }\n        return key instanceof Short && this._map.containsKey(this.unwrapKey(key));\n    }\n    \n    public int size() {\n        return this._map.size();\n    }\n    \n    public boolean isEmpty() {\n        return this.size() == 0;\n    }\n    \n    public void putAll(final Map<? extends Short, ? extends Byte> map) {\n        final Iterator<? extends Entry<? extends Short, ? extends Byte>> it = map.entrySet().iterator();\n        int i = map.size();\n        while (i-- > 0) {\n            final Entry<? extends Short, ? extends Byte> e = (Entry<? extends Short, ? extends Byte>)it.next();\n            this.put((Short)e.getKey(), (Byte)e.getValue());\n        }\n    }\n    \n    protected Short wrapKey(final short k) {\n        return k;\n    }\n    \n    protected short unwrapKey(final Object key) {\n        return (short)key;\n    }\n    \n    protected Byte wrapValue(final byte k) {\n        return k;\n    }\n    \n    protected byte unwrapValue(final Object value) {\n        return (byte)value;\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        this._map = (TShortByteMap)in.readObject();\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        out.writeObject(this._map);\n    }\n}\n"
    },
    {
        "project_name": "trove",
        "class": "TDoubleShortMapDecorator",
        "fqdn": "gnu.trove.decorator",
        "source_code": "package gnu.trove.decorator;\n\nimport gnu.trove.map.*;\nimport gnu.trove.iterator.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class TDoubleShortMapDecorator extends AbstractMap<Double, Short> implements Map<Double, Short>, Externalizable, Cloneable\n{\n    static final long serialVersionUID = 1L;\n    protected TDoubleShortMap _map;\n    \n    public TDoubleShortMapDecorator() {\n    }\n    \n    public TDoubleShortMapDecorator(final TDoubleShortMap map) {\n        this._map = map;\n    }\n    \n    public TDoubleShortMap getMap() {\n        return this._map;\n    }\n    \n    public Short put(final Double key, final Short value) {\n        double k;\n        if (key == null) {\n            k = this._map.getNoEntryKey();\n        }\n        else {\n            k = this.unwrapKey(key);\n        }\n        short v;\n        if (value == null) {\n            v = this._map.getNoEntryValue();\n        }\n        else {\n            v = this.unwrapValue(value);\n        }\n        final short retval = this._map.put(k, v);\n        if (retval == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(retval);\n    }\n    \n    public Short get(final Object key) {\n        double k;\n        if (key != null) {\n            if (!(key instanceof Double)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final short v = this._map.get(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public void clear() {\n        this._map.clear();\n    }\n    \n    public Short remove(final Object key) {\n        double k;\n        if (key != null) {\n            if (!(key instanceof Double)) {\n                return null;\n            }\n            k = this.unwrapKey(key);\n        }\n        else {\n            k = this._map.getNoEntryKey();\n        }\n        final short v = this._map.remove(k);\n        if (v == this._map.getNoEntryValue()) {\n            return null;\n        }\n        return this.wrapValue(v);\n    }\n    \n    public Set<Entry<Double, Short>> entrySet() {\n        return new AbstractSet<Entry<Double, Short>>() {\n            public int size() {\n                return TDoubleShortMapDecorator.this._map.size();\n            }\n            \n            public boolean isEmpty() {\n                return TDoubleShortMapDecorator.this.isEmpty();\n            }\n            \n            public boolean contains(final Object o) {\n                if (o instanceof Entry) {\n                    final Object k = ((Entry)o).getKey();\n                    final Object v = ((Entry)o).getValue();\n                    return TDoubleShortMapDecorator.this.containsKey(k) && TDoubleShortMapDecorator.this.get(k).equals(v);\n                }\n                return false;\n            }\n            \n            public Iterator<Entry<Double, Short>> iterator() {\n                return new Iterator<Entry<Double, Short>>() {\n                    private final TDoubleShortIterator it = TDoubleShortMapDecorator.this._map.iterator();\n                    \n                    public Entry<Double, Short> next() {\n                        this.it.advance();\n                        final double ik = this.it.key();\n                        final Double key = (ik == TDoubleShortMapDecorator.this._map.getNoEntryKey()) ? null : TDoubleShortMapDecorator.this.wrapKey(ik);\n                        final short iv = this.it.value();\n                        final Short v = (iv == TDoubleShortMapDecorator.this._map.getNoEntryValue()) ? null : TDoubleShortMapDecorator.this.wrapValue(iv);\n                        return new Entry<Double, Short>() {\n                            private Short val = v;\n                            \n                            public boolean equals(final Object o) {\n                                return o instanceof Entry && ((Entry)o).getKey().equals(key) && ((Entry)o).getValue().equals(this.val);\n                            }\n                            \n                            public Double getKey() {\n                                return key;\n                            }\n                            \n                            public Short getValue() {\n                                return this.val;\n                            }\n                            \n                            public int hashCode() {\n                                return key.hashCode() + this.val.hashCode();\n                            }\n                            \n                            public Short setValue(final Short value) {\n                                this.val = value;\n                                return TDoubleShortMapDecorator.this.put(key, value);\n                            }\n                        };\n                    }\n                    \n                    public boolean hasNext() {\n                        return this.it.hasNext();\n                    }\n                    \n                    public void remove() {\n                        this.it.remove();\n                    }\n                };\n            }\n            \n            public boolean add(final Entry<Double, Short> o) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public boolean remove(final Object o) {\n                boolean modified = false;\n                if (this.contains(o)) {\n                    final Double key = ((Entry)o).getKey();\n                    TDoubleShortMapDecorator.this._map.remove(TDoubleShortMapDecorator.this.unwrapKey(key));\n                    modified = true;\n                }\n                return modified;\n            }\n            \n            public boolean addAll(final Collection<? extends Entry<Double, Short>> c) {\n                throw new UnsupportedOperationException();\n            }\n            \n            public void clear() {\n                TDoubleShortMapDecorator.this.clear();\n            }\n        };\n    }\n    \n    public boolean containsValue(final Object val) {\n        return val instanceof Short && this._map.containsValue(this.unwrapValue(val));\n    }\n    \n    public boolean containsKey(final Object key) {\n        if (key == null) {\n            return this._map.containsKey(this._map.getNoEntryKey());\n        }\n        return key instanceof Double && this._map.containsKey(this.unwrapKey(key));\n    }\n    \n    public int size() {\n        return this._map.size();\n    }\n    \n    public boolean isEmpty() {\n        return this.size() == 0;\n    }\n    \n    public void putAll(final Map<? extends Double, ? extends Short> map) {\n        final Iterator<? extends Entry<? extends Double, ? extends Short>> it = map.entrySet().iterator();\n        int i = map.size();\n        while (i-- > 0) {\n            final Entry<? extends Double, ? extends Short> e = (Entry<? extends Double, ? extends Short>)it.next();\n            this.put((Double)e.getKey(), (Short)e.getValue());\n        }\n    }\n    \n    protected Double wrapKey(final double k) {\n        return k;\n    }\n    \n    protected double unwrapKey(final Object key) {\n        return (double)key;\n    }\n    \n    protected Short wrapValue(final short k) {\n        return k;\n    }\n    \n    protected short unwrapValue(final Object value) {\n        return (short)value;\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        this._map = (TDoubleShortMap)in.readObject();\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        out.writeObject(this._map);\n    }\n}\n"
    },
    {
        "project_name": "trove",
        "class": "TShortHash",
        "fqdn": "gnu.trove.impl.hash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport java.util.*;\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\n\npublic abstract class TShortHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient short[] _set;\n    protected short no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TShortHash() {\n        this.no_entry_value = Constants.DEFAULT_SHORT_NO_ENTRY_VALUE;\n        if (this.no_entry_value != 0) {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TShortHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_value = Constants.DEFAULT_SHORT_NO_ENTRY_VALUE;\n        if (this.no_entry_value != 0) {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TShortHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = Constants.DEFAULT_SHORT_NO_ENTRY_VALUE;\n        if (this.no_entry_value != 0) {\n            Arrays.fill(this._set, this.no_entry_value);\n        }\n    }\n    \n    public TShortHash(final int initialCapacity, final float loadFactor, final short no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_value = no_entry_value;\n        if (no_entry_value != 0) {\n            Arrays.fill(this._set, no_entry_value);\n        }\n    }\n    \n    public short getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new short[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final short val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TShortProcedure procedure) {\n        final byte[] states = this._states;\n        final short[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_value;\n        super.removeAt(index);\n    }\n    \n    protected int index(final short val) {\n        final byte[] states = this._states;\n        final short[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == val) {\n            return index;\n        }\n        return this.indexRehashed(val, index, hash, state);\n    }\n    \n    int indexRehashed(final short key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final short val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final short val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final short val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n}\n"
    },
    {
        "project_name": "trove",
        "class": "TFloatCharHash",
        "fqdn": "gnu.trove.impl.hash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\nimport java.io.*;\n\npublic abstract class TFloatCharHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient float[] _set;\n    protected float no_entry_key;\n    protected char no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TFloatCharHash() {\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = '\\0';\n    }\n    \n    public TFloatCharHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = '\\0';\n    }\n    \n    public TFloatCharHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = '\\0';\n    }\n    \n    public TFloatCharHash(final int initialCapacity, final float loadFactor, final float no_entry_key, final char no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = no_entry_key;\n        this.no_entry_value = no_entry_value;\n    }\n    \n    public float getNoEntryKey() {\n        return this.no_entry_key;\n    }\n    \n    public char getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new float[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final float val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TFloatProcedure procedure) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_key;\n        super.removeAt(index);\n    }\n    \n    protected int index(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == key) {\n            return index;\n        }\n        return this.indexRehashed(key, index, hash, state);\n    }\n    \n    int indexRehashed(final float key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final float val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final float val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final float val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n    \n    protected int XinsertKey(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        int index = hash % length;\n        byte state = states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n        if (state == 1 && set[index] == key) {\n            return -index - 1;\n        }\n        final int probe = 1 + hash % (length - 2);\n        if (state != 2) {\n            do {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            } while (state == 1 && set[index] != key);\n        }\n        if (state == 2) {\n            final int firstRemoved = index;\n            while (state != 0 && (state == 2 || set[index] != key)) {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            }\n            if (state == 1) {\n                return -index - 1;\n            }\n            set[index] = key;\n            states[index] = 1;\n            return firstRemoved;\n        }\n        else {\n            if (state == 1) {\n                return -index - 1;\n            }\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        super.writeExternal(out);\n        out.writeFloat(this.no_entry_key);\n        out.writeChar(this.no_entry_value);\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        super.readExternal(in);\n        this.no_entry_key = in.readFloat();\n        this.no_entry_value = in.readChar();\n    }\n}\n"
    },
    {
        "project_name": "trove",
        "class": "TFloatDoubleHash",
        "fqdn": "gnu.trove.impl.hash",
        "source_code": "package gnu.trove.impl.hash;\n\nimport gnu.trove.procedure.*;\nimport gnu.trove.impl.*;\nimport java.io.*;\n\npublic abstract class TFloatDoubleHash extends TPrimitiveHash\n{\n    static final long serialVersionUID = 1L;\n    public transient float[] _set;\n    protected float no_entry_key;\n    protected double no_entry_value;\n    protected boolean consumeFreeSlot;\n    \n    public TFloatDoubleHash() {\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = 0.0;\n    }\n    \n    public TFloatDoubleHash(final int initialCapacity) {\n        super(initialCapacity);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = 0.0;\n    }\n    \n    public TFloatDoubleHash(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = 0.0f;\n        this.no_entry_value = 0.0;\n    }\n    \n    public TFloatDoubleHash(final int initialCapacity, final float loadFactor, final float no_entry_key, final double no_entry_value) {\n        super(initialCapacity, loadFactor);\n        this.no_entry_key = no_entry_key;\n        this.no_entry_value = no_entry_value;\n    }\n    \n    public float getNoEntryKey() {\n        return this.no_entry_key;\n    }\n    \n    public double getNoEntryValue() {\n        return this.no_entry_value;\n    }\n    \n    protected int setUp(final int initialCapacity) {\n        final int capacity = super.setUp(initialCapacity);\n        this._set = new float[capacity];\n        return capacity;\n    }\n    \n    public boolean contains(final float val) {\n        return this.index(val) >= 0;\n    }\n    \n    public boolean forEach(final TFloatProcedure procedure) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        int i = set.length;\n        while (i-- > 0) {\n            if (states[i] == 1 && !procedure.execute(set[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected void removeAt(final int index) {\n        this._set[index] = this.no_entry_key;\n        super.removeAt(index);\n    }\n    \n    protected int index(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        final int index = hash % length;\n        final byte state = states[index];\n        if (state == 0) {\n            return -1;\n        }\n        if (state == 1 && set[index] == key) {\n            return index;\n        }\n        return this.indexRehashed(key, index, hash, state);\n    }\n    \n    int indexRehashed(final float key, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        do {\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                return -1;\n            }\n            if (key == this._set[index] && state != 2) {\n                return index;\n            }\n        } while (index != loopIndex);\n        return -1;\n    }\n    \n    protected int insertKey(final float val) {\n        final int hash = HashFunctions.hash(val) & Integer.MAX_VALUE;\n        final int index = hash % this._states.length;\n        final byte state = this._states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            this.insertKeyAt(index, val);\n            return index;\n        }\n        if (state == 1 && this._set[index] == val) {\n            return -index - 1;\n        }\n        return this.insertKeyRehash(val, index, hash, state);\n    }\n    \n    int insertKeyRehash(final float val, int index, final int hash, byte state) {\n        final int length = this._set.length;\n        final int probe = 1 + hash % (length - 2);\n        final int loopIndex = index;\n        int firstRemoved = -1;\n        do {\n            if (state == 2 && firstRemoved == -1) {\n                firstRemoved = index;\n            }\n            index -= probe;\n            if (index < 0) {\n                index += length;\n            }\n            state = this._states[index];\n            if (state == 0) {\n                if (firstRemoved != -1) {\n                    this.insertKeyAt(firstRemoved, val);\n                    return firstRemoved;\n                }\n                this.consumeFreeSlot = true;\n                this.insertKeyAt(index, val);\n                return index;\n            }\n            else {\n                if (state == 1 && this._set[index] == val) {\n                    return -index - 1;\n                }\n                continue;\n            }\n        } while (index != loopIndex);\n        if (firstRemoved != -1) {\n            this.insertKeyAt(firstRemoved, val);\n            return firstRemoved;\n        }\n        throw new IllegalStateException(\"No free or removed slots available. Key set full?!!\");\n    }\n    \n    void insertKeyAt(final int index, final float val) {\n        this._set[index] = val;\n        this._states[index] = 1;\n    }\n    \n    protected int XinsertKey(final float key) {\n        final byte[] states = this._states;\n        final float[] set = this._set;\n        final int length = states.length;\n        final int hash = HashFunctions.hash(key) & Integer.MAX_VALUE;\n        int index = hash % length;\n        byte state = states[index];\n        this.consumeFreeSlot = false;\n        if (state == 0) {\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n        if (state == 1 && set[index] == key) {\n            return -index - 1;\n        }\n        final int probe = 1 + hash % (length - 2);\n        if (state != 2) {\n            do {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            } while (state == 1 && set[index] != key);\n        }\n        if (state == 2) {\n            final int firstRemoved = index;\n            while (state != 0 && (state == 2 || set[index] != key)) {\n                index -= probe;\n                if (index < 0) {\n                    index += length;\n                }\n                state = states[index];\n            }\n            if (state == 1) {\n                return -index - 1;\n            }\n            set[index] = key;\n            states[index] = 1;\n            return firstRemoved;\n        }\n        else {\n            if (state == 1) {\n                return -index - 1;\n            }\n            this.consumeFreeSlot = true;\n            set[index] = key;\n            states[index] = 1;\n            return index;\n        }\n    }\n    \n    public void writeExternal(final ObjectOutput out) throws IOException {\n        out.writeByte(0);\n        super.writeExternal(out);\n        out.writeFloat(this.no_entry_key);\n        out.writeDouble(this.no_entry_value);\n    }\n    \n    public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\n        in.readByte();\n        super.readExternal(in);\n        this.no_entry_key = in.readFloat();\n        this.no_entry_value = in.readDouble();\n    }\n}\n"
    },
    {
        "project_name": "33_javaviewcontrol",
        "class": "TokenMgrError",
        "fqdn": "com.pmdesigns.jvc.tools",
        "source_code": "package com.pmdesigns.jvc.tools;\n\npublic class TokenMgrError extends Error\n{\n    private static final long serialVersionUID = 1L;\n    static final int LEXICAL_ERROR = 0;\n    static final int STATIC_LEXER_ERROR = 1;\n    static final int INVALID_LEXICAL_STATE = 2;\n    static final int LOOP_DETECTED = 3;\n    int errorCode;\n    \n    protected static final String addEscapes(final String str) {\n        final StringBuffer retval = new StringBuffer();\n        for (int i = 0; i < str.length(); ++i) {\n            switch (str.charAt(i)) {\n                case '\\0': {\n                    break;\n                }\n                case '\\b': {\n                    retval.append(\"\\\\b\");\n                    break;\n                }\n                case '\\t': {\n                    retval.append(\"\\\\t\");\n                    break;\n                }\n                case '\\n': {\n                    retval.append(\"\\\\n\");\n                    break;\n                }\n                case '\\f': {\n                    retval.append(\"\\\\f\");\n                    break;\n                }\n                case '\\r': {\n                    retval.append(\"\\\\r\");\n                    break;\n                }\n                case '\\\"': {\n                    retval.append(\"\\\\\\\"\");\n                    break;\n                }\n                case '\\'': {\n                    retval.append(\"\\\\'\");\n                    break;\n                }\n                case '\\\\': {\n                    retval.append(\"\\\\\\\\\");\n                    break;\n                }\n                default: {\n                    final char ch;\n                    if ((ch = str.charAt(i)) < ' ' || ch > '~') {\n                        final String s = \"0000\" + Integer.toString(ch, 16);\n                        retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                        break;\n                    }\n                    retval.append(ch);\n                    break;\n                }\n            }\n        }\n        return retval.toString();\n    }\n    \n    protected static String LexicalError(final boolean EOFSeen, final int lexState, final int errorLine, final int errorColumn, final String errorAfter, final char curChar) {\n        return \"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\" + \" (\" + (int)curChar + \"), \")) + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\";\n    }\n    \n    @Override\n    public String getMessage() {\n        return super.getMessage();\n    }\n    \n    public TokenMgrError() {\n    }\n    \n    public TokenMgrError(final String message, final int reason) {\n        super(message);\n        this.errorCode = reason;\n    }\n    \n    public TokenMgrError(final boolean EOFSeen, final int lexState, final int errorLine, final int errorColumn, final String errorAfter, final char curChar, final int reason) {\n        this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "BrentOptimizer",
        "fqdn": "org.apache.commons.math3.optim.univariate",
        "source_code": "package org.apache.commons.math3.optim.univariate;\n\nimport org.apache.commons.math3.optim.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.optim.nonlinear.scalar.*;\nimport org.apache.commons.math3.util.*;\n\npublic class BrentOptimizer extends UnivariateOptimizer\n{\n    private static final double GOLDEN_SECTION;\n    private static final double MIN_RELATIVE_TOLERANCE;\n    private final double relativeThreshold;\n    private final double absoluteThreshold;\n    \n    public BrentOptimizer(final double rel, final double abs, final ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n        if (rel < BrentOptimizer.MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, BrentOptimizer.MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0.0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        this.relativeThreshold = rel;\n        this.absoluteThreshold = abs;\n    }\n    \n    public BrentOptimizer(final double rel, final double abs) {\n        this(rel, abs, null);\n    }\n    \n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = this.getGoalType() == GoalType.MINIMIZE;\n        final double lo = this.getMin();\n        final double mid = this.getStartValue();\n        final double hi = this.getMax();\n        final ConvergenceChecker<UnivariatePointValuePair> checker = this.getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        }\n        else {\n            a = hi;\n            b = lo;\n        }\n        double v;\n        double w;\n        double x = w = (v = mid);\n        double d = 0.0;\n        double e = 0.0;\n        double fx = this.computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair best;\n        UnivariatePointValuePair current = best = new UnivariatePointValuePair(x, isMinim ? fx : (-fx));\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = this.relativeThreshold * FastMath.abs(x) + this.absoluteThreshold;\n            final double tol2 = 2.0 * tol1;\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                return this.best(best, this.best(previous, current, isMinim), isMinim);\n            }\n            double p = 0.0;\n            double q = 0.0;\n            double r = 0.0;\n            double u = 0.0;\n            if (FastMath.abs(e) > tol1) {\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2.0 * (q - r);\n                if (q > 0.0) {\n                    p = -p;\n                }\n                else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    d = p / q;\n                    u = x + d;\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        }\n                        else {\n                            d = -tol1;\n                        }\n                    }\n                }\n                else {\n                    if (x < m) {\n                        e = b - x;\n                    }\n                    else {\n                        e = a - x;\n                    }\n                    d = BrentOptimizer.GOLDEN_SECTION * e;\n                }\n            }\n            else {\n                if (x < m) {\n                    e = b - x;\n                }\n                else {\n                    e = a - x;\n                }\n                d = BrentOptimizer.GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0.0) {\n                    u = x + tol1;\n                }\n                else {\n                    u = x - tol1;\n                }\n            }\n            else {\n                u = x + d;\n            }\n            double fu = this.computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : (-fu));\n            best = this.best(best, this.best(previous, current, isMinim), isMinim);\n            if (checker != null && checker.converged(iter, previous, current)) {\n                return best;\n            }\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                }\n                else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            }\n            else {\n                if (u < x) {\n                    a = u;\n                }\n                else {\n                    b = u;\n                }\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                }\n                else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n            ++iter;\n        }\n    }\n    \n    private UnivariatePointValuePair best(final UnivariatePointValuePair a, final UnivariatePointValuePair b, final boolean isMinim) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n        if (isMinim) {\n            return (a.getValue() <= b.getValue()) ? a : b;\n        }\n        return (a.getValue() >= b.getValue()) ? a : b;\n    }\n    \n    static {\n        GOLDEN_SECTION = 0.5 * (3.0 - FastMath.sqrt(5.0));\n        MIN_RELATIVE_TOLERANCE = 2.0 * FastMath.ulp(1.0);\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "EmbeddedRungeKuttaIntegrator",
        "fqdn": "org.apache.commons.math3.ode.nonstiff",
        "source_code": "package org.apache.commons.math3.ode.nonstiff;\n\nimport org.apache.commons.math3.ode.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.ode.sampling.*;\nimport org.apache.commons.math3.exception.*;\n\npublic abstract class EmbeddedRungeKuttaIntegrator extends AdaptiveStepsizeIntegrator\n{\n    private final boolean fsal;\n    private final double[] c;\n    private final double[][] a;\n    private final double[] b;\n    private final RungeKuttaStepInterpolator prototype;\n    private final double exp;\n    private double safety;\n    private double minReduction;\n    private double maxGrowth;\n    \n    protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) {\n        super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n        this.fsal = fsal;\n        this.c = c;\n        this.a = a;\n        this.b = b;\n        this.prototype = prototype;\n        this.exp = -1.0 / this.getOrder();\n        this.setSafety(0.9);\n        this.setMinReduction(0.2);\n        this.setMaxGrowth(10.0);\n    }\n    \n    protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) {\n        super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n        this.fsal = fsal;\n        this.c = c;\n        this.a = a;\n        this.b = b;\n        this.prototype = prototype;\n        this.exp = -1.0 / this.getOrder();\n        this.setSafety(0.9);\n        this.setMinReduction(0.2);\n        this.setMaxGrowth(10.0);\n    }\n    \n    public abstract int getOrder();\n    \n    public double getSafety() {\n        return this.safety;\n    }\n    \n    public void setSafety(final double safety) {\n        this.safety = safety;\n    }\n    \n    public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {\n        this.sanityChecks(equations, t);\n        this.setEquations(equations);\n        final boolean forward = t > equations.getTime();\n        final double[] y0 = equations.getCompleteState();\n        final double[] y2 = y0.clone();\n        final int stages = this.c.length + 1;\n        final double[][] yDotK = new double[stages][y2.length];\n        final double[] yTmp = y0.clone();\n        final double[] yDotTmp = new double[y2.length];\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator)this.prototype.copy();\n        interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n        interpolator.storeTime(equations.getTime());\n        this.stepStart = equations.getTime();\n        double hNew = 0.0;\n        boolean firstTime = true;\n        this.initIntegration(equations.getTime(), y0, t);\n        this.isLastStep = false;\n        do {\n            interpolator.shift();\n            double error = 10.0;\n            while (error >= 1.0) {\n                if (firstTime || !this.fsal) {\n                    this.computeDerivatives(this.stepStart, y2, yDotK[0]);\n                }\n                if (firstTime) {\n                    final double[] scale = new double[this.mainSetDimension];\n                    if (this.vecAbsoluteTolerance == null) {\n                        for (int i = 0; i < scale.length; ++i) {\n                            scale[i] = this.scalAbsoluteTolerance + this.scalRelativeTolerance * FastMath.abs(y2[i]);\n                        }\n                    }\n                    else {\n                        for (int i = 0; i < scale.length; ++i) {\n                            scale[i] = this.vecAbsoluteTolerance[i] + this.vecRelativeTolerance[i] * FastMath.abs(y2[i]);\n                        }\n                    }\n                    hNew = this.initializeStep(forward, this.getOrder(), scale, this.stepStart, y2, yDotK[0], yTmp, yDotK[1]);\n                    firstTime = false;\n                }\n                this.stepSize = hNew;\n                if (forward) {\n                    if (this.stepStart + this.stepSize >= t) {\n                        this.stepSize = t - this.stepStart;\n                    }\n                }\n                else if (this.stepStart + this.stepSize <= t) {\n                    this.stepSize = t - this.stepStart;\n                }\n                for (int k = 1; k < stages; ++k) {\n                    for (int j = 0; j < y0.length; ++j) {\n                        double sum = this.a[k - 1][0] * yDotK[0][j];\n                        for (int l = 1; l < k; ++l) {\n                            sum += this.a[k - 1][l] * yDotK[l][j];\n                        }\n                        yTmp[j] = y2[j] + this.stepSize * sum;\n                    }\n                    this.computeDerivatives(this.stepStart + this.c[k - 1] * this.stepSize, yTmp, yDotK[k]);\n                }\n                for (int m = 0; m < y0.length; ++m) {\n                    double sum2 = this.b[0] * yDotK[0][m];\n                    for (int l2 = 1; l2 < stages; ++l2) {\n                        sum2 += this.b[l2] * yDotK[l2][m];\n                    }\n                    yTmp[m] = y2[m] + this.stepSize * sum2;\n                }\n                error = this.estimateError(yDotK, y2, yTmp, this.stepSize);\n                if (error >= 1.0) {\n                    final double factor = FastMath.min(this.maxGrowth, FastMath.max(this.minReduction, this.safety * FastMath.pow(error, this.exp)));\n                    hNew = this.filterStep(this.stepSize * factor, forward, false);\n                }\n            }\n            interpolator.storeTime(this.stepStart + this.stepSize);\n            System.arraycopy(yTmp, 0, y2, 0, y0.length);\n            System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n            this.stepStart = this.acceptStep(interpolator, y2, yDotTmp, t);\n            System.arraycopy(y2, 0, yTmp, 0, y2.length);\n            if (!this.isLastStep) {\n                interpolator.storeTime(this.stepStart);\n                if (this.fsal) {\n                    System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n                }\n                final double factor = FastMath.min(this.maxGrowth, FastMath.max(this.minReduction, this.safety * FastMath.pow(error, this.exp)));\n                final double scaledH = this.stepSize * factor;\n                final double nextT = this.stepStart + scaledH;\n                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n                hNew = this.filterStep(scaledH, forward, nextIsLast);\n                final double filteredNextT = this.stepStart + hNew;\n                final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n                if (!filteredNextIsLast) {\n                    continue;\n                }\n                hNew = t - this.stepStart;\n            }\n        } while (!this.isLastStep);\n        equations.setTime(this.stepStart);\n        equations.setCompleteState(y2);\n        this.resetInternalState();\n    }\n    \n    public double getMinReduction() {\n        return this.minReduction;\n    }\n    \n    public void setMinReduction(final double minReduction) {\n        this.minReduction = minReduction;\n    }\n    \n    public double getMaxGrowth() {\n        return this.maxGrowth;\n    }\n    \n    public void setMaxGrowth(final double maxGrowth) {\n        this.maxGrowth = maxGrowth;\n    }\n    \n    protected abstract double estimateError(final double[][] p0, final double[] p1, final double[] p2, final double p3);\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "ProperFractionFormat",
        "fqdn": "org.apache.commons.math3.fraction",
        "source_code": "package org.apache.commons.math3.fraction;\n\nimport java.text.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.exception.util.*;\n\npublic class ProperFractionFormat extends FractionFormat\n{\n    private static final long serialVersionUID = 760934726031766749L;\n    private NumberFormat wholeFormat;\n    \n    public ProperFractionFormat() {\n        this(FractionFormat.getDefaultNumberFormat());\n    }\n    \n    public ProperFractionFormat(final NumberFormat format) {\n        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n    }\n    \n    public ProperFractionFormat(final NumberFormat wholeFormat, final NumberFormat numeratorFormat, final NumberFormat denominatorFormat) {\n        super(numeratorFormat, denominatorFormat);\n        this.setWholeFormat(wholeFormat);\n    }\n    \n    public StringBuffer format(final Fraction fraction, final StringBuffer toAppendTo, final FieldPosition pos) {\n        pos.setBeginIndex(0);\n        pos.setEndIndex(0);\n        int num = fraction.getNumerator();\n        final int den = fraction.getDenominator();\n        final int whole = num / den;\n        num %= den;\n        if (whole != 0) {\n            this.getWholeFormat().format(whole, toAppendTo, pos);\n            toAppendTo.append(' ');\n            num = Math.abs(num);\n        }\n        this.getNumeratorFormat().format(num, toAppendTo, pos);\n        toAppendTo.append(\" / \");\n        this.getDenominatorFormat().format(den, toAppendTo, pos);\n        return toAppendTo;\n    }\n    \n    public NumberFormat getWholeFormat() {\n        return this.wholeFormat;\n    }\n    \n    public Fraction parse(final String source, final ParsePosition pos) {\n        final Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        final int initialIndex = pos.getIndex();\n        AbstractFormat.parseAndIgnoreWhitespace(source, pos);\n        final Number whole = this.getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        AbstractFormat.parseAndIgnoreWhitespace(source, pos);\n        final Number num = this.getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        if (num.intValue() < 0) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        final int startIndex = pos.getIndex();\n        final char c = AbstractFormat.parseNextCharacter(source, pos);\n        switch (c) {\n            case '\\0': {\n                return new Fraction(num.intValue(), 1);\n            }\n            case '/': {\n                AbstractFormat.parseAndIgnoreWhitespace(source, pos);\n                final Number den = this.getDenominatorFormat().parse(source, pos);\n                if (den == null) {\n                    pos.setIndex(initialIndex);\n                    return null;\n                }\n                if (den.intValue() < 0) {\n                    pos.setIndex(initialIndex);\n                    return null;\n                }\n                final int w = whole.intValue();\n                final int n = num.intValue();\n                final int d = den.intValue();\n                return new Fraction((Math.abs(w) * d + n) * MathUtils.copySign(1, w), d);\n            }\n            default: {\n                pos.setIndex(initialIndex);\n                pos.setErrorIndex(startIndex);\n                return null;\n            }\n        }\n    }\n    \n    public void setWholeFormat(final NumberFormat format) {\n        if (format == null) {\n            throw new NullArgumentException(LocalizedFormats.WHOLE_FORMAT, new Object[0]);\n        }\n        this.wholeFormat = format;\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "IntervalsSet",
        "fqdn": "org.apache.commons.math3.geometry.euclidean.oned",
        "source_code": "package org.apache.commons.math3.geometry.euclidean.oned;\n\nimport org.apache.commons.math3.geometry.*;\nimport org.apache.commons.math3.util.*;\nimport java.util.*;\nimport org.apache.commons.math3.geometry.partitioning.*;\n\npublic class IntervalsSet extends AbstractRegion<Euclidean1D, Euclidean1D>\n{\n    public IntervalsSet() {\n    }\n    \n    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n    \n    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }\n    \n    public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) {\n        super(boundary);\n    }\n    \n    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && lower < 0.0) {\n            if (Double.isInfinite(upper) && upper > 0.0) {\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            final SubHyperplane<Euclidean1D> upperCut = new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null);\n        }\n        else {\n            final SubHyperplane<Euclidean1D> lowerCut = new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n            if (Double.isInfinite(upper) && upper > 0.0) {\n                return new BSPTree<Euclidean1D>(lowerCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null);\n            }\n            final SubHyperplane<Euclidean1D> upperCut2 = new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(lowerCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(upperCut2, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null), null);\n        }\n    }\n    \n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }\n    \n    protected void computeGeometricalProperties() {\n        if (((AbstractRegion<Euclidean1D, T>)this).getTree(false).getCut() == null) {\n            ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(Vector1D.NaN);\n            this.setSize(((boolean)((AbstractRegion<Euclidean1D, T>)this).getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0.0);\n        }\n        else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : this.asList()) {\n                size += interval.getSize();\n                sum += interval.getSize() * interval.getBarycenter();\n            }\n            this.setSize(size);\n            if (Double.isInfinite(size)) {\n                ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(Vector1D.NaN);\n            }\n            else if (size >= Precision.SAFE_MIN) {\n                ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(new Vector1D(sum / size));\n            }\n            else {\n                ((AbstractRegion<Euclidean1D, T>)this).setBarycenter(((OrientedPoint)((AbstractRegion<Euclidean1D, T>)this).getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }\n    \n    public double getInf() {\n        BSPTree<Euclidean1D> node = ((AbstractRegion<Euclidean1D, T>)this).getTree(false);\n        double inf = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint)node.getCut().getHyperplane();\n            inf = op.getLocation().getX();\n            node = (op.isDirect() ? node.getMinus() : node.getPlus());\n        }\n        return node.getAttribute() ? Double.NEGATIVE_INFINITY : inf;\n    }\n    \n    public double getSup() {\n        BSPTree<Euclidean1D> node = ((AbstractRegion<Euclidean1D, T>)this).getTree(false);\n        double sup = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint)node.getCut().getHyperplane();\n            sup = op.getLocation().getX();\n            node = (op.isDirect() ? node.getPlus() : node.getMinus());\n        }\n        return node.getAttribute() ? Double.POSITIVE_INFINITY : sup;\n    }\n    \n    public List<Interval> asList() {\n        final List<Interval> list = new ArrayList<Interval>();\n        this.recurseList(((AbstractRegion<Euclidean1D, T>)this).getTree(false), list, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n        return list;\n    }\n    \n    private void recurseList(final BSPTree<Euclidean1D> node, final List<Interval> list, final double lower, final double upper) {\n        if (node.getCut() == null) {\n            if (node.getAttribute()) {\n                list.add(new Interval(lower, upper));\n            }\n        }\n        else {\n            final OrientedPoint op = (OrientedPoint)node.getCut().getHyperplane();\n            final Vector1D loc = op.getLocation();\n            double x = loc.getX();\n            final BSPTree<Euclidean1D> low = op.isDirect() ? node.getMinus() : node.getPlus();\n            final BSPTree<Euclidean1D> high = op.isDirect() ? node.getPlus() : node.getMinus();\n            this.recurseList(low, list, lower, x);\n            if (((AbstractRegion<Euclidean1D, T>)this).checkPoint(low, loc) == Region.Location.INSIDE && ((AbstractRegion<Euclidean1D, T>)this).checkPoint(high, loc) == Region.Location.INSIDE) {\n                x = list.remove(list.size() - 1).getInf();\n            }\n            this.recurseList(high, list, x, upper);\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "SimplexTableau",
        "fqdn": "org.apache.commons.math3.optimization.linear",
        "source_code": "package org.apache.commons.math3.optimization.linear;\n\nimport org.apache.commons.math3.optimization.*;\nimport java.util.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.linear.*;\nimport java.io.*;\n\nclass SimplexTableau implements Serializable\n{\n    private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\";\n    private static final int DEFAULT_ULPS = 10;\n    private static final double CUTOFF_THRESHOLD = 1.0E-12;\n    private static final long serialVersionUID = -1369660067587938365L;\n    private final LinearObjectiveFunction f;\n    private final List<LinearConstraint> constraints;\n    private final boolean restrictToNonNegative;\n    private final List<String> columnLabels;\n    private transient RealMatrix tableau;\n    private final int numDecisionVariables;\n    private final int numSlackVariables;\n    private int numArtificialVariables;\n    private final double epsilon;\n    private final int maxUlps;\n    \n    SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {\n        this(f, constraints, goalType, restrictToNonNegative, epsilon, 10);\n    }\n    \n    SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon, final int maxUlps) {\n        this.columnLabels = new ArrayList<String>();\n        this.f = f;\n        this.constraints = this.normalizeConstraints(constraints);\n        this.restrictToNonNegative = restrictToNonNegative;\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n        this.numDecisionVariables = f.getCoefficients().getDimension() + (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables = this.getConstraintTypeCounts(Relationship.LEQ) + this.getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = this.getConstraintTypeCounts(Relationship.EQ) + this.getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = this.createTableau(goalType == GoalType.MAXIMIZE);\n        this.initializeColumnLabels();\n    }\n    \n    protected void initializeColumnLabels() {\n        if (this.getNumObjectiveFunctions() == 2) {\n            this.columnLabels.add(\"W\");\n        }\n        this.columnLabels.add(\"Z\");\n        for (int i = 0; i < this.getOriginalNumDecisionVariables(); ++i) {\n            this.columnLabels.add(\"x\" + i);\n        }\n        if (!this.restrictToNonNegative) {\n            this.columnLabels.add(\"x-\");\n        }\n        for (int i = 0; i < this.getNumSlackVariables(); ++i) {\n            this.columnLabels.add(\"s\" + i);\n        }\n        for (int i = 0; i < this.getNumArtificialVariables(); ++i) {\n            this.columnLabels.add(\"a\" + i);\n        }\n        this.columnLabels.add(\"RHS\");\n    }\n    \n    protected RealMatrix createTableau(final boolean maximize) {\n        final int width = this.numDecisionVariables + this.numSlackVariables + this.numArtificialVariables + this.getNumObjectiveFunctions() + 1;\n        final int height = this.constraints.size() + this.getNumObjectiveFunctions();\n        final Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n        if (this.getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1.0);\n        }\n        final int zIndex = (this.getNumObjectiveFunctions() != 1) ? 1 : 0;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1.0 : -1.0);\n        final RealVector objectiveCoefficients = maximize ? this.f.getCoefficients().mapMultiply(-1.0) : this.f.getCoefficients();\n        this.copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1, maximize ? this.f.getConstantTerm() : (-1.0 * this.f.getConstantTerm()));\n        if (!this.restrictToNonNegative) {\n            matrix.setEntry(zIndex, this.getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients));\n        }\n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < this.constraints.size(); ++i) {\n            final LinearConstraint constraint = this.constraints.get(i);\n            final int row = this.getNumObjectiveFunctions() + i;\n            this.copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n            if (!this.restrictToNonNegative) {\n                matrix.setEntry(row, this.getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n            matrix.setEntry(row, width - 1, constraint.getValue());\n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, this.getSlackVariableOffset() + slackVar++, 1.0);\n            }\n            else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, this.getSlackVariableOffset() + slackVar++, -1.0);\n            }\n            if (constraint.getRelationship() == Relationship.EQ || constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(0, this.getArtificialVariableOffset() + artificialVar, 1.0);\n                matrix.setEntry(row, this.getArtificialVariableOffset() + artificialVar++, 1.0);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n        return matrix;\n    }\n    \n    public List<LinearConstraint> normalizeConstraints(final Collection<LinearConstraint> originalConstraints) {\n        final List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (final LinearConstraint constraint : originalConstraints) {\n            normalized.add(this.normalize(constraint));\n        }\n        return normalized;\n    }\n    \n    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0.0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1.0), constraint.getRelationship().oppositeRelationship(), -1.0 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());\n    }\n    \n    protected final int getNumObjectiveFunctions() {\n        return (this.numArtificialVariables > 0) ? 2 : 1;\n    }\n    \n    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : this.constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }\n    \n    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n        double sum = 0.0;\n        for (final double coefficient : coefficients.toArray()) {\n            sum -= coefficient;\n        }\n        return sum;\n    }\n    \n    protected Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = 0; i < this.getHeight(); ++i) {\n            final double entry = this.getEntry(i, col);\n            if (Precision.equals(entry, 1.0, this.maxUlps) && row == null) {\n                row = i;\n            }\n            else if (!Precision.equals(entry, 0.0, this.maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }\n    \n    protected void dropPhase1Objective() {\n        if (this.getNumObjectiveFunctions() == 1) {\n            return;\n        }\n        final Set<Integer> columnsToDrop = new TreeSet<Integer>();\n        columnsToDrop.add(0);\n        for (int i = this.getNumObjectiveFunctions(); i < this.getArtificialVariableOffset(); ++i) {\n            final double entry = this.tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0.0, this.epsilon) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n        for (int i = 0; i < this.getNumArtificialVariables(); ++i) {\n            final int col = i + this.getArtificialVariableOffset();\n            if (this.getBasicRow(col) == null) {\n                columnsToDrop.add(col);\n            }\n        }\n        final double[][] matrix = new double[this.getHeight() - 1][this.getWidth() - columnsToDrop.size()];\n        for (int j = 1; j < this.getHeight(); ++j) {\n            int col2 = 0;\n            for (int k = 0; k < this.getWidth(); ++k) {\n                if (!columnsToDrop.contains(k)) {\n                    matrix[j - 1][col2++] = this.tableau.getEntry(j, k);\n                }\n            }\n        }\n        final Integer[] drop = columnsToDrop.toArray(new Integer[columnsToDrop.size()]);\n        for (int l = drop.length - 1; l >= 0; --l) {\n            this.columnLabels.remove((int)drop[l]);\n        }\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n    \n    private void copyArray(final double[] src, final double[] dest) {\n        System.arraycopy(src, 0, dest, this.getNumObjectiveFunctions(), src.length);\n    }\n    \n    boolean isOptimal() {\n        for (int i = this.getNumObjectiveFunctions(); i < this.getWidth() - 1; ++i) {\n            final double entry = this.tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0.0, this.epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    protected PointValuePair getSolution() {\n        final int negativeVarColumn = this.columnLabels.indexOf(\"x-\");\n        final Integer negativeVarBasicRow = (negativeVarColumn > 0) ? this.getBasicRow(negativeVarColumn) : null;\n        final double mostNegative = (negativeVarBasicRow == null) ? 0.0 : this.getEntry(negativeVarBasicRow, this.getRhsOffset());\n        final Set<Integer> basicRows = new HashSet<Integer>();\n        final double[] coefficients = new double[this.getOriginalNumDecisionVariables()];\n        for (int i = 0; i < coefficients.length; ++i) {\n            final int colIndex = this.columnLabels.indexOf(\"x\" + i);\n            if (colIndex < 0) {\n                coefficients[i] = 0.0;\n            }\n            else {\n                final Integer basicRow = this.getBasicRow(colIndex);\n                if (basicRow != null && basicRow == 0) {\n                    coefficients[i] = 0.0;\n                }\n                else if (basicRows.contains(basicRow)) {\n                    coefficients[i] = 0.0 - (this.restrictToNonNegative ? 0.0 : mostNegative);\n                }\n                else {\n                    basicRows.add(basicRow);\n                    coefficients[i] = ((basicRow == null) ? 0.0 : this.getEntry(basicRow, this.getRhsOffset())) - (this.restrictToNonNegative ? 0.0 : mostNegative);\n                }\n            }\n        }\n        return new PointValuePair(coefficients, this.f.getValue(coefficients));\n    }\n    \n    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < this.getWidth(); ++j) {\n            this.tableau.setEntry(dividendRow, j, this.tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }\n    \n    protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {\n        for (int i = 0; i < this.getWidth(); ++i) {\n            double result = this.tableau.getEntry(minuendRow, i) - this.tableau.getEntry(subtrahendRow, i) * multiple;\n            if (FastMath.abs(result) < 1.0E-12) {\n                result = 0.0;\n            }\n            this.tableau.setEntry(minuendRow, i, result);\n        }\n    }\n    \n    protected final int getWidth() {\n        return this.tableau.getColumnDimension();\n    }\n    \n    protected final int getHeight() {\n        return this.tableau.getRowDimension();\n    }\n    \n    protected final double getEntry(final int row, final int column) {\n        return this.tableau.getEntry(row, column);\n    }\n    \n    protected final void setEntry(final int row, final int column, final double value) {\n        this.tableau.setEntry(row, column, value);\n    }\n    \n    protected final int getSlackVariableOffset() {\n        return this.getNumObjectiveFunctions() + this.numDecisionVariables;\n    }\n    \n    protected final int getArtificialVariableOffset() {\n        return this.getNumObjectiveFunctions() + this.numDecisionVariables + this.numSlackVariables;\n    }\n    \n    protected final int getRhsOffset() {\n        return this.getWidth() - 1;\n    }\n    \n    protected final int getNumDecisionVariables() {\n        return this.numDecisionVariables;\n    }\n    \n    protected final int getOriginalNumDecisionVariables() {\n        return this.f.getCoefficients().getDimension();\n    }\n    \n    protected final int getNumSlackVariables() {\n        return this.numSlackVariables;\n    }\n    \n    protected final int getNumArtificialVariables() {\n        return this.numArtificialVariables;\n    }\n    \n    protected final double[][] getData() {\n        return this.tableau.getData();\n    }\n    \n    public boolean equals(final Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof SimplexTableau) {\n            final SimplexTableau rhs = (SimplexTableau)other;\n            return this.restrictToNonNegative == rhs.restrictToNonNegative && this.numDecisionVariables == rhs.numDecisionVariables && this.numSlackVariables == rhs.numSlackVariables && this.numArtificialVariables == rhs.numArtificialVariables && this.epsilon == rhs.epsilon && this.maxUlps == rhs.maxUlps && this.f.equals(rhs.f) && this.constraints.equals(rhs.constraints) && this.tableau.equals(rhs.tableau);\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        return Boolean.valueOf(this.restrictToNonNegative).hashCode() ^ this.numDecisionVariables ^ this.numSlackVariables ^ this.numArtificialVariables ^ Double.valueOf(this.epsilon).hashCode() ^ this.maxUlps ^ this.f.hashCode() ^ this.constraints.hashCode() ^ this.tableau.hashCode();\n    }\n    \n    private void writeObject(final ObjectOutputStream oos) throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(this.tableau, oos);\n    }\n    \n    private void readObject(final ObjectInputStream ois) throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "AbstractSimplex",
        "fqdn": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
        "source_code": "package org.apache.commons.math3.optim.nonlinear.scalar.noderiv;\n\nimport org.apache.commons.math3.optim.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.analysis.*;\nimport java.util.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.util.*;\n\npublic abstract class AbstractSimplex implements OptimizationData\n{\n    private PointValuePair[] simplex;\n    private double[][] startConfiguration;\n    private final int dimension;\n    \n    protected AbstractSimplex(final int n) {\n        this(n, 1.0);\n    }\n    \n    protected AbstractSimplex(final int n, final double sideLength) {\n        this(createHypercubeSteps(n, sideLength));\n    }\n    \n    protected AbstractSimplex(final double[] steps) {\n        if (steps == null) {\n            throw new NullArgumentException();\n        }\n        if (steps.length == 0) {\n            throw new ZeroException();\n        }\n        this.dimension = steps.length;\n        this.startConfiguration = new double[this.dimension][this.dimension];\n        for (int i = 0; i < this.dimension; ++i) {\n            final double[] vertexI = this.startConfiguration[i];\n            for (int j = 0; j < i + 1; ++j) {\n                if (steps[j] == 0.0) {\n                    throw new ZeroException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX, new Object[0]);\n                }\n                System.arraycopy(steps, 0, vertexI, 0, j + 1);\n            }\n        }\n    }\n    \n    protected AbstractSimplex(final double[][] referenceSimplex) {\n        if (referenceSimplex.length <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SIMPLEX_NEED_ONE_POINT, referenceSimplex.length);\n        }\n        this.dimension = referenceSimplex.length - 1;\n        this.startConfiguration = new double[this.dimension][this.dimension];\n        final double[] ref0 = referenceSimplex[0];\n        for (int i = 0; i < referenceSimplex.length; ++i) {\n            final double[] refI = referenceSimplex[i];\n            if (refI.length != this.dimension) {\n                throw new DimensionMismatchException(refI.length, this.dimension);\n            }\n            for (int j = 0; j < i; ++j) {\n                final double[] refJ = referenceSimplex[j];\n                boolean allEquals = true;\n                for (int k = 0; k < this.dimension; ++k) {\n                    if (refI[k] != refJ[k]) {\n                        allEquals = false;\n                        break;\n                    }\n                }\n                if (allEquals) {\n                    throw new MathIllegalArgumentException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX, new Object[] { i, j });\n                }\n            }\n            if (i > 0) {\n                final double[] confI = this.startConfiguration[i - 1];\n                for (int l = 0; l < this.dimension; ++l) {\n                    confI[l] = refI[l] - ref0[l];\n                }\n            }\n        }\n    }\n    \n    public int getDimension() {\n        return this.dimension;\n    }\n    \n    public int getSize() {\n        return this.simplex.length;\n    }\n    \n    public abstract void iterate(final MultivariateFunction p0, final Comparator<PointValuePair> p1);\n    \n    public void build(final double[] startPoint) {\n        if (this.dimension != startPoint.length) {\n            throw new DimensionMismatchException(this.dimension, startPoint.length);\n        }\n        (this.simplex = new PointValuePair[this.dimension + 1])[0] = new PointValuePair(startPoint, Double.NaN);\n        for (int i = 0; i < this.dimension; ++i) {\n            final double[] confI = this.startConfiguration[i];\n            final double[] vertexI = new double[this.dimension];\n            for (int k = 0; k < this.dimension; ++k) {\n                vertexI[k] = startPoint[k] + confI[k];\n            }\n            this.simplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n        }\n    }\n    \n    public void evaluate(final MultivariateFunction evaluationFunction, final Comparator<PointValuePair> comparator) {\n        for (int i = 0; i < this.simplex.length; ++i) {\n            final PointValuePair vertex = this.simplex[i];\n            final double[] point = vertex.getPointRef();\n            if (Double.isNaN(((Pair<K, Double>)vertex).getValue())) {\n                this.simplex[i] = new PointValuePair(point, evaluationFunction.value(point), false);\n            }\n        }\n        Arrays.sort(this.simplex, comparator);\n    }\n    \n    protected void replaceWorstPoint(PointValuePair pointValuePair, final Comparator<PointValuePair> comparator) {\n        for (int i = 0; i < this.dimension; ++i) {\n            if (comparator.compare(this.simplex[i], pointValuePair) > 0) {\n                final PointValuePair tmp = this.simplex[i];\n                this.simplex[i] = pointValuePair;\n                pointValuePair = tmp;\n            }\n        }\n        this.simplex[this.dimension] = pointValuePair;\n    }\n    \n    public PointValuePair[] getPoints() {\n        final PointValuePair[] copy = new PointValuePair[this.simplex.length];\n        System.arraycopy(this.simplex, 0, copy, 0, this.simplex.length);\n        return copy;\n    }\n    \n    public PointValuePair getPoint(final int index) {\n        if (index < 0 || index >= this.simplex.length) {\n            throw new OutOfRangeException(index, 0, this.simplex.length - 1);\n        }\n        return this.simplex[index];\n    }\n    \n    protected void setPoint(final int index, final PointValuePair point) {\n        if (index < 0 || index >= this.simplex.length) {\n            throw new OutOfRangeException(index, 0, this.simplex.length - 1);\n        }\n        this.simplex[index] = point;\n    }\n    \n    protected void setPoints(final PointValuePair[] points) {\n        if (points.length != this.simplex.length) {\n            throw new DimensionMismatchException(points.length, this.simplex.length);\n        }\n        this.simplex = points;\n    }\n    \n    private static double[] createHypercubeSteps(final int n, final double sideLength) {\n        final double[] steps = new double[n];\n        for (int i = 0; i < n; ++i) {\n            steps[i] = sideLength;\n        }\n        return steps;\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "DfpDec",
        "fqdn": "org.apache.commons.math3.dfp",
        "source_code": "package org.apache.commons.math3.dfp;\n\npublic class DfpDec extends Dfp\n{\n    protected DfpDec(final DfpField factory) {\n        super(factory);\n    }\n    \n    protected DfpDec(final DfpField factory, final byte x) {\n        super(factory, x);\n    }\n    \n    protected DfpDec(final DfpField factory, final int x) {\n        super(factory, x);\n    }\n    \n    protected DfpDec(final DfpField factory, final long x) {\n        super(factory, x);\n    }\n    \n    protected DfpDec(final DfpField factory, final double x) {\n        super(factory, x);\n        this.round(0);\n    }\n    \n    public DfpDec(final Dfp d) {\n        super(d);\n        this.round(0);\n    }\n    \n    protected DfpDec(final DfpField factory, final String s) {\n        super(factory, s);\n        this.round(0);\n    }\n    \n    protected DfpDec(final DfpField factory, final byte sign, final byte nans) {\n        super(factory, sign, nans);\n    }\n    \n    public Dfp newInstance() {\n        return new DfpDec(this.getField());\n    }\n    \n    public Dfp newInstance(final byte x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final int x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final long x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final double x) {\n        return new DfpDec(this.getField(), x);\n    }\n    \n    public Dfp newInstance(final Dfp d) {\n        if (this.getField().getRadixDigits() != d.getField().getRadixDigits()) {\n            this.getField().setIEEEFlagsBits(1);\n            final Dfp result = this.newInstance(this.getZero());\n            result.nans = 3;\n            return this.dotrap(1, \"newInstance\", d, result);\n        }\n        return new DfpDec(d);\n    }\n    \n    public Dfp newInstance(final String s) {\n        return new DfpDec(this.getField(), s);\n    }\n    \n    public Dfp newInstance(final byte sign, final byte nans) {\n        return new DfpDec(this.getField(), sign, nans);\n    }\n    \n    protected int getDecimalDigits() {\n        return this.getRadixDigits() * 4 - 3;\n    }\n    \n    protected int round(final int in) {\n        final int msb = this.mant[this.mant.length - 1];\n        if (msb == 0) {\n            return 0;\n        }\n        int cmaxdigits = this.mant.length * 4;\n        for (int lsbthreshold = 1000; lsbthreshold > msb; lsbthreshold /= 10, --cmaxdigits) {}\n        final int digits = this.getDecimalDigits();\n        final int lsbshift = cmaxdigits - digits;\n        final int lsd = lsbshift / 4;\n        int lsbthreshold = 1;\n        for (int i = 0; i < lsbshift % 4; ++i) {\n            lsbthreshold *= 10;\n        }\n        final int lsb = this.mant[lsd];\n        if (lsbthreshold <= 1 && digits == 4 * this.mant.length - 3) {\n            return super.round(in);\n        }\n        int n;\n        int discarded;\n        if (lsbthreshold == 1) {\n            n = this.mant[lsd - 1] / 1000 % 10;\n            final int[] mant = this.mant;\n            final int n2 = lsd - 1;\n            mant[n2] %= 1000;\n            discarded = (in | this.mant[lsd - 1]);\n        }\n        else {\n            n = lsb * 10 / lsbthreshold % 10;\n            discarded = (in | lsb % (lsbthreshold / 10));\n        }\n        for (int j = 0; j < lsd; ++j) {\n            discarded |= this.mant[j];\n            this.mant[j] = 0;\n        }\n        this.mant[lsd] = lsb / lsbthreshold * lsbthreshold;\n        boolean inc = false;\n        switch (this.getField().getRoundingMode()) {\n            case ROUND_DOWN: {\n                inc = false;\n                break;\n            }\n            case ROUND_UP: {\n                inc = (n != 0 || discarded != 0);\n                break;\n            }\n            case ROUND_HALF_UP: {\n                inc = (n >= 5);\n                break;\n            }\n            case ROUND_HALF_DOWN: {\n                inc = (n > 5);\n                break;\n            }\n            case ROUND_HALF_EVEN: {\n                inc = (n > 5 || (n == 5 && discarded != 0) || (n == 5 && discarded == 0 && (lsb / lsbthreshold & 0x1) == 0x1));\n                break;\n            }\n            case ROUND_HALF_ODD: {\n                inc = (n > 5 || (n == 5 && discarded != 0) || (n == 5 && discarded == 0 && (lsb / lsbthreshold & 0x1) == 0x0));\n                break;\n            }\n            case ROUND_CEIL: {\n                inc = (this.sign == 1 && (n != 0 || discarded != 0));\n                break;\n            }\n            default: {\n                inc = (this.sign == -1 && (n != 0 || discarded != 0));\n                break;\n            }\n        }\n        if (inc) {\n            int rh = lsbthreshold;\n            for (int k = lsd; k < this.mant.length; ++k) {\n                final int r = this.mant[k] + rh;\n                rh = r / 10000;\n                this.mant[k] = r % 10000;\n            }\n            if (rh != 0) {\n                this.shiftRight();\n                this.mant[this.mant.length - 1] = rh;\n            }\n        }\n        if (this.exp < -32767) {\n            this.getField().setIEEEFlagsBits(8);\n            return 8;\n        }\n        if (this.exp > 32768) {\n            this.getField().setIEEEFlagsBits(4);\n            return 4;\n        }\n        if (n != 0 || discarded != 0) {\n            this.getField().setIEEEFlagsBits(16);\n            return 16;\n        }\n        return 0;\n    }\n    \n    public Dfp nextAfter(final Dfp x) {\n        final String trapName = \"nextAfter\";\n        if (this.getField().getRadixDigits() != x.getField().getRadixDigits()) {\n            this.getField().setIEEEFlagsBits(1);\n            final Dfp result = this.newInstance(this.getZero());\n            result.nans = 3;\n            return this.dotrap(1, \"nextAfter\", x, result);\n        }\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n        if (this.equals(x)) {\n            return this.newInstance(x);\n        }\n        if (this.lessThan(this.getZero())) {\n            up = !up;\n        }\n        Dfp result2;\n        if (up) {\n            Dfp inc = this.power10(this.intLog10() - this.getDecimalDigits() + 1);\n            inc = Dfp.copysign(inc, this);\n            if (this.equals(this.getZero())) {\n                inc = this.power10K(-32767 - this.mant.length - 1);\n            }\n            if (inc.equals(this.getZero())) {\n                result2 = Dfp.copysign(this.newInstance(this.getZero()), this);\n            }\n            else {\n                result2 = this.add(inc);\n            }\n        }\n        else {\n            Dfp inc = this.power10(this.intLog10());\n            inc = Dfp.copysign(inc, this);\n            if (this.equals(inc)) {\n                inc = inc.divide(this.power10(this.getDecimalDigits()));\n            }\n            else {\n                inc = inc.divide(this.power10(this.getDecimalDigits() - 1));\n            }\n            if (this.equals(this.getZero())) {\n                inc = this.power10K(-32767 - this.mant.length - 1);\n            }\n            if (inc.equals(this.getZero())) {\n                result2 = Dfp.copysign(this.newInstance(this.getZero()), this);\n            }\n            else {\n                result2 = this.subtract(inc);\n            }\n        }\n        if (result2.classify() == 1 && this.classify() != 1) {\n            this.getField().setIEEEFlagsBits(16);\n            result2 = this.dotrap(16, \"nextAfter\", x, result2);\n        }\n        if (result2.equals(this.getZero()) && !this.equals(this.getZero())) {\n            this.getField().setIEEEFlagsBits(16);\n            result2 = this.dotrap(16, \"nextAfter\", x, result2);\n        }\n        return result2;\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "HypergeometricDistribution",
        "fqdn": "org.apache.commons.math3.distribution",
        "source_code": "package org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.random.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.util.*;\n\npublic class HypergeometricDistribution extends AbstractIntegerDistribution\n{\n    private static final long serialVersionUID = -436928820673516179L;\n    private final int numberOfSuccesses;\n    private final int populationSize;\n    private final int sampleSize;\n    private double numericalVariance;\n    private boolean numericalVarianceIsCalculated;\n    \n    public HypergeometricDistribution(final int populationSize, final int numberOfSuccesses, final int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        this(new Well19937c(), populationSize, numberOfSuccesses, sampleSize);\n    }\n    \n    public HypergeometricDistribution(final RandomGenerator rng, final int populationSize, final int numberOfSuccesses, final int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        super(rng);\n        this.numericalVariance = Double.NaN;\n        this.numericalVarianceIsCalculated = false;\n        if (populationSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE, populationSize);\n        }\n        if (numberOfSuccesses < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES, numberOfSuccesses);\n        }\n        if (sampleSize < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\n        }\n        if (numberOfSuccesses > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE, numberOfSuccesses, populationSize, true);\n        }\n        if (sampleSize > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE, sampleSize, populationSize, true);\n        }\n        this.numberOfSuccesses = numberOfSuccesses;\n        this.populationSize = populationSize;\n        this.sampleSize = sampleSize;\n    }\n    \n    public double cumulativeProbability(final int x) {\n        final int[] domain = this.getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);\n        double ret;\n        if (x < domain[0]) {\n            ret = 0.0;\n        }\n        else if (x >= domain[1]) {\n            ret = 1.0;\n        }\n        else {\n            ret = this.innerCumulativeProbability(domain[0], x, 1);\n        }\n        return ret;\n    }\n    \n    private int[] getDomain(final int n, final int m, final int k) {\n        return new int[] { this.getLowerDomain(n, m, k), this.getUpperDomain(m, k) };\n    }\n    \n    private int getLowerDomain(final int n, final int m, final int k) {\n        return FastMath.max(0, m - (n - k));\n    }\n    \n    public int getNumberOfSuccesses() {\n        return this.numberOfSuccesses;\n    }\n    \n    public int getPopulationSize() {\n        return this.populationSize;\n    }\n    \n    public int getSampleSize() {\n        return this.sampleSize;\n    }\n    \n    private int getUpperDomain(final int m, final int k) {\n        return FastMath.min(k, m);\n    }\n    \n    public double probability(final int x) {\n        final int[] domain = this.getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);\n        double ret;\n        if (x < domain[0] || x > domain[1]) {\n            ret = 0.0;\n        }\n        else {\n            final double p = this.sampleSize / this.populationSize;\n            final double q = (this.populationSize - this.sampleSize) / this.populationSize;\n            final double p2 = SaddlePointExpansion.logBinomialProbability(x, this.numberOfSuccesses, p, q);\n            final double p3 = SaddlePointExpansion.logBinomialProbability(this.sampleSize - x, this.populationSize - this.numberOfSuccesses, p, q);\n            final double p4 = SaddlePointExpansion.logBinomialProbability(this.sampleSize, this.populationSize, p, q);\n            ret = FastMath.exp(p2 + p3 - p4);\n        }\n        return ret;\n    }\n    \n    public double upperCumulativeProbability(final int x) {\n        final int[] domain = this.getDomain(this.populationSize, this.numberOfSuccesses, this.sampleSize);\n        double ret;\n        if (x <= domain[0]) {\n            ret = 1.0;\n        }\n        else if (x > domain[1]) {\n            ret = 0.0;\n        }\n        else {\n            ret = this.innerCumulativeProbability(domain[1], x, -1);\n        }\n        return ret;\n    }\n    \n    private double innerCumulativeProbability(int x0, final int x1, final int dx) {\n        double ret;\n        for (ret = this.probability(x0); x0 != x1; x0 += dx, ret += this.probability(x0)) {}\n        return ret;\n    }\n    \n    public double getNumericalMean() {\n        return this.getSampleSize() * this.getNumberOfSuccesses() / this.getPopulationSize();\n    }\n    \n    public double getNumericalVariance() {\n        if (!this.numericalVarianceIsCalculated) {\n            this.numericalVariance = this.calculateNumericalVariance();\n            this.numericalVarianceIsCalculated = true;\n        }\n        return this.numericalVariance;\n    }\n    \n    protected double calculateNumericalVariance() {\n        final double N = this.getPopulationSize();\n        final double m = this.getNumberOfSuccesses();\n        final double n = this.getSampleSize();\n        return n * m * (N - n) * (N - m) / (N * N * (N - 1.0));\n    }\n    \n    public int getSupportLowerBound() {\n        return FastMath.max(0, this.getSampleSize() + this.getNumberOfSuccesses() - this.getPopulationSize());\n    }\n    \n    public int getSupportUpperBound() {\n        return FastMath.min(this.getNumberOfSuccesses(), this.getSampleSize());\n    }\n    \n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "AbstractIntegrator",
        "fqdn": "org.apache.commons.math3.ode",
        "source_code": "package org.apache.commons.math3.ode;\n\nimport org.apache.commons.math3.ode.events.*;\nimport org.apache.commons.math3.analysis.solvers.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.ode.sampling.*;\nimport java.util.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.util.*;\n\npublic abstract class AbstractIntegrator implements FirstOrderIntegrator\n{\n    protected Collection<StepHandler> stepHandlers;\n    protected double stepStart;\n    protected double stepSize;\n    protected boolean isLastStep;\n    protected boolean resetOccurred;\n    private Collection<EventState> eventsStates;\n    private boolean statesInitialized;\n    private final String name;\n    private Incrementor evaluations;\n    private transient ExpandableStatefulODE expandable;\n    \n    public AbstractIntegrator(final String name) {\n        this.name = name;\n        this.stepHandlers = new ArrayList<StepHandler>();\n        this.stepStart = Double.NaN;\n        this.stepSize = Double.NaN;\n        this.eventsStates = new ArrayList<EventState>();\n        this.statesInitialized = false;\n        this.evaluations = new Incrementor();\n        this.setMaxEvaluations(-1);\n        this.evaluations.resetCount();\n    }\n    \n    protected AbstractIntegrator() {\n        this(null);\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n    \n    public void addStepHandler(final StepHandler handler) {\n        this.stepHandlers.add(handler);\n    }\n    \n    public Collection<StepHandler> getStepHandlers() {\n        return Collections.unmodifiableCollection((Collection<? extends StepHandler>)this.stepHandlers);\n    }\n    \n    public void clearStepHandlers() {\n        this.stepHandlers.clear();\n    }\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount) {\n        this.addEventHandler(handler, maxCheckInterval, convergence, maxIterationCount, new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n    \n    public void addEventHandler(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateSolver solver) {\n        this.eventsStates.add(new EventState(handler, maxCheckInterval, convergence, maxIterationCount, solver));\n    }\n    \n    public Collection<EventHandler> getEventHandlers() {\n        final List<EventHandler> list = new ArrayList<EventHandler>();\n        for (final EventState state : this.eventsStates) {\n            list.add(state.getEventHandler());\n        }\n        return Collections.unmodifiableCollection((Collection<? extends EventHandler>)list);\n    }\n    \n    public void clearEventHandlers() {\n        this.eventsStates.clear();\n    }\n    \n    public double getCurrentStepStart() {\n        return this.stepStart;\n    }\n    \n    public double getCurrentSignedStepsize() {\n        return this.stepSize;\n    }\n    \n    public void setMaxEvaluations(final int maxEvaluations) {\n        this.evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n    \n    public int getMaxEvaluations() {\n        return this.evaluations.getMaximalCount();\n    }\n    \n    public int getEvaluations() {\n        return this.evaluations.getCount();\n    }\n    \n    protected void initIntegration(final double t0, final double[] y0, final double t) {\n        this.evaluations.resetCount();\n        for (final EventState state : this.eventsStates) {\n            state.getEventHandler().init(t0, y0, t);\n        }\n        for (final StepHandler handler : this.stepHandlers) {\n            handler.init(t0, y0, t);\n        }\n        this.setStateInitialized(false);\n    }\n    \n    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n    \n    protected ExpandableStatefulODE getExpandable() {\n        return this.expandable;\n    }\n    \n    protected Incrementor getEvaluationsCounter() {\n        return this.evaluations;\n    }\n    \n    public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n        this.integrate(expandableODE, t);\n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n    }\n    \n    public abstract void integrate(final ExpandableStatefulODE p0, final double p1) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException;\n    \n    public void computeDerivatives(final double t, final double[] y, final double[] yDot) throws MaxCountExceededException, DimensionMismatchException {\n        this.evaluations.incrementCount();\n        this.expandable.computeDerivatives(t, y, yDot);\n    }\n    \n    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n    \n    protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n        if (!this.statesInitialized) {\n            for (final EventState state : this.eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            this.statesInitialized = true;\n        }\n        final int orderingSign = interpolator.isForward() ? 1 : -1;\n        final SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n            public int compare(final EventState es0, final EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n        });\n        for (final EventState state2 : this.eventsStates) {\n            if (state2.evaluateStep(interpolator)) {\n                occuringEvents.add(state2);\n            }\n        }\n        while (!occuringEvents.isEmpty()) {\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventYPrimary = interpolator.getInterpolatedState().clone();\n            final double[] eventYComplete = new double[y.length];\n            this.expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(), eventYComplete);\n            int index = 0;\n            for (final EquationsMapper secondary : this.expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++), eventYComplete);\n            }\n            for (final EventState state3 : this.eventsStates) {\n                state3.stepAccepted(eventT, eventYPrimary);\n                this.isLastStep = (this.isLastStep || state3.stop());\n            }\n            for (final StepHandler handler : this.stepHandlers) {\n                handler.handleStep(interpolator, this.isLastStep);\n            }\n            if (this.isLastStep) {\n                System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                return eventT;\n            }\n            boolean needReset = false;\n            for (final EventState state4 : this.eventsStates) {\n                needReset = (needReset || state4.reset(eventT, eventYComplete));\n            }\n            if (needReset) {\n                interpolator.setInterpolatedTime(eventT);\n                System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                this.computeDerivatives(eventT, y, yDot);\n                this.resetOccurred = true;\n                return eventT;\n            }\n            previousT = eventT;\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n            if (!currentEvent.evaluateStep(interpolator)) {\n                continue;\n            }\n            occuringEvents.add(currentEvent);\n        }\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state5 : this.eventsStates) {\n            state5.stepAccepted(currentT, currentY);\n            this.isLastStep = (this.isLastStep || state5.stop());\n        }\n        this.isLastStep = (this.isLastStep || Precision.equals(currentT, tEnd, 1));\n        for (final StepHandler handler2 : this.stepHandlers) {\n            handler2.handleStep(interpolator, this.isLastStep);\n        }\n        return currentT;\n    }\n    \n    protected void sanityChecks(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException {\n        final double threshold = 1000.0 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()), FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL, dt, threshold, false);\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "MultidimensionalCounter",
        "fqdn": "org.apache.commons.math3.util",
        "source_code": "package org.apache.commons.math3.util;\n\nimport org.apache.commons.math3.exception.*;\nimport java.util.*;\n\npublic class MultidimensionalCounter implements Iterable<Integer>\n{\n    private final int dimension;\n    private final int[] uniCounterOffset;\n    private final int[] size;\n    private final int totalSize;\n    private final int last;\n    \n    public MultidimensionalCounter(final int... size) throws NotStrictlyPositiveException {\n        this.dimension = size.length;\n        this.size = MathArrays.copyOf(size);\n        this.uniCounterOffset = new int[this.dimension];\n        this.last = this.dimension - 1;\n        int tS = size[this.last];\n        for (int i = 0; i < this.last; ++i) {\n            int count = 1;\n            for (int j = i + 1; j < this.dimension; ++j) {\n                count *= size[j];\n            }\n            this.uniCounterOffset[i] = count;\n            tS *= size[i];\n        }\n        this.uniCounterOffset[this.last] = 0;\n        if (tS <= 0) {\n            throw new NotStrictlyPositiveException(tS);\n        }\n        this.totalSize = tS;\n    }\n    \n    public Iterator iterator() {\n        return new Iterator();\n    }\n    \n    public int getDimension() {\n        return this.dimension;\n    }\n    \n    public int[] getCounts(final int index) throws OutOfRangeException {\n        if (index < 0 || index >= this.totalSize) {\n            throw new OutOfRangeException(index, 0, this.totalSize);\n        }\n        final int[] indices = new int[this.dimension];\n        int count = 0;\n        for (int i = 0; i < this.last; ++i) {\n            int idx;\n            int offset;\n            for (idx = 0, offset = this.uniCounterOffset[i]; count <= index; count += offset, ++idx) {}\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n        indices[this.last] = index - count;\n        return indices;\n    }\n    \n    public int getCount(final int... c) throws OutOfRangeException, DimensionMismatchException {\n        if (c.length != this.dimension) {\n            throw new DimensionMismatchException(c.length, this.dimension);\n        }\n        int count = 0;\n        for (int i = 0; i < this.dimension; ++i) {\n            final int index = c[i];\n            if (index < 0 || index >= this.size[i]) {\n                throw new OutOfRangeException(index, 0, this.size[i] - 1);\n            }\n            count += this.uniCounterOffset[i] * c[i];\n        }\n        return count + c[this.last];\n    }\n    \n    public int getSize() {\n        return this.totalSize;\n    }\n    \n    public int[] getSizes() {\n        return MathArrays.copyOf(this.size);\n    }\n    \n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < this.dimension; ++i) {\n            sb.append(\"[\").append(this.getCount(i)).append(\"]\");\n        }\n        return sb.toString();\n    }\n    \n    public class Iterator implements java.util.Iterator<Integer>\n    {\n        private final int[] counter;\n        private int count;\n        \n        Iterator() {\n            this.counter = new int[MultidimensionalCounter.this.dimension];\n            this.count = -1;\n            this.counter[MultidimensionalCounter.this.last] = -1;\n        }\n        \n        public boolean hasNext() {\n            for (int i = 0; i < MultidimensionalCounter.this.dimension; ++i) {\n                if (this.counter[i] != MultidimensionalCounter.this.size[i] - 1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        public Integer next() {\n            for (int i = MultidimensionalCounter.this.last; i >= 0; --i) {\n                if (this.counter[i] != MultidimensionalCounter.this.size[i] - 1) {\n                    final int[] counter = this.counter;\n                    final int n = i;\n                    ++counter[n];\n                    break;\n                }\n                this.counter[i] = 0;\n            }\n            return ++this.count;\n        }\n        \n        public int getCount() {\n            return this.count;\n        }\n        \n        public int[] getCounts() {\n            return MathArrays.copyOf(this.counter);\n        }\n        \n        public int getCount(final int dim) {\n            return this.counter[dim];\n        }\n        \n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "RectangularCholeskyDecomposition",
        "fqdn": "org.apache.commons.math3.linear",
        "source_code": "package org.apache.commons.math3.linear;\n\nimport org.apache.commons.math3.util.*;\n\npublic class RectangularCholeskyDecomposition\n{\n    private final RealMatrix root;\n    private int rank;\n    \n    public RectangularCholeskyDecomposition(final RealMatrix matrix) throws NonPositiveDefiniteMatrixException {\n        this(matrix, 0.0);\n    }\n    \n    public RectangularCholeskyDecomposition(final RealMatrix matrix, final double small) throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n        final int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        boolean loop = true;\n        while (loop) {\n            int swapR = r;\n            for (int j = r + 1; j < order; ++j) {\n                final int ii = index[j];\n                final int isr = index[swapR];\n                if (c[ii][ii] > c[isr][isr]) {\n                    swapR = j;\n                }\n            }\n            if (swapR != r) {\n                final int tmpIndex = index[r];\n                index[r] = index[swapR];\n                index[swapR] = tmpIndex;\n                final double[] tmpRow = b[r];\n                b[r] = b[swapR];\n                b[swapR] = tmpRow;\n            }\n            final int ir = index[r];\n            if (c[ir][ir] <= small) {\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n                for (int k = r; k < order; ++k) {\n                    if (c[index[k]][index[k]] < -small) {\n                        throw new NonPositiveDefiniteMatrixException(c[index[k]][index[k]], k, small);\n                    }\n                }\n                loop = false;\n            }\n            else {\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse = 1.0 / sqrt;\n                final double inverse2 = 1.0 / c[ir][ir];\n                for (int l = r + 1; l < order; ++l) {\n                    final int ii2 = index[l];\n                    final double e = inverse * c[ii2][ir];\n                    b[l][r] = e;\n                    final double[] array = c[ii2];\n                    final int n = ii2;\n                    array[n] -= c[ii2][ir] * c[ii2][ir] * inverse2;\n                    for (int m = r + 1; m < l; ++m) {\n                        final int ij = index[m];\n                        final double f = c[ii2][ij] - e * b[m][r];\n                        c[ii2][ij] = f;\n                        c[ij][ii2] = f;\n                    }\n                }\n                loop = (++r < order);\n            }\n        }\n        this.rank = r;\n        this.root = MatrixUtils.createRealMatrix(order, r);\n        for (int i2 = 0; i2 < order; ++i2) {\n            for (int j2 = 0; j2 < r; ++j2) {\n                this.root.setEntry(index[i2], j2, b[i2][j2]);\n            }\n        }\n    }\n    \n    public RealMatrix getRootMatrix() {\n        return this.root;\n    }\n    \n    public int getRank() {\n        return this.rank;\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "Fraction",
        "fqdn": "org.apache.commons.math3.fraction",
        "source_code": "package org.apache.commons.math3.fraction;\n\nimport java.io.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.*;\nimport java.math.*;\nimport org.apache.commons.math3.*;\n\npublic class Fraction extends Number implements FieldElement<Fraction>, Comparable<Fraction>, Serializable\n{\n    public static final Fraction TWO;\n    public static final Fraction ONE;\n    public static final Fraction ZERO;\n    public static final Fraction FOUR_FIFTHS;\n    public static final Fraction ONE_FIFTH;\n    public static final Fraction ONE_HALF;\n    public static final Fraction ONE_QUARTER;\n    public static final Fraction ONE_THIRD;\n    public static final Fraction THREE_FIFTHS;\n    public static final Fraction THREE_QUARTERS;\n    public static final Fraction TWO_FIFTHS;\n    public static final Fraction TWO_QUARTERS;\n    public static final Fraction TWO_THIRDS;\n    public static final Fraction MINUS_ONE;\n    private static final long serialVersionUID = 3698073679419233275L;\n    private final int denominator;\n    private final int numerator;\n    \n    public Fraction(final double value) throws FractionConversionException {\n        this(value, 1.0E-5, 100);\n    }\n    \n    public Fraction(final double value, final double epsilon, final int maxIterations) throws FractionConversionException {\n        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n    }\n    \n    public Fraction(final double value, final int maxDenominator) throws FractionConversionException {\n        this(value, 0.0, maxDenominator, 100);\n    }\n    \n    private Fraction(final double value, final double epsilon, final int maxDenominator, final int maxIterations) throws FractionConversionException {\n        final long overflow = 2147483647L;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1L);\n        }\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int)a0;\n            this.denominator = 1;\n            return;\n        }\n        long p0 = 1L;\n        long q0 = 0L;\n        long p2 = a0;\n        long q2 = 1L;\n        long p3 = 0L;\n        long q3 = 1L;\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            final double r2 = 1.0 / (r0 - a0);\n            final long a2 = (long)FastMath.floor(r2);\n            p3 = a2 * p2 + p0;\n            q3 = a2 * q2 + q0;\n            if (FastMath.abs(p3) > overflow || FastMath.abs(q3) > overflow) {\n                throw new FractionConversionException(value, p3, q3);\n            }\n            final double convergent = p3 / q3;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q3 < maxDenominator) {\n                p0 = p2;\n                p2 = p3;\n                q0 = q2;\n                q2 = q3;\n                a0 = a2;\n                r0 = r2;\n            }\n            else {\n                stop = true;\n            }\n        } while (!stop);\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n        if (q3 < maxDenominator) {\n            this.numerator = (int)p3;\n            this.denominator = (int)q3;\n        }\n        else {\n            this.numerator = (int)p2;\n            this.denominator = (int)q2;\n        }\n    }\n    \n    public Fraction(final int num) {\n        this(num, 1);\n    }\n    \n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, new Object[] { num, den });\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, new Object[] { num, den });\n            }\n            num = -num;\n            den = -den;\n        }\n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator = num;\n        this.denominator = den;\n    }\n    \n    public Fraction abs() {\n        Fraction ret;\n        if (this.numerator >= 0) {\n            ret = this;\n        }\n        else {\n            ret = this.negate();\n        }\n        return ret;\n    }\n    \n    public int compareTo(final Fraction object) {\n        final long nOd = this.numerator * object.denominator;\n        final long dOn = this.denominator * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? 1 : 0);\n    }\n    \n    public double doubleValue() {\n        return this.numerator / this.denominator;\n    }\n    \n    public boolean equals(final Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Fraction) {\n            final Fraction rhs = (Fraction)other;\n            return this.numerator == rhs.numerator && this.denominator == rhs.denominator;\n        }\n        return false;\n    }\n    \n    public float floatValue() {\n        return (float)this.doubleValue();\n    }\n    \n    public int getDenominator() {\n        return this.denominator;\n    }\n    \n    public int getNumerator() {\n        return this.numerator;\n    }\n    \n    public int hashCode() {\n        return 37 * (629 + this.numerator) + this.denominator;\n    }\n    \n    public int intValue() {\n        return (int)this.doubleValue();\n    }\n    \n    public long longValue() {\n        return (long)this.doubleValue();\n    }\n    \n    public Fraction negate() {\n        if (this.numerator == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, new Object[] { this.numerator, this.denominator });\n        }\n        return new Fraction(-this.numerator, this.denominator);\n    }\n    \n    public Fraction reciprocal() {\n        return new Fraction(this.denominator, this.numerator);\n    }\n    \n    public Fraction add(final Fraction fraction) {\n        return this.addSub(fraction, true);\n    }\n    \n    public Fraction add(final int i) {\n        return new Fraction(this.numerator + i * this.denominator, this.denominator);\n    }\n    \n    public Fraction subtract(final Fraction fraction) {\n        return this.addSub(fraction, false);\n    }\n    \n    public Fraction subtract(final int i) {\n        return new Fraction(this.numerator - i * this.denominator, this.denominator);\n    }\n    \n    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION, new Object[0]);\n        }\n        if (this.numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }\n        final int d1 = ArithmeticUtils.gcd(this.denominator, fraction.denominator);\n        if (d1 == 1) {\n            final int uvp = ArithmeticUtils.mulAndCheck(this.numerator, fraction.denominator);\n            final int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, this.denominator);\n            return new Fraction(isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) : ArithmeticUtils.subAndCheck(uvp, upv), ArithmeticUtils.mulAndCheck(this.denominator, fraction.denominator));\n        }\n        final BigInteger uvp2 = BigInteger.valueOf(this.numerator).multiply(BigInteger.valueOf(fraction.denominator / d1));\n        final BigInteger upv2 = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(this.denominator / d1));\n        final BigInteger t = isAdd ? uvp2.add(upv2) : uvp2.subtract(upv2);\n        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        final int d2 = (tmodd1 == 0) ? d1 : ArithmeticUtils.gcd(tmodd1, d1);\n        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new MathArithmeticException(LocalizedFormats.NUMERATOR_OVERFLOW_AFTER_MULTIPLY, new Object[] { w });\n        }\n        return new Fraction(w.intValue(), ArithmeticUtils.mulAndCheck(this.denominator / d1, fraction.denominator / d2));\n    }\n    \n    public Fraction multiply(final Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION, new Object[0]);\n        }\n        if (this.numerator == 0 || fraction.numerator == 0) {\n            return Fraction.ZERO;\n        }\n        final int d1 = ArithmeticUtils.gcd(this.numerator, fraction.denominator);\n        final int d2 = ArithmeticUtils.gcd(fraction.numerator, this.denominator);\n        return getReducedFraction(ArithmeticUtils.mulAndCheck(this.numerator / d1, fraction.numerator / d2), ArithmeticUtils.mulAndCheck(this.denominator / d2, fraction.denominator / d1));\n    }\n    \n    public Fraction multiply(final int i) {\n        return new Fraction(this.numerator * i, this.denominator);\n    }\n    \n    public Fraction divide(final Fraction fraction) {\n        if (fraction == null) {\n            throw new NullArgumentException(LocalizedFormats.FRACTION, new Object[0]);\n        }\n        if (fraction.numerator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_FRACTION_TO_DIVIDE_BY, new Object[] { fraction.numerator, fraction.denominator });\n        }\n        return this.multiply(fraction.reciprocal());\n    }\n    \n    public Fraction divide(final int i) {\n        return new Fraction(this.numerator, this.denominator * i);\n    }\n    \n    public double percentageValue() {\n        return 100.0 * this.doubleValue();\n    }\n    \n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, new Object[] { numerator, denominator });\n        }\n        if (numerator == 0) {\n            return Fraction.ZERO;\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 0x1) == 0x0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, new Object[] { numerator, denominator });\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        final int gcd = ArithmeticUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n    \n    public String toString() {\n        String str = null;\n        if (this.denominator == 1) {\n            str = Integer.toString(this.numerator);\n        }\n        else if (this.numerator == 0) {\n            str = \"0\";\n        }\n        else {\n            str = this.numerator + \" / \" + this.denominator;\n        }\n        return str;\n    }\n    \n    public FractionField getField() {\n        return FractionField.getInstance();\n    }\n    \n    static {\n        TWO = new Fraction(2, 1);\n        ONE = new Fraction(1, 1);\n        ZERO = new Fraction(0, 1);\n        FOUR_FIFTHS = new Fraction(4, 5);\n        ONE_FIFTH = new Fraction(1, 5);\n        ONE_HALF = new Fraction(1, 2);\n        ONE_QUARTER = new Fraction(1, 4);\n        ONE_THIRD = new Fraction(1, 3);\n        THREE_FIFTHS = new Fraction(3, 5);\n        THREE_QUARTERS = new Fraction(3, 4);\n        TWO_FIFTHS = new Fraction(2, 5);\n        TWO_QUARTERS = new Fraction(2, 4);\n        TWO_THIRDS = new Fraction(2, 3);\n        MINUS_ONE = new Fraction(-1, 1);\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "MathUtils",
        "fqdn": "org.apache.commons.math3.util",
        "source_code": "package org.apache.commons.math3.util;\n\nimport java.util.*;\nimport org.apache.commons.math3.exception.util.*;\nimport org.apache.commons.math3.exception.*;\n\npublic final class MathUtils\n{\n    public static final double TWO_PI = 6.283185307179586;\n    \n    public static int hash(final double value) {\n        return new Double(value).hashCode();\n    }\n    \n    public static int hash(final double[] value) {\n        return Arrays.hashCode(value);\n    }\n    \n    public static double normalizeAngle(final double a, final double center) {\n        return a - 6.283185307179586 * FastMath.floor((a + 3.141592653589793 - center) / 6.283185307179586);\n    }\n    \n    public static double reduce(final double a, final double period, final double offset) {\n        final double p = FastMath.abs(period);\n        return a - p * FastMath.floor((a - offset) / p) - offset;\n    }\n    \n    public static byte copySign(final byte magnitude, final byte sign) throws MathArithmeticException {\n        if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n            return magnitude;\n        }\n        if (sign >= 0 && magnitude == -128) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return (byte)(-magnitude);\n    }\n    \n    public static short copySign(final short magnitude, final short sign) throws MathArithmeticException {\n        if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n            return magnitude;\n        }\n        if (sign >= 0 && magnitude == -32768) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return (short)(-magnitude);\n    }\n    \n    public static int copySign(final int magnitude, final int sign) throws MathArithmeticException {\n        if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n            return magnitude;\n        }\n        if (sign >= 0 && magnitude == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return -magnitude;\n    }\n    \n    public static long copySign(final long magnitude, final long sign) throws MathArithmeticException {\n        if ((magnitude >= 0L && sign >= 0L) || (magnitude < 0L && sign < 0L)) {\n            return magnitude;\n        }\n        if (sign >= 0L && magnitude == Long.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW, new Object[0]);\n        }\n        return -magnitude;\n    }\n    \n    public static void checkFinite(final double x) throws NotFiniteNumberException {\n        if (Double.isInfinite(x) || Double.isNaN(x)) {\n            throw new NotFiniteNumberException(x, new Object[0]);\n        }\n    }\n    \n    public static void checkFinite(final double[] val) throws NotFiniteNumberException {\n        for (int i = 0; i < val.length; ++i) {\n            final double x = val[i];\n            if (Double.isInfinite(x) || Double.isNaN(x)) {\n                throw new NotFiniteNumberException(LocalizedFormats.ARRAY_ELEMENT, x, new Object[] { i });\n            }\n        }\n    }\n    \n    public static void checkNotNull(final Object o, final Localizable pattern, final Object... args) throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException(pattern, args);\n        }\n    }\n    \n    public static void checkNotNull(final Object o) throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-math",
        "class": "SchurTransformer",
        "fqdn": "org.apache.commons.math3.linear",
        "source_code": "package org.apache.commons.math3.linear;\n\nimport org.apache.commons.math3.util.*;\nimport org.apache.commons.math3.exception.*;\nimport org.apache.commons.math3.exception.util.*;\n\nclass SchurTransformer\n{\n    private static final int MAX_ITERATIONS = 100;\n    private final double[][] matrixP;\n    private final double[][] matrixT;\n    private RealMatrix cachedP;\n    private RealMatrix cachedT;\n    private RealMatrix cachedPt;\n    private final double epsilon;\n    \n    public SchurTransformer(final RealMatrix matrix) {\n        this.epsilon = Precision.EPSILON;\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n        final HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n        this.matrixT = transformer.getH().getData();\n        this.matrixP = transformer.getP().getData();\n        this.cachedT = null;\n        this.cachedP = null;\n        this.cachedPt = null;\n        this.transform();\n    }\n    \n    public RealMatrix getP() {\n        if (this.cachedP == null) {\n            this.cachedP = MatrixUtils.createRealMatrix(this.matrixP);\n        }\n        return this.cachedP;\n    }\n    \n    public RealMatrix getPT() {\n        if (this.cachedPt == null) {\n            this.cachedPt = this.getP().transpose();\n        }\n        return this.cachedPt;\n    }\n    \n    public RealMatrix getT() {\n        if (this.cachedT == null) {\n            this.cachedT = MatrixUtils.createRealMatrix(this.matrixT);\n        }\n        return this.cachedT;\n    }\n    \n    private void transform() {\n        final int n = this.matrixT.length;\n        final double norm = this.getNorm();\n        final ShiftInfo shift = new ShiftInfo();\n        int iteration = 0;\n        int iu = n - 1;\n        while (iu >= 0) {\n            final int il = this.findSmallSubDiagonalElement(iu, norm);\n            if (il == iu) {\n                this.matrixT[iu][iu] += shift.exShift;\n                --iu;\n                iteration = 0;\n            }\n            else if (il == iu - 1) {\n                double p = (this.matrixT[iu - 1][iu - 1] - this.matrixT[iu][iu]) / 2.0;\n                double q = p * p + this.matrixT[iu][iu - 1] * this.matrixT[iu - 1][iu];\n                final double[] array = this.matrixT[iu];\n                final int n2 = iu;\n                array[n2] += shift.exShift;\n                final double[] array2 = this.matrixT[iu - 1];\n                final int n3 = iu - 1;\n                array2[n3] += shift.exShift;\n                if (q >= 0.0) {\n                    double z = FastMath.sqrt(FastMath.abs(q));\n                    if (p >= 0.0) {\n                        z += p;\n                    }\n                    else {\n                        z = p - z;\n                    }\n                    final double x = this.matrixT[iu][iu - 1];\n                    final double s = FastMath.abs(x) + FastMath.abs(z);\n                    p = x / s;\n                    q = z / s;\n                    final double r = FastMath.sqrt(p * p + q * q);\n                    p /= r;\n                    q /= r;\n                    for (int j = iu - 1; j < n; ++j) {\n                        z = this.matrixT[iu - 1][j];\n                        this.matrixT[iu - 1][j] = q * z + p * this.matrixT[iu][j];\n                        this.matrixT[iu][j] = q * this.matrixT[iu][j] - p * z;\n                    }\n                    for (int i = 0; i <= iu; ++i) {\n                        z = this.matrixT[i][iu - 1];\n                        this.matrixT[i][iu - 1] = q * z + p * this.matrixT[i][iu];\n                        this.matrixT[i][iu] = q * this.matrixT[i][iu] - p * z;\n                    }\n                    for (int i = 0; i <= n - 1; ++i) {\n                        z = this.matrixP[i][iu - 1];\n                        this.matrixP[i][iu - 1] = q * z + p * this.matrixP[i][iu];\n                        this.matrixP[i][iu] = q * this.matrixP[i][iu] - p * z;\n                    }\n                }\n                iu -= 2;\n                iteration = 0;\n            }\n            else {\n                this.computeShift(il, iu, iteration, shift);\n                if (++iteration > 100) {\n                    throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED, 100, new Object[0]);\n                }\n                final double[] hVec = new double[3];\n                final int im = this.initQRStep(il, iu, shift, hVec);\n                this.performDoubleQRStep(il, im, iu, shift, hVec);\n            }\n        }\n    }\n    \n    private double getNorm() {\n        double norm = 0.0;\n        for (int i = 0; i < this.matrixT.length; ++i) {\n            for (int j = FastMath.max(i - 1, 0); j < this.matrixT.length; ++j) {\n                norm += FastMath.abs(this.matrixT[i][j]);\n            }\n        }\n        return norm;\n    }\n    \n    private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n        int l;\n        for (l = startIdx; l > 0; --l) {\n            double s = FastMath.abs(this.matrixT[l - 1][l - 1]) + FastMath.abs(this.matrixT[l][l]);\n            if (s == 0.0) {\n                s = norm;\n            }\n            if (FastMath.abs(this.matrixT[l][l - 1]) < this.epsilon * s) {\n                break;\n            }\n        }\n        return l;\n    }\n    \n    private void computeShift(final int l, final int idx, final int iteration, final ShiftInfo shift) {\n        shift.x = this.matrixT[idx][idx];\n        final double n = 0.0;\n        shift.w = n;\n        shift.y = n;\n        if (l < idx) {\n            shift.y = this.matrixT[idx - 1][idx - 1];\n            shift.w = this.matrixT[idx][idx - 1] * this.matrixT[idx - 1][idx];\n        }\n        if (iteration == 10) {\n            shift.exShift += shift.x;\n            for (int i = 0; i <= idx; ++i) {\n                final double[] array = this.matrixT[i];\n                final int n2 = i;\n                array[n2] -= shift.x;\n            }\n            final double s = FastMath.abs(this.matrixT[idx][idx - 1]) + FastMath.abs(this.matrixT[idx - 1][idx - 2]);\n            shift.x = 0.75 * s;\n            shift.y = 0.75 * s;\n            shift.w = -0.4375 * s * s;\n        }\n        if (iteration == 30) {\n            double s = (shift.y - shift.x) / 2.0;\n            s = s * s + shift.w;\n            if (s > 0.0) {\n                s = FastMath.sqrt(s);\n                if (shift.y < shift.x) {\n                    s = -s;\n                }\n                s = shift.x - shift.w / ((shift.y - shift.x) / 2.0 + s);\n                for (int j = 0; j <= idx; ++j) {\n                    final double[] array2 = this.matrixT[j];\n                    final int n3 = j;\n                    array2[n3] -= s;\n                }\n                shift.exShift += s;\n                final double x = 0.964;\n                shift.w = x;\n                shift.y = x;\n                shift.x = x;\n            }\n        }\n    }\n    \n    private int initQRStep(final int il, final int iu, final ShiftInfo shift, final double[] hVec) {\n        int im;\n        for (im = iu - 2; im >= il; --im) {\n            final double z = this.matrixT[im][im];\n            final double r = shift.x - z;\n            final double s = shift.y - z;\n            hVec[0] = (r * s - shift.w) / this.matrixT[im + 1][im] + this.matrixT[im][im + 1];\n            hVec[1] = this.matrixT[im + 1][im + 1] - z - r - s;\n            hVec[2] = this.matrixT[im + 2][im + 1];\n            if (im == il) {\n                break;\n            }\n            final double lhs = FastMath.abs(this.matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(this.matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(this.matrixT[im + 1][im + 1]));\n            if (lhs < this.epsilon * rhs) {\n                break;\n            }\n        }\n        return im;\n    }\n    \n    private void performDoubleQRStep(final int il, final int im, final int iu, final ShiftInfo shift, final double[] hVec) {\n        final int n = this.matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n        for (int k = im; k <= iu - 1; ++k) {\n            final boolean notlast = k != iu - 1;\n            if (k != im) {\n                p = this.matrixT[k][k - 1];\n                q = this.matrixT[k + 1][k - 1];\n                r = (notlast ? this.matrixT[k + 2][k - 1] : 0.0);\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, this.epsilon)) {\n                    p /= shift.x;\n                    q /= shift.x;\n                    r /= shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    this.matrixT[k][k - 1] = -s * shift.x;\n                }\n                else if (il != im) {\n                    this.matrixT[k][k - 1] = -this.matrixT[k][k - 1];\n                }\n                p += s;\n                shift.x = p / s;\n                shift.y = q / s;\n                final double z = r / s;\n                q /= p;\n                r /= p;\n                for (int j = k; j < n; ++j) {\n                    p = this.matrixT[k][j] + q * this.matrixT[k + 1][j];\n                    if (notlast) {\n                        p += r * this.matrixT[k + 2][j];\n                        this.matrixT[k + 2][j] -= p * z;\n                    }\n                    this.matrixT[k][j] -= p * shift.x;\n                    this.matrixT[k + 1][j] -= p * shift.y;\n                }\n                for (int i = 0; i <= FastMath.min(iu, k + 3); ++i) {\n                    p = shift.x * this.matrixT[i][k] + shift.y * this.matrixT[i][k + 1];\n                    if (notlast) {\n                        p += z * this.matrixT[i][k + 2];\n                        this.matrixT[i][k + 2] -= p * r;\n                    }\n                    this.matrixT[i][k] -= p;\n                    this.matrixT[i][k + 1] -= p * q;\n                }\n                for (int high = this.matrixT.length - 1, l = 0; l <= high; ++l) {\n                    p = shift.x * this.matrixP[l][k] + shift.y * this.matrixP[l][k + 1];\n                    if (notlast) {\n                        p += z * this.matrixP[l][k + 2];\n                        this.matrixP[l][k + 2] -= p * r;\n                    }\n                    this.matrixP[l][k] -= p;\n                    this.matrixP[l][k + 1] -= p * q;\n                }\n            }\n        }\n        for (int m = im + 2; m <= iu; ++m) {\n            this.matrixT[m][m - 2] = 0.0;\n            if (m > im + 2) {\n                this.matrixT[m][m - 3] = 0.0;\n            }\n        }\n    }\n    \n    private static class ShiftInfo\n    {\n        double x;\n        double y;\n        double w;\n        double exShift;\n    }\n}\n"
    },
    {
        "project_name": "21_geo-google",
        "class": "GeoStatusCode",
        "fqdn": "geo.google.datamodel",
        "source_code": "package geo.google.datamodel;\n\npublic enum GeoStatusCode\n{\n    G_GEO_SUCCESS(200, \"No errors occurred; the address was successfully parsed and its geocode has been returned. (Since 2.55)\"), \n    G_GEO_BAD_REQUEST(400, \"A directions request could not be successfully parsed. (Since 2.81)\"), \n    G_GEO_SERVER_ERROR(500, \"A geocoding or directions request could not be successfully processed, yet the exact reason for the failure is not known. (Since 2.55)\"), \n    G_GEO_MISSING_QUERY(601, \"The HTTP q parameter was either missing or had no value. For geocoding requests, this means that an empty address was specified as input. For directions requests, this means that no query was specified in the input. (Since 2.81)\"), \n    G_GEO_UNKNOWN_ADDRESS(602, \"No corresponding geographic location could be found for the specified address. This may be due to the fact that the address is relatively new, or it may be incorrect. (Since 2.55)\"), \n    G_GEO_UNAVAILABLE_ADDRESS(603, \"The geocode for the given address or the route for the given directions query cannot be returned due to legal or contractual reasons. (Since 2.55)\"), \n    G_GEO_UNKNOWN_DIRECTIONS(604, \"The GDirections object could not compute directions between the points mentioned in the query. This is usually because there is no route available between the two points, or because we do not have data for routing in that region. (Since 2.81)\"), \n    G_GEO_BAD_KEY(610, \"The given key is either invalid or does not match the domain for which it was given. (Since 2.55)\"), \n    G_GEO_TOO_MANY_QUERIES(620, \"The given key has gone over the requests limit in the 24 hour period. \"), \n    G_GEO_UNKOWN_STATUS(-1, \"Uknown Status\");\n    \n    private String _description;\n    private int _code;\n    \n    private GeoStatusCode(final int code, final String description) {\n        this._code = code;\n        this._description = description;\n    }\n    \n    public int getCode() {\n        return this._code;\n    }\n    \n    public String getCodeName() {\n        return this.name();\n    }\n    \n    public String getDescription() {\n        return this._description;\n    }\n    \n    public static GeoStatusCode getStatusCode(final int code) {\n        switch (code) {\n            case 200: {\n                return GeoStatusCode.G_GEO_SUCCESS;\n            }\n            case 400: {\n                return GeoStatusCode.G_GEO_BAD_REQUEST;\n            }\n            case 500: {\n                return GeoStatusCode.G_GEO_SERVER_ERROR;\n            }\n            case 601: {\n                return GeoStatusCode.G_GEO_MISSING_QUERY;\n            }\n            case 602: {\n                return GeoStatusCode.G_GEO_UNKNOWN_ADDRESS;\n            }\n            case 603: {\n                return GeoStatusCode.G_GEO_UNAVAILABLE_ADDRESS;\n            }\n            case 604: {\n                return GeoStatusCode.G_GEO_UNKNOWN_DIRECTIONS;\n            }\n            case 610: {\n                return GeoStatusCode.G_GEO_BAD_KEY;\n            }\n            case 620: {\n                return GeoStatusCode.G_GEO_TOO_MANY_QUERIES;\n            }\n            default: {\n                return GeoStatusCode.G_GEO_UNKOWN_STATUS;\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "21_geo-google",
        "class": "AddressToUsAddressFunctor",
        "fqdn": "geo.google.mapping",
        "source_code": "package geo.google.mapping;\n\nimport geo.google.datamodel.*;\nimport geo.google.*;\nimport org.apache.commons.collections.*;\nimport oasis.names.tc.ciq.xsdschema.xal._2.*;\nimport java.util.*;\n\npublic final class AddressToUsAddressFunctor implements Functor<GeoUsAddress, GeoAddress, GeoException>\n{\n    private static final AddressToUsAddressFunctor _instance;\n    \n    public static AddressToUsAddressFunctor getInstance() {\n        return AddressToUsAddressFunctor._instance;\n    }\n    \n    @Override\n    public GeoUsAddress execute(final GeoAddress addr) {\n        final GeoUsAddress ret = new GeoUsAddress();\n        final AddressDetails.Country country = addr.getAddressDetails().getCountry();\n        if (country != null) {\n            final List<AddressDetails.Country.CountryNameCode> countryNames = country.getCountryNameCode();\n            if (CollectionUtils.isNotEmpty((Collection)countryNames)) {\n                ret.setCountry(countryNames.get(0).getContent());\n            }\n            final AdministrativeArea adminArea = country.getAdministrativeArea();\n            if (adminArea != null) {\n                final List<AdministrativeArea.AdministrativeAreaName> names = adminArea.getAdministrativeAreaName();\n                if (CollectionUtils.isNotEmpty((Collection)names)) {\n                    ret.setState(names.get(0).getContent());\n                }\n                final AdministrativeArea.SubAdministrativeArea subAdminArea = adminArea.getSubAdministrativeArea();\n                final Locality locality = (subAdminArea == null) ? adminArea.getLocality() : subAdminArea.getLocality();\n                if (subAdminArea != null) {\n                    final List<AdministrativeArea.SubAdministrativeArea.SubAdministrativeAreaName> subNames = subAdminArea.getSubAdministrativeAreaName();\n                    if (CollectionUtils.isNotEmpty((Collection)subNames)) {\n                        ret.setCounty(subNames.get(0).getContent());\n                    }\n                }\n                if (locality != null) {\n                    final List<Locality.LocalityName> localNames = locality.getLocalityName();\n                    if (CollectionUtils.isNotEmpty((Collection)localNames)) {\n                        ret.setCity(localNames.get(0).getContent());\n                    }\n                    final PostalCode postalCode = locality.getPostalCode();\n                    final List<PostalCode.PostalCodeNumber> numbers = postalCode.getPostalCodeNumber();\n                    if (CollectionUtils.isNotEmpty((Collection)numbers)) {\n                        ret.setPostalCode(numbers.get(0).getContent());\n                    }\n                    if (locality.getThoroughfare() != null) {\n                        final List<ThoroughfareNameType> thoroughfares = locality.getThoroughfare().getThoroughfareName();\n                        if (CollectionUtils.isNotEmpty((Collection)thoroughfares)) {\n                            ret.setAddressLine1(thoroughfares.get(0).getContent());\n                            if (thoroughfares.size() > 1) {\n                                ret.setAddressLine2(thoroughfares.get(1).getContent());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (addr.getCoordinate() != null) {\n            ret.setCoordinate(addr.getCoordinate().clone());\n        }\n        ret.setAccuracy(addr.getAccuracy());\n        return ret;\n    }\n    \n    static {\n        _instance = new AddressToUsAddressFunctor();\n    }\n}\n"
    },
    {
        "project_name": "35_corina",
        "class": "TucsonSimple",
        "fqdn": "corina.formats",
        "source_code": "package corina.formats;\n\nimport corina.ui.*;\nimport java.io.*;\nimport corina.util.*;\nimport corina.*;\n\npublic class TucsonSimple implements Filetype\n{\n    @Override\n    public String toString() {\n        return I18n.getText(\"format.tucsonsimple\");\n    }\n    \n    @Override\n    public String getDefaultExtension() {\n        return \".RWL\";\n    }\n    \n    @Override\n    public Sample load(final BufferedReader r) throws IOException {\n        throw new WrongFiletypeException();\n    }\n    \n    private String make6digitCode(final Sample s) {\n        String code;\n        if (s.meta.containsKey(\"id\")) {\n            code = s.meta.get(\"id\").toString();\n        }\n        else {\n            code = \"000000\";\n        }\n        if (code.length() > 6) {\n            code = code.substring(0, 6);\n        }\n        else {\n            while (code.length() < 6) {\n                code += \" \";\n            }\n        }\n        return code;\n    }\n    \n    private void saveRowHeader(final BufferedWriter w, final Sample s, final String code, final int yearWidth, final Year y) throws IOException {\n        String prefix;\n        if (y.compareTo(s.range.getStart()) < 0) {\n            prefix = s.range.getStart().toString();\n        }\n        else {\n            prefix = y.toString();\n        }\n        while (prefix.length() < yearWidth) {\n            prefix = \" \" + prefix;\n        }\n        w.write(code + prefix);\n    }\n    \n    protected void saveData(final Sample s, final BufferedWriter w) throws IOException {\n        final Range r = this.computeRange(s);\n        final Year start = r.getStart();\n        final Year end = r.getEnd();\n        final String code = this.make6digitCode(s);\n        final boolean isSummed = false;\n        final boolean isProcessed = false;\n        Year y = start;\n        if (isProcessed) {\n            y = y.add(-start.column());\n        }\n        while (true) {\n            if (y.column() == 0 || (y.equals(start) && !isProcessed)) {\n                this.saveRowHeader(w, s, code, isProcessed ? 4 : 6, y);\n            }\n            if (y.compareTo(end) > 0 || (isProcessed && y.compareTo(start) < 0)) {\n                if (!isProcessed) {\n                    w.write(\"   999\");\n                    break;\n                }\n                w.write(isSummed ? \"9990  0\" : \"9990   \");\n            }\n            else {\n                w.write(StringUtils.leftPad(s.data.get(y.diff(start)).toString(), isProcessed ? 4 : 6));\n                if (isSummed) {\n                    w.write(StringUtils.leftPad(s.count.get(y.diff(start)).toString(), 3));\n                }\n                else if (isProcessed) {\n                    w.write(\"   \");\n                }\n            }\n            if (isProcessed && y.compareTo(end) > 0 && y.column() == 9) {\n                break;\n            }\n            if (y.column() == 9) {\n                w.newLine();\n            }\n            y = y.add(1);\n        }\n        w.newLine();\n    }\n    \n    private Range computeRange(final Sample s) {\n        final Year start = s.range.getStart();\n        if (start.compareTo(new Year(1)) >= 0) {\n            return s.range;\n        }\n        if (start.add(8000).compareTo(new Year(1)) >= 0) {\n            return s.range.redateBy(8000);\n        }\n        return s.range.redateStartTo(new Year(1001));\n    }\n    \n    @Override\n    public void save(final Sample s, final BufferedWriter w) throws IOException {\n        this.saveData(s, w);\n    }\n}\n"
    },
    {
        "project_name": "89_jiggler",
        "class": "ConnectedComponents",
        "fqdn": "jigl.image.ops",
        "source_code": "package jigl.image.ops;\n\nimport jigl.image.types.*;\nimport jigl.image.*;\nimport jigl.image.exceptions.*;\n\npublic class ConnectedComponents extends SimpleOperator\n{\n    public static final int FOUR_CONNECTED = 0;\n    public static final int EIGHT_CONNECTED = 1;\n    private int neighbors;\n    private int background;\n    \n    public ConnectedComponents(final int numberNeighbors, final int backgroundColor) throws InvalidArgumentException {\n        this.neighbors = 0;\n        this.background = 0;\n        this.neighbors = numberNeighbors;\n        this.background = backgroundColor;\n        if ((this.neighbors != 0 && this.neighbors != 1) || (this.background != 1 && this.background != 0)) {\n            throw new InvalidArgumentException();\n        }\n    }\n    \n    @Override\n    protected GrayImage apply(final BinaryImage image) {\n        final int[] equiv = new int[100000];\n        int current = 1;\n        int min = 1000;\n        final int[] friends = new int[4];\n        final GrayImage gimage = new GrayImage(image.X(), image.Y());\n        for (int x = 0; x < 1000; ++x) {\n            equiv[x] = -1;\n        }\n        for (int x = 0; x < image.X(); ++x) {\n            for (int y = 0; y < image.Y(); ++y) {\n                if (image.get(x, y) == this.background) {\n                    gimage.set(x, y, Integer.valueOf(0));\n                }\n                else if (x == 0 && y == 0) {\n                    gimage.set(0, 0, Integer.valueOf(current));\n                    ++current;\n                }\n                else {\n                    if (x - 1 == -1) {\n                        friends[1] = (friends[0] = -1);\n                        friends[2] = gimage.get(x, y - 1);\n                        if (x + 1 >= image.X()) {\n                            friends[3] = -1;\n                        }\n                        else {\n                            friends[3] = gimage.get(x + 1, y - 1);\n                        }\n                    }\n                    else if (y - 1 == -1) {\n                        friends[0] = gimage.get(x - 1, y);\n                        friends[1] = -1;\n                        friends[3] = (friends[2] = -1);\n                    }\n                    else {\n                        friends[0] = gimage.get(x - 1, y);\n                        friends[1] = gimage.get(x - 1, y - 1);\n                        friends[2] = gimage.get(x, y - 1);\n                        if (x + 1 >= image.X()) {\n                            friends[3] = -1;\n                        }\n                        else {\n                            friends[3] = gimage.get(x + 1, y - 1);\n                        }\n                    }\n                    if (this.neighbors == 0) {\n                        if (friends[0] <= 0 && friends[2] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(current));\n                            ++current;\n                        }\n                        else if (friends[0] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(friends[2]));\n                        }\n                        else if (friends[2] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(friends[0]));\n                        }\n                        else if (friends[0] < friends[2]) {\n                            gimage.set(x, y, Integer.valueOf(friends[0]));\n                            equiv[friends[2]] = friends[0];\n                        }\n                        else {\n                            gimage.set(x, y, Integer.valueOf(friends[2]));\n                            if (friends[0] != friends[2]) {\n                                equiv[friends[0]] = friends[2];\n                            }\n                        }\n                    }\n                    else if (this.neighbors == 1) {\n                        if (friends[0] <= 0 && friends[1] <= 0 && friends[2] <= 0 && friends[3] <= 0) {\n                            gimage.set(x, y, Integer.valueOf(current));\n                            ++current;\n                        }\n                        else {\n                            int minVal = 1000;\n                            for (int z = 0; z < 4; ++z) {\n                                if (friends[z] < minVal && friends[z] != 0 && friends[z] != -1) {\n                                    min = z;\n                                    minVal = friends[z];\n                                }\n                            }\n                            gimage.set(x, y, Integer.valueOf(friends[min]));\n                            for (int z = 0; z < 4; ++z) {\n                                if (friends[z] != friends[min] && friends[z] != 0 && friends[z] != -1) {\n                                    equiv[friends[z]] = friends[min];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int curVal = 0;\n        for (int x2 = 0; x2 < gimage.X(); ++x2) {\n            for (int y2 = 0; y2 < gimage.Y(); ++y2) {\n                for (curVal = gimage.get(x2, y2); equiv[curVal] != -1; curVal = equiv[curVal]) {}\n                gimage.set(x2, y2, Integer.valueOf(curVal));\n            }\n        }\n        return gimage;\n    }\n}\n"
    },
    {
        "project_name": "89_jiggler",
        "class": "Shift",
        "fqdn": "jigl.image.ops",
        "source_code": "package jigl.image.ops;\n\nimport jigl.image.types.*;\nimport jigl.image.*;\nimport jigl.image.exceptions.*;\n\npublic class Shift extends SimpleOperator\n{\n    public static final int NOWRAP = 0;\n    public static final int WRAP = 1;\n    private int xoffset;\n    private int yoffset;\n    private boolean wrap;\n    \n    public Shift(final int x, final int y, final int wrap) {\n        this.xoffset = 0;\n        this.yoffset = 0;\n        this.wrap = false;\n        this.xoffset = x;\n        this.yoffset = y;\n        if (wrap == 1) {\n            this.wrap = true;\n        }\n    }\n    \n    @Override\n    protected GrayImage apply(final GrayImage image) {\n        final int X = image.X();\n        final int Y = image.Y();\n        final GrayImage temp = new GrayImage(X, Y);\n        if (this.wrap) {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (this.xoffset > 0 && this.yoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else if (this.xoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (Y + this.yoffset + y) % Y, image.get(x, y));\n                    }\n                    else if (this.yoffset > 0) {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset + Y) % Y, image.get(x, y));\n                    }\n                }\n            }\n        }\n        else {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (x + this.xoffset >= 0 && x + this.xoffset < X && y + this.yoffset >= 0 && y + this.yoffset < Y) {\n                        temp.set(x, y, image.get(x + this.xoffset, y + this.yoffset));\n                    }\n                    else {\n                        temp.set(x, y, Integer.valueOf(0));\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n    \n    @Override\n    protected RealGrayImage apply(final RealGrayImage image) {\n        final int X = image.X();\n        final int Y = image.Y();\n        final RealGrayImage temp = new RealGrayImage(X, Y);\n        if (this.wrap) {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (this.xoffset > 0 && this.yoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else if (this.xoffset > 0) {\n                        temp.set((x + this.xoffset) % X, (Y + this.yoffset + y) % Y, image.get(x, y));\n                    }\n                    else if (this.yoffset > 0) {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset) % Y, image.get(x, y));\n                    }\n                    else {\n                        temp.set((X + this.xoffset + x) % X, (y + this.yoffset + Y) % Y, image.get(x, y));\n                    }\n                }\n            }\n        }\n        else {\n            for (int y = 0; y < Y; ++y) {\n                for (int x = 0; x < X; ++x) {\n                    if (x + this.xoffset >= 0 && x + this.xoffset < X && y + this.yoffset >= 0 && y + this.yoffset < Y) {\n                        temp.set(x, y, image.get(x + this.xoffset, y + this.yoffset));\n                    }\n                    else {\n                        temp.set(x, y, Float.valueOf(0.0f));\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n    \n    @Override\n    protected ColorImage apply(final ColorImage image) {\n        final ColorImage temp = new ColorImage(image.X(), image.Y());\n        temp.setPlane(0, this.apply(image.plane(0)));\n        temp.setPlane(1, this.apply(image.plane(1)));\n        temp.setPlane(2, this.apply(image.plane(2)));\n        return temp;\n    }\n    \n    @Override\n    protected RealColorImage apply(final RealColorImage image) {\n        final RealColorImage temp = new RealColorImage(image.X(), image.Y());\n        temp.setPlane(0, this.apply(image.plane(0)));\n        temp.setPlane(1, this.apply(image.plane(1)));\n        temp.setPlane(2, this.apply(image.plane(2)));\n        return temp;\n    }\n}\n"
    },
    {
        "project_name": "15_beanbin",
        "class": "ReflectionSearch",
        "fqdn": "net.sourceforge.beanbin.reflect",
        "source_code": "package net.sourceforge.beanbin.reflect;\n\nimport net.sourceforge.beanbin.search.*;\nimport java.lang.annotation.*;\nimport net.sourceforge.beanbin.*;\nimport net.sourceforge.beanbin.query.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class ReflectionSearch\n{\n    private Class clazz;\n    private Query query;\n    \n    public ReflectionSearch(final Class clazz) {\n        this.clazz = clazz;\n        this.query = new Query();\n    }\n    \n    public boolean hasAnnotation(final String term) {\n        for (final Annotation anno : this.clazz.getAnnotations()) {\n            final String name = anno.annotationType().getName();\n            final String className = name.substring(name.lastIndexOf(\".\") + 1);\n            final String termName = term.toString().substring(1);\n            if (this.hasWildcard(termName)) {\n                final WildcardSearch wild = new WildcardSearch(termName);\n                if (wild.doesMatch(name)) {\n                    return true;\n                }\n                if (wild.doesMatch(className)) {\n                    return true;\n                }\n            }\n            else {\n                if (name.equals(termName)) {\n                    return true;\n                }\n                if (className.equals(termName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean hasWildcard(final String term) {\n        return term.indexOf(\"*\") != -1;\n    }\n    \n    public ReflectionSearch methodsThatHave(final String term) throws BeanBinException {\n        this.query.add(new MethodReflectionCriteria(this.clazz, term, SearchType.EQUALS));\n        return this;\n    }\n    \n    public ReflectionSearch methodsThatDontHave(final String term) throws BeanBinException {\n        this.query.add(new MethodReflectionCriteria(this.clazz, term, SearchType.DOESNOTEQUAL));\n        return this;\n    }\n    \n    public ReflectionSearch and() {\n        this.query.setNextConditional(Conditional.AND);\n        return this;\n    }\n    \n    public ReflectionSearch or() {\n        this.query.setNextConditional(Conditional.OR);\n        return this;\n    }\n    \n    public List<Method> getMethods() throws BeanBinException {\n        List<Method> list = (List<Method>)ReflectionShelf.getInstance().get(this.query);\n        if (list == null) {\n            list = new ArrayList<Method>();\n            for (final Criteria criteria : this.query.getCriterias()) {\n                if (criteria instanceof ReflectionCriteria) {\n                    final ReflectionCriteria crit = (ReflectionCriteria)criteria;\n                    final Conditional cond = crit.getPreviousCondition();\n                    if (cond != null) {\n                        if (cond == Conditional.AND) {\n                            this.intersect(list, crit.getResults());\n                        }\n                        else {\n                            this.union(list, crit.getResults());\n                        }\n                    }\n                    else {\n                        list = crit.getResults();\n                    }\n                }\n            }\n            ReflectionShelf.getInstance().put(this.query, list);\n        }\n        return list;\n    }\n    \n    protected void intersect(final List<Method> master, final List<Method> toadd) {\n        for (int i = 0; i < master.size(); ++i) {\n            if (!toadd.contains(master.get(i))) {\n                master.remove(i--);\n            }\n        }\n    }\n    \n    protected void union(final List<Method> master, final List<Method> toadd) {\n        for (final Method method : toadd) {\n            if (!master.contains(method)) {\n                master.add(method);\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "74_fixsuite",
        "class": "TreeView",
        "fqdn": "org.fixsuite.message.view",
        "source_code": "package org.fixsuite.message.view;\n\nimport javax.swing.*;\nimport java.util.*;\nimport org.fixsuite.message.info.*;\nimport javax.swing.event.*;\nimport org.fixsuite.message.*;\nimport java.awt.event.*;\nimport javax.swing.tree.*;\nimport java.awt.*;\n\npublic class TreeView extends JPanel implements ActionListener, KeyListener, TreeSelectionListener\n{\n    private static final long serialVersionUID = 1L;\n    private JScrollPane mainScrollPane;\n    private JTree fixTree;\n    private JLabel searchLabel;\n    private JTextField searchTextField;\n    private JButton searchButton;\n    private JButton clearButton;\n    private JButton expandButton;\n    private JButton collapseButton;\n    private Library library;\n    \n    public TreeView(final Library library) {\n        this.library = library;\n        this.initGUI();\n    }\n    \n    private void initGUI() {\n        this.setLayout(new BorderLayout());\n        (this.mainScrollPane = new JScrollPane()).setPreferredSize(new Dimension(300, 400));\n        this.add(this.mainScrollPane, \"Center\");\n        (this.fixTree = new JTree(this.loadFIXTree())).setCellRenderer(new FixInfoCellRenderer());\n        this.fixTree.addTreeSelectionListener(this);\n        this.mainScrollPane.getViewport().add(this.fixTree);\n        this.searchLabel = new JLabel(\"Search \");\n        (this.searchTextField = new JTextField(20)).setToolTipText(\"Search for Item (regex)\");\n        this.searchTextField.addKeyListener(this);\n        (this.searchButton = new JButton(\"Go\")).addActionListener(this);\n        this.searchButton.setToolTipText(\"Start Search\");\n        (this.clearButton = new JButton(new ImageIcon(\".\\\\resources\\\\clear.gif\"))).addActionListener(this);\n        this.clearButton.setToolTipText(\"Clear the Search Results\");\n        (this.expandButton = new JButton(new ImageIcon(\".\\\\resources\\\\expand.gif\"))).addActionListener(this);\n        this.expandButton.setToolTipText(\"Expand the Tree\");\n        (this.collapseButton = new JButton(new ImageIcon(\".\\\\resources\\\\collapse.gif\"))).addActionListener(this);\n        this.collapseButton.setToolTipText(\"Collapse the Tree\");\n        final JToolBar toolbar = new JToolBar();\n        toolbar.setFloatable(false);\n        toolbar.add(this.clearButton);\n        toolbar.addSeparator();\n        toolbar.add(this.searchLabel);\n        toolbar.add(this.searchTextField);\n        toolbar.add(this.searchButton);\n        toolbar.addSeparator();\n        toolbar.add(this.expandButton);\n        toolbar.add(this.collapseButton);\n        this.add(toolbar, \"North\");\n    }\n    \n    private FixInfoTreeNode loadFIXTree() {\n        final FixInfoTreeNode root = new FixInfoTreeNode((Object)\"Dictionaries\");\n        for (final DictionaryInfo dictionary : this.library.getDictionaries()) {\n            final FixInfoTreeNode node = new FixInfoTreeNode((Object)dictionary.getVersion());\n            this.loadMessages(node, dictionary);\n            root.add(node);\n        }\n        return root;\n    }\n    \n    private void loadMessages(final FixInfoTreeNode versionNode, final DictionaryInfo dictionary) {\n        for (final MessageInfo message : dictionary.getMessages()) {\n            final FixInfoTreeNode node = new FixInfoTreeNode((Object)message);\n            this.loadItems(node, message, 0);\n            versionNode.add(node);\n        }\n    }\n    \n    private void loadItems(final FixInfoTreeNode branchNode, final CompositeFixInfo leafNode, int level) {\n        ++level;\n        for (final FixInfo info : leafNode.getItems()) {\n            final FixInfoTreeNode node = new FixInfoTreeNode((Object)info);\n            if (info instanceof CompositeFixInfo && level < 5) {\n                this.loadItems(node, (CompositeFixInfo)info, level);\n            }\n            branchNode.add(node);\n        }\n    }\n    \n    private void expandAll() {\n        synchronized (this.fixTree) {\n            for (int row = 0; row < this.fixTree.getRowCount(); ++row) {\n                this.fixTree.expandRow(row);\n            }\n        }\n    }\n    \n    private void collapseAll() {\n        synchronized (this.fixTree) {\n            for (int row = this.fixTree.getRowCount() - 1; row >= 0; --row) {\n                this.fixTree.collapseRow(row);\n            }\n        }\n    }\n    \n    private void search(final FixInfoTreeNode node, final String searchString) {\n        int count = 0;\n        if (node.getUserObject() instanceof FixInfo) {\n            final FixInfo info = (FixInfo)node.getUserObject();\n            if (info instanceof MessageInfo) {\n                if (((MessageInfo)info).getName().matches(searchString) || ((MessageInfo)info).getMessageType().matches(searchString)) {\n                    node.setHighlighted(true);\n                    this.fixTree.expandPath(new TreePath(node.getPath()));\n                }\n            }\n            else if (info instanceof ComponentInfo) {\n                if (((ComponentInfo)info).getName().matches(searchString)) {\n                    node.setHighlighted(true);\n                    this.fixTree.expandPath(new TreePath(node.getPath()));\n                }\n            }\n            else if (info instanceof FieldInfo) {\n                final String tagNumber = \"\" + ((FieldInfo)info).getTagNumber();\n                if (((FieldInfo)info).getName().matches(searchString) || tagNumber.matches(searchString)) {\n                    node.setHighlighted(true);\n                    if (node.getChildCount() > 0) {\n                        this.fixTree.expandPath(new TreePath(node.getPath()));\n                    }\n                    else {\n                        this.fixTree.expandPath(new TreePath(((FixInfoTreeNode)node.getParent()).getPath()));\n                    }\n                }\n            }\n        }\n        while (count < node.getChildCount()) {\n            final FixInfoTreeNode childNode = (FixInfoTreeNode)node.getChildAt(count);\n            this.search(childNode, searchString);\n            ++count;\n        }\n    }\n    \n    private void clear(final FixInfoTreeNode node) {\n        int count = 0;\n        node.setHighlighted(false);\n        while (count < node.getChildCount()) {\n            final FixInfoTreeNode childNode = (FixInfoTreeNode)node.getChildAt(count);\n            this.clear(childNode);\n            ++count;\n        }\n    }\n    \n    @Override\n    public void valueChanged(final TreeSelectionEvent event) {\n        final FixInfoTreeNode node = (FixInfoTreeNode)this.fixTree.getLastSelectedPathComponent();\n        if (node != null) {\n            if (node.getUserObject() instanceof FieldInfo) {\n                if (((FixInfoTreeNode)node.getParent()).getUserObject() instanceof ComponentInfo) {\n                    LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), (ComponentInfo)((FixInfoTreeNode)node.getParent()).getUserObject());\n                }\n                else {\n                    LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), (ComponentInfo)((FixInfoTreeNode)node.getPath()[2]).getUserObject());\n                }\n            }\n            else if (node.getUserObject() instanceof MessageInfo) {\n                LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), null);\n            }\n            else if (node.getUserObject() instanceof ComponentInfo) {\n                LibrarySuite.getInstance().getDetailsPanel().displayDetails((FixInfo)node.getUserObject(), null);\n            }\n            else {\n                LibrarySuite.getInstance().getDetailsPanel().clearDisplay();\n            }\n        }\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent event) {\n        if (event.getSource().equals(this.collapseButton)) {\n            this.collapseAll();\n        }\n        else if (event.getSource().equals(this.expandButton)) {\n            this.expandAll();\n        }\n        else if (event.getSource().equals(this.searchButton)) {\n            this.clear((FixInfoTreeNode)this.fixTree.getModel().getRoot());\n            this.collapseAll();\n            this.search((FixInfoTreeNode)this.fixTree.getModel().getRoot(), this.searchTextField.getText().trim());\n        }\n        else if (event.getSource().equals(this.clearButton)) {\n            this.clear((FixInfoTreeNode)this.fixTree.getModel().getRoot());\n            this.collapseAll();\n        }\n    }\n    \n    @Override\n    public void keyPressed(final KeyEvent event) {\n        if (event.getKeyCode() == 10) {\n            this.searchButton.doClick();\n        }\n    }\n    \n    @Override\n    public void keyReleased(final KeyEvent event) {\n    }\n    \n    @Override\n    public void keyTyped(final KeyEvent event) {\n    }\n    \n    private class FixInfoTreeNode extends DefaultMutableTreeNode\n    {\n        private static final long serialVersionUID = 1L;\n        private boolean isHighlighted;\n        \n        private FixInfoTreeNode(final Object userObject) {\n            super(userObject);\n            this.isHighlighted = false;\n        }\n        \n        private boolean isHighlighted() {\n            return this.isHighlighted;\n        }\n        \n        private void setHighlighted(final boolean isHighlighted) {\n            this.isHighlighted = isHighlighted;\n        }\n    }\n    \n    private class FixInfoCellRenderer extends DefaultTreeCellRenderer\n    {\n        private static final long serialVersionUID = 1L;\n        \n        @Override\n        public Component getTreeCellRendererComponent(final JTree tree, final Object value, final boolean sel, final boolean expanded, final boolean leaf, final int row, final boolean hasFocus) {\n            final JLabel label = (JLabel)super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n            if (((FixInfoTreeNode)value).getUserObject() instanceof FieldInfo) {\n                final FieldInfo field = (FieldInfo)((FixInfoTreeNode)value).getUserObject();\n                label.setText(field.getName() + \" (\" + field.getTagNumber() + \")\");\n            }\n            else if (((FixInfoTreeNode)value).getUserObject() instanceof MessageInfo) {\n                final MessageInfo message = (MessageInfo)((FixInfoTreeNode)value).getUserObject();\n                label.setText(message.getName() + \" (\" + message.getMessageType() + \")\");\n            }\n            else if (((FixInfoTreeNode)value).getUserObject() instanceof ComponentInfo) {\n                final ComponentInfo component = (ComponentInfo)((FixInfoTreeNode)value).getUserObject();\n                label.setText(\"[\" + component.getName() + \"]\");\n            }\n            if (((FixInfoTreeNode)value).isHighlighted()) {\n                label.setForeground(Color.BLUE);\n            }\n            return label;\n        }\n    }\n}\n"
    },
    {
        "project_name": "74_fixsuite",
        "class": "Library",
        "fqdn": "org.fixsuite.message",
        "source_code": "package org.fixsuite.message;\n\nimport org.fixsuite.message.info.*;\nimport java.io.*;\nimport java.text.*;\nimport org.fixsuite.message.parsers.fpl.*;\nimport java.util.*;\nimport org.slf4j.*;\n\npublic class Library\n{\n    private static final String FIELDS_FILE_NAME = \"Fields.xml\";\n    private static final String ENUMS_FILE_NAME = \"Enums.xml\";\n    private static final String COMPONENTS_FILE_NAME = \"Components.xml\";\n    private static final String MSG_TYPE_FILE_NAME = \"MsgType.xml\";\n    private static final String MSG_CONTENTS_FILE_NAME = \"MsgContents.xml\";\n    private static final int FIELDS_FILE_KEY = 1;\n    private static final int ENUMS_FILE_KEY = 2;\n    private static final int COMPONENTS_FILE_KEY = 3;\n    private static final int MSG_TYPE_FILE_KEY = 4;\n    private static final int MSG_CONTENTS_FILE_KEY = 5;\n    private static Logger logger;\n    private Map<String, DictionaryInfo> dictionaries;\n    \n    public Library() {\n        this.dictionaries = new TreeMap<String, DictionaryInfo>();\n    }\n    \n    public boolean loadFromDirectory(final String libraryPath) {\n        boolean result = true;\n        final long startTime = System.currentTimeMillis();\n        if (!this.dictionaries.isEmpty()) {\n            Library.logger.debug(\"Unloading previous dictionaries\");\n            this.dictionaries.clear();\n        }\n        System.gc();\n        final long startMemory = Runtime.getRuntime().freeMemory();\n        final File path = new File(libraryPath);\n        if (path.isDirectory()) {\n            final File[] files = path.listFiles();\n            if (files.length != 0) {\n                for (int i = 0; i < files.length; ++i) {\n                    if (files[i].isDirectory()) {\n                        this.loadDirectory(this.arrangeFiles(files[i].listFiles()), files[i].getName());\n                    }\n                }\n                if (!this.dictionaries.isEmpty()) {\n                    Library.logger.debug(\"Loaded \" + this.dictionaries.size() + \" FIX dictionaries.\");\n                }\n                else {\n                    Library.logger.error(\"Unable to load any dictionaries\");\n                }\n            }\n            else {\n                Library.logger.error(\"Supplied directory is empty.\");\n                result = false;\n            }\n        }\n        else {\n            Library.logger.error(\"Supplied path is not a directory.\");\n            result = false;\n        }\n        System.gc();\n        Library.logger.debug(\"Approximate memory allocation: \" + new DecimalFormat().format((Runtime.getRuntime().freeMemory() - startMemory) / 1000000.0) + \" MB.\");\n        Library.logger.info(\"Loading time: \" + (System.currentTimeMillis() - startTime) + \" milliseconds.\");\n        return result;\n    }\n    \n    public List<DictionaryInfo> getDictionaries() {\n        return new ArrayList<DictionaryInfo>(this.dictionaries.values());\n    }\n    \n    public DictionaryInfo getDictionary(final String version) {\n        return this.dictionaries.get(version);\n    }\n    \n    private void loadDirectory(final List<File> files, final String version) {\n        final DictionaryInfo dictionary = new DictionaryInfo(version);\n        for (final File file : files) {\n            MainParser.parse(dictionary, file);\n        }\n        if (dictionary.isLoaded()) {\n            this.dictionaries.put(dictionary.getVersion(), dictionary);\n        }\n        else {\n            Library.logger.debug(\"Unable to load dictionary from \" + version + \".\");\n        }\n    }\n    \n    private List<File> arrangeFiles(final File[] files) {\n        final Map<Integer, File> arrangedFiles = new TreeMap<Integer, File>();\n        for (int i = 0; i < files.length; ++i) {\n            if (files[i].getName().equals(\"Fields.xml\")) {\n                arrangedFiles.put(1, files[i]);\n            }\n            else if (files[i].getName().equals(\"Enums.xml\")) {\n                arrangedFiles.put(2, files[i]);\n            }\n            else if (files[i].getName().equals(\"Components.xml\")) {\n                arrangedFiles.put(3, files[i]);\n            }\n            else if (files[i].getName().equals(\"MsgType.xml\")) {\n                arrangedFiles.put(4, files[i]);\n            }\n            else if (files[i].getName().equals(\"MsgContents.xml\")) {\n                arrangedFiles.put(5, files[i]);\n            }\n        }\n        return new ArrayList<File>(arrangedFiles.values());\n    }\n    \n    static {\n        Library.logger = LoggerFactory.getLogger((Class)Library.class);\n    }\n}\n"
    },
    {
        "project_name": "2_a4j",
        "class": "Product",
        "fqdn": "net.kencochrane.a4j.DAO",
        "source_code": "package net.kencochrane.a4j.DAO;\n\nimport net.kencochrane.a4j.file.*;\nimport java.util.*;\nimport com.wutka.jox.*;\nimport net.kencochrane.a4j.beans.*;\nimport java.io.*;\n\npublic class Product\n{\n    public FullProduct getProduct(final String asin, final String offer, final String page) {\n        final FileUtil fileUtil = new FileUtil();\n        JOXBeanInputStream joxIn = null;\n        final FullProduct fullProduct = new FullProduct();\n        ProductDetails productDetails = new ProductDetails();\n        ProductDetails accessoryProductDetails = new ProductDetails();\n        Accessories accessories = new Accessories();\n        ArrayList accessoryArray = new ArrayList();\n        ArrayList detailsArray = new ArrayList();\n        MiniProduct miniProduct = new MiniProduct();\n        final Search search = new Search();\n        try {\n            FileInputStream fileIn = fileUtil.fetchASINFile(asin, \"heavy\", offer, page);\n            if (fileIn == null) {\n                return null;\n            }\n            joxIn = new JOXBeanInputStream((InputStream)fileIn);\n            ProductInfo productInfoBean = (ProductInfo)joxIn.readObject((Class)ProductInfo.class);\n            joxIn.close();\n            fileIn.close();\n            if (productInfoBean != null && productInfoBean.getDetails().length > 0) {\n                productDetails = productInfoBean.getDetails()[0];\n                fullProduct.setDetails(productDetails);\n                accessories = productDetails.getAccessories();\n                accessoryArray = accessories.getAccessoryArray();\n                if (accessoryArray != null && accessoryArray.size() > 0) {\n                    fileIn = fileUtil.fetchAccessories(asin, accessoryArray);\n                    if (fileIn != null) {\n                        joxIn = new JOXBeanInputStream((InputStream)fileIn);\n                        productInfoBean = (ProductInfo)joxIn.readObject((Class)ProductInfo.class);\n                        joxIn.close();\n                        fileIn.close();\n                        if (productInfoBean != null && productInfoBean.getProductsArrayList().size() > 0) {\n                            detailsArray = productInfoBean.getProductsArrayList();\n                            for (int x = 0; x < detailsArray.size(); ++x) {\n                                accessoryProductDetails = detailsArray.get(x);\n                                if (accessoryProductDetails != null) {\n                                    miniProduct = new MiniProduct();\n                                    miniProduct.setAsin(accessoryProductDetails.getAsin());\n                                    miniProduct.setImageURL(accessoryProductDetails.getImageUrlSmall());\n                                    miniProduct.setManufacturer(accessoryProductDetails.getManufacturer());\n                                    miniProduct.setName(accessoryProductDetails.getProductName());\n                                    miniProduct.setPrice(accessoryProductDetails.getOurPrice());\n                                    fullProduct.addAccessory(miniProduct);\n                                }\n                            }\n                        }\n                    }\n                }\n                productInfoBean = search.SimilaritesSearch(asin, \"1\");\n                if (productInfoBean != null && productInfoBean.getProductsArrayList() != null && productInfoBean.getProductsArrayList().size() > 0) {\n                    detailsArray = productInfoBean.getProductsArrayList();\n                    for (int x = 0; x < detailsArray.size(); ++x) {\n                        accessoryProductDetails = detailsArray.get(x);\n                        if (accessoryProductDetails != null) {\n                            miniProduct = new MiniProduct();\n                            miniProduct.setAsin(accessoryProductDetails.getAsin());\n                            miniProduct.setImageURL(accessoryProductDetails.getImageUrlSmall());\n                            miniProduct.setManufacturer(accessoryProductDetails.getManufacturer());\n                            miniProduct.setName(accessoryProductDetails.getProductName());\n                            miniProduct.setPrice(accessoryProductDetails.getOurPrice());\n                            fullProduct.addSimilarItem(miniProduct);\n                        }\n                    }\n                }\n            }\n        }\n        catch (Exception exc) {\n            exc.printStackTrace();\n        }\n        return fullProduct;\n    }\n}\n"
    },
    {
        "project_name": "84_ifx-framework",
        "class": "IFXObject",
        "fqdn": "org.sourceforge.ifx.basetypes",
        "source_code": "package org.sourceforge.ifx.basetypes;\n\nimport java.lang.reflect.*;\n\npublic class IFXObject\n{\n    private static final String TABSTOP = \"  \";\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (!(obj instanceof IFXObject)) {\n            return false;\n        }\n        final IFXObject that = (IFXObject)obj;\n        return this.doCheckEquals(this, that);\n    }\n    \n    @Override\n    public String toString() {\n        return this.stringify(this, 0);\n    }\n    \n    private String stringify(final IFXObject obj, final int level) {\n        int depth = level;\n        final StringBuffer buf = new StringBuffer();\n        try {\n            final Class objClass = obj.getClass();\n            buf.append(objClass.getName()).append(\" = {\");\n            ++depth;\n            final Method[] methods = objClass.getMethods();\n            for (int i = 0; i < methods.length; ++i) {\n                final Method method = methods[i];\n                final String methodName = method.getName();\n                if (!methodName.equals(\"getClass\") && methodName.startsWith(\"get\")) {\n                    final String memberName = methodName.substring(3);\n                    buf.append(\"\\n\").append(this.tab(depth)).append(memberName).append(\" = \");\n                    final Object retObj = method.invoke(obj, (Object[])null);\n                    if (retObj == null) {\n                        buf.append(\"NULL\");\n                    }\n                    else if (retObj.getClass().isArray()) {\n                        final int numObjs = Array.getLength(retObj);\n                        buf.append(\"[\\n\");\n                        ++depth;\n                        for (int j = 0; j < numObjs; ++j) {\n                            if (j > 0) {\n                                buf.append(\",\\n\");\n                            }\n                            buf.append(this.tab(depth)).append(\"[\").append(j).append(\"]:\");\n                            final IFXObject arrayObj = (IFXObject)Array.get(retObj, j);\n                            buf.append(this.stringify(arrayObj, depth));\n                        }\n                        --depth;\n                        buf.append(\"\\n\").append(this.tab(depth)).append(\"]\");\n                    }\n                    else if (retObj instanceof IBaseType) {\n                        buf.append(((IBaseType)retObj).getString());\n                    }\n                    else {\n                        buf.append(this.stringify((IFXObject)retObj, depth));\n                    }\n                }\n            }\n        }\n        catch (Exception e) {\n            buf.append(\"Exception! \" + e.toString());\n        }\n        --depth;\n        buf.append(\"\\n\").append(this.tab(depth)).append(\"}\");\n        return buf.toString();\n    }\n    \n    private boolean doCheckEquals(final IFXObject thisObj, final IFXObject thatObj) {\n        if (thisObj == null && thatObj == null) {\n            return true;\n        }\n        if (thisObj == null ^ thatObj == null) {\n            return false;\n        }\n        if (!thisObj.getClass().getName().equals(thatObj.getClass().getName())) {\n            return false;\n        }\n        final Method[] thisMethods = thisObj.getClass().getMethods();\n        final Method[] thatMethods = thatObj.getClass().getMethods();\n        boolean matched = true;\n        for (int i = 0; i < thisMethods.length; ++i) {\n            if (thisMethods[i].getName().startsWith(\"get\") && !thisMethods[i].getName().equals(\"getClass\")) {\n                Method thatMethod = null;\n                for (int j = 0; j < thatMethods.length; ++j) {\n                    if (thatMethods[j].getName().equals(thisMethods[i].getName())) {\n                        thatMethod = thatMethods[j];\n                        break;\n                    }\n                }\n                IFXObject thatRetVal = null;\n                IFXObject thisRetVal = null;\n                try {\n                    if (thisMethods[i].getReturnType().isArray()) {\n                        final Object thisRetValObj = thisMethods[i].invoke(thisObj, (Object[])null);\n                        final Object thatRetValObj = thatMethod.invoke(thatObj, (Object[])null);\n                        int thisNumElements = 0;\n                        int thatNumElements = 0;\n                        if (thisRetValObj != null) {\n                            thisNumElements = Array.getLength(thisRetValObj);\n                        }\n                        if (thatRetValObj != null) {\n                            thatNumElements = Array.getLength(thatRetValObj);\n                        }\n                        if (thisNumElements != thatNumElements) {\n                            matched = false;\n                        }\n                        for (int k = 0; k < thisNumElements && matched; matched = this.doCheckEquals(thisRetVal, thatRetVal), ++k) {\n                            thisRetVal = (IFXObject)Array.get(thisRetValObj, k);\n                            thatRetVal = (IFXObject)Array.get(thatRetValObj, k);\n                        }\n                    }\n                    else {\n                        thisRetVal = (IFXObject)thisMethods[i].invoke(thisObj, (Object[])null);\n                        thatRetVal = (IFXObject)thatMethod.invoke(thatObj, (Object[])null);\n                        if (thisRetVal instanceof IBaseType && thatRetVal instanceof IBaseType) {\n                            final String thisRetValAsString = ((IBaseType)thisRetVal).getString();\n                            final String thatRetValAsString = ((IBaseType)thatRetVal).getString();\n                            matched = ((thisRetValAsString == null && thatRetValAsString == null) || (!(thisRetValAsString == null ^ thatRetValAsString == null) && thisRetValAsString.equals(thatRetValAsString)));\n                        }\n                        else {\n                            matched = this.doCheckEquals(thisRetVal, thatRetVal);\n                        }\n                    }\n                }\n                catch (Exception e) {\n                    e.printStackTrace(System.out);\n                    matched = false;\n                }\n                if (!matched) {\n                    break;\n                }\n            }\n        }\n        return matched;\n    }\n    \n    private String tab(final int level) {\n        final StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < level; ++i) {\n            buf.append(\"  \");\n        }\n        return buf.toString();\n    }\n}\n"
    },
    {
        "project_name": "checkstyle",
        "class": "FileText",
        "fqdn": "com.puppycrawl.tools.checkstyle.api",
        "source_code": "package com.puppycrawl.tools.checkstyle.api;\n\nimport java.nio.charset.*;\nimport com.google.common.io.*;\nimport java.util.regex.*;\nimport java.util.*;\nimport java.io.*;\n\npublic final class FileText extends AbstractList<String>\n{\n    private static final int READ_BUFFER_SIZE = 1024;\n    private static final Pattern LINE_TERMINATOR;\n    private final File file;\n    private final Charset charset;\n    private final String fullText;\n    private final String[] lines;\n    private int[] lineBreaks;\n    \n    public FileText(final File file, final String charsetName) throws IOException {\n        this.file = file;\n        CharsetDecoder decoder;\n        try {\n            this.charset = Charset.forName(charsetName);\n            decoder = this.charset.newDecoder();\n            decoder.onMalformedInput(CodingErrorAction.REPLACE);\n            decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        catch (UnsupportedCharsetException ex) {\n            final String message = \"Unsupported charset: \" + charsetName;\n            throw new IllegalStateException(message, ex);\n        }\n        this.fullText = readFile(file, decoder);\n        final ArrayList<String> textLines = new ArrayList<String>();\n        final BufferedReader reader = new BufferedReader(new StringReader(this.fullText));\n        while (true) {\n            final String line = reader.readLine();\n            if (line == null) {\n                break;\n            }\n            textLines.add(line);\n        }\n        this.lines = textLines.toArray(new String[textLines.size()]);\n    }\n    \n    public FileText(final FileText fileText) {\n        this.file = fileText.file;\n        this.charset = fileText.charset;\n        this.fullText = fileText.fullText;\n        this.lines = fileText.lines.clone();\n        if (fileText.lineBreaks == null) {\n            this.lineBreaks = null;\n        }\n        else {\n            this.lineBreaks = fileText.lineBreaks.clone();\n        }\n    }\n    \n    private FileText(final File file, final List<String> lines) {\n        final StringBuilder buf = new StringBuilder();\n        for (final String line : lines) {\n            buf.append(line).append('\\n');\n        }\n        buf.trimToSize();\n        this.file = file;\n        this.charset = null;\n        this.fullText = buf.toString();\n        this.lines = lines.toArray(new String[lines.size()]);\n    }\n    \n    private static String readFile(final File inputFile, final CharsetDecoder decoder) throws IOException {\n        if (!inputFile.exists()) {\n            throw new FileNotFoundException(inputFile.getPath() + \" (No such file or directory)\");\n        }\n        final StringBuilder buf = new StringBuilder();\n        final FileInputStream stream = new FileInputStream(inputFile);\n        final Reader reader = new InputStreamReader(stream, decoder);\n        try {\n            final char[] chars = new char[1024];\n            while (true) {\n                final int len = reader.read(chars);\n                if (len < 0) {\n                    break;\n                }\n                buf.append(chars, 0, len);\n            }\n        }\n        finally {\n            Closeables.closeQuietly(reader);\n        }\n        return buf.toString();\n    }\n    \n    public static FileText fromLines(final File file, final List<String> lines) {\n        if (lines instanceof FileText) {\n            return (FileText)lines;\n        }\n        return new FileText(file, lines);\n    }\n    \n    public File getFile() {\n        return this.file;\n    }\n    \n    public Charset getCharset() {\n        return this.charset;\n    }\n    \n    public CharSequence getFullText() {\n        return this.fullText;\n    }\n    \n    public String[] toLinesArray() {\n        return this.lines.clone();\n    }\n    \n    private int[] findLineBreaks() {\n        if (this.lineBreaks == null) {\n            final int[] lineBreakPositions = new int[this.size() + 1];\n            lineBreakPositions[0] = 0;\n            int lineNo = 1;\n            final Matcher matcher = FileText.LINE_TERMINATOR.matcher(this.fullText);\n            while (matcher.find()) {\n                lineBreakPositions[lineNo] = matcher.end();\n                ++lineNo;\n            }\n            if (lineNo < lineBreakPositions.length) {\n                lineBreakPositions[lineNo] = this.fullText.length();\n            }\n            this.lineBreaks = lineBreakPositions;\n        }\n        return this.lineBreaks;\n    }\n    \n    public LineColumn lineColumn(final int pos) {\n        final int[] lineBreakPositions = this.findLineBreaks();\n        int lineNo = Arrays.binarySearch(lineBreakPositions, pos);\n        if (lineNo < 0) {\n            lineNo = -lineNo - 2;\n        }\n        final int startOfLine = lineBreakPositions[lineNo];\n        final int columnNo = pos - startOfLine;\n        return new LineColumn(lineNo + 1, columnNo);\n    }\n    \n    @Override\n    public String get(final int lineNo) {\n        return this.lines[lineNo];\n    }\n    \n    @Override\n    public int size() {\n        return this.lines.length;\n    }\n    \n    static {\n        LINE_TERMINATOR = Pattern.compile(\"\\\\n|\\\\r\\\\n?\");\n    }\n}\n"
    },
    {
        "project_name": "checkstyle",
        "class": "AbstractLoader",
        "fqdn": "com.puppycrawl.tools.checkstyle.api",
        "source_code": "package com.puppycrawl.tools.checkstyle.api;\n\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.google.common.collect.*;\nimport javax.xml.parsers.*;\nimport java.io.*;\nimport org.xml.sax.*;\n\npublic abstract class AbstractLoader extends DefaultHandler\n{\n    private final Map<String, String> publicIdToResourceNameMap;\n    private final XMLReader parser;\n    \n    protected AbstractLoader(final String publicId, final String dtdResourceName) throws SAXException, ParserConfigurationException {\n        this(new HashMap<String, String>(1));\n        this.publicIdToResourceNameMap.put(publicId, dtdResourceName);\n    }\n    \n    protected AbstractLoader(final Map<String, String> publicIdToResourceNameMap) throws SAXException, ParserConfigurationException {\n        this.publicIdToResourceNameMap = (Map<String, String>)Maps.newHashMap((Map<?, ?>)publicIdToResourceNameMap);\n        final SAXParserFactory factory = SAXParserFactory.newInstance();\n        factory.setValidating(true);\n        factory.setNamespaceAware(true);\n        (this.parser = factory.newSAXParser().getXMLReader()).setContentHandler(this);\n        this.parser.setEntityResolver(this);\n        this.parser.setErrorHandler(this);\n    }\n    \n    public void parseInputSource(final InputSource inputSource) throws IOException, SAXException {\n        this.parser.parse(inputSource);\n    }\n    \n    @Override\n    public InputSource resolveEntity(final String publicId, final String systemId) throws SAXException, IOException {\n        if (this.publicIdToResourceNameMap.keySet().contains(publicId)) {\n            final String dtdResourceName = this.publicIdToResourceNameMap.get(publicId);\n            final ClassLoader loader = this.getClass().getClassLoader();\n            final InputStream dtdIs = loader.getResourceAsStream(dtdResourceName);\n            return new InputSource(dtdIs);\n        }\n        return super.resolveEntity(publicId, systemId);\n    }\n    \n    @Override\n    public void error(final SAXParseException exception) throws SAXException {\n        throw exception;\n    }\n    \n    @Override\n    public void fatalError(final SAXParseException exception) throws SAXException {\n        throw exception;\n    }\n}\n"
    },
    {
        "project_name": "52_lagoon",
        "class": "LagoonCLI",
        "fqdn": "nu.staldal.lagoon",
        "source_code": "package nu.staldal.lagoon;\n\nimport java.util.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport java.io.*;\nimport nu.staldal.xtree.*;\n\npublic class LagoonCLI\n{\n    private static boolean DEBUG;\n    private static final String syntaxMsg = \"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\";\n    private static Properties properties;\n    \n    public static void main(final String[] args) {\n        boolean force = false;\n        boolean build = false;\n        long interval = 0L;\n        if (args.length < 1) {\n            System.out.println(\"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\");\n            return;\n        }\n        if (args.length > 1 && args[1].equals(\"build\")) {\n            build = true;\n        }\n        else if (args.length > 1 && args[1].equals(\"force\")) {\n            force = true;\n        }\n        else if (args.length > 1) {\n            try {\n                interval = 1000 * Integer.parseInt(args[1]);\n            }\n            catch (NumberFormatException e5) {\n                System.out.println(\"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\");\n                return;\n            }\n            if (interval < 1L) {\n                System.out.println(\"Syntax:\\nnu.staldal.lagoon.LagoonCLI <property_file> [<interval>|build|force]\\nnu.staldal.lagoon.LagoonCLI <sitemap_file> [<interval>|build|force]\");\n                return;\n            }\n        }\n        LagoonProcessor processor;\n        try {\n            System.out.println(\"Initializing Lagoon...\");\n            String targetURL;\n            File sourceDir;\n            File sitemapFile;\n            String password;\n            if (args[0].endsWith(\".xml\") || args[0].endsWith(\".sitemap\")) {\n                targetURL = System.getProperty(\"user.dir\");\n                sourceDir = new File(targetURL);\n                sitemapFile = new File(args[0]);\n                password = null;\n            }\n            else {\n                final File propertyFile = new File(args[0]);\n                LagoonCLI.properties = new Properties();\n                final FileInputStream fis = new FileInputStream(propertyFile);\n                LagoonCLI.properties.load(fis);\n                fis.close();\n                targetURL = getProperty(\"targetURL\");\n                sitemapFile = new File(getProperty(\"sitemapFile\"));\n                sourceDir = new File(getProperty(\"sourceDir\"));\n                password = LagoonCLI.properties.getProperty(\"password\");\n            }\n            Element sitemapTree;\n            try {\n                sitemapTree = TreeBuilder.parseXML(TreeBuilder.fileToInputSource(sitemapFile), false);\n            }\n            catch (SAXException e) {\n                final Exception ee = e.getException();\n                if (ee == null) {\n                    e.printStackTrace();\n                    throw new LagoonException(e.getMessage());\n                }\n                if (ee instanceof IOException) {\n                    throw (IOException)ee;\n                }\n                ee.printStackTrace();\n                throw new LagoonException(ee.getMessage());\n            }\n            processor = new LagoonProcessor(targetURL, sitemapTree, sourceDir, password, new PrintWriter(System.out, true), new PrintWriter(System.err, true));\n        }\n        catch (AuthenticationMissingException e6) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"Password is required but not specified\");\n            return;\n        }\n        catch (AuthenticationException e7) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"Incorrect password\");\n            return;\n        }\n        catch (FileNotFoundException e2) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"File not found: \" + e2.getMessage());\n            return;\n        }\n        catch (IOException e3) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(\"I/O error: \" + e3.toString());\n            if (LagoonCLI.DEBUG) {\n                e3.printStackTrace();\n            }\n            return;\n        }\n        catch (LagoonException e4) {\n            System.err.println(\"Error while initializing Lagoon:\");\n            System.err.println(e4.getMessage());\n            return;\n        }\n        System.out.println(\"Lagoon initialized successfully\");\n        try {\n            if (build) {\n                System.out.println(\"Building website...\");\n                final long timeBefore = System.currentTimeMillis();\n                if (!processor.build(false)) {\n                    System.out.println(\"...with errors...\");\n                }\n                final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                showTime(timeElapsed);\n            }\n            else if (force) {\n                System.out.println(\"Force building website...\");\n                final long timeBefore = System.currentTimeMillis();\n                if (!processor.build(true)) {\n                    System.out.println(\"...with errors...\");\n                }\n                final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                showTime(timeElapsed);\n            }\n            else if (interval > 0L) {\n                while (true) {\n                    System.out.println(\"Building website...\");\n                    final long timeBefore = System.currentTimeMillis();\n                    if (!processor.build(false)) {\n                        System.out.println(\"...with errors...\");\n                    }\n                    final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                    showTime(timeElapsed);\n                    if (timeElapsed < interval) {\n                        try {\n                            Thread.sleep(interval - timeElapsed);\n                        }\n                        catch (InterruptedException ex) {}\n                    }\n                }\n            }\n            else {\n                final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                while (true) {\n                    System.out.println(\"Ready\");\n                    final String s = in.readLine();\n                    if (s.length() < 1) {\n                        continue;\n                    }\n                    final char c = Character.toLowerCase(s.charAt(0));\n                    if (c == 'b') {\n                        System.out.println(\"Building website...\");\n                        final long timeBefore2 = System.currentTimeMillis();\n                        if (!processor.build(false)) {\n                            System.out.println(\"...with errors...\");\n                        }\n                        final long timeElapsed2 = System.currentTimeMillis() - timeBefore2;\n                        showTime(timeElapsed2);\n                    }\n                    else if (c == 'f') {\n                        System.out.println(\"Force building website...\");\n                        final long timeBefore2 = System.currentTimeMillis();\n                        if (!processor.build(true)) {\n                            System.out.println(\"...with errors...\");\n                        }\n                        final long timeElapsed2 = System.currentTimeMillis() - timeBefore2;\n                        showTime(timeElapsed2);\n                    }\n                    else {\n                        if (c == 'q') {\n                            break;\n                        }\n                        continue;\n                    }\n                }\n            }\n            if (LagoonCLI.DEBUG) {\n                final Thread[] threads = new Thread[Thread.activeCount()];\n                Thread.enumerate(threads);\n                for (int i = 0; i < threads.length; ++i) {\n                    if (threads[i] != null && threads[i] != Thread.currentThread()) {\n                        System.out.println(\"Thread still running: \" + threads[i]);\n                    }\n                }\n            }\n            System.out.println(\"Exiting Lagoon...\");\n            processor.destroy();\n            System.exit(0);\n        }\n        catch (FileNotFoundException e2) {\n            System.err.println(\"File not found: \" + e2.getMessage());\n        }\n        catch (IOException e3) {\n            System.err.println(\"I/O error: \" + e3.toString());\n            if (LagoonCLI.DEBUG) {\n                e3.printStackTrace();\n            }\n        }\n    }\n    \n    private static String getProperty(final String name) throws LagoonException {\n        final String value = LagoonCLI.properties.getProperty(name);\n        if (value == null) {\n            throw new LagoonException(\"Property \" + name + \" not specified\");\n        }\n        return value.trim();\n    }\n    \n    private static void showTime(final long ms) {\n        if (ms < 10000L) {\n            System.out.println(\"in \" + ms + \" ms\");\n        }\n        else {\n            System.out.println(\"in \" + ms / 1000L + \" s\");\n        }\n    }\n    \n    static {\n        LagoonCLI.DEBUG = false;\n    }\n}\n"
    },
    {
        "project_name": "52_lagoon",
        "class": "LagoonGUI",
        "fqdn": "nu.staldal.lagoon",
        "source_code": "package nu.staldal.lagoon;\n\nimport java.awt.event.*;\nimport org.xml.sax.*;\nimport nu.staldal.lagoon.core.*;\nimport nu.staldal.xtree.*;\nimport java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class LagoonGUI extends Frame implements WindowListener\n{\n    private static final boolean DEBUG = false;\n    private Panel buttonPanel;\n    private Panel inputPanel;\n    private Panel centerPanel;\n    private Button loadButton;\n    private Button saveButton;\n    private Button buildButton;\n    private Button forceButton;\n    private Button exitButton;\n    private InputComponent sitemapFile;\n    private InputComponent sourceDir;\n    private InputComponent targetURL;\n    private String password;\n    private Label statusLabel;\n    private TextArea progressArea;\n    private LagoonProcessor processor;\n    private long sitemapLastModified;\n    \n    public static void main(final String[] args) throws Exception {\n        final LagoonGUI appFrame = new LagoonGUI();\n        appFrame.show();\n        if (args.length > 0) {\n            appFrame.loadProperties(new File(args[0]));\n        }\n    }\n    \n    LagoonGUI() {\n        super(\"Lagoon\");\n        this.processor = null;\n        this.sitemapLastModified = 0L;\n        this.addWindowListener(this);\n        this.add(this.inputPanel = new Panel(), \"North\");\n        this.inputPanel.setLayout(new GridLayout(0, 1));\n        this.inputPanel.add(this.sitemapFile = new InputComponent(this, \"Sitemap file\", \"\", true));\n        this.inputPanel.add(this.sourceDir = new InputComponent(this, \"Source directory\", \".\"));\n        this.inputPanel.add(this.targetURL = new InputComponent(this, \"Target URL\", \".\"));\n        this.add(this.centerPanel = new Panel(), \"Center\");\n        this.centerPanel.setLayout(new BorderLayout());\n        this.centerPanel.add(this.progressArea = new TextArea(null, 5, 50, 1), \"North\");\n        this.progressArea.setEditable(false);\n        this.centerPanel.add(this.statusLabel = new Label(\"Not initialized\"), \"South\");\n        this.add(this.buttonPanel = new Panel(), \"South\");\n        this.buttonPanel.add(this.loadButton = new Button(\"Load Properties\"));\n        this.loadButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.loadPropertyFile();\n            }\n        });\n        this.buttonPanel.add(this.saveButton = new Button(\"Save Properties\"));\n        this.saveButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.savePropertyFile();\n            }\n        });\n        this.buttonPanel.add(this.buildButton = new Button(\"Build\"));\n        this.buildButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.build(false);\n            }\n        });\n        this.buttonPanel.add(this.forceButton = new Button(\"Force build\"));\n        this.forceButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.build(true);\n            }\n        });\n        this.buttonPanel.add(this.exitButton = new Button(\"Exit\"));\n        this.exitButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                LagoonGUI.this.exit();\n            }\n        });\n        this.setBackground(Color.lightGray);\n        this.pack();\n    }\n    \n    @Override\n    public void windowOpened(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowClosing(final WindowEvent e) {\n        this.exit();\n    }\n    \n    @Override\n    public void windowClosed(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowIconified(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowDeiconified(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowActivated(final WindowEvent e) {\n    }\n    \n    @Override\n    public void windowDeactivated(final WindowEvent e) {\n    }\n    \n    private void build(final boolean force) {\n        this.loadButton.setEnabled(false);\n        this.saveButton.setEnabled(false);\n        this.buildButton.setEnabled(false);\n        this.forceButton.setEnabled(false);\n        this.sitemapFile.setEnabled(false);\n        this.sourceDir.setEnabled(false);\n        this.targetURL.setEnabled(false);\n        final File sm = new File(this.sitemapFile.getValue());\n        if (this.processor == null || this.sitemapFile.hasChanged() || this.sourceDir.hasChanged() || this.targetURL.hasChanged()) {\n            this.init();\n        }\n        else if (sm.lastModified() > this.sitemapLastModified) {\n            this.init();\n        }\n        if (this.processor != null) {\n            final long timeBefore = System.currentTimeMillis();\n            this.progressArea.setText(\"--- Start build ---\\n\");\n            this.statusLabel.setText(\"Building...\");\n            try {\n                final boolean success = this.processor.build(force);\n                final long timeElapsed = System.currentTimeMillis() - timeBefore;\n                if (!success) {\n                    this.progressArea.append(\"--- Build finished with error(s) \" + showTime(timeElapsed) + \" ---\");\n                    final MessageDialog ed = new MessageDialog(this, \"Building error\", \"Error(s) occured while building\");\n                    ed.show();\n                }\n                else {\n                    this.progressArea.append(\"--- Build finished successfully \" + showTime(timeElapsed) + \" ---\");\n                }\n            }\n            catch (FileNotFoundException e) {\n                final MessageDialog ed2 = new MessageDialog(this, \"Fatal Building error\", \"File not found: \" + e.getMessage());\n                ed2.show();\n            }\n            catch (IOException e2) {\n                final MessageDialog ed2 = new MessageDialog(this, \"Fatal Building error\", e2.toString());\n                ed2.show();\n            }\n            this.statusLabel.setText(\"Ready\");\n        }\n        else {\n            this.statusLabel.setText(\"Not initialized\");\n        }\n        this.sitemapLastModified = sm.lastModified();\n        this.loadButton.setEnabled(true);\n        this.saveButton.setEnabled(true);\n        this.buildButton.setEnabled(true);\n        this.forceButton.setEnabled(true);\n        this.sitemapFile.setEnabled(true);\n        this.sourceDir.setEnabled(true);\n        this.targetURL.setEnabled(true);\n    }\n    \n    private void exit() {\n        try {\n            if (this.processor != null) {\n                this.processor.destroy();\n            }\n        }\n        catch (IOException e) {\n            System.err.println(\"Error destroying LagoonProcessor: \" + e.toString());\n        }\n        System.exit(0);\n    }\n    \n    private void init() {\n        this.statusLabel.setText(\"Initializing...\");\n        try {\n            if (this.processor != null) {\n                this.processor.destroy();\n            }\n        }\n        catch (IOException e) {\n            System.err.println(\"Error destroying LagoonProcessor: \" + e.toString());\n        }\n        this.processor = null;\n        try {\n            Element sitemapTree;\n            try {\n                final FileInputStream fis = new FileInputStream(new File(this.sitemapFile.getValue()));\n                final InputSource is = new InputSource(this.sitemapFile.getValue());\n                is.setByteStream(fis);\n                sitemapTree = TreeBuilder.parseXML(is, false);\n                fis.close();\n            }\n            catch (SAXException e2) {\n                final Exception ee = e2.getException();\n                if (ee == null) {\n                    e2.printStackTrace();\n                    throw new LagoonException(e2.getMessage());\n                }\n                if (ee instanceof IOException) {\n                    throw (IOException)ee;\n                }\n                ee.printStackTrace();\n                throw new LagoonException(ee.getMessage());\n            }\n            final PrintWriter pw = new PrintWriter(new TextAreaWriter(this.progressArea), true);\n            this.processor = new LagoonProcessor(this.targetURL.getValue(), sitemapTree, new File(this.sourceDir.getValue()), this.password, pw, pw);\n        }\n        catch (AuthenticationMissingException e5) {\n            final PasswordDialog pwd = new PasswordDialog(this, \"Password\", \"Password needed to access target\");\n            pwd.show();\n            this.password = pwd.getPassword();\n            if (this.password != null) {\n                this.init();\n            }\n        }\n        catch (AuthenticationException e6) {\n            final PasswordDialog pwd = new PasswordDialog(this, \"Password\", \"Invalid password, try again\");\n            pwd.show();\n            this.password = pwd.getPassword();\n            if (this.password != null) {\n                this.init();\n            }\n        }\n        catch (FileNotFoundException e3) {\n            final MessageDialog ed = new MessageDialog(this, \"Initializing error\", \"File not found: \" + e3.getMessage());\n            ed.show();\n        }\n        catch (IOException e) {\n            final MessageDialog ed = new MessageDialog(this, \"Initializing error\", e.toString());\n            ed.show();\n        }\n        catch (LagoonException e4) {\n            final MessageDialog ed = new MessageDialog(this, \"Initializing error\", e4.getMessage());\n            ed.show();\n        }\n    }\n    \n    private void loadPropertyFile() {\n        final FileDialog propertyFileDialog = new FileDialog(this, \"Load property file\");\n        propertyFileDialog.show();\n        final File propertyFile = (propertyFileDialog.getFile() == null) ? null : new File(propertyFileDialog.getDirectory(), propertyFileDialog.getFile());\n        if (propertyFile != null) {\n            this.loadProperties(propertyFile);\n        }\n    }\n    \n    private void loadProperties(final File propertyFile) {\n        try {\n            final FileInputStream fis = new FileInputStream(propertyFile);\n            final Properties prop = new Properties();\n            prop.load(fis);\n            fis.close();\n            this.sitemapFile.setValue(getProperty(prop, \"sitemapFile\"));\n            this.sourceDir.setValue(getProperty(prop, \"sourceDir\"));\n            this.targetURL.setValue(getProperty(prop, \"targetURL\"));\n            this.password = prop.getProperty(\"password\");\n        }\n        catch (LagoonException e) {\n            final MessageDialog ed = new MessageDialog(this, \"Error in propertry file\", e.getMessage());\n            ed.show();\n        }\n        catch (IOException e2) {\n            final MessageDialog ed = new MessageDialog(this, \"Error reading property file\", e2.toString());\n            ed.show();\n        }\n    }\n    \n    private void savePropertyFile() {\n        final FileDialog propertyFileDialog = new FileDialog(this, \"Save property file\", 1);\n        propertyFileDialog.show();\n        final File propertyFile = (propertyFileDialog.getFile() == null) ? null : new File(propertyFileDialog.getDirectory(), propertyFileDialog.getFile());\n        if (propertyFile != null) {\n            try {\n                final FileOutputStream fos = new FileOutputStream(propertyFile);\n                final Properties prop = new Properties();\n                prop.setProperty(\"sitemapFile\", this.sitemapFile.getValue());\n                prop.setProperty(\"sourceDir\", this.sourceDir.getValue());\n                prop.setProperty(\"targetURL\", this.targetURL.getValue());\n                if (this.password != null) {\n                    final YesNoQueryDialog ynDialog = new YesNoQueryDialog(this, \"Save property file\", \"Save password in property file?\", \"Yes\", \"No\");\n                    ynDialog.show();\n                    if (ynDialog.getResult()) {\n                        prop.setProperty(\"password\", this.password);\n                    }\n                }\n                prop.store(fos, \"Lagoon properties\");\n                fos.close();\n                this.statusLabel.setText(\"Properties saved\");\n            }\n            catch (IOException e) {\n                final MessageDialog ed = new MessageDialog(this, \"Error writing property file\", e.toString());\n                ed.show();\n            }\n        }\n    }\n    \n    private static String getProperty(final Properties prop, final String name) throws LagoonException {\n        final String value = prop.getProperty(name);\n        if (value == null) {\n            throw new LagoonException(\"Property \" + name + \" not specified\");\n        }\n        return value.trim();\n    }\n    \n    private static String showTime(final long ms) {\n        if (ms < 10000L) {\n            return \"in \" + ms + \" ms\";\n        }\n        return \"in \" + ms / 1000L + \" s\";\n    }\n}\n"
    },
    {
        "project_name": "60_sugar",
        "class": "FSPathExplorer",
        "fqdn": "net.sf.sugar.fspath.cli",
        "source_code": "/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net) \n * \n * All rights reserved.\n * \n * This file is part of FSPath.\n * \n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage net.sf.sugar.fspath.cli;\n/*\n * FSPathExplorer.java\n *\n * Created on 04 April 2008, 16:36\n *\n * To change this template, choose Tools | Template Manager\n * and open the template in the editor.\n */\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport net.sf.sugar.fspath.FSPath;\nimport net.sf.sugar.fspath.FSPathAttributes;\nimport net.sf.sugar.fspath.FSPathFactory;\nimport net.sf.sugar.fspath.FSPathResult;\nimport net.sf.sugar.fspath.FSPathResultList;\n\n\n/**\n *  This is a simple command line tool for interacting with the filesystem\n *\n * @author kbishop\n */\npublic class FSPathExplorer {\n   \n    public File rootPath;\n    \n    public String fsPathQuery = \"\";\n    \n    public FSPath fsPath;\n\n    public Prompt prompt;\n\n    public PrintStream out;\n\n    public PrintStream err;\n    \n    private enum Opt {\n        path, p, find, f\n    }\n    \n    /** Creates a new instance of FSPathExplorer */\n    public FSPathExplorer() {\n        this.out = System.out;\n        this.err = System.err;\n        this.prompt = new Prompt(System.in, out, err);\n        this.prompt.setPromptText(\"fspath>\");\n    }\n    \n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        \n        //checkArgs(args);\n        \n        showWelcome();\n        \n        FSPathExplorer explorer = new FSPathExplorer();\n        \n        explorer.configureExplorer(args);\n        \n        explorer.createFSPath();\n        \n        explorer.start();\n\n    }\n    \n//    protected static void checkArgs(String[] args) {\n//        if(args.length < 1) {\n//            showUsage();\n//            System.exit(1);\n//        }\n//    }\n    \n    \n//    protected static void showUsage() {\n//        \n//        StringBuffer usage = new StringBuffer(\"usage : java -jar FSPathExplorer [options] <-f|-find> <FSPath_query>\");\n//        usage.append(\"\\n\\n\\t Options : \")\n//               .append(\"\\n\\t\\t -path <root_path> : the relative or absolute path of the directory to start from.\")\n//               .append(\"\\n\\t\\t -p <root_path> :  see -path.\")\n//               .append(\"\\n\\n\\t Example FSPath queries :\")\n//               .append(\"\\n\\t\\t //dir[@name = 'var']/dir[@name = 'www']/dir[@name = 'htdocs']/file[contains(name, '.html')]\");\n//        \n//    }\n    \n    public static void showWelcome() {\n        \n        StringBuffer welcome = \n            new StringBuffer(\"\\n+-------------------------------------------------------+\");\n              welcome.append(\"\\n|                                                       |\")\n                     .append(\"\\n| FSPathExplorer                                        |\")\n                     .append(\"\\n|                                                       |\")\n                     .append(\"\\n+-------------------------------------------------------+\\n\")\n                     .append(\"\\nType 'help' for commands...\\n\")\n                     .append(\"\\nScanning filesystem metadata...\\n\")\n                     .append(\"\\n+-------------------------------------------------------+\")\n                     .append(\"\\n| PLEASE NOTE running FSPathExplorer from the top level |\")\n                     .append(\"\\n| of your filesystem is not advised                     |\")\n                     .append(\"\\n+-------------------------------------------------------+\");\n        \n        System.out.println(welcome);\n    }\n    \n    public static void showHelp() {\n        \n        StringBuffer help = new StringBuffer(\"FSPathExplorer help :\");\n        help.append(\"\\n\\nEnter an FSPath query to search the filesystem\")\n            .append(\"\\n\\nExamples :\")\n            .append(\"\\n\\n1) //dir[@name = 'foo'] \\n   finds any directory under the current directory named 'foo'\")\n            .append(\"\\n\\n2) //dir[@name = 'src']//file[@length > 10000] \\n   finds any file which is nested anywhere below a 'src' directory\")\n            .append(\"\\n   with a file size greater than 10000 bytes\")\n            .append(\"\\n\\n3) //dir[fs:matches(@name, '^[.].*')] \\n   finds all directories in the directory sructure which begin with a '.'\");\n            \n        help.append(\"\\n\\nAttributes : (see javadoc for java.io.File for more info)\")\n            .append(\"\\n\");\n        \n        for (FSPathAttributes a : FSPathAttributes.values()) {\n            if (!(a.name().equals(\"dir\") || a.name().equals(\"file\"))) {\n                help.append(\"\\n\").append(\"@\").append(a);\n            }\n        }\n        \n        help.append(\"\\n\\nCommands :\\n\");\n        \n        for (Commands c : Commands.values()) {\n            help.append(\"\\n\").append(c.getCommandText()).append(\"\\t: \").append(c.getDescription());\n        }\n        \n        System.out.println(help.append(\"\\n\"));\n    }\n    \n    /**\n     *  Assumes args is not null or 0 length.\n     */\n    public void configureExplorer(String[] args) {\n              \n        Map<Opt, Integer> arguments = new HashMap<Opt, Integer>();\n        \n        for (int i = 0; i < args.length; i++) {\n\n            if (args[i].equals(\"-\" + Opt.p.toString()) || args[i].equals(\"-\" + Opt.path.toString())) {\n                arguments.put(Opt.path, i);\n            }\n            \n            if (args[i].equals(\"-\" + Opt.f.toString()) || args[i].equals(\"-\" + Opt.find.toString())){              \n                arguments.put(Opt.find, i);\n            }\n        }\n        \n        Integer pathIndex = arguments.get(Opt.path);\n        \n        if (pathIndex != null) {\n            this.rootPath = new File(args[pathIndex.intValue() + 1]);\n        }  \n        \n        Integer queryIndex = arguments.get(Opt.find);\n        \n        if (queryIndex != null) {\n            for(int i = (queryIndex + 1); i < args.length; i++) {\n                this.fsPathQuery += args[i];\n            }\n        } \n        \n    }\n    \n    public void createFSPath() {\n        if (this.rootPath != null) {\n            this.fsPath = FSPathFactory.newFSPath(this.rootPath);\n        } else {\n            this.fsPath = FSPathFactory.newFSPath();\n        }\n\n    }\n    \n    public void start() {\n        \n        boolean running = true;\n        \n        while (running) {  \n\n            try {\n                String currentExpression = this.prompt.readLine();\n                \n                String[] expressionWords = currentExpression.split(\" \");\n                \n                if (expressionWords[0] != null && Commands.isCommand(expressionWords[0])) {\n\n                    if (expressionWords[0].equals(Commands.EXIT.getCommandText())) {\n                        this.prompt.close();\n                        out.println(\"exiting.....\");\n                        break;\n                    }\n                    \n                    if (expressionWords[0].equals(Commands.PWD.getCommandText())) {\n                        out.println(\"Current directory : \" + this.fsPath.getRootDirectory().getAbsolutePath());\n                    }\n                    \n                    if (expressionWords[0].equals(Commands.CD.getCommandText())) {\n                        try {\n                            File newDir = new File(expressionWords[1]);\n                            if (newDir.exists() \n                                && newDir.isDirectory()\n                                && newDir.canRead()) {\n                                \n                                this.fsPath = FSPathFactory.newFSPath(newDir);\n                                \n                                out.println(\"changed to : \" + newDir.getAbsolutePath());\n                            }\n                        } catch (Throwable t) {\n                            out.println(\"unable to change to \" + expressionWords[1] \n                                    + \" please make sure that the directory exitst and a is readable\");\n                        }\n                    }\n                    \n                    if (expressionWords[0].equals(Commands.HELP.getCommandText())) {\n                        showHelp();\n                    }\n                    \n                } else {\n                    //assume its an FSPath query and try to execute it\n                    this.fsPathQuery = currentExpression;\n                    \n                    FSPathResultList results = this.fsPath.query(this.fsPathQuery);\n\n                    for (FSPathResult result : results) {\n                        out.println(result.getFile().getPath());\n                    }\n                }\n          \n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n    \n}\n"
    },
    {
        "project_name": "60_sugar",
        "class": "FSPathResult",
        "fqdn": "net.sf.sugar.fspath",
        "source_code": "/**\n * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)\n *\n * All rights reserved.\n *\n * This file is part of FSPath.\n *\n * FSPath is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FSPath is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * FSPathResult.java\n *\n * Created on 08 April 2008, 16:21\n *\n */\n\npackage net.sf.sugar.fspath;\n\nimport java.io.File;\nimport java.net.URI;\nimport java.util.Date;\n\n/**\n * This class is a simple wrapper for any of the possible result types\n * that may be returned by an FSPath query.\n *\n *\n * Most FSPath queries are likely to return list of java.io.File object\n * which will be wrapped by an instance of this class.\n *\n *\n * @author kbishop\n * @version $Id$\n */\npublic class FSPathResult {\n\n    private File resultFile;\n\n    private String resultString;\n\n    private Double resultDouble;\n\n    private Date resultDate;\n\n    private URI resultURI;\n\n    private Boolean resultBoolean;\n\n    /** Creates a new instance of FSPathResult */\n    public FSPathResult(File file) {\n        this.resultFile = file;\n    }\n\n    public FSPathResult(String string) {\n        this.resultString = string;\n    }\n\n    public FSPathResult(Double resultLong) {\n        this.resultDouble = resultLong;\n    }\n\n    public FSPathResult(Date date) {\n        this.resultDate = date;\n    }\n\n    public FSPathResult(URI uri) {\n        this.resultURI = uri;\n    }\n\n    public FSPathResult(Boolean resultBoolean) {\n        this.resultBoolean = resultBoolean;\n    }\n\n    public File getFile() {\n        return this.resultFile;\n    }\n\n    public String getString() {\n        return this.resultString;\n    }\n\n    public Double getDouble() {\n        return this.resultDouble;\n    }\n\n    public Date getDate() {\n        return this.resultDate;\n    }\n\n    public URI getURI() {\n        return this.resultURI;\n    }\n\n    public Boolean getBoolean() {\n        return this.resultBoolean;\n    }\n\n\t/**\n\t *  Returns a String representation of the underlying object which\n\t *  this class wraps.\n\t *\n\t *\tThe following rules apply : <br/>\n\t *  <br/>\n\t *  if the underlying object is a java.io.File, then getAbsolutePath() method is called on it.<br/>\n\t *  if the underlying object is any of Boolean, Date, Double, String or URI then toString() is called in<br/>\n\t *\n\t *  @returns String\n\t */\n    public String toString() {\n\n\t\tif (this.resultFile != null) {\n\t\t\treturn this.resultFile.getAbsolutePath();\n\t\t}\n\n\t\tif (this.resultString != null) {\n\t\t\treturn this.resultString;\n\t\t}\n\n\t\tif (this.resultDouble != null) {\n\t\t\treturn this.resultDouble.toString();\n\t\t}\n\n\t\tif (this.resultBoolean != null) {\n\t\t\treturn this.resultBoolean.toString();\n\t\t}\n\n\t\tif (this.resultDate != null) {\n\t\t\treturn this.resultDate.toString();\n\t\t}\n\n\t\tif (this.resultURI != null) {\n\t\t\treturn this.resultURI.toString();\n\t\t}\n\n\t\treturn \"FSPathResult : empty\";\n\t}\n}\n"
    },
    {
        "project_name": "51_jiprof",
        "class": "LocalVariablesSorter",
        "fqdn": "org.objectweb.asm.jip.commons",
        "source_code": "package org.objectweb.asm.jip.commons;\n\nimport org.objectweb.asm.jip.*;\n\npublic class LocalVariablesSorter extends MethodAdapter\n{\n    private static final Type OBJECT_TYPE;\n    private int[] mapping;\n    private Object[] newLocals;\n    protected final int firstLocal;\n    protected int nextLocal;\n    private boolean changed;\n    \n    public LocalVariablesSorter(final int access, final String desc, final MethodVisitor mv) {\n        super(mv);\n        this.mapping = new int[40];\n        this.newLocals = new Object[20];\n        final Type[] args = Type.getArgumentTypes(desc);\n        this.nextLocal = (((0x8 & access) == 0x0) ? 1 : 0);\n        for (int i = 0; i < args.length; ++i) {\n            this.nextLocal += args[i].getSize();\n        }\n        this.firstLocal = this.nextLocal;\n    }\n    \n    @Override\n    public void visitVarInsn(final int opcode, final int var) {\n        Type type = null;\n        switch (opcode) {\n            case 22:\n            case 55: {\n                type = Type.LONG_TYPE;\n                break;\n            }\n            case 24:\n            case 57: {\n                type = Type.DOUBLE_TYPE;\n                break;\n            }\n            case 23:\n            case 56: {\n                type = Type.FLOAT_TYPE;\n                break;\n            }\n            case 21:\n            case 54: {\n                type = Type.INT_TYPE;\n                break;\n            }\n            default: {\n                type = LocalVariablesSorter.OBJECT_TYPE;\n                break;\n            }\n        }\n        this.mv.visitVarInsn(opcode, this.remap(var, type));\n    }\n    \n    @Override\n    public void visitIincInsn(final int var, final int increment) {\n        this.mv.visitIincInsn(this.remap(var, Type.INT_TYPE), increment);\n    }\n    \n    @Override\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        this.mv.visitMaxs(maxStack, this.nextLocal);\n    }\n    \n    @Override\n    public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) {\n        final int newIndex = this.remap(index, Type.getType(desc));\n        this.mv.visitLocalVariable(name, desc, signature, start, end, newIndex);\n    }\n    \n    @Override\n    public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) {\n        if (type != -1) {\n            throw new IllegalStateException(\"ClassReader.accept() should be called with EXPAND_FRAMES flag\");\n        }\n        if (!this.changed) {\n            this.mv.visitFrame(type, nLocal, local, nStack, stack);\n            return;\n        }\n        final Object[] oldLocals = new Object[this.newLocals.length];\n        System.arraycopy(this.newLocals, 0, oldLocals, 0, oldLocals.length);\n        int index = 0;\n        for (final Object t : local) {\n            final int size = (t == Opcodes.LONG || t == Opcodes.DOUBLE) ? 2 : 1;\n            if (t != Opcodes.TOP) {\n                Type typ;\n                if (t == Opcodes.INTEGER) {\n                    typ = Type.INT_TYPE;\n                }\n                else if (t == Opcodes.FLOAT) {\n                    typ = Type.FLOAT_TYPE;\n                }\n                else if (t == Opcodes.LONG) {\n                    typ = Type.LONG_TYPE;\n                }\n                else if (t == Opcodes.DOUBLE) {\n                    typ = Type.DOUBLE_TYPE;\n                }\n                else {\n                    typ = Type.getObjectType((String)t);\n                }\n                this.setFrameLocal(this.remap(index, typ), t);\n            }\n            index += size;\n        }\n        index = 0;\n        int number = 0;\n        int i = 0;\n        while (index < this.newLocals.length) {\n            final Object t2 = this.newLocals[index++];\n            if (t2 != null && t2 != Opcodes.TOP) {\n                this.newLocals[i] = t2;\n                number = i + 1;\n                if (t2 == Opcodes.LONG || t2 == Opcodes.DOUBLE) {\n                    ++index;\n                }\n            }\n            else {\n                this.newLocals[i] = Opcodes.TOP;\n            }\n            ++i;\n        }\n        this.mv.visitFrame(type, number, this.newLocals, nStack, stack);\n        this.newLocals = oldLocals;\n    }\n    \n    public int newLocal(final Type type) {\n        Object t = null;\n        switch (type.getSort()) {\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5: {\n                t = Opcodes.INTEGER;\n                break;\n            }\n            case 6: {\n                t = Opcodes.FLOAT;\n                break;\n            }\n            case 7: {\n                t = Opcodes.LONG;\n                break;\n            }\n            case 8: {\n                t = Opcodes.DOUBLE;\n                break;\n            }\n            case 9: {\n                t = type.getDescriptor();\n                break;\n            }\n            default: {\n                t = type.getInternalName();\n                break;\n            }\n        }\n        final int local = this.nextLocal;\n        this.nextLocal += type.getSize();\n        this.setLocalType(local, type);\n        this.setFrameLocal(local, t);\n        return local;\n    }\n    \n    protected void setLocalType(final int local, final Type type) {\n    }\n    \n    private void setFrameLocal(final int local, final Object type) {\n        final int l = this.newLocals.length;\n        if (local >= l) {\n            final Object[] a = new Object[Math.max(2 * l, local + 1)];\n            System.arraycopy(this.newLocals, 0, a, 0, l);\n            this.newLocals = a;\n        }\n        this.newLocals[local] = type;\n    }\n    \n    private int remap(final int var, final Type type) {\n        if (var < this.firstLocal) {\n            return var;\n        }\n        final int key = 2 * var + type.getSize() - 1;\n        final int size = this.mapping.length;\n        if (key >= size) {\n            final int[] newMapping = new int[Math.max(2 * size, key + 1)];\n            System.arraycopy(this.mapping, 0, newMapping, 0, size);\n            this.mapping = newMapping;\n        }\n        int value = this.mapping[key];\n        if (value == 0) {\n            value = this.newLocalMapping(type);\n            this.setLocalType(value, type);\n            this.mapping[key] = value + 1;\n        }\n        else {\n            --value;\n        }\n        if (value != var) {\n            this.changed = true;\n        }\n        return value;\n    }\n    \n    protected int newLocalMapping(final Type type) {\n        final int local = this.nextLocal;\n        this.nextLocal += type.getSize();\n        return local;\n    }\n    \n    static {\n        OBJECT_TYPE = Type.getObjectType(\"java/lang/Object\");\n    }\n}\n"
    },
    {
        "project_name": "51_jiprof",
        "class": "Profile",
        "fqdn": "com.mentorgen.tools.profile.runtime",
        "source_code": "package com.mentorgen.tools.profile.runtime;\n\nimport com.mentorgen.tools.profile.*;\nimport java.util.*;\nimport com.mentorgen.tools.profile.output.*;\nimport java.io.*;\n\npublic final class Profile implements Runnable\n{\n    private static boolean _debugStart;\n    private static boolean _debugException;\n    private static ThreadDictionary _threadDictionary;\n    private static List<Frame> _frameList;\n    private static Map<Long, Frame> _threadActiveFrame;\n    private static Map<String, Method> _methodDictionary;\n    private static Object _lock;\n    private static Map<String, ClassAllocation> _allocList;\n    private static Controller _controller;\n    private static Thread _controllerThread;\n    \n    public static void initProfiler() {\n        System.err.println(\"Java Interactive Profiler: starting\");\n        init();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Profile()));\n        Profile._controller = new Controller();\n        if (Controller._remote) {\n            (Profile._controllerThread = new Thread(Profile._controller)).start();\n        }\n    }\n    \n    public static void init() {\n        Profile._threadActiveFrame = new HashMap<Long, Frame>(1001);\n        Profile._threadDictionary = new ThreadDictionary();\n        Profile._methodDictionary = new HashMap<String, Method>(2003);\n        Profile._frameList = new ArrayList<Frame>(1001);\n        Profile._lock = new Object();\n        Profile._allocList = new HashMap<String, ClassAllocation>();\n    }\n    \n    public static void clear() {\n        init();\n    }\n    \n    public static void start() {\n        Profile._controller.start();\n    }\n    \n    public static void stop() {\n        Profile._controller.stop();\n    }\n    \n    public static void setFileName(final String fileName) {\n        Profile._controller.setFileName(fileName);\n    }\n    \n    public static void shutdown() {\n        synchronized (Profile._lock) {\n            Controller._profile = false;\n            for (final Long threadId : ((HashMap<Long, V>)Profile._threadDictionary).keySet()) {\n                final Frame f = Profile._threadDictionary.getMostRecentFrame(threadId);\n                f.close();\n            }\n            for (final Frame frame : frameList()) {\n                frame.computeNetTime();\n            }\n        }\n    }\n    \n    public static Iterable<Long> threads() {\n        return Profile._threadDictionary.threads();\n    }\n    \n    public static Iterable<Frame> interactions(final long threadId) {\n        return Profile._threadDictionary.interactions(threadId);\n    }\n    \n    public static Iterable<Frame> frameList() {\n        return Profile._frameList;\n    }\n    \n    public static Iterable<ClassAllocation> allocations() {\n        return Profile._allocList.values();\n    }\n    \n    public static long getThreadTotalTime(final long threadId) {\n        return Profile._threadDictionary.getThreadTotalTime(threadId);\n    }\n    \n    public static void sortFrameList(final Comparator<Frame> comp) {\n        synchronized (Profile._lock) {\n            Collections.sort(Profile._frameList, comp);\n        }\n    }\n    \n    public static void start(final String className, final String methodName) {\n        final long start = System.nanoTime();\n        final long threadId = Thread.currentThread().getId();\n        synchronized (Profile._lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            final Method method = new Method(className, methodName);\n            if (Profile._methodDictionary.get(method.toString()) == null) {\n                Profile._methodDictionary.put(method.toString(), method);\n            }\n            final Frame parent = Profile._threadActiveFrame.get(threadId);\n            Frame target = null;\n            if (parent != null) {\n                target = parent.getChild(method);\n                if (target == null) {\n                    target = new Frame(parent, method, threadId);\n                    Profile._frameList.add(target);\n                }\n            }\n            else {\n                target = new Frame(null, method, threadId);\n                Profile._frameList.add(target);\n                Profile._threadDictionary.add(threadId, target);\n            }\n            if (Profile._debugStart) {\n                System.out.print(\"  (\");\n                System.out.print(className);\n                System.out.print(\" : \");\n                System.out.print(methodName);\n                System.out.println(')');\n                final Frame root = Profile._threadDictionary.getMostRecentFrame(threadId);\n                System.out.println(root);\n            }\n            Profile._threadActiveFrame.put(threadId, target);\n            target.overhead(System.nanoTime() - start);\n            target.setBeginTime(start);\n        }\n    }\n    \n    public static void end(final String className, final String method) {\n        final long start = System.nanoTime();\n        synchronized (Profile._lock) {\n            final long threadId = Thread.currentThread().getId();\n            final Frame target = findFrame(threadId, className, method);\n            if (target == null) {\n                return;\n            }\n            if (target.getParent() != null) {\n                Profile._threadActiveFrame.put(threadId, target.getParent());\n            }\n            else {\n                Profile._threadActiveFrame.put(threadId, null);\n            }\n            target.overhead(System.nanoTime() - start);\n            target.setEndTime(System.nanoTime());\n        }\n    }\n    \n    public static void beginWait(final String className, final String methodName) {\n        final long start = System.nanoTime();\n        synchronized (Profile._lock) {\n            final Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.beginWait(System.nanoTime());\n        }\n    }\n    \n    public static void endWait(final String className, final String methodName) {\n        final long start = System.nanoTime();\n        synchronized (Profile._lock) {\n            final Frame target = findFrame(Thread.currentThread().getId(), className, methodName);\n            if (target == null) {\n                return;\n            }\n            target.overhead(System.nanoTime() - start);\n            target.endWait(System.nanoTime());\n        }\n    }\n    \n    public static void unwind(final String className, final String methodName, final String exception) {\n        if (Profile._debugException || Controller._debug) {\n            System.out.println(\"Catch: \" + exception);\n        }\n        synchronized (Profile._lock) {\n            final long threadId = Thread.currentThread().getId();\n            final Frame target = findFrame(threadId, className, methodName);\n            if (target == null) {\n                return;\n            }\n            Profile._threadActiveFrame.put(threadId, target);\n        }\n    }\n    \n    private static final Frame findFrame(final long threadId, final String className, final String methodName) {\n        if (!Controller._profile) {\n            return null;\n        }\n        Frame target = Profile._threadActiveFrame.get(threadId);\n        if (target == null) {\n            return null;\n        }\n        boolean detectedException = false;\n        while (!target.getClassName().equals(className) || !target.getMethodName().equals(methodName)) {\n            if (!detectedException) {\n                detectedException = true;\n                if (Profile._debugException || Controller._debug) {\n                    System.err.print(\"Detected an exception at \");\n                    System.err.print(className);\n                    System.err.print('.');\n                    System.err.println(methodName);\n                }\n            }\n            else if (Profile._debugException) {\n                System.err.print(\"Unwinding \");\n                System.err.print(target.getClassName());\n                System.err.print('.');\n                System.err.println(target.getMethodName());\n            }\n            target.setEndTime(System.nanoTime());\n            target = target.getParent();\n            if (target == null) {\n                if (Profile._debugException) {\n                    System.err.println(\"Stack completely unwound.\");\n                }\n                return null;\n            }\n        }\n        return target;\n    }\n    \n    public static void alloc(final String className) {\n        synchronized (Profile._lock) {\n            if (!Controller._profile) {\n                return;\n            }\n            final long threadId = Thread.currentThread().getId();\n            final Frame target = Profile._threadActiveFrame.get(threadId);\n            if (target != null && target.getClassName().equals(className) && target.getMethodName().equals(\"<init>\")) {\n                return;\n            }\n            ClassAllocation ca = Profile._allocList.get(className);\n            if (ca == null) {\n                ca = new ClassAllocation(className);\n                Profile._allocList.put(className, ca);\n            }\n            ca.incAllocCount();\n        }\n    }\n    \n    @Override\n    public void run() {\n        try {\n            if (Profile._threadDictionary.size() > 0) {\n                shutdown();\n                ProfileDump.dump();\n            }\n            Profile._controller.close();\n            if (Profile._controllerThread != null) {\n                Profile._controllerThread.interrupt();\n            }\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    static {\n        Profile._debugStart = false;\n        Profile._debugException = false;\n    }\n}\n"
    },
    {
        "project_name": "jsci",
        "class": "SimpleCharStream",
        "fqdn": "JSci.maths.symbolic",
        "source_code": "package JSci.maths.symbolic;\n\nimport java.io.*;\n\nclass SimpleCharStream\n{\n    public static final boolean staticFlag = true;\n    static int bufsize;\n    static int available;\n    static int tokenBegin;\n    public static int bufpos;\n    protected static int[] bufline;\n    protected static int[] bufcolumn;\n    protected static int column;\n    protected static int line;\n    protected static boolean prevCharIsCR;\n    protected static boolean prevCharIsLF;\n    protected static Reader inputStream;\n    protected static char[] buffer;\n    protected static int maxNextCharInd;\n    protected static int inBuf;\n    \n    protected static void ExpandBuff(final boolean wrapAround) {\n        final char[] newbuffer = new char[SimpleCharStream.bufsize + 2048];\n        final int[] newbufline = new int[SimpleCharStream.bufsize + 2048];\n        final int[] newbufcolumn = new int[SimpleCharStream.bufsize + 2048];\n        try {\n            if (wrapAround) {\n                System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, newbuffer, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                System.arraycopy(SimpleCharStream.buffer, 0, newbuffer, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin, SimpleCharStream.bufpos);\n                SimpleCharStream.buffer = newbuffer;\n                System.arraycopy(SimpleCharStream.bufline, SimpleCharStream.tokenBegin, newbufline, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                System.arraycopy(SimpleCharStream.bufline, 0, newbufline, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin, SimpleCharStream.bufpos);\n                SimpleCharStream.bufline = newbufline;\n                System.arraycopy(SimpleCharStream.bufcolumn, SimpleCharStream.tokenBegin, newbufcolumn, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                System.arraycopy(SimpleCharStream.bufcolumn, 0, newbufcolumn, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin, SimpleCharStream.bufpos);\n                SimpleCharStream.bufcolumn = newbufcolumn;\n                SimpleCharStream.maxNextCharInd = (SimpleCharStream.bufpos += SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n            }\n            else {\n                System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, newbuffer, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                SimpleCharStream.buffer = newbuffer;\n                System.arraycopy(SimpleCharStream.bufline, SimpleCharStream.tokenBegin, newbufline, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                SimpleCharStream.bufline = newbufline;\n                System.arraycopy(SimpleCharStream.bufcolumn, SimpleCharStream.tokenBegin, newbufcolumn, 0, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin);\n                SimpleCharStream.bufcolumn = newbufcolumn;\n                SimpleCharStream.maxNextCharInd = (SimpleCharStream.bufpos -= SimpleCharStream.tokenBegin);\n            }\n        }\n        catch (Throwable t) {\n            throw new Error(t.getMessage());\n        }\n        SimpleCharStream.bufsize += 2048;\n        SimpleCharStream.available = SimpleCharStream.bufsize;\n        SimpleCharStream.tokenBegin = 0;\n    }\n    \n    protected static void FillBuff() throws IOException {\n        if (SimpleCharStream.maxNextCharInd == SimpleCharStream.available) {\n            if (SimpleCharStream.available == SimpleCharStream.bufsize) {\n                if (SimpleCharStream.tokenBegin > 2048) {\n                    SimpleCharStream.bufpos = (SimpleCharStream.maxNextCharInd = 0);\n                    SimpleCharStream.available = SimpleCharStream.tokenBegin;\n                }\n                else if (SimpleCharStream.tokenBegin < 0) {\n                    SimpleCharStream.bufpos = (SimpleCharStream.maxNextCharInd = 0);\n                }\n                else {\n                    ExpandBuff(false);\n                }\n            }\n            else if (SimpleCharStream.available > SimpleCharStream.tokenBegin) {\n                SimpleCharStream.available = SimpleCharStream.bufsize;\n            }\n            else if (SimpleCharStream.tokenBegin - SimpleCharStream.available < 2048) {\n                ExpandBuff(true);\n            }\n            else {\n                SimpleCharStream.available = SimpleCharStream.tokenBegin;\n            }\n        }\n        try {\n            final int i;\n            if ((i = SimpleCharStream.inputStream.read(SimpleCharStream.buffer, SimpleCharStream.maxNextCharInd, SimpleCharStream.available - SimpleCharStream.maxNextCharInd)) == -1) {\n                SimpleCharStream.inputStream.close();\n                throw new IOException();\n            }\n            SimpleCharStream.maxNextCharInd += i;\n        }\n        catch (IOException e) {\n            --SimpleCharStream.bufpos;\n            backup(0);\n            if (SimpleCharStream.tokenBegin == -1) {\n                SimpleCharStream.tokenBegin = SimpleCharStream.bufpos;\n            }\n            throw e;\n        }\n    }\n    \n    public static char BeginToken() throws IOException {\n        SimpleCharStream.tokenBegin = -1;\n        final char c = readChar();\n        SimpleCharStream.tokenBegin = SimpleCharStream.bufpos;\n        return c;\n    }\n    \n    protected static void UpdateLineColumn(final char c) {\n        ++SimpleCharStream.column;\n        if (SimpleCharStream.prevCharIsLF) {\n            SimpleCharStream.prevCharIsLF = false;\n            SimpleCharStream.line += (SimpleCharStream.column = 1);\n        }\n        else if (SimpleCharStream.prevCharIsCR) {\n            SimpleCharStream.prevCharIsCR = false;\n            if (c == '\\n') {\n                SimpleCharStream.prevCharIsLF = true;\n            }\n            else {\n                SimpleCharStream.line += (SimpleCharStream.column = 1);\n            }\n        }\n        switch (c) {\n            case '\\r': {\n                SimpleCharStream.prevCharIsCR = true;\n                break;\n            }\n            case '\\n': {\n                SimpleCharStream.prevCharIsLF = true;\n                break;\n            }\n            case '\\t': {\n                --SimpleCharStream.column;\n                SimpleCharStream.column += 8 - (SimpleCharStream.column & 0x7);\n                break;\n            }\n        }\n        SimpleCharStream.bufline[SimpleCharStream.bufpos] = SimpleCharStream.line;\n        SimpleCharStream.bufcolumn[SimpleCharStream.bufpos] = SimpleCharStream.column;\n    }\n    \n    public static char readChar() throws IOException {\n        if (SimpleCharStream.inBuf > 0) {\n            --SimpleCharStream.inBuf;\n            if (++SimpleCharStream.bufpos == SimpleCharStream.bufsize) {\n                SimpleCharStream.bufpos = 0;\n            }\n            return SimpleCharStream.buffer[SimpleCharStream.bufpos];\n        }\n        if (++SimpleCharStream.bufpos >= SimpleCharStream.maxNextCharInd) {\n            FillBuff();\n        }\n        final char c = SimpleCharStream.buffer[SimpleCharStream.bufpos];\n        UpdateLineColumn(c);\n        return c;\n    }\n    \n    public static int getColumn() {\n        return SimpleCharStream.bufcolumn[SimpleCharStream.bufpos];\n    }\n    \n    public static int getLine() {\n        return SimpleCharStream.bufline[SimpleCharStream.bufpos];\n    }\n    \n    public static int getEndColumn() {\n        return SimpleCharStream.bufcolumn[SimpleCharStream.bufpos];\n    }\n    \n    public static int getEndLine() {\n        return SimpleCharStream.bufline[SimpleCharStream.bufpos];\n    }\n    \n    public static int getBeginColumn() {\n        return SimpleCharStream.bufcolumn[SimpleCharStream.tokenBegin];\n    }\n    \n    public static int getBeginLine() {\n        return SimpleCharStream.bufline[SimpleCharStream.tokenBegin];\n    }\n    \n    public static void backup(final int amount) {\n        SimpleCharStream.inBuf += amount;\n        if ((SimpleCharStream.bufpos -= amount) < 0) {\n            SimpleCharStream.bufpos += SimpleCharStream.bufsize;\n        }\n    }\n    \n    public SimpleCharStream(final Reader dstream, final int startline, final int startcolumn, final int buffersize) {\n        if (SimpleCharStream.inputStream != null) {\n            throw new Error(\"\\n   ERROR: Second call to the constructor of a static SimpleCharStream.  You must\\n       either use ReInit() or set the JavaCC option STATIC to false\\n       during the generation of this class.\");\n        }\n        SimpleCharStream.inputStream = dstream;\n        SimpleCharStream.line = startline;\n        SimpleCharStream.column = startcolumn - 1;\n        SimpleCharStream.bufsize = buffersize;\n        SimpleCharStream.available = buffersize;\n        SimpleCharStream.buffer = new char[buffersize];\n        SimpleCharStream.bufline = new int[buffersize];\n        SimpleCharStream.bufcolumn = new int[buffersize];\n    }\n    \n    public SimpleCharStream(final Reader dstream, final int startline, final int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n    \n    public SimpleCharStream(final Reader dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n    \n    public void ReInit(final Reader dstream, final int startline, final int startcolumn, final int buffersize) {\n        SimpleCharStream.inputStream = dstream;\n        SimpleCharStream.line = startline;\n        SimpleCharStream.column = startcolumn - 1;\n        if (SimpleCharStream.buffer == null || buffersize != SimpleCharStream.buffer.length) {\n            SimpleCharStream.bufsize = buffersize;\n            SimpleCharStream.available = buffersize;\n            SimpleCharStream.buffer = new char[buffersize];\n            SimpleCharStream.bufline = new int[buffersize];\n            SimpleCharStream.bufcolumn = new int[buffersize];\n        }\n        SimpleCharStream.prevCharIsLF = (SimpleCharStream.prevCharIsCR = false);\n        SimpleCharStream.tokenBegin = (SimpleCharStream.inBuf = (SimpleCharStream.maxNextCharInd = 0));\n        SimpleCharStream.bufpos = -1;\n    }\n    \n    public void ReInit(final Reader dstream, final int startline, final int startcolumn) {\n        this.ReInit(dstream, startline, startcolumn, 4096);\n    }\n    \n    public void ReInit(final Reader dstream) {\n        this.ReInit(dstream, 1, 1, 4096);\n    }\n    \n    public SimpleCharStream(final InputStream dstream, final int startline, final int startcolumn, final int buffersize) {\n        this(new InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n    \n    public SimpleCharStream(final InputStream dstream, final int startline, final int startcolumn) {\n        this(dstream, startline, startcolumn, 4096);\n    }\n    \n    public SimpleCharStream(final InputStream dstream) {\n        this(dstream, 1, 1, 4096);\n    }\n    \n    public void ReInit(final InputStream dstream, final int startline, final int startcolumn, final int buffersize) {\n        this.ReInit(new InputStreamReader(dstream), startline, startcolumn, 4096);\n    }\n    \n    public void ReInit(final InputStream dstream) {\n        this.ReInit(dstream, 1, 1, 4096);\n    }\n    \n    public void ReInit(final InputStream dstream, final int startline, final int startcolumn) {\n        this.ReInit(dstream, startline, startcolumn, 4096);\n    }\n    \n    public static String GetImage() {\n        if (SimpleCharStream.bufpos >= SimpleCharStream.tokenBegin) {\n            return new String(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, SimpleCharStream.bufpos - SimpleCharStream.tokenBegin + 1);\n        }\n        return new String(SimpleCharStream.buffer, SimpleCharStream.tokenBegin, SimpleCharStream.bufsize - SimpleCharStream.tokenBegin) + new String(SimpleCharStream.buffer, 0, SimpleCharStream.bufpos + 1);\n    }\n    \n    public static char[] GetSuffix(final int len) {\n        final char[] ret = new char[len];\n        if (SimpleCharStream.bufpos + 1 >= len) {\n            System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.bufpos - len + 1, ret, 0, len);\n        }\n        else {\n            System.arraycopy(SimpleCharStream.buffer, SimpleCharStream.bufsize - (len - SimpleCharStream.bufpos - 1), ret, 0, len - SimpleCharStream.bufpos - 1);\n            System.arraycopy(SimpleCharStream.buffer, 0, ret, len - SimpleCharStream.bufpos - 1, SimpleCharStream.bufpos + 1);\n        }\n        return ret;\n    }\n    \n    public static void Done() {\n        SimpleCharStream.buffer = null;\n        SimpleCharStream.bufline = null;\n        SimpleCharStream.bufcolumn = null;\n    }\n    \n    public static void adjustBeginLineColumn(int newLine, final int newCol) {\n        int start = SimpleCharStream.tokenBegin;\n        int len;\n        if (SimpleCharStream.bufpos >= SimpleCharStream.tokenBegin) {\n            len = SimpleCharStream.bufpos - SimpleCharStream.tokenBegin + SimpleCharStream.inBuf + 1;\n        }\n        else {\n            len = SimpleCharStream.bufsize - SimpleCharStream.tokenBegin + SimpleCharStream.bufpos + 1 + SimpleCharStream.inBuf;\n        }\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        int nextColDiff = 0;\n        int columnDiff = 0;\n        while (i < len && SimpleCharStream.bufline[j = start % SimpleCharStream.bufsize] == SimpleCharStream.bufline[k = ++start % SimpleCharStream.bufsize]) {\n            SimpleCharStream.bufline[j] = newLine;\n            nextColDiff = columnDiff + SimpleCharStream.bufcolumn[k] - SimpleCharStream.bufcolumn[j];\n            SimpleCharStream.bufcolumn[j] = newCol + columnDiff;\n            columnDiff = nextColDiff;\n            ++i;\n        }\n        if (i < len) {\n            SimpleCharStream.bufline[j] = newLine++;\n            SimpleCharStream.bufcolumn[j] = newCol + columnDiff;\n            while (i++ < len) {\n                if (SimpleCharStream.bufline[j = start % SimpleCharStream.bufsize] != SimpleCharStream.bufline[++start % SimpleCharStream.bufsize]) {\n                    SimpleCharStream.bufline[j] = newLine++;\n                }\n                else {\n                    SimpleCharStream.bufline[j] = newLine;\n                }\n            }\n        }\n        SimpleCharStream.line = SimpleCharStream.bufline[j];\n        SimpleCharStream.column = SimpleCharStream.bufcolumn[j];\n    }\n    \n    static {\n        SimpleCharStream.bufpos = -1;\n        SimpleCharStream.column = 0;\n        SimpleCharStream.line = 1;\n        SimpleCharStream.prevCharIsCR = false;\n        SimpleCharStream.prevCharIsLF = false;\n        SimpleCharStream.maxNextCharInd = 0;\n        SimpleCharStream.inBuf = 0;\n    }\n}\n"
    },
    {
        "project_name": "85_shop",
        "class": "JSJshop",
        "fqdn": "umd.cs.shop",
        "source_code": "package umd.cs.shop;\n\nimport javax.swing.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\n\npublic final class JSJshop\n{\n    public static boolean corbaToHicap;\n    public static JApplet applet;\n    private JSPlanningDomain dom;\n    private JSPlanningProblem prob;\n    private JSListPlanningProblem probSet;\n    private JSPlan sol;\n    private JSJshopNode tree;\n    private JSPairPlanTSListNodes solution;\n    \n    public static void main(final String[] args) {\n        if (args.length < 2 || args.length > 4) {\n            JSUtil.println(\"Usage :\");\n            JSUtil.println(\" java JSJshop <domainDef-file-name> <problemDef-file-name> [number-of-plans]\");\n            JSUtil.println(\"[number-of-plans] can be 'one' or 'all'. The default value is 'one'\");\n            return;\n        }\n        final String one = \"one\";\n        final String all = \"all\";\n        try {\n            for (int i = 2; i < args.length; ++i) {\n                if (one.equalsIgnoreCase(args[i])) {\n                    JSJshopVars.allPlans = false;\n                }\n                else if (all.equalsIgnoreCase(args[i])) {\n                    JSJshopVars.allPlans = true;\n                }\n                else {\n                    final int level = JSJshopVars.flagLevel = Integer.valueOf(args[i]);\n                }\n            }\n        }\n        catch (NumberFormatException e) {\n            JSUtil.println(\"Invalid parameter\");\n            return;\n        }\n        new JSJshop(args[0], args[1]);\n    }\n    \n    public JSJshop() {\n        this.probSet = new JSListPlanningProblem();\n        this.tree = null;\n    }\n    \n    public JSJshop(final String nameDomainFile, final String nameProblemFile) {\n        this.probSet = new JSListPlanningProblem();\n        this.tree = null;\n        JSUtil.println(\"Reading file \" + nameDomainFile);\n        if (!this.parserFile(nameDomainFile)) {\n            if (!JSJshopVars.flagExit) {\n                return;\n            }\n            System.exit(0);\n        }\n        JSUtil.println(\"Domain file parsed successfully\");\n        JSUtil.println(\"Reading file \" + nameProblemFile);\n        if (!this.parserFile(nameProblemFile)) {\n            if (!JSJshopVars.flagExit) {\n                return;\n            }\n            System.exit(0);\n        }\n        JSUtil.println(\"Problem file parsed successfully\");\n        for (int k = 0; k < this.probSet.size(); ++k) {\n            this.prob = this.probSet.elementAt(k);\n            JSUtil.println(\"Solving Problem :\" + this.prob.Name());\n            final JSListPairPlanTStateNodes allPlans = this.dom.solveAll(this.prob, JSJshopVars.allPlans);\n            if (allPlans.isEmpty()) {\n                (this.sol = new JSPlan()).assignFailure();\n                this.solution = new JSPairPlanTSListNodes(new JSPairPlanTState(this.sol, new JSTState()), new Vector());\n                JSUtil.println(\"0 plans found\");\n            }\n            else {\n                this.solution = allPlans.elementAt(0);\n                this.sol = this.solution.planS().plan();\n                JSUtil.println(allPlans.size() + \" plans found.\");\n                if (JSJshopVars.flagLevel > 0) {\n                    JSUtil.println(\"********* PLANS *******\");\n                    for (int i = 0; i < allPlans.size(); ++i) {\n                        JSUtil.println(\"Plan # \" + (i + 1));\n                        final JSPairPlanTSListNodes pair = allPlans.elementAt(i);\n                        pair.planS().plan().printPlan();\n                    }\n                }\n            }\n        }\n    }\n    \n    public JSJshop(final String nameFile, final JSTaskAtom pred) {\n        this.probSet = new JSListPlanningProblem();\n        this.tree = null;\n        this.setFile(nameFile, pred);\n    }\n    \n    public JSJshopNode getTree() {\n        return this.tree;\n    }\n    \n    public JSPairPlanTSListNodes getSolution() {\n        return this.solution;\n    }\n    \n    public JSListLogicalAtoms getAddList() {\n        if (this.tree == null) {\n            return null;\n        }\n        return this.solution.planS().tState().addList();\n    }\n    \n    public JSListLogicalAtoms getDeleteList() {\n        if (this.tree == null) {\n            return null;\n        }\n        return this.solution.planS().tState().deleteList();\n    }\n    \n    public JSPairPlanTSListNodes setFile(final String nameFile, final JSTaskAtom pred) {\n        Vector listNodes = new Vector();\n        JSJshopVars.VarCounter = 0;\n        this.parserFile(nameFile);\n        JSUtil.flag(\"File parsed\");\n        this.dom.print();\n        JSUtil.flag(\"<- domain\");\n        this.prob.print();\n        JSUtil.flag(\"<- problem\");\n        JSJshopVars.allPlans = false;\n        final JSListPairPlanTStateNodes listPairs = this.dom.solveAll(this.prob, JSJshopVars.allPlans);\n        if (listPairs.size() == 0) {\n            return null;\n        }\n        final JSPairPlanTSListNodes pair = listPairs.elementAt(0);\n        JSUtil.flag(\"**After planning\");\n        this.sol = pair.planS().plan();\n        if (this.sol.isFailure()) {\n            JSUtil.print(\"*NO* SOLUTION FOUND\");\n            return null;\n        }\n        JSUtil.print(\"SOLUTION FOUND\");\n        pair.planS().tState().print();\n        JSUtil.println(\"***************FINAL SOLUTION*******\");\n        this.sol.print();\n        JSUtil.println(\"********* list-tree FINAL SOLUTION*******\");\n        listNodes = pair.listNodes();\n        for (int i = 0; i < listNodes.size(); ++i) {\n            final JSJshopNode node = listNodes.elementAt(i);\n            node.print2();\n        }\n        final JSJshopNode node = listNodes.elementAt(listNodes.size() - 1);\n        listNodes.removeElement(node);\n        this.tree = new JSJshopNode(node, listNodes);\n        JSUtil.println(\"********* tree FINAL SOLUTION*******\");\n        this.tree.print();\n        return this.solution = pair;\n    }\n    \n    public void testParser() {\n        try {\n            final FileReader fr = new FileReader(\"farp.shp\");\n            final StreamTokenizer tokenizer = new StreamTokenizer(fr);\n            JSUtil.initParseTable(tokenizer);\n            while (tokenizer.nextToken() != -1) {\n                if (tokenizer.ttype == -2) {\n                    System.err.print(new Double(tokenizer.nval).toString() + \" \");\n                }\n                if (tokenizer.ttype == JSJshopVars.leftPar) {\n                    System.err.print(\"( \");\n                }\n                if (tokenizer.ttype == JSJshopVars.rightPar) {\n                    System.err.print(\") \");\n                }\n                if (tokenizer.ttype == JSJshopVars.colon) {\n                    System.err.print(\": \");\n                }\n                if (tokenizer.ttype == JSJshopVars.semicolon) {\n                    System.err.print(\"; \");\n                }\n                if (tokenizer.ttype == JSJshopVars.apostrophe) {\n                    System.err.print(\"' \");\n                }\n                if (tokenizer.ttype == JSJshopVars.exclamation) {\n                    System.err.print(\"! \");\n                }\n                if (tokenizer.ttype == JSJshopVars.interrogation) {\n                    System.err.print(\"? \");\n                }\n                if (tokenizer.ttype == JSJshopVars.minus) {\n                    System.err.print(\"- \");\n                }\n                if (tokenizer.ttype == JSJshopVars.lessT) {\n                    System.err.print(\"< \");\n                }\n                if (tokenizer.ttype == JSJshopVars.equalT) {\n                    System.err.print(\"= \");\n                }\n                if (tokenizer.ttype == JSJshopVars.greaterT) {\n                    System.err.print(\"> \");\n                }\n                if (tokenizer.ttype == JSJshopVars.plus) {\n                    System.err.print(\"+ \");\n                }\n                if (tokenizer.ttype == JSJshopVars.backquote) {\n                    System.err.print(\"` \");\n                }\n                if (tokenizer.ttype == JSJshopVars.slash) {\n                    System.err.print(\"/ \");\n                }\n                if (tokenizer.ttype == JSJshopVars.coma) {\n                    System.err.print(\", \");\n                }\n                if (tokenizer.ttype == JSJshopVars.astherisk) {\n                    System.err.print(\"* \");\n                }\n                if (tokenizer.ttype == JSJshopVars.rightBrac) {\n                    System.err.print(\"] \");\n                }\n                if (tokenizer.ttype == JSJshopVars.leftBrac) {\n                    System.err.print(\"[ \");\n                }\n                if (tokenizer.ttype == JSJshopVars.verticalL) {\n                    System.err.print(\"| \");\n                }\n                if (tokenizer.ttype == -3) {\n                    System.err.print(tokenizer.sval + \" \");\n                }\n            }\n            fr.close();\n        }\n        catch (Exception e) {\n            JSUtil.println(\"Error reading control parameters: \" + e);\n            System.exit(1);\n        }\n    }\n    \n    public boolean parserFile(final String libraryFile) {\n        final String libraryDirectory = \".\";\n        try {\n            final FileReader fr = new FileReader(libraryFile);\n            final StreamTokenizer tokenizer = new StreamTokenizer(fr);\n            tokenizer.lowerCaseMode(true);\n            JSUtil.initParseTable(tokenizer);\n            if (fr == null) {\n                JSUtil.println(\"Can not open file : \" + libraryFile);\n                return false;\n            }\n            while (tokenizer.nextToken() != -1) {\n                this.processToken(tokenizer);\n            }\n            fr.close();\n        }\n        catch (IOException e) {\n            System.out.println(\"Error in readFile() : \" + e);\n            return false;\n        }\n        catch (JSParserError parserError) {\n            System.out.println(\"Error in parsing file\");\n            return false;\n        }\n        return true;\n    }\n    \n    public BufferedReader getBufferedReader(final String dir, final String file) {\n        return this.getBufferedReader(dir, file);\n    }\n    \n    public BufferedReader getBufferedReader(final String dir, final String file, final JApplet applet) {\n        if (file == null) {\n            return null;\n        }\n        BufferedReader br = null;\n        FileInputStream libraryFileInputStream = null;\n        InputStream conn = null;\n        try {\n            if (applet != null) {\n                final URL url = this.getAppletURL(file, applet);\n                if (url == null) {\n                    System.err.println(\"Util.getBufferedReader() error: cannot get URL\");\n                    return null;\n                }\n                conn = url.openStream();\n                if (conn == null) {\n                    System.err.println(\"Util.getBufferedReader() error: cannot open URL\");\n                    return null;\n                }\n            }\n            else {\n                libraryFileInputStream = new FileInputStream(dir + File.separator + file);\n            }\n        }\n        catch (IOException e) {\n            System.err.println(\"Error 1 in Util.getBufferedReader : \" + e);\n            return null;\n        }\n        if (applet != null) {\n            br = new BufferedReader(new InputStreamReader(conn));\n        }\n        else {\n            try {\n                br = new BufferedReader(new InputStreamReader(libraryFileInputStream, System.getProperty(\"file.encoding\")));\n            }\n            catch (UnsupportedEncodingException e2) {\n                System.err.println(\"Error 2 in Util.getBufferedReader : \" + e2);\n                return null;\n            }\n        }\n        return br;\n    }\n    \n    public URL getAppletURL(final String file, final JApplet applet) {\n        try {\n            return new URL(applet.getCodeBase() + file);\n        }\n        catch (MalformedURLException e) {\n            return null;\n        }\n    }\n    \n    public void processToken(final StreamTokenizer tokenizer) {\n        if (tokenizer.ttype != JSJshopVars.leftPar) {\n            System.err.println(\"Line : \" + tokenizer.lineno() + \" Expected '('\");\n            throw new JSParserError();\n        }\n        if (!JSUtil.expectTokenType(-3, tokenizer, \"Expected 'defdomain or defproblem' \")) {\n            throw new JSParserError();\n        }\n        tokenizer.pushBack();\n        final String w = JSUtil.readWord(tokenizer, \"JSJshop>>processToken\");\n        if (w.equals(\"%%%\")) {\n            throw new JSParserError();\n        }\n        if (w.equalsIgnoreCase(\"defdomain\")) {\n            this.dom = new JSPlanningDomain(tokenizer);\n            return;\n        }\n        if (w.equalsIgnoreCase(\"defproblem\")) {\n            this.prob = new JSPlanningProblem(tokenizer);\n            this.probSet.addElement(this.prob);\n            return;\n        }\n        System.err.println(\"Line : \" + tokenizer.lineno() + \" Expecting defdomain or defproblem\");\n        throw new JSParserError();\n    }\n    \n    public JSPlanningDomain dom() {\n        return this.dom;\n    }\n    \n    public JSPlanningProblem prob() {\n        return this.prob;\n    }\n    \n    public JSPlan sol() {\n        return this.sol;\n    }\n    \n    public JSJshopNode tree() {\n        return this.tree;\n    }\n    \n    static {\n        JSJshop.corbaToHicap = false;\n    }\n}\n"
    },
    {
        "project_name": "85_shop",
        "class": "JSPredicateForm",
        "fqdn": "umd.cs.shop",
        "source_code": "package umd.cs.shop;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class JSPredicateForm extends Vector\n{\n    JSPredicateForm() {\n    }\n    \n    public JSPredicateForm(final String text) {\n        if (text != null) {\n            this.JSPredicateFormInit(new StreamTokenizer(new StringReader(text)));\n        }\n    }\n    \n    public JSPredicateForm(final StreamTokenizer tokenizer) {\n        this.JSPredicateFormInit(tokenizer);\n    }\n    \n    void JSPredicateFormInit(final StreamTokenizer tokenizer) {\n        if (tokenizer == null) {\n            throw new JSParserError();\n        }\n        if (!JSUtil.expectTokenType(JSJshopVars.leftPar, tokenizer, \"expected '('\")) {\n            throw new JSParserError();\n        }\n        if (!JSUtil.readToken(tokenizer, \"Reading Predicate\")) {\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype == JSJshopVars.rightPar) {\n            JSUtil.println(\"Unexpected ) while reading Predicate\");\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype == JSJshopVars.exclamation) {\n            if (!JSUtil.expectTokenType(-3, tokenizer, \"Operator name expected\")) {\n                throw new JSParserError();\n            }\n            tokenizer.pushBack();\n            final String w = JSUtil.readWord(tokenizer, \"JSPredicateForm\");\n            if (w.equals(\"%%%\")) {\n                throw new JSParserError();\n            }\n            this.addElement(\"!\" + w);\n        }\n        else if (tokenizer.ttype == -3 && tokenizer.sval.equalsIgnoreCase(\"not\")) {\n            this.addElement(new String(tokenizer.sval));\n            this.addElement(new JSPredicateForm(tokenizer));\n            if (JSUtil.expectTokenType(JSJshopVars.rightPar, tokenizer, \"JSPredicateForm\")) {\n                return;\n            }\n            throw new JSParserError();\n        }\n        else {\n            if (tokenizer.ttype == -3 && tokenizer.sval.equalsIgnoreCase(\"call\")) {\n                this.addElement(new String(tokenizer.sval));\n                tokenizer.ttype = JSJshopVars.leftPar;\n                tokenizer.pushBack();\n                final JSTerm t = new JSTerm(tokenizer);\n                t.makeEval(true);\n                this.addElement(t);\n                return;\n            }\n            if (tokenizer.ttype != -3) {\n                JSUtil.println(\"PlanningDomain: error\");\n                throw new JSParserError();\n            }\n            tokenizer.pushBack();\n            final String w = JSUtil.readWord(tokenizer, \"JSPredicateForm\");\n            if (w.equals(\"%%%\")) {\n                throw new JSParserError();\n            }\n            this.addElement(w);\n        }\n        if (!JSUtil.readToken(tokenizer, \"JSPredicateForm\")) {\n            throw new JSParserError();\n        }\n        while (tokenizer.ttype != JSJshopVars.rightPar) {\n            tokenizer.pushBack();\n            this.addElement(new JSTerm(tokenizer));\n            if (!JSUtil.readToken(tokenizer, \"JSPredicateForm\")) {\n                throw new JSParserError();\n            }\n        }\n    }\n    \n    public void print() {\n        if (this.size() == 0) {\n            JSUtil.println(\"Predicateform.print(): 0 elements\");\n            return;\n        }\n        final String str = this.elementAt(0);\n        JSUtil.print(\"(\");\n        JSUtil.print(str + \" \");\n        if (str.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm el = this.elementAt(1);\n            el.print();\n        }\n        else {\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el2 = this.elementAt(i);\n                el2.print();\n            }\n        }\n        JSUtil.print(\" ) \");\n    }\n    \n    public StringBuffer toStr() {\n        final StringBuffer res = new StringBuffer();\n        if (this.size() == 0) {\n            JSUtil.println(\"Predicateform.print(): 0 elements\");\n            return res;\n        }\n        res.append(\"(\");\n        final String str = this.elementAt(0);\n        res.append(str);\n        if (str.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm el = this.elementAt(1);\n            res.append(el.toStr());\n        }\n        else {\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el2 = this.elementAt(i);\n                res.append(el2.toStr());\n            }\n        }\n        res.append(\")\");\n        return res;\n    }\n    \n    public JSPredicateForm clonePF() {\n        final JSPredicateForm np = new JSPredicateForm();\n        final String str = this.elementAt(0);\n        if (str.equalsIgnoreCase(\"not\")) {\n            np.addElement(this.elementAt(0));\n            final JSPredicateForm el = this.elementAt(1);\n            np.addElement(el.clonePF());\n        }\n        else {\n            np.addElement(this.elementAt(0));\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                np.addElement(ti.cloneT());\n            }\n        }\n        return np;\n    }\n    \n    public JSPredicateForm applySubstitutionPF(final JSSubstitution alpha) {\n        final JSPredicateForm np = new JSPredicateForm();\n        final String str = this.elementAt(0);\n        if (str.equalsIgnoreCase(\"not\")) {\n            np.addElement(this.elementAt(0));\n            final JSPredicateForm el = this.elementAt(1);\n            np.addElement(el.applySubstitutionPF(alpha));\n        }\n        else {\n            np.addElement(this.elementAt(0));\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                np.addElement(ti.applySubstitutionT(alpha));\n            }\n        }\n        return np;\n    }\n    \n    public JSSubstitution matches(final JSPredicateForm t) {\n        return this.matches(t, new JSSubstitution());\n    }\n    \n    public JSSubstitution matches(final JSPredicateForm t, final JSSubstitution alpha) {\n        JSSubstitution beta = new JSSubstitution();\n        if (this.size() != t.size()) {\n            beta.assignFailure();\n            return beta;\n        }\n        final String functor = this.elementAt(0);\n        if (!functor.equalsIgnoreCase(t.elementAt(0))) {\n            beta.assignFailure();\n            return beta;\n        }\n        if (functor.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm e1 = this.elementAt(1);\n            final JSPredicateForm e2 = t.elementAt(1);\n            beta = e1.matches(e2, alpha);\n            return beta;\n        }\n        JSSubstitution gama = new JSSubstitution();\n        final JSSubstitution newAlpha = alpha.cloneS();\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            if (!ti.equals(t.elementAt(i))) {\n                gama = ti.matches(t.elementAt(i), newAlpha);\n                if (gama.fail()) {\n                    return gama;\n                }\n                beta.addElements(gama);\n                newAlpha.addElements(gama);\n            }\n        }\n        return beta;\n    }\n    \n    public boolean equals(final JSPredicateForm t) {\n        if (t == null) {\n            return false;\n        }\n        final String functor = this.elementAt(0);\n        if (this.size() != t.size()) {\n            return false;\n        }\n        final String functor2 = t.elementAt(0);\n        if (!functor.equalsIgnoreCase(functor2)) {\n            return false;\n        }\n        if (functor.equalsIgnoreCase(\"not\")) {\n            final JSPredicateForm e1 = this.elementAt(1);\n            final JSPredicateForm e2 = t.elementAt(1);\n            return e1.equals(e2);\n        }\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            final JSTerm oti = t.elementAt(i);\n            if (!ti.equals(oti)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public JSPredicateForm standarizerPredicateForm() {\n        final JSPredicateForm nTA = new JSPredicateForm();\n        final String str = this.elementAt(0);\n        if (str.equalsIgnoreCase(\"not\")) {\n            nTA.addElement(this.elementAt(0));\n            final JSPredicateForm el = this.elementAt(1);\n            nTA.addElement(el.standarizerPredicateForm());\n            return nTA;\n        }\n        nTA.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nTA.addElement(ti.standardizerTerm());\n        }\n        return nTA;\n    }\n}\n"
    },
    {
        "project_name": "85_shop",
        "class": "JSTerm",
        "fqdn": "umd.cs.shop",
        "source_code": "package umd.cs.shop;\n\nimport java.io.*;\n\npublic class JSTerm extends JSPredicateForm\n{\n    private boolean isVariable;\n    private boolean isConstant;\n    private boolean isFunction;\n    private boolean isEval;\n    \n    JSTerm() {\n    }\n    \n    JSTerm(final StreamTokenizer tokenizer) {\n        this.isEval = false;\n        if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype != JSJshopVars.leftPar) {\n            if (tokenizer.ttype != JSJshopVars.interrogation) {\n                if (tokenizer.ttype == JSJshopVars.percent) {\n                    if (!JSUtil.expectTokenType(-3, tokenizer, \" Expecting word as term\")) {\n                        throw new JSParserError();\n                    }\n                    this.addElement(\"%\" + tokenizer.sval);\n                }\n                else if (tokenizer.ttype == -2) {\n                    this.addElement(new Double(tokenizer.nval).toString());\n                }\n                else {\n                    if (tokenizer.ttype != -3) {\n                        JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Term expected\");\n                        throw new JSParserError();\n                    }\n                    tokenizer.pushBack();\n                    final String varname = JSUtil.readWord(tokenizer, \"Expecting constant symbol as term\");\n                    this.addElement(varname);\n                }\n                this.isVariable = false;\n                this.isConstant = true;\n                this.isFunction = false;\n                return;\n            }\n            if (!JSUtil.readToken(tokenizer, \"Expecting variable name in term\")) {\n                throw new JSParserError();\n            }\n            tokenizer.pushBack();\n            final String varname = JSUtil.readWord(tokenizer, \"Expecting variable name in term\");\n            this.addElement(\"?\" + varname);\n            this.isVariable = true;\n            this.isConstant = false;\n            this.isFunction = false;\n        }\n        else {\n            this.isVariable = false;\n            this.isConstant = false;\n            this.isFunction = true;\n            if (tokenizer.ttype != JSJshopVars.leftPar) {\n                JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Expected (\");\n                throw new JSParserError();\n            }\n            if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                throw new JSParserError();\n            }\n            if (tokenizer.ttype == -3 && tokenizer.sval.equalsIgnoreCase(\"call\")) {\n                this.isEval = true;\n                if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                    throw new JSParserError();\n                }\n            }\n            if (tokenizer.ttype != -3 || !tokenizer.sval.equalsIgnoreCase(\"list\")) {\n                if (tokenizer.ttype == JSJshopVars.lessT) {\n                    if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                        throw new JSParserError();\n                    }\n                    if (tokenizer.ttype == JSJshopVars.equalT) {\n                        this.addElement(\"<=\");\n                    }\n                    else {\n                        this.addElement(\"<\");\n                        tokenizer.pushBack();\n                    }\n                }\n                else if (tokenizer.ttype == JSJshopVars.greaterT) {\n                    if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                        throw new JSParserError();\n                    }\n                    if (tokenizer.ttype == JSJshopVars.equalT) {\n                        this.addElement(\">=\");\n                    }\n                    else {\n                        this.addElement(\">\");\n                        tokenizer.pushBack();\n                    }\n                }\n                else if (tokenizer.ttype == JSJshopVars.plus || tokenizer.ttype == JSJshopVars.minus || tokenizer.ttype == JSJshopVars.slash || tokenizer.ttype == JSJshopVars.astherisk) {\n                    this.addElement(JSUtil.stringTokenizer(tokenizer));\n                }\n                else {\n                    if (tokenizer.ttype != -3) {\n                        JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Term expected\");\n                        throw new JSParserError();\n                    }\n                    tokenizer.pushBack();\n                    final String w = JSUtil.readWord(tokenizer, \"JSTerm\");\n                    if (w.equals(\"%%%\")) {\n                        JSUtil.println(\"Line : \" + tokenizer.lineno() + \" Term expected\");\n                        throw new JSParserError();\n                    }\n                    this.addElement(w);\n                }\n                try {\n                    tokenizer.nextToken();\n                    while (tokenizer.ttype != JSJshopVars.rightPar) {\n                        tokenizer.pushBack();\n                        this.addElement(new JSTerm(tokenizer));\n                        tokenizer.nextToken();\n                    }\n                }\n                catch (Exception e) {\n                    JSUtil.println(\"JSTerm: Error reading control parameters: \" + e);\n                    System.exit(1);\n                }\n                return;\n            }\n            if (!JSUtil.readToken(tokenizer, \"Expecting Term\")) {\n                throw new JSParserError();\n            }\n            if (tokenizer.ttype == JSJshopVars.rightPar) {\n                this.addElement(\"nil\");\n                this.makeConstant();\n                return;\n            }\n            tokenizer.pushBack();\n            this.addElement(\".\");\n            this.addElement(new JSTerm(tokenizer));\n            this.addElement(this.parseList(tokenizer));\n        }\n    }\n    \n    public JSTerm parseList(final StreamTokenizer tokenizer) {\n        final JSTerm t = new JSTerm();\n        if (!JSUtil.readToken(tokenizer, \"Expecting elements of the list\")) {\n            throw new JSParserError();\n        }\n        if (tokenizer.ttype == JSJshopVars.rightPar) {\n            t.addElement(\"nil\");\n            t.makeConstant();\n            return t;\n        }\n        if (tokenizer.ttype != JSJshopVars.dot) {\n            tokenizer.pushBack();\n            t.makeFunction();\n            t.addElement(\".\");\n            t.addElement(new JSTerm(tokenizer));\n            t.addElement(this.parseList(tokenizer));\n            return t;\n        }\n        final JSTerm cdr = new JSTerm(tokenizer);\n        if (!JSUtil.expectTokenType(JSJshopVars.rightPar, tokenizer, \"Expecting ')' for term.\")) {\n            throw new JSParserError();\n        }\n        if (cdr.isVariable || cdr.elementAt(0).equalsIgnoreCase(\"nil\") || cdr.elementAt(0).equals(\".\")) {\n            return cdr;\n        }\n        t.addElement(\".\");\n        t.addElement(cdr);\n        final JSTerm r = new JSTerm();\n        r.addElement(\"nil\");\n        r.makeConstant();\n        t.addElement(r);\n        return t;\n    }\n    \n    private void printList(final JSTerm t) {\n        final String str = \"nil\";\n        if (str.equalsIgnoreCase(t.elementAt(0))) {\n            JSUtil.print(\") \");\n            return;\n        }\n        if (t.isVariable) {\n            JSUtil.print(\" . \");\n            t.print();\n            JSUtil.print(\") \");\n            return;\n        }\n        JSTerm tt = t.elementAt(1);\n        tt.print();\n        JSUtil.print(\" \");\n        tt = t.elementAt(2);\n        this.printList(tt);\n    }\n    \n    @Override\n    public void print() {\n        if (this.isVariable || this.isConstant) {\n            JSUtil.print(this.elementAt(0) + \" \");\n        }\n        else {\n            JSUtil.print(\"(\");\n            if (this.elementAt(0).equals(\".\")) {\n                JSUtil.print(\"list \");\n                this.printList(this);\n                return;\n            }\n            if (this.isEval) {\n                JSUtil.print(\"call \");\n            }\n            JSUtil.print(this.elementAt(0) + \" \");\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el = this.elementAt(i);\n                el.print();\n            }\n            JSUtil.print(\")\");\n        }\n    }\n    \n    public JSTerm cloneT() {\n        final JSTerm nt = new JSTerm();\n        nt.isEval = this.isEval;\n        if (this.isConstant()) {\n            nt.addElement(this.elementAt(0));\n            nt.makeConstant();\n            return nt;\n        }\n        if (this.isVariable()) {\n            nt.addElement(this.elementAt(0));\n            nt.makeVariable();\n            return nt;\n        }\n        nt.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nt.addElement(ti.cloneT());\n        }\n        nt.makeFunction();\n        return nt;\n    }\n    \n    public JSTerm applySubstitutionT(final JSSubstitution alpha) {\n        if (this.isConstant()) {\n            return this.cloneT();\n        }\n        if (this.isVariable()) {\n            final JSTerm nt = alpha.instance(this);\n            return nt.cloneT();\n        }\n        final JSTerm nt = new JSTerm();\n        nt.makeEval(this.isEval);\n        nt.makeFunction();\n        nt.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nt.addElement(ti.applySubstitutionT(alpha));\n        }\n        return nt;\n    }\n    \n    public JSSubstitution matches(final JSTerm t) {\n        return this.matches(t, new JSSubstitution());\n    }\n    \n    public JSSubstitution matches(final JSTerm t, final JSSubstitution alpha) {\n        final JSSubstitution beta = new JSSubstitution();\n        if (this.isConstant()) {\n            if (!t.isConstant()) {\n                return t.matches(this, alpha);\n            }\n            if (!this.equals(t)) {\n                beta.assignFailure();\n            }\n            return beta;\n        }\n        else if (this.isVariable()) {\n            final JSTerm nt = alpha.instance(this);\n            if (!nt.equals(this)) {\n                return nt.matches(t, alpha);\n            }\n            beta.addElement(new JSPairVarTerm(this, t));\n            return beta;\n        }\n        else {\n            if (t.isVariable) {\n                return t.matches(this);\n            }\n            if (!t.isFunction()) {\n                beta.assignFailure();\n                return beta;\n            }\n            if (this.size() != t.size()) {\n                beta.assignFailure();\n                return beta;\n            }\n            final String functor = this.elementAt(0);\n            if (!functor.equalsIgnoreCase(t.elementAt(0))) {\n                beta.assignFailure();\n                return beta;\n            }\n            JSSubstitution gama = new JSSubstitution();\n            final JSSubstitution newAlpha = (JSSubstitution)alpha.clone();\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                if (!ti.equals(t.elementAt(i))) {\n                    gama = ti.matches(t.elementAt(i), newAlpha);\n                    if (gama.fail()) {\n                        gama.assignFailure();\n                        return gama;\n                    }\n                    beta.addElements(gama);\n                    newAlpha.addElements(gama);\n                }\n            }\n            return beta;\n        }\n    }\n    \n    public boolean equals(final JSTerm t) {\n        if (this.isConstant()) {\n            if (!t.isConstant()) {\n                return false;\n            }\n            final String name = this.elementAt(0);\n            final String name2 = t.elementAt(0);\n            return name.equalsIgnoreCase(name2);\n        }\n        else if (this.isVariable()) {\n            if (!t.isVariable()) {\n                return false;\n            }\n            final String name = this.elementAt(0);\n            final String name2 = t.elementAt(0);\n            return name.equalsIgnoreCase(name2);\n        }\n        else {\n            if (!t.isFunction()) {\n                return false;\n            }\n            if (this.size() != t.size()) {\n                return false;\n            }\n            final String functor = this.elementAt(0);\n            final String functor2 = t.elementAt(0);\n            if (!functor.equalsIgnoreCase(functor2)) {\n                return false;\n            }\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm ti = this.elementAt(i);\n                final JSTerm oti = t.elementAt(i);\n                if (!ti.equals(oti)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    \n    public boolean isVariable() {\n        return this.isVariable;\n    }\n    \n    public boolean isConstant() {\n        return this.isConstant;\n    }\n    \n    public boolean isFunction() {\n        return this.isFunction;\n    }\n    \n    public boolean isEval() {\n        return this.isEval;\n    }\n    \n    public void makeFunction() {\n        this.isVariable = false;\n        this.isConstant = false;\n        this.isFunction = true;\n    }\n    \n    public void makeVariable() {\n        this.isVariable = true;\n        this.isConstant = false;\n        this.isFunction = false;\n    }\n    \n    public void makeConstant() {\n        this.isVariable = false;\n        this.isConstant = true;\n        this.isFunction = false;\n    }\n    \n    public void makeEval(final boolean evaluable) {\n        this.isEval = evaluable;\n    }\n    \n    @Override\n    public StringBuffer toStr() {\n        final StringBuffer res = new StringBuffer();\n        if (this.isVariable || this.isConstant) {\n            res.append(this.elementAt(0) + \" \");\n        }\n        else {\n            res.append(\"(\");\n            res.append(this.elementAt(0) + \" \");\n            for (short i = 1; i < this.size(); ++i) {\n                final JSTerm el = this.elementAt(i);\n                res.append(el.toStr());\n            }\n            res.append(\")\");\n        }\n        return res;\n    }\n    \n    public boolean isGround() {\n        if (this.isConstant()) {\n            return true;\n        }\n        if (this.isVariable()) {\n            return false;\n        }\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            if (!ti.isGround()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public JSTerm standardizerTerm() {\n        final JSTerm nt = new JSTerm();\n        nt.makeEval(this.isEval);\n        if (this.isConstant()) {\n            nt.addElement(this.elementAt(0));\n            nt.makeConstant();\n            return nt;\n        }\n        if (this.isVariable()) {\n            nt.addElement(this.elementAt(0) + String.valueOf(JSJshopVars.VarCounter));\n            nt.makeVariable();\n            return nt;\n        }\n        nt.addElement(this.elementAt(0));\n        for (short i = 1; i < this.size(); ++i) {\n            final JSTerm ti = this.elementAt(i);\n            nt.addElement(ti.standardizerTerm());\n        }\n        nt.makeFunction();\n        return nt;\n    }\n    \n    public JSTerm call() {\n        if (this.isConstant()) {\n            return (JSTerm)this.clone();\n        }\n        if (!this.isEval() && this.isVariable()) {\n            return (JSTerm)this.clone();\n        }\n        if (this.isVariable()) {\n            return new JSTerm();\n        }\n        final JSTerm f = new JSTerm();\n        f.makeFunction();\n        f.addElement(this.elementAt(0));\n        for (int i = 1; i < this.size(); ++i) {\n            f.addElement(this.elementAt(i).call());\n        }\n        if (!this.isEval()) {\n            return f;\n        }\n        final String op = new String(f.elementAt(0));\n        final JSTerm operant1 = f.elementAt(1).call();\n        if (operant1.size() == 0 && !op.equalsIgnoreCase(\"not\")) {\n            return new JSTerm();\n        }\n        JSTerm t;\n        if (JSEvaluate.OperantNum(op) > 1) {\n            final JSTerm operant2 = f.elementAt(2).call();\n            if (operant2.size() == 0) {\n                return new JSTerm();\n            }\n            t = JSEvaluate.applyOperator(op, operant1, operant2);\n        }\n        else {\n            t = JSEvaluate.applyOperatorUnary(op, operant1);\n        }\n        return t;\n    }\n}\n"
    },
    {
        "project_name": "85_shop",
        "class": "JSState",
        "fqdn": "umd.cs.shop",
        "source_code": "package umd.cs.shop;\n\nimport java.io.*;\n\npublic class JSState extends JSListLogicalAtoms\n{\n    private String label;\n    \n    public JSState() {\n    }\n    \n    public JSState(final StreamTokenizer tokenizer) {\n        super(tokenizer);\n    }\n    \n    public void addElementsToState(final JSListLogicalAtoms s) {\n        int j = 0;\n        for (int i = 0; i < s.size(); ++i) {\n            if (!this.contains(s.elementAt(i))) {\n                this.insertElementAt(s.elementAt(i), j);\n                ++j;\n            }\n        }\n    }\n    \n    JSState apply(final JSPlan pl) {\n        final JSState ns = new JSState();\n        JSUtil.flag20(\"<STATE>.apply(<JSPlan>) not implemented yet\");\n        return ns;\n    }\n    \n    JSTState applyOp(final JSOperator op, final JSSubstitution alpha, final JSListLogicalAtoms addL, final JSListLogicalAtoms delL) {\n        final JSListLogicalAtoms add = op.addList();\n        final JSListLogicalAtoms del = op.deleteList();\n        final JSListLogicalAtoms opAddL = add.applySubstitutionListLogicalAtoms(alpha);\n        final JSListLogicalAtoms opDelL = del.applySubstitutionListLogicalAtoms(alpha);\n        final JSState ns = new JSState();\n        final JSListLogicalAtoms nAddL = new JSListLogicalAtoms();\n        final JSListLogicalAtoms nDelL = new JSListLogicalAtoms();\n        if (JSJshopVars.flagLevel > 3) {\n            JSUtil.print(\" Matching Operator : (\");\n            JSUtil.print(\":Operator \");\n            op.head().applySubstitutionTA(alpha).print();\n            JSUtil.print(\"-: \");\n            opDelL.print();\n            JSUtil.print(\"+: \");\n            opAddL.print();\n            JSUtil.println(\")\");\n        }\n        for (short i = 0; i < this.size(); ++i) {\n            final JSPredicateForm el = this.elementAt(i);\n            if (!opDelL.contains(el)) {\n                ns.addElement(el);\n            }\n        }\n        ns.addElementsToState(opAddL);\n        for (short i = 0; i < addL.size(); ++i) {\n            final JSPredicateForm el = addL.elementAt(i);\n            if (!opDelL.contains(el)) {\n                nAddL.addElement(el);\n            }\n        }\n        nAddL.addElements(opAddL);\n        for (short i = 0; i < delL.size(); ++i) {\n            final JSPredicateForm el = delL.elementAt(i);\n            if (!opAddL.contains(el)) {\n                nDelL.addElement(el);\n            }\n        }\n        nDelL.addElements(opDelL);\n        if (JSJshopVars.flagLevel > 3) {\n            JSUtil.println(\"The resulting state :\");\n            ns.print();\n            JSUtil.println(\"-----------\");\n        }\n        return new JSTState(ns, nAddL, nDelL);\n    }\n    \n    public JSSubstitution satisfies(final JSListLogicalAtoms conds, final JSSubstitution alpha, final JSListAxioms axioms) {\n        final JSListSubstitution satisfiers = axioms.TheoremProver(conds, this, alpha, false);\n        JSSubstitution answer;\n        if (satisfiers.fail()) {\n            answer = new JSSubstitution();\n            answer.assignFailure();\n        }\n        else {\n            answer = (JSSubstitution)alpha.clone();\n            answer.addElements(satisfiers.elementAt(0));\n        }\n        return answer;\n    }\n    \n    public JSListSubstitution satisfiesAll(final JSListLogicalAtoms conds, final JSSubstitution alpha, final JSListAxioms axioms) {\n        final String first = conds.Label();\n        final boolean findfirst = !first.equalsIgnoreCase(\"first\");\n        final JSListSubstitution answers = new JSListSubstitution();\n        final JSListSubstitution satisfiers = axioms.TheoremProver(conds, this, alpha, findfirst);\n        for (int i = 0; i < satisfiers.size(); ++i) {\n            final JSSubstitution beta = (JSSubstitution)satisfiers.elementAt(i).clone();\n            beta.addElements((JSSubstitution)alpha.clone());\n            answers.addElement(beta);\n        }\n        return answers;\n    }\n    \n    public JSListSubstitution satisfiesTAm(final JSPredicateForm t, final JSSubstitution alpha) {\n        final JSListSubstitution answers = new JSListSubstitution();\n        if (JSJshopVars.flagLevel > 7) {\n            System.out.println(\" \");\n        }\n        for (int i = 0; i < this.size(); ++i) {\n            final JSPredicateForm el = this.elementAt(i);\n            final JSSubstitution subs = t.matches(el, alpha);\n            if (!subs.fail()) {\n                if (JSJshopVars.flagLevel > 7) {\n                    JSUtil.println(\" Goal matches atom: \");\n                    el.print();\n                }\n                answers.addElement(subs);\n            }\n        }\n        if (JSJshopVars.flagLevel > 7 && answers.isEmpty()) {\n            JSUtil.println(\" Goal does not match any atom.\");\n        }\n        return answers;\n    }\n}\n"
    },
    {
        "project_name": "1_tullibee",
        "class": "ExecutionFilter",
        "fqdn": "com.ib.client",
        "source_code": "package com.ib.client;\n\npublic class ExecutionFilter\n{\n    public int m_clientId;\n    public String m_acctCode;\n    public String m_time;\n    public String m_symbol;\n    public String m_secType;\n    public String m_exchange;\n    public String m_side;\n    \n    public ExecutionFilter() {\n        this.m_clientId = 0;\n    }\n    \n    public ExecutionFilter(final int p_clientId, final String p_acctCode, final String p_time, final String p_symbol, final String p_secType, final String p_exchange, final String p_side) {\n        this.m_clientId = p_clientId;\n        this.m_acctCode = p_acctCode;\n        this.m_time = p_time;\n        this.m_symbol = p_symbol;\n        this.m_secType = p_secType;\n        this.m_exchange = p_exchange;\n        this.m_side = p_side;\n    }\n    \n    @Override\n    public boolean equals(final Object p_other) {\n        boolean l_bRetVal = false;\n        if (p_other == null) {\n            l_bRetVal = false;\n        }\n        else if (this == p_other) {\n            l_bRetVal = true;\n        }\n        else {\n            final ExecutionFilter l_theOther = (ExecutionFilter)p_other;\n            l_bRetVal = (this.m_clientId == l_theOther.m_clientId && this.m_acctCode.equalsIgnoreCase(l_theOther.m_acctCode) && this.m_time.equalsIgnoreCase(l_theOther.m_time) && this.m_symbol.equalsIgnoreCase(l_theOther.m_symbol) && this.m_secType.equalsIgnoreCase(l_theOther.m_secType) && this.m_exchange.equalsIgnoreCase(l_theOther.m_exchange) && this.m_side.equalsIgnoreCase(l_theOther.m_side));\n        }\n        return l_bRetVal;\n    }\n}\n"
    },
    {
        "project_name": "1_tullibee",
        "class": "ComboLeg",
        "fqdn": "com.ib.client",
        "source_code": "package com.ib.client;\n\npublic class ComboLeg\n{\n    public static final int SAME = 0;\n    public static final int OPEN = 1;\n    public static final int CLOSE = 2;\n    public static final int UNKNOWN = 3;\n    public int m_conId;\n    public int m_ratio;\n    public String m_action;\n    public String m_exchange;\n    public int m_openClose;\n    public int m_shortSaleSlot;\n    public String m_designatedLocation;\n    \n    public ComboLeg() {\n        this(0, 0, null, null, 0, 0, null);\n    }\n    \n    public ComboLeg(final int p_conId, final int p_ratio, final String p_action, final String p_exchange, final int p_openClose) {\n        this(p_conId, p_ratio, p_action, p_exchange, p_openClose, 0, null);\n    }\n    \n    public ComboLeg(final int p_conId, final int p_ratio, final String p_action, final String p_exchange, final int p_openClose, final int p_shortSaleSlot, final String p_designatedLocation) {\n        this.m_conId = p_conId;\n        this.m_ratio = p_ratio;\n        this.m_action = p_action;\n        this.m_exchange = p_exchange;\n        this.m_openClose = p_openClose;\n        this.m_shortSaleSlot = p_shortSaleSlot;\n        this.m_designatedLocation = p_designatedLocation;\n    }\n    \n    @Override\n    public boolean equals(final Object p_other) {\n        if (this == p_other) {\n            return true;\n        }\n        if (p_other == null) {\n            return false;\n        }\n        final ComboLeg l_theOther = (ComboLeg)p_other;\n        return this.m_conId == l_theOther.m_conId && this.m_ratio == l_theOther.m_ratio && this.m_openClose == l_theOther.m_openClose && this.m_shortSaleSlot == l_theOther.m_shortSaleSlot && Util.StringCompareIgnCase(this.m_action, l_theOther.m_action) == 0 && Util.StringCompareIgnCase(this.m_exchange, l_theOther.m_exchange) == 0 && Util.StringCompareIgnCase(this.m_designatedLocation, l_theOther.m_designatedLocation) == 0;\n    }\n}\n"
    },
    {
        "project_name": "77_io-project",
        "class": "ClientGroup",
        "fqdn": "ioproject.server.network",
        "source_code": "package ioproject.server.network;\n\nimport java.lang.ref.*;\nimport ioproject.common.network.*;\nimport java.util.*;\n\npublic class ClientGroup implements Iterable<Client>\n{\n    private ClientGroup parentGroup;\n    private Set<WeakReference<ClientGroup>> subGroups;\n    private Set<Client> clients;\n    private ClientHandler handler;\n    \n    ClientGroup(final ClientGroup theParentGroup) {\n        this.parentGroup = theParentGroup;\n        this.subGroups = new LinkedHashSet<WeakReference<ClientGroup>>();\n        this.clients = new LinkedHashSet<Client>();\n        this.handler = null;\n    }\n    \n    ClientGroup parentGroup() {\n        return this.parentGroup;\n    }\n    \n    synchronized boolean notifyMessageSent(final Client client, final Object message) {\n        if (!this.clients.contains(client)) {\n            return false;\n        }\n        boolean inSubGroup = false;\n        for (final WeakReference<ClientGroup> groupReference : this.subGroups) {\n            inSubGroup = (groupReference.get().notifyMessageSent(client, message) || inSubGroup);\n        }\n        if (!inSubGroup && this.handler != null) {\n            this.handler.messageSent(client, message);\n        }\n        return true;\n    }\n    \n    synchronized boolean notifyMessageReceived(final Client client, final Object message) {\n        if (!this.clients.contains(client)) {\n            return false;\n        }\n        boolean inSubGroup = false;\n        for (final WeakReference<ClientGroup> groupReference : this.subGroups) {\n            inSubGroup = (groupReference.get().notifyMessageReceived(client, message) || inSubGroup);\n        }\n        if (!inSubGroup && this.handler != null) {\n            this.handler.messageReceived(client, message);\n        }\n        return true;\n    }\n    \n    synchronized boolean notifyExceptionCaught(final Client client, final Throwable cause) {\n        if (!this.clients.contains(client)) {\n            return false;\n        }\n        boolean inSubGroup = false;\n        for (final WeakReference<ClientGroup> groupReference : this.subGroups) {\n            inSubGroup = (groupReference.get().notifyExceptionCaught(client, cause) || inSubGroup);\n        }\n        if (!inSubGroup && this.handler != null) {\n            this.handler.exceptionCaught(client, cause);\n        }\n        return true;\n    }\n    \n    @Override\n    public Iterator<Client> iterator() {\n        return Collections.unmodifiableSet((Set<? extends Client>)this.clients).iterator();\n    }\n    \n    public synchronized boolean contains(final Client client) {\n        return this.clients.contains(client);\n    }\n    \n    public synchronized int size() {\n        return this.clients.size();\n    }\n    \n    public synchronized boolean add(final Client client) {\n        final boolean parentContainsClient = this.parentGroup == null || this.parentGroup.contains(client);\n        if (parentContainsClient) {\n            this.clients.add(client);\n        }\n        if (this.handler != null) {\n            this.handler.clientAdded(client);\n        }\n        return parentContainsClient;\n    }\n    \n    public synchronized boolean remove(final Client client) {\n        final boolean clientIsMember = this.clients.contains(client);\n        if (clientIsMember) {\n            this.clients.remove(client);\n            for (final WeakReference<ClientGroup> subGroupReference : this.subGroups) {\n                subGroupReference.get().remove(client);\n            }\n        }\n        if (this.handler != null) {\n            this.handler.clientRemoved(client);\n        }\n        return clientIsMember;\n    }\n    \n    public synchronized ClientGroup createSubGroup() {\n        final ClientGroup subGroup = new ClientGroup(this);\n        this.subGroups.add(new WeakReference<ClientGroup>(subGroup));\n        return subGroup;\n    }\n    \n    public synchronized void addClientHandler(final ClientHandler aHandler) {\n        this.handler = aHandler;\n    }\n}\n"
    },
    {
        "project_name": "scribe",
        "class": "Verifier",
        "fqdn": "org.scribe.model",
        "source_code": "package org.scribe.model;\n\nimport org.scribe.utils.*;\n\npublic class Verifier\n{\n    private final String value;\n    \n    public Verifier(final String value) {\n        Preconditions.checkNotNull(value, \"Must provide a valid string as verifier\");\n        this.value = value;\n    }\n    \n    public String getValue() {\n        return this.value;\n    }\n}\n"
    },
    {
        "project_name": "scribe",
        "class": "Token",
        "fqdn": "org.scribe.model",
        "source_code": "package org.scribe.model;\n\nimport java.io.*;\n\npublic class Token implements Serializable\n{\n    private static final long serialVersionUID = 715000866082812683L;\n    private final String token;\n    private final String secret;\n    private final String rawResponse;\n    \n    public Token(final String token, final String secret) {\n        this(token, secret, null);\n    }\n    \n    public Token(final String token, final String secret, final String rawResponse) {\n        this.token = token;\n        this.secret = secret;\n        this.rawResponse = rawResponse;\n    }\n    \n    public String getToken() {\n        return this.token;\n    }\n    \n    public String getSecret() {\n        return this.secret;\n    }\n    \n    public String getRawResponse() {\n        if (this.rawResponse == null) {\n            throw new IllegalStateException(\"This token object was not constructed by scribe and does not have a rawResponse\");\n        }\n        return this.rawResponse;\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"Token[%s , %s]\", this.token, this.secret);\n    }\n}\n"
    },
    {
        "project_name": "scribe",
        "class": "Request",
        "fqdn": "org.scribe.model",
        "source_code": "package org.scribe.model;\n\nimport org.scribe.exceptions.*;\nimport org.scribe.utils.*;\nimport java.util.*;\nimport java.net.*;\nimport java.io.*;\nimport java.nio.charset.*;\nimport java.util.concurrent.*;\n\nclass Request\n{\n    private static final String CONTENT_LENGTH = \"Content-Length\";\n    private String url;\n    private Verb verb;\n    private Map<String, String> querystringParams;\n    private Map<String, String> bodyParams;\n    private Map<String, String> headers;\n    private String payload;\n    private HttpURLConnection connection;\n    private String charset;\n    private byte[] bytePayload;\n    private boolean connectionKeepAlive;\n    \n    public Request(final Verb verb, final String url) {\n        this.payload = null;\n        this.bytePayload = null;\n        this.connectionKeepAlive = false;\n        this.verb = verb;\n        this.url = url;\n        this.querystringParams = new HashMap<String, String>();\n        this.bodyParams = new HashMap<String, String>();\n        this.headers = new HashMap<String, String>();\n    }\n    \n    public Response send() {\n        try {\n            this.createConnection();\n            return this.doSend();\n        }\n        catch (IOException ioe) {\n            throw new OAuthException(\"Problems while creating connection\", ioe);\n        }\n    }\n    \n    private void createConnection() throws IOException {\n        final String effectiveUrl = URLUtils.appendParametersToQueryString(this.url, this.querystringParams);\n        if (this.connection == null) {\n            System.setProperty(\"http.keepAlive\", this.connectionKeepAlive ? \"true\" : \"false\");\n            this.connection = (HttpURLConnection)new URL(effectiveUrl).openConnection();\n        }\n    }\n    \n    Response doSend() throws IOException {\n        this.connection.setRequestMethod(this.verb.name());\n        this.addHeaders(this.connection);\n        if (this.verb.equals(Verb.PUT) || this.verb.equals(Verb.POST)) {\n            this.addBody(this.connection, this.getByteBodyContents());\n        }\n        return new Response(this.connection);\n    }\n    \n    void addHeaders(final HttpURLConnection conn) {\n        for (final String key : this.headers.keySet()) {\n            conn.setRequestProperty(key, this.headers.get(key));\n        }\n    }\n    \n    void addBody(final HttpURLConnection conn, final byte[] content) throws IOException {\n        conn.setRequestProperty(\"Content-Length\", String.valueOf(content.length));\n        conn.setDoOutput(true);\n        conn.getOutputStream().write(content);\n    }\n    \n    public void addHeader(final String key, final String value) {\n        this.headers.put(key, value);\n    }\n    \n    public void addBodyParameter(final String key, final String value) {\n        this.bodyParams.put(key, value);\n    }\n    \n    public void addQuerystringParameter(final String key, final String value) {\n        this.querystringParams.put(key, value);\n    }\n    \n    public void addPayload(final String payload) {\n        this.payload = payload;\n    }\n    \n    public void addPayload(final byte[] payload) {\n        this.bytePayload = payload;\n    }\n    \n    public Map<String, String> getQueryStringParams() {\n        try {\n            final Map<String, String> params = new HashMap<String, String>();\n            final String queryString = new URL(this.url).getQuery();\n            params.putAll(URLUtils.queryStringToMap(queryString));\n            params.putAll(this.querystringParams);\n            return params;\n        }\n        catch (MalformedURLException mue) {\n            throw new OAuthException(\"Malformed URL\", mue);\n        }\n    }\n    \n    public Map<String, String> getBodyParams() {\n        return this.bodyParams;\n    }\n    \n    public String getUrl() {\n        return this.url;\n    }\n    \n    public String getSanitizedUrl() {\n        return this.url.replaceAll(\"\\\\?.*\", \"\").replace(\"\\\\:\\\\d{4}\", \"\");\n    }\n    \n    public String getBodyContents() {\n        try {\n            return new String(this.getByteBodyContents(), this.getCharset());\n        }\n        catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Unsupported Charset: \" + this.charset, uee);\n        }\n    }\n    \n    byte[] getByteBodyContents() {\n        if (this.bytePayload != null) {\n            return this.bytePayload;\n        }\n        final String body = (this.payload != null) ? this.payload : URLUtils.formURLEncodeMap(this.bodyParams);\n        try {\n            return body.getBytes(this.getCharset());\n        }\n        catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Unsupported Charset: \" + this.getCharset(), uee);\n        }\n    }\n    \n    public Verb getVerb() {\n        return this.verb;\n    }\n    \n    public Map<String, String> getHeaders() {\n        return this.headers;\n    }\n    \n    public String getCharset() {\n        return (this.charset == null) ? Charset.defaultCharset().name() : this.charset;\n    }\n    \n    public void setConnectTimeout(final int duration, final TimeUnit unit) {\n        this.connection.setConnectTimeout((int)unit.toMillis(duration));\n    }\n    \n    public void setReadTimeout(final int duration, final TimeUnit unit) {\n        this.connection.setReadTimeout((int)unit.toMillis(duration));\n    }\n    \n    public void setCharset(final String charsetName) {\n        this.charset = charsetName;\n    }\n    \n    public void setConnectionKeepAlive(final boolean connectionKeepAlive) {\n        this.connectionKeepAlive = connectionKeepAlive;\n    }\n    \n    void setConnection(final HttpURLConnection connection) {\n        this.connection = connection;\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"@Request(%s %s)\", this.getVerb(), this.getUrl());\n    }\n}\n"
    },
    {
        "project_name": "scribe",
        "class": "OAuthRequest",
        "fqdn": "org.scribe.model",
        "source_code": "package org.scribe.model;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class OAuthRequest extends Request\n{\n    private static final String OAUTH_PREFIX = \"oauth_\";\n    private Map<String, String> oauthParameters;\n    \n    public OAuthRequest(final Verb verb, final String url) {\n        super(verb, url);\n        this.oauthParameters = new HashMap<String, String>();\n    }\n    \n    public void addOAuthParameter(final String key, final String value) {\n        this.oauthParameters.put(this.checkKey(key), value);\n    }\n    \n    private String checkKey(final String key) {\n        if (key.startsWith(\"oauth_\") || key.equals(\"scope\")) {\n            return key;\n        }\n        throw new IllegalArgumentException(String.format(\"OAuth parameters must either be '%s' or start with '%s'\", \"scope\", \"oauth_\"));\n    }\n    \n    public Map<String, String> getOauthParameters() {\n        return this.oauthParameters;\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"@OAuthRequest(%s, %s)\", this.getVerb(), this.getUrl());\n    }\n}\n"
    },
    {
        "project_name": "scribe",
        "class": "Response",
        "fqdn": "org.scribe.model",
        "source_code": "package org.scribe.model;\n\nimport java.net.*;\nimport java.io.*;\nimport org.scribe.utils.*;\nimport java.util.*;\n\npublic class Response\n{\n    private static final String EMPTY = \"\";\n    private int code;\n    private String body;\n    private InputStream stream;\n    private Map<String, String> headers;\n    \n    Response(final HttpURLConnection connection) throws IOException {\n        try {\n            connection.connect();\n            this.code = connection.getResponseCode();\n            this.headers = this.parseHeaders(connection);\n            this.stream = (this.wasSuccessful() ? connection.getInputStream() : connection.getErrorStream());\n        }\n        catch (UnknownHostException e) {\n            this.code = 404;\n            this.body = \"\";\n        }\n    }\n    \n    private String parseBodyContents() {\n        return this.body = StreamUtils.getStreamContents(this.getStream());\n    }\n    \n    private Map<String, String> parseHeaders(final HttpURLConnection conn) {\n        final Map<String, String> headers = new HashMap<String, String>();\n        for (final String key : conn.getHeaderFields().keySet()) {\n            headers.put(key, conn.getHeaderFields().get(key).get(0));\n        }\n        return headers;\n    }\n    \n    private boolean wasSuccessful() {\n        return this.getCode() >= 200 && this.getCode() < 400;\n    }\n    \n    public String getBody() {\n        return (this.body != null) ? this.body : this.parseBodyContents();\n    }\n    \n    public InputStream getStream() {\n        return this.stream;\n    }\n    \n    public int getCode() {\n        return this.code;\n    }\n    \n    public Map<String, String> getHeaders() {\n        return this.headers;\n    }\n    \n    public String getHeader(final String name) {\n        return this.headers.get(name);\n    }\n}\n"
    },
    {
        "project_name": "scribe",
        "class": "OAuthConfig",
        "fqdn": "org.scribe.model",
        "source_code": "package org.scribe.model;\n\npublic class OAuthConfig\n{\n    private final String apiKey;\n    private final String apiSecret;\n    private final String callback;\n    private final SignatureType signatureType;\n    private final String scope;\n    \n    public OAuthConfig(final String key, final String secret) {\n        this(key, secret, null, null, null);\n    }\n    \n    public OAuthConfig(final String key, final String secret, final String callback, final SignatureType type, final String scope) {\n        this.apiKey = key;\n        this.apiSecret = secret;\n        this.callback = ((callback != null) ? callback : \"oob\");\n        this.signatureType = ((type != null) ? type : SignatureType.Header);\n        this.scope = scope;\n    }\n    \n    public String getApiKey() {\n        return this.apiKey;\n    }\n    \n    public String getApiSecret() {\n        return this.apiSecret;\n    }\n    \n    public String getCallback() {\n        return this.callback;\n    }\n    \n    public SignatureType getSignatureType() {\n        return this.signatureType;\n    }\n    \n    public String getScope() {\n        return this.scope;\n    }\n    \n    public boolean hasScope() {\n        return this.scope != null;\n    }\n}\n"
    }
]