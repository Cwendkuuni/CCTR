[
    {
        "project_name": "Time",
        "bug-id": "1",
        "class": "UnsupportedDurationField",
        "fqdn": "org.joda.time.field",
        "source_code": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n/**\n * A placeholder implementation to use when a duration field is not supported.\n * <p>\n * UnsupportedDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic final class UnsupportedDurationField extends DurationField implements Serializable {\n\n    /** Serialization lock. */\n    private static final long serialVersionUID = -6390301302770925357L;\n\n    /** The cache of unsupported duration field instances */\n    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n\n    /**\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     */\n    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    /** The name of the field */\n    private final DurationFieldType iType;\n\n    /**\n     * Constructor.\n     * \n     * @param type  the type to use\n     */\n    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    //-----------------------------------------------------------------------\n    // Design note: Simple Accessors return a suitable value, but methods\n    // intended to perform calculations throw an UnsupportedOperationException.\n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    /**\n     * This field is not supported.\n     *\n     * @return false always\n     */\n    public boolean isSupported() {\n        return false;\n    }\n\n    /**\n     * This field is precise.\n     * \n     * @return true always\n     */\n    public boolean isPrecise() {\n        return true;\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always returns zero.\n     *\n     * @return zero always\n     */\n    public long getUnitMillis() {\n        return 0;\n    }\n\n    /**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */\n    public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n        return 0;\n    }\n\n    //------------------------------------------------------------------------\n    /**\n     * Compares this duration field to another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    /**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */\n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    /**\n     * Ensure proper singleton serialization\n     */\n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n"
    },
    {
        "project_name": "Time",
        "bug-id": "2",
        "class": "UnsupportedDurationField",
        "fqdn": "org.joda.time.field",
        "source_code": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\n\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\n\n/**\n * A placeholder implementation to use when a duration field is not supported.\n * <p>\n * UnsupportedDurationField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n */\npublic final class UnsupportedDurationField extends DurationField implements Serializable {\n\n    /** Serialization lock. */\n    private static final long serialVersionUID = -6390301302770925357L;\n\n    /** The cache of unsupported duration field instances */\n    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n\n    /**\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     */\n    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n\n    /** The name of the field */\n    private final DurationFieldType iType;\n\n    /**\n     * Constructor.\n     * \n     * @param type  the type to use\n     */\n    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n\n    //-----------------------------------------------------------------------\n    // Design note: Simple Accessors return a suitable value, but methods\n    // intended to perform calculations throw an UnsupportedOperationException.\n\n    public final DurationFieldType getType() {\n        return iType;\n    }\n\n    public String getName() {\n        return iType.getName();\n    }\n\n    /**\n     * This field is not supported.\n     *\n     * @return false always\n     */\n    public boolean isSupported() {\n        return false;\n    }\n\n    /**\n     * This field is precise.\n     * \n     * @return true always\n     */\n    public boolean isPrecise() {\n        return true;\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getValue(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getValueAsLong(long duration, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(int value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getMillis(long value, long instant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, int value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long add(long instant, long value) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always throws UnsupportedOperationException\n     *\n     * @throws UnsupportedOperationException\n     */\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        throw unsupported();\n    }\n\n    /**\n     * Always returns zero.\n     *\n     * @return zero always\n     */\n    public long getUnitMillis() {\n        return 0;\n    }\n\n    /**\n     * Always returns zero, indicating that sort order is not relevent.\n     *\n     * @return zero always\n     */\n    public int compareTo(DurationField durationField) {\n        return 0;\n    }\n\n    //------------------------------------------------------------------------\n    /**\n     * Compares this duration field to another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        } else if (obj instanceof UnsupportedDurationField) {\n            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n            if (other.getName() == null) {\n                return (getName() == null);\n            }\n            return (other.getName().equals(getName()));\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hashcode.\n     * \n     * @return the hashcode\n     */\n    public int hashCode() {\n        return getName().hashCode();\n    }\n\n    /**\n     * Get a suitable debug string.\n     * \n     * @return debug string\n     */\n    public String toString() {\n        return \"UnsupportedDurationField[\" + getName() + ']';\n    }\n\n    /**\n     * Ensure proper singleton serialization\n     */\n    private Object readResolve() {\n        return getInstance(iType);\n    }\n\n    private UnsupportedOperationException unsupported() {\n        return new UnsupportedOperationException(iType + \" field is unsupported\");\n    }\n\n}\n"
    },
    {
        "project_name": "Time",
        "bug-id": "26",
        "class": "LenientDateTimeField",
        "fqdn": "org.joda.time.field",
        "source_code": "/*\n *  Copyright 2001-2007 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\n\n/**\n * Converts a strict DateTimeField into a lenient one. By being lenient, the\n * set method accepts out of bounds values, performing an addition instead.\n * <p>\n * LenientDateTimeField is thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @see org.joda.time.chrono.LenientChronology\n * @see StrictDateTimeField\n * @since 1.0\n */\npublic class LenientDateTimeField extends DelegatedDateTimeField {\n\n    private static final long serialVersionUID = 8714085824173290599L;\n\n    private final Chronology iBase;\n\n    /**\n     * Returns a lenient version of the given field. If it is already lenient,\n     * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n     * returned.\n     */\n    public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n        if (field == null) {\n            return null;\n        }\n        if (field instanceof StrictDateTimeField) {\n            field = ((StrictDateTimeField)field).getWrappedField();\n        }\n        if (field.isLenient()) {\n            return field;\n        }\n        return new LenientDateTimeField(field, base);\n    }\n\n    protected LenientDateTimeField(DateTimeField field, Chronology base) {\n        super(field);\n        iBase = base;\n    }\n\n    public final boolean isLenient() {\n        return true;\n    }\n\n    /**\n     * Set values which may be out of bounds by adding the difference between\n     * the new value and the current value.\n     */\n    public long set(long instant, int value) {\n        // lenient needs to handle time zone chronologies\n        // so we do the calculation using local milliseconds\n        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n        long difference = FieldUtils.safeSubtract(value, get(instant));\n        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n        return iBase.getZone().convertLocalToUTC(localInstant, false);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "91",
        "class": "CharacterReader",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.UncheckedIOException;\nimport org.jsoup.helper.Validate;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n */\npublic final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxStringCacheLen = 12;\n    static final int maxBufferLen = 1024 * 32; // visible for testing\n    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n\n    private final char[] charBuf;\n    private final Reader reader;\n    private int bufLength;\n    private int bufSplitPoint;\n    private int bufPos;\n    private int readerPos;\n    private int bufMark = -1;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    public CharacterReader(Reader input, int sz) {\n        Validate.notNull(input);\n        Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n        bufferUp();\n\n    }\n\n    public CharacterReader(Reader input) {\n        this(input, maxBufferLen);\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        final int pos = bufPos;\n        if (pos < bufSplitPoint)\n            return;\n\n        try {\n            reader.skip(pos);\n            reader.mark(maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != -1) {\n                bufLength = read;\n                readerPos += pos;\n                bufPos = 0;\n                bufMark = -1;\n                bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        if (bufPos < 1)\n            throw new UncheckedIOException(new IOException(\"No buffer left to unconsume\"));\n\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        // extra buffer up, to get as much rewind capacity as possible\n        bufSplitPoint = 0;\n        bufferUp();\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        if (bufMark == -1)\n            throw new UncheckedIOException(new IOException(\"Mark invalid\"));\n\n        bufPos = bufMark;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n\n        OUTER: while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (pos < remaining) {\n            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                break;\n            pos++;\n        }\n        bufPos = pos;\n        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                case '/':\n                case '>':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n\n    /**\n     *  Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be\n     *  decoded correctly, so a bunch of NULLs indicates a binary file\n     */\n\n\n\n    @Override\n    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "91",
        "class": "UncheckedIOException",
        "fqdn": "org.jsoup",
        "source_code": "package org.jsoup;\n\nimport java.io.IOException;\n\npublic class UncheckedIOException extends RuntimeException {\n    public UncheckedIOException(IOException cause) {\n        super(cause);\n    }\n\n\n    public IOException ioException() {\n        return (IOException) getCause();\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "47",
        "class": "Entities",
        "fqdn": "org.jsoup.nodes",
        "source_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.parser.Parser;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.CharsetEncoder;\nimport java.util.*;\n\n/**\n * HTML entities, and escape routines.\n * Source: <a href=\"http://www.w3.org/TR/html5/named-character-references.html#named-character-references\">W3C HTML\n * named character references</a>.\n */\npublic class Entities {\n    public enum EscapeMode {\n        /** Restricted entities suitable for XHTML output: lt, gt, amp, and quot only. */\n        xhtml(xhtmlByVal),\n        /** Default HTML output entities. */\n        base(baseByVal),\n        /** Complete HTML entities. */\n        extended(fullByVal);\n\n        private Map<Character, String> map;\n\n        EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full;\n    private static final Map<Character, String> xhtmlByVal;\n    private static final Map<String, Character> base;\n    private static final Map<Character, String> baseByVal;\n    private static final Map<Character, String> fullByVal;\n\n    private Entities() {}\n\n    /**\n     * Check if the input is a known named entity\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity\n     */\n    public static boolean isNamedEntity(String name) {\n        return full.containsKey(name);\n    }\n\n    /**\n     * Check if the input is a known named entity in the base entity set.\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity in the base set\n     * @see #isNamedEntity(String)\n     */\n    public static boolean isBaseNamedEntity(String name) {\n        return base.containsKey(name);\n    }\n\n    /**\n     * Get the Character value of the named entity\n     * @param name named entity (e.g. \"lt\" or \"amp\")\n     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n     */\n    public static Character getCharacterByName(String name) {\n        return full.get(name);\n    }\n    \n    static String escape(String string, Document.OutputSettings out) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        escape(accum, string, out, false, false, false);\n        return accum.toString();\n    }\n\n    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n\n    static String unescape(String string) {\n        return unescape(string, false);\n    }\n\n    /**\n     * Unescape the input string.\n     * @param string to un-HTML-escape\n     * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n     * @return unescaped string\n     */\n    static String unescape(String string, boolean strict) {\n        return Parser.unescapeEntities(string, strict);\n    }\n\n    /*\n     * Provides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.\n     * After KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,\n     * performance may be bad. We can add more encoders for common character sets that are impacted by performance\n     * issues on Android if required.\n     *\n     * Benchmarks:     *\n     * OLD toHtml() impl v New (fastpath) in millis\n     * Wiki: 1895, 16\n     * CNN: 6378, 55\n     * Alterslash: 3013, 28\n     * Jsoup: 167, 2\n     */\n\n    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n        // todo add more charset tests if impacted by Android's bad perf in canEncode\n        switch (charset) {\n            case ascii:\n                return c < 0x80;\n            case utf:\n                return true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above\n            default:\n                return fallback.canEncode(c);\n        }\n    }\n\n    private enum CoreCharset {\n        ascii, utf, fallback;\n\n        private static CoreCharset byName(String name) {\n            if (name.equals(\"US-ASCII\"))\n                return ascii;\n            if (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\n                return utf;\n            return fallback;\n        }\n    }\n\n\n    // xhtml has restricted entities\n    private static final Object[][] xhtmlArray = {\n            {\"quot\", 0x00022},\n            {\"amp\", 0x00026},\n            {\"lt\", 0x0003C},\n            {\"gt\", 0x0003E}\n    };\n\n    static {\n        xhtmlByVal = new HashMap<Character, String>();\n        base = loadEntities(\"entities-base.properties\");  // most common / default\n        baseByVal = toCharacterKey(base);\n        full = loadEntities(\"entities-full.properties\"); // extended and overblown.\n        fullByVal = toCharacterKey(full);\n\n        for (Object[] entity : xhtmlArray) {\n            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n            xhtmlByVal.put(c, ((String) entity[0]));\n        }\n    }\n\n    private static Map<String, Character> loadEntities(String filename) {\n        Properties properties = new Properties();\n        Map<String, Character> entities = new HashMap<String, Character>();\n        try {\n            InputStream in = Entities.class.getResourceAsStream(filename);\n            properties.load(in);\n            in.close();\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n        }\n\n        for (Map.Entry entry: properties.entrySet()) {\n            Character val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\n            String name = (String) entry.getKey();\n            entities.put(name, val);\n        }\n        return entities;\n    }\n\n    private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\n        Map<Character, String> outMap = new HashMap<Character, String>();\n        for (Map.Entry<String, Character> entry: inMap.entrySet()) {\n            Character character = entry.getValue();\n            String name = entry.getKey();\n\n            if (outMap.containsKey(character)) {\n                // dupe, prefer the lower case version\n                if (name.toLowerCase().equals(name))\n                    outMap.put(character, name);\n            } else {\n                outMap.put(character, name);\n            }\n        }\n        return outMap;\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "92",
        "class": "ParseSettings",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.Attributes;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * Controls parser settings, to optionally preserve tag and/or attribute name case.\n */\npublic class ParseSettings {\n    /**\n     * HTML default settings: both tag and attribute names are lower-cased during parsing.\n     */\n    public static final ParseSettings htmlDefault;\n    /**\n     * Preserve both tag and attribute case.\n     */\n    public static final ParseSettings preserveCase;\n\n    static {\n        htmlDefault = new ParseSettings(false, false);\n        preserveCase = new ParseSettings(true, true);\n    }\n\n    private final boolean preserveTagCase;\n    private final boolean preserveAttributeCase;\n\n    /**\n     * Returns true if preserving tag name case.\n     */\n    public boolean preserveTagCase() {\n        return preserveTagCase;\n    }\n\n    /**\n     * Returns true if preserving attribute case.\n     */\n\n    /**\n     * Define parse settings.\n     * @param tag preserve tag case?\n     * @param attribute preserve attribute name case?\n     */\n    public ParseSettings(boolean tag, boolean attribute) {\n        preserveTagCase = tag;\n        preserveAttributeCase = attribute;\n    }\n\n    /**\n     * Normalizes a tag name according to the case preservation setting.\n     */\n    public String normalizeTag(String name) {\n        name = name.trim();\n        if (!preserveTagCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    /**\n     * Normalizes an attribute according to the case preservation setting.\n     */\n    public String normalizeAttribute(String name) {\n        name = name.trim();\n        if (!preserveAttributeCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    Attributes normalizeAttributes(Attributes attributes) {\n        if (!preserveAttributeCase) {\n            attributes.normalize();\n        }\n        return attributes;\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "92",
        "class": "XmlTreeBuilder",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.CDataNode;\nimport org.jsoup.nodes.Comment;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.DocumentType;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.nodes.XmlDeclaration;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.List;\n\n/**\n * Use the {@code XmlTreeBuilder} when you want to parse XML without any of the HTML DOM rules being applied to the\n * document.\n * <p>Usage example: {@code Document xmlDoc = Jsoup.parse(html, baseUrl, Parser.xmlParser());}</p>\n *\n * @author Jonathan Hedley\n */\npublic class XmlTreeBuilder extends TreeBuilder {\n    ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, new Parser(this));\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, new Parser(this));\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        // start tag, end tag, doctype, comment, character, eof\n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: // could put some normalisation here if desired\n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus && comment.isXmlDeclaration()) {\n            // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            XmlDeclaration decl = comment.asXmlDeclaration(); // else, we couldn't parse it as a decl, so leave as a comment\n            if (decl != null)\n                insert = decl;\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n\n    List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {\n        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n        runParser();\n        return doc.childNodes();\n    }\n\n    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n        return parseFragment(inputFragment, baseUri, parser);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "92",
        "class": "Token",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attributes;\n\nimport static org.jsoup.internal.Normalizer.lowerCase;\n\n/**\n * Parse tokens for the Tokeniser.\n */\nabstract class Token {\n    TokenType type;\n\n    private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    /**\n     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n     * piece of data, which immediately get GCed.\n     */\n    abstract Token reset();\n\n    static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }\n\n    static final class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        String pubSysKey = null;\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        @Override\n        Token reset() {\n            reset(name);\n            pubSysKey = null;\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n        String getPubSysKey() {\n            return pubSysKey;\n        }\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token {\n        protected String tagName;\n        protected String normalName; // lc version of tag name, for case insensitive tree build\n        private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n        private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n        private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\n        private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\n        private boolean hasPendingAttributeValue = false;\n        boolean selfClosing = false;\n        Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        @Override\n        Tag reset() {\n            tagName = null;\n            normalName = null;\n            pendingAttributeName = null;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            selfClosing = false;\n            attributes = null;\n            return this;\n        }\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    String value;\n                    if (hasPendingAttributeValue)\n                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                    else if (hasEmptyAttributeValue)\n                        value = \"\";\n                    else\n                        value = null;\n                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).\n                    attributes.put(pendingAttributeName, value);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n\n        final void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                newAttribute();\n            }\n        }\n\n        /** Preserves case */\n        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        /** Lower case */\n        final String normalName() { // lower case, used in tree building for working out where in tree it should go\n            return normalName;\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = lowerCase(name);\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        final Attributes getAttributes() {\n            return attributes;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = lowerCase(tagName);\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        final void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(char[] append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints) {\n            ensureAttributeValue();\n            for (int codepoint : appendCodepoints) {\n                pendingAttributeValue.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }\n\n        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }\n    }\n\n    final static class StartTag extends Tag {\n        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = new Attributes();\n            // todo - would prefer these to be null, but need to check Element assertions\n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = lowerCase(tagName);\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    final static class EndTag extends Tag{\n        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    final static class Comment extends Token {\n        final StringBuilder data = new StringBuilder();\n        boolean bogus = false;\n\n        @Override\n        Token reset() {\n            reset(data);\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    static class Character extends Token {\n        private String data;\n\n        Character() {\n            super();\n            type = TokenType.Character;\n        }\n\n        @Override\n        Token reset() {\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    final static class CData extends Character {\n        CData(String data) {\n            super();\n            this.data(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"<![CDATA[\" + getData() + \"]]>\";\n        }\n\n    }\n\n    final static class EOF extends Token {\n        EOF() {\n            type = Token.TokenType.EOF;\n        }\n\n        @Override\n        Token reset() {\n            return this;\n        }\n    }\n\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    final Comment asComment() {\n        return (Comment) this;\n    }\n\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    final boolean isCData() {\n        return this instanceof CData;\n    }\n\n    final Character asCharacter() {\n        return (Character) this;\n    }\n\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    public enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character, // note no CData - treated in builder as an extension of Character\n        EOF\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "53",
        "class": "TokenQueue",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n/**\n * A character queue with parsing helpers.\n *\n * @author Jonathan Hedley\n */\npublic class TokenQueue {\n    private String queue;\n    private int pos = 0;\n    \n    private static final char ESC = '\\\\'; // escape char for chomp balanced.\n\n    /**\n     Create a new TokenQueue.\n     @param data string of data to back queue.\n     */\n    public TokenQueue(String data) {\n        Validate.notNull(data);\n        queue = data;\n    }\n\n    /**\n     * Is the queue empty?\n     * @return true if no data left in queue.\n     */\n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }\n    \n    private int remainingLength() {\n        return queue.length() - pos;\n    }\n\n    /**\n     * Retrieves but does not remove the first character from the queue.\n     * @return First character, or 0 if empty.\n     */\n    public char peek() {\n        return isEmpty() ? 0 : queue.charAt(pos);\n    }\n\n    /**\n     Add a character to the start of the queue (will be the next character retrieved).\n     @param c character to add\n     */\n    public void addFirst(Character c) {\n        addFirst(c.toString());\n    }\n\n    /**\n     Add a string to the start of the queue.\n     @param seq string to add.\n     */\n    public void addFirst(String seq) {\n        // not very performant, but an edge case\n        queue = seq + queue.substring(pos);\n        pos = 0;\n    }\n\n    /**\n     * Tests if the next characters on the queue match the sequence. Case insensitive.\n     * @param seq String to check queue for.\n     * @return true if the next characters match.\n     */\n    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    /**\n     * Case sensitive match test.\n     * @param seq string to case sensitively check for\n     * @return true if matched, false if not\n     */\n    public boolean matchesCS(String seq) {\n        return queue.startsWith(seq, pos);\n    }\n    \n\n    /**\n     Tests if the next characters match any of the sequences. Case insensitive.\n     @param seq list of strings to case insensitively check for\n     @return true of any matched, false if none did\n     */\n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesStartTag() {\n        // micro opt for matching \"<x\"\n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }\n\n    /**\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     */\n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     Tests if queue starts with a whitespace character.\n     @return if starts with whitespace\n     */\n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }\n\n    /**\n     Test if the queue matches a word character (letter or digit).\n     @return if matches a word character\n     */\n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }\n\n    /**\n     * Drops the next character off the queue.\n     */\n    public void advance() {\n        if (!isEmpty()) pos++;\n    }\n\n    /**\n     * Consume one character off queue.\n     * @return first character on queue.\n     */\n    public char consume() {\n        return queue.charAt(pos++);\n    }\n\n    /**\n     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\n     * throw an illegal state exception -- but you should be running match() against that condition.\n     <p>\n     Case insensitive.\n     * @param seq sequence to remove from head of queue.\n     */\n    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }\n\n    /**\n     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n     * @return The matched data consumed from queue.\n     */\n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }\n    \n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.\n     @param seq any number of terminators to consume to. <b>Case insensitive.</b>\n     @return consumed string   \n     */\n    // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this\n    // is is a case sensitive time...\n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n     * @return Data matched from queue.\n     */\n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }\n    \n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }\n\n    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }\n    \n    /**\n     * Unescaped a \\ escaped string.\n     * @param in backslash escaped string\n     * @return unescaped string\n     */\n    public static String unescape(String in) {\n        StringBuilder out = new StringBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last != 0 && last == ESC)\n                    out.append(c);\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return out.toString();\n    }\n\n    /**\n     * Pulls the next run of whitespace characters of the queue.\n     * @return Whether consuming whitespace or not\n     */\n    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }\n\n    /**\n     * Retrieves the next run of word type (letter or digit) off the queue.\n     * @return String of word characters from queue, or empty string if none.\n     */\n    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }\n    \n    /**\n     * Consume an tag name off the queue (word or :, _, -)\n     * \n     * @return tag name\n     */\n    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n    \n    /**\n     * Consume a CSS element selector (tag name, but | instead of : for namespaces, to not conflict with :pseudo selects).\n     * \n     * @return tag name\n     */\n    public String consumeElementSelector() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)\n     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier\n     @return identifier\n     */\n    public String consumeCssIdentifier() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))\n            pos++;\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consume an attribute key off the queue (letter, digit, -, _, :\")\n     @return attribute key\n     */\n    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consume and return whatever is left on the queue.\n     @return remained of queue.\n     */\n    public String remainder() {\n        final String remainder = queue.substring(pos, queue.length());\n        pos = queue.length();\n        return remainder;\n    }\n    \n    @Override\n    public String toString() {\n        return queue.substring(pos);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "21",
        "class": "QueryParser",
        "fqdn": "org.jsoup.select",
        "source_code": "package org.jsoup.select;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.TokenQueue;\n\n/**\n * Parses a CSS selector into an Evaluator tree.\n */\nclass QueryParser {\n    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n\n    private TokenQueue tq;\n    private String query;\n    private List<Evaluator> evals = new ArrayList<Evaluator>();\n\n    /**\n     * Create a new QueryParser.\n     * @param query CSS query\n     */\n    private QueryParser(String query) {\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }\n\n    /**\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     */\n    public static Evaluator parse(String query) {\n        QueryParser p = new QueryParser(query);\n        return p.parse();\n    }\n\n    /**\n     * Parse the query\n     * @return Evaluator\n     */\n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchChomp(\",\")) {\n                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n                evals.clear();\n                evals.add(or);\n                while (!tq.isEmpty()) {\n                    String subQuery = tq.chompTo(\",\");\n                    or.add(parse(subQuery));\n                }\n            } else if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n        Evaluator e;\n\n        if (evals.size() == 1)\n            e = evals.get(0);\n        else\n            e = new CombiningEvaluator.And(evals);\n        evals.clear();\n        Evaluator f = parse(subQuery);\n\n        if (combinator == '>')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n        else if (combinator == ' ')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n        else if (combinator == '+')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n        else if (combinator == '~')\n            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq = new StringBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return sq.toString();\n    }\n\n    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord())\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n        else // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }\n\n    private void byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        evals.add(new Evaluator.Id(id));\n    }\n\n    private void byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        evals.add(new Evaluator.Class(className.trim().toLowerCase()));\n    }\n\n    private void byTag() {\n        String tagName = tq.consumeElementSelector();\n        Validate.notEmpty(tagName);\n\n        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n        if (tagName.contains(\"|\"))\n            tagName = tagName.replace(\"|\", \":\");\n\n        evals.add(new Evaluator.Tag(tagName.trim().toLowerCase()));\n    }\n\n    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private void allElements() {\n        evals.add(new Evaluator.AllElements());\n    }\n\n    // pseudo selectors :lt, :gt, :eq\n    private void indexLessThan() {\n        evals.add(new Evaluator.IndexLessThan(consumeIndex()));\n    }\n\n    private void indexGreaterThan() {\n        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n    }\n\n    private void indexEquals() {\n        evals.add(new Evaluator.IndexEquals(consumeIndex()));\n    }\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    // pseudo selector :has(el)\n    private void has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n        evals.add(new StructuralEvaluator.Has(parse(subQuery)));\n    }\n\n    // pseudo selector :contains(text), containsOwn(text)\n    private void contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        if (own)\n            evals.add(new Evaluator.ContainsOwnText(searchText));\n        else\n            evals.add(new Evaluator.ContainsText(searchText));\n    }\n\n    // :matches(regex), matchesOwn(regex)\n    private void matches(boolean own) {\n        tq.consume(own ? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n\n        if (own)\n            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n        else\n            evals.add(new Evaluator.Matches(Pattern.compile(regex)));\n    }\n\n    // :not(selector)\n    private void not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        evals.add(new StructuralEvaluator.Not(parse(subQuery)));\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "58",
        "class": "Jsoup",
        "fqdn": "org.jsoup",
        "source_code": "package org.jsoup;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.safety.Cleaner;\nimport org.jsoup.safety.Whitelist;\nimport org.jsoup.helper.DataUtil;\nimport org.jsoup.helper.HttpConnection;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\n/**\n The core public access point to the jsoup functionality.\n\n @author Jonathan Hedley */\npublic class Jsoup {\n    private Jsoup() {}\n\n    /**\n     Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.\n\n     @param html    HTML to parse\n     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n     before the HTML declares a {@code <base href>} tag.\n     @return sane HTML\n     */\n    public static Document parse(String html, String baseUri) {\n        return Parser.parse(html, baseUri);\n    }\n\n    /**\n     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.\n\n     @param html    HTML to parse\n     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n     before the HTML declares a {@code <base href>} tag.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n     */\n    public static Document parse(String html, String baseUri, Parser parser) {\n        return parser.parseInput(html, baseUri);\n    }\n\n    /**\n     Parse HTML into a Document. As no base URI is specified, absolute URL detection relies on the HTML including a\n     {@code <base href>} tag.\n\n     @param html HTML to parse\n     @return sane HTML\n\n     @see #parse(String, String)\n     */\n    public static Document parse(String html) {\n        return Parser.parse(html, \"\");\n    }\n\n    /**\n     * Creates a new {@link Connection} to a URL. Use to fetch and parse a HTML page.\n     * <p>\n     * Use examples:\n     * <ul>\n     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").userAgent(\"Mozilla\").data(\"name\", \"jsoup\").get();</code></li>\n     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").cookie(\"auth\", \"token\").post();</code></li>\n     * </ul>\n     * @param url URL to connect to. The protocol must be {@code http} or {@code https}.\n     * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.\n     */\n    public static Connection connect(String url) {\n        return HttpConnection.connect(url);\n    }\n\n    /**\n     Parse the contents of a file as HTML.\n\n     @param in          file to load HTML from\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(File in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }\n\n    /**\n     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n\n     @param in          file to load HTML from\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     @see #parse(File, String, String)\n     */\n    public static Document parse(File in, String charsetName) throws IOException {\n        return DataUtil.load(in, charsetName, in.getAbsolutePath());\n    }\n\n     /**\n     Read an input stream, and parse it to a Document.\n\n     @param in          input stream to read. Make sure to close it after parsing.\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }\n\n    /**\n     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.\n\n     @param in          input stream to read. Make sure to close it after parsing.\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n\n    /**\n     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n     @param bodyHtml body HTML fragment\n     @param baseUri  URL to resolve relative URLs against.\n     @return sane HTML document\n\n     @see Document#body()\n     */\n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        return Parser.parseBodyFragment(bodyHtml, baseUri);\n    }\n\n    /**\n     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n     @param bodyHtml body HTML fragment\n     @return sane HTML document\n\n     @see Document#body()\n     */\n    public static Document parseBodyFragment(String bodyHtml) {\n        return Parser.parseBodyFragment(bodyHtml, \"\");\n    }\n\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n\n    /**\n     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted\n     tags and attributes.\n\n     @param bodyHtml  input untrusted HTML (body fragment)\n     @param baseUri   URL to resolve relative URLs against\n     @param whitelist white-list of permitted HTML elements\n     @return safe HTML (body fragment)\n\n     @see Cleaner#clean(Document)\n     */\n    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        return clean.body().html();\n    }\n\n    /**\n     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted\n     tags and attributes.\n\n     @param bodyHtml  input untrusted HTML (body fragment)\n     @param whitelist white-list of permitted HTML elements\n     @return safe HTML (body fragment)\n\n     @see Cleaner#clean(Document)\n     */\n    public static String clean(String bodyHtml, Whitelist whitelist) {\n        return clean(bodyHtml, \"\", whitelist);\n    }\n\n    /**\n     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of\n     * permitted tags and attributes.\n     * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an\n     * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add\n     * structural tags (<code>html, head, body</code> etc) to the whitelist.\n     *\n     * @param bodyHtml input untrusted HTML (body fragment)\n     * @param baseUri URL to resolve relative URLs against\n     * @param whitelist white-list of permitted HTML elements\n     * @param outputSettings document output settings; use to control pretty-printing and entity escape modes\n     * @return safe HTML (body fragment)\n     * @see Cleaner#clean(Document)\n     */\n    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(whitelist);\n        Document clean = cleaner.clean(dirty);\n        clean.outputSettings(outputSettings);\n        return clean.body().html();\n    }\n\n    /**\n     Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.\n     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.\n     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n     @param bodyHtml HTML to test\n     @param whitelist whitelist to test against\n     @return true if no tags or attributes were removed; false otherwise\n     @see #clean(String, org.jsoup.safety.Whitelist) \n     */\n    public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n        return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n    }\n    \n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "58",
        "class": "Cleaner",
        "fqdn": "org.jsoup.safety",
        "source_code": "package org.jsoup.safety;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.DataNode;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.jsoup.parser.ParseErrorList;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.select.NodeTraversor;\nimport org.jsoup.select.NodeVisitor;\n\n\n\n/**\n The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes\n that you are expecting; no junk, and no cross-site scripting attacks!\n <p>\n The HTML cleaner parses the input as HTML and then runs it through a white-list, so the output HTML can only contain\n HTML that is allowed by the whitelist.\n </p>\n <p>\n It is assumed that the input HTML is a body fragment; the clean methods only pull from the source's body, and the\n canned white-lists only allow body contained tags.\n </p>\n <p>\n Rather than interacting directly with a Cleaner object, generally see the {@code clean} methods in {@link org.jsoup.Jsoup}.\n </p>\n */\npublic class Cleaner {\n    private Whitelist whitelist;\n\n    /**\n     Create a new cleaner, that sanitizes documents using the supplied whitelist.\n     @param whitelist white-list to clean with\n     */\n    public Cleaner(Whitelist whitelist) {\n        Validate.notNull(whitelist);\n        this.whitelist = whitelist;\n    }\n\n    /**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n\n    /**\n     Determines if the input document <b>body</b>is valid, against the whitelist. It is considered valid if all the tags and attributes\n     in the input HTML are allowed by the whitelist, and that there is no content in the <code>head</code>.\n     <p>\n     This method can be used as a validator for user input. An invalid document will still be cleaned successfully\n     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n     to ensure enforced attributes are set correctly, and that the output is tidied.\n     </p>\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */\n    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0;\n    }\n\n\n    /**\n     Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.\n     */\n    private final class CleaningVisitor implements NodeVisitor {\n        private int numDiscarded = 0;\n        private final Element root;\n        private Element destination; // current element to append nodes to\n\n        private CleaningVisitor(Element root, Element destination) {\n            this.root = root;\n            this.destination = destination;\n        }\n\n        public void head(Node source, int depth) {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs\n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && whitelist.isSafeTag(source.parent().nodeName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData(), source.baseUri());\n              destination.appendChild(destData);\n            } else { // else, we don't care about comments, xml proc instructions, etc\n                numDiscarded++;\n            }\n        }\n\n        public void tail(Node source, int depth) {\n            if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) {\n                destination = destination.parent(); // would have descended, so pop destination stack\n            }\n        }\n    }\n\n    private int copySafeNodes(Element source, Element dest) {\n        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n        NodeTraversor traversor = new NodeTraversor(cleaningVisitor);\n        traversor.traverse(source);\n        return cleaningVisitor.numDiscarded;\n    }\n\n    private ElementMeta createSafeElement(Element sourceEl) {\n        String sourceTag = sourceEl.tagName();\n        Attributes destAttrs = new Attributes();\n        Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs);\n        int numDiscarded = 0;\n\n        Attributes sourceAttrs = sourceEl.attributes();\n        for (Attribute sourceAttr : sourceAttrs) {\n            if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr))\n                destAttrs.put(sourceAttr);\n            else\n                numDiscarded++;\n        }\n        Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag);\n        destAttrs.addAll(enforcedAttrs);\n\n        return new ElementMeta(dest, numDiscarded);\n    }\n\n    private static class ElementMeta {\n        Element el;\n        int numAttribsDiscarded;\n\n        ElementMeta(Element el, int numAttribsDiscarded) {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }\n    }\n\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "58",
        "class": "Parser",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.List;\n\n/**\n * Parses HTML into a {@link org.jsoup.nodes.Document}. Generally best to use one of the  more convenient parse methods\n * in {@link org.jsoup.Jsoup}.\n */\npublic class Parser {\n    private static final int DEFAULT_MAX_ERRORS = 0; // by default, error tracking is disabled.\n    \n    private TreeBuilder treeBuilder;\n    private int maxErrors = DEFAULT_MAX_ERRORS;\n    private ParseErrorList errors;\n    private ParseSettings settings;\n\n    /**\n     * Create a new Parser, using the specified TreeBuilder\n     * @param treeBuilder TreeBuilder to use to parse input into Documents.\n     */\n    public Parser(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        settings = treeBuilder.defaultSettings();\n    }\n    \n    public Document parseInput(String html, String baseUri) {\n        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n        return treeBuilder.parse(html, baseUri, errors, settings);\n    }\n\n    // gets & sets\n    /**\n     * Get the TreeBuilder currently in use.\n     * @return current TreeBuilder.\n     */\n    public TreeBuilder getTreeBuilder() {\n        return treeBuilder;\n    }\n\n    /**\n     * Update the TreeBuilder used when parsing content.\n     * @param treeBuilder current TreeBuilder\n     * @return this, for chaining\n     */\n    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        return this;\n    }\n\n    /**\n     * Check if parse error tracking is enabled.\n     * @return current track error state.\n     */\n    public boolean isTrackErrors() {\n        return maxErrors > 0;\n    }\n\n    /**\n     * Enable or disable parse error tracking for the next parse.\n     * @param maxErrors the maximum number of errors to track. Set to 0 to disable.\n     * @return this, for chaining\n     */\n    public Parser setTrackErrors(int maxErrors) {\n        this.maxErrors = maxErrors;\n        return this;\n    }\n\n    /**\n     * Retrieve the parse errors, if any, from the last parse.\n     * @return list of parse errors, up to the size of the maximum errors tracked.\n     */\n    public List<ParseError> getErrors() {\n        return errors;\n    }\n\n    public Parser settings(ParseSettings settings) {\n        this.settings = settings;\n        return this;\n    }\n\n    public ParseSettings settings() {\n        return settings;\n    }\n\n    // static parse functions below\n    /**\n     * Parse HTML into a Document.\n     *\n     * @param html HTML to parse\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return parsed Document\n     */\n    public static Document parse(String html, String baseUri) {\n        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    /**\n     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n     *\n     * @param fragmentHtml the fragment of HTML to parse\n     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n     * provides stack context (for implicit element creation).\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n     */\n    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    /**\n     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n     *\n     * @param fragmentHtml the fragment of HTML to parse\n     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n     * provides stack context (for implicit element creation).\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     * @param errorList list to add errors to\n     *\n     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n     */\n\n    /**\n     * Parse a fragment of XML into a list of nodes.\n     *\n     * @param fragmentXml the fragment of XML to parse\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     * @return list of nodes parsed from the input XML.\n     */\n    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n    }\n\n    /**\n     * Parse a fragment of HTML into the {@code body} of a Document.\n     *\n     * @param bodyHtml fragment of HTML\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return Document, with empty head, and HTML parsed into body\n     */\n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Document doc = Document.createShell(baseUri);\n        Element body = doc.body();\n        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n        Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented\n        for (int i = nodes.length - 1; i > 0; i--) {\n            nodes[i].remove();\n        }\n        for (Node node : nodes) {\n            body.appendChild(node);\n        }\n        return doc;\n    }\n\n    /**\n     * Utility method to unescape HTML entities from a string\n     * @param string HTML escaped string\n     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)\n     * @return an unescaped string\n     */\n    public static String unescapeEntities(String string, boolean inAttribute) {\n        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());\n        return tokeniser.unescapeEntities(inAttribute);\n    }\n\n    /**\n     * @param bodyHtml HTML to parse\n     * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return parsed Document\n     * @deprecated Use {@link #parseBodyFragment} or {@link #parseFragment} instead.\n     */\n    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n        return parse(bodyHtml, baseUri);\n    }\n    \n    // builders\n\n    /**\n     * Create a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,\n     * based on a knowledge of the semantics of the incoming tags.\n     * @return a new HTML parser.\n     */\n    public static Parser htmlParser() {\n        return new Parser(new HtmlTreeBuilder());\n    }\n\n    /**\n     * Create a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,\n     * rather creates a simple tree directly from the input.\n     * @return a new simple XML parser.\n     */\n    public static Parser xmlParser() {\n        return new Parser(new XmlTreeBuilder());\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "28",
        "class": "Entities",
        "fqdn": "org.jsoup.nodes",
        "source_code": "package org.jsoup.nodes;\n\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.CharsetEncoder;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * HTML entities, and escape routines.\n * Source: <a href=\"http://www.w3.org/TR/html5/named-character-references.html#named-character-references\">W3C HTML\n * named character references</a>.\n */\npublic class Entities {\n    public enum EscapeMode {\n        /** Restricted entities suitable for XHTML output: lt, gt, amp, apos, and quot only. */\n        xhtml(xhtmlByVal),\n        /** Default HTML output entities. */\n        base(baseByVal),\n        /** Complete HTML entities. */\n        extended(fullByVal);\n\n        private Map<Character, String> map;\n\n        EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full;\n    private static final Map<Character, String> xhtmlByVal;\n    private static final Map<String, Character> base;\n    private static final Map<Character, String> baseByVal;\n    private static final Map<Character, String> fullByVal;\n    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");\n    private static final Pattern strictUnescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);\");\n\n    private Entities() {}\n\n    /**\n     * Check if the input is a known named entity\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity\n     */\n    public static boolean isNamedEntity(String name) {\n        return full.containsKey(name);\n    }\n\n    /**\n     * Check if the input is a known named entity in the base entity set.\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity in the base set\n     * @see #isNamedEntity(String)\n     */\n\n    /**\n     * Get the Character value of the named entity\n     * @param name named entity (e.g. \"lt\" or \"amp\")\n     * @return the Character value of the named entity (e.g. '<' or '&')\n     */\n    public static Character getCharacterByName(String name) {\n        return full.get(name);\n    }\n    \n    static String escape(String string, Document.OutputSettings out) {\n        return escape(string, out.encoder(), out.escapeMode());\n    }\n\n    static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        Map<Character, String> map = escapeMode.getMap();\n\n        for (int pos = 0; pos < string.length(); pos++) {\n            Character c = string.charAt(pos);\n            if (map.containsKey(c))\n                accum.append('&').append(map.get(c)).append(';');\n            else if (encoder.canEncode(c))\n                accum.append(c.charValue());\n            else\n                accum.append(\"&#\").append((int) c).append(';');\n        }\n\n        return accum.toString();\n    }\n\n    static String unescape(String string) {\n        return unescape(string, false);\n    }\n\n    /**\n     * Unescape the input string.\n     * @param string\n     * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n     * @return\n     */\n    static String unescape(String string, boolean strict) {\n        if (!string.contains(\"&\"))\n            return string;\n        Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);\n        StringBuffer accum = new StringBuffer(string.length());\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10;\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                }\n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n            if (charval != -1 || charval > 0xFFFF) {\n                String c = Character.toString((char) charval);\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n\n    // xhtml has restricted entities\n    private static final Object[][] xhtmlArray = {\n            {\"quot\", 0x00022},\n            {\"amp\", 0x00026},\n            {\"apos\", 0x00027},\n            {\"lt\", 0x0003C},\n            {\"gt\", 0x0003E}\n    };\n\n    static {\n        xhtmlByVal = new HashMap<Character, String>();\n        base = loadEntities(\"entities-base.properties\");  // most common / default\n        baseByVal = toCharacterKey(base);\n        full = loadEntities(\"entities-full.properties\"); // extended and overblown.\n        fullByVal = toCharacterKey(full);\n\n        for (Object[] entity : xhtmlArray) {\n            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n            xhtmlByVal.put(c, ((String) entity[0]));\n        }\n    }\n\n    private static Map<String, Character> loadEntities(String filename) {\n        Properties properties = new Properties();\n        Map<String, Character> entities = new HashMap<String, Character>();\n        try {\n            InputStream in = Entities.class.getResourceAsStream(filename);\n            properties.load(in);\n            in.close();\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n        }\n\n        for (Map.Entry entry: properties.entrySet()) {\n            Character val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\n            String name = (String) entry.getKey();\n            entities.put(name, val);\n        }\n        return entities;\n    }\n\n    private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\n        Map<Character, String> outMap = new HashMap<Character, String>();\n        for (Map.Entry<String, Character> entry: inMap.entrySet()) {\n            Character character = entry.getValue();\n            String name = entry.getKey();\n\n            if (outMap.containsKey(character)) {\n                // dupe, prefer the lower case version\n                if (name.toLowerCase().equals(name))\n                    outMap.put(character, name);\n            } else {\n                outMap.put(character, name);\n            }\n        }\n        return outMap;\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "28",
        "class": "Tokeniser",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Entities;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Readers the input stream into tokens.\n */\nclass Tokeniser {\n    static final char replacementChar = '\\uFFFD'; // replaces null character\n\n    private CharacterReader reader; // html input\n    private ParseErrorList errors; // errors found while tokenising\n\n    private TokeniserState state = TokeniserState.Data; // current tokenisation state\n    private Token emitPending; // the token we are about to emit on next read\n    private boolean isEmitPending = false;\n    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n    StringBuilder dataBuffer; // buffers data looking for </script>\n\n    Token.Tag tagPending; // tag we are building up\n    Token.Doctype doctypePending; // doctype building up\n    Token.Comment commentPending; // comment building up\n    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n    private boolean selfClosingFlagAcknowledged = true;\n\n    Tokeniser(CharacterReader reader, ParseErrorList errors) {\n        this.reader = reader;\n        this.errors = errors;\n    }\n\n    Token read() {\n        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        if (charBuffer.length() > 0) {\n            String str = charBuffer.toString();\n            charBuffer.delete(0, charBuffer.length());\n            return new Token.Character(str);\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes != null)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }\n\n    void emit(String str) {\n        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n        // does not set isEmitPending; read checks that\n        charBuffer.append(str);\n    }\n\n    void emit(char c) {\n        charBuffer.append(c);\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState state) {\n        this.state = state;\n    }\n\n    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }\n\n    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }\n\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities.\n            String nameRef = reader.consumeLetterThenDigitSequence();\n            String origNameRef = new String(nameRef);\n            boolean looksLegit = reader.matches(';');\n            // found if a base named entity without a ;, or an extended entity with the ;.\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) // named with semicolon\n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending = new Token.Comment();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createDoctypePending() {\n        doctypePending = new Token.Doctype();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        dataBuffer = new StringBuilder();\n    }\n\n    boolean isAppropriateEndTagToken() {\n        if (lastStartTag == null)\n            return false;\n        return tagPending.tagName.equals(lastStartTag.tagName);\n    }\n\n    String appropriateEndTagName() {\n        return lastStartTag.tagName;\n    }\n\n    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }\n\n    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }\n\n    private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }\n\n    private void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), errorMsg));\n    }\n\n    boolean currentNodeInHtmlNS() {\n        // todo: implement namespaces correctly\n        return true;\n        // Element currentNode = currentNode();\n        // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n    }\n\n    /**\n     * Utility method to consume reader and unescape entities found within.\n     * @param inAttribute\n     * @return unescaped string from reader\n     */\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "28",
        "class": "Parser",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\n\nimport java.util.List;\n\n/**\n * Parses HTML into a {@link org.jsoup.nodes.Document}. Generally best to use one of the  more convenient parse methods\n * in {@link org.jsoup.Jsoup}.\n */\npublic class Parser {\n    private static final int DEFAULT_MAX_ERRORS = 0; // by default, error tracking is disabled.\n    \n    private TreeBuilder treeBuilder;\n    private int maxErrors = DEFAULT_MAX_ERRORS;\n    private ParseErrorList errors;\n\n    /**\n     * Create a new Parser, using the specified TreeBuilder\n     * @param treeBuilder TreeBuilder to use to parse input into Documents.\n     */\n    public Parser(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n    }\n    \n    public Document parseInput(String html, String baseUri) {\n        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n        Document doc = treeBuilder.parse(html, baseUri, errors);\n        return doc;\n    }\n\n    // gets & sets\n    /**\n     * Get the TreeBuilder currently in use.\n     * @return current TreeBuilder.\n     */\n    public TreeBuilder getTreeBuilder() {\n        return treeBuilder;\n    }\n\n    /**\n     * Update the TreeBuilder used when parsing content.\n     * @param treeBuilder current TreeBuilder\n     * @return this, for chaining\n     */\n    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        return this;\n    }\n\n    /**\n     * Check if parse error tracking is enabled.\n     * @return current track error state.\n     */\n    public boolean isTrackErrors() {\n        return maxErrors > 0;\n    }\n\n    /**\n     * Enable or disable parse error tracking for the next parse.\n     * @param maxErrors the maximum number of errors to track. Set to 0 to disable.\n     * @return this, for chaining\n     */\n    public Parser setTrackErrors(int maxErrors) {\n        this.maxErrors = maxErrors;\n        return this;\n    }\n\n    /**\n     * Retrieve the parse errors, if any, from the last parse.\n     * @return list of parse errors, up to the size of the maximum errors tracked.\n     */\n    public List<ParseError> getErrors() {\n        return errors;\n    }\n\n    // static parse functions below\n    /**\n     * Parse HTML into a Document.\n     *\n     * @param html HTML to parse\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return parsed Document\n     */\n    public static Document parse(String html, String baseUri) {\n        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking());\n    }\n\n    /**\n     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n     *\n     * @param fragmentHtml the fragment of HTML to parse\n     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n     * provides stack context (for implicit element creation).\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n     */\n    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking());\n    }\n\n    /**\n     * Parse a fragment of HTML into the {@code body} of a Document.\n     *\n     * @param bodyHtml fragment of HTML\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return Document, with empty head, and HTML parsed into body\n     */\n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Document doc = Document.createShell(baseUri);\n        Element body = doc.body();\n        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n        Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented\n        for (Node node : nodes) {\n            body.appendChild(node);\n        }\n        return doc;\n    }\n\n    /**\n     * Utility method to unescape HTML entities from a string\n     * @param string HTML escaped string\n     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)\n     * @return an unescaped string\n     */\n\n    /**\n     * @param bodyHtml HTML to parse\n     * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return parsed Document\n     * @deprecated Use {@link #parseBodyFragment} or {@link #parseFragment} instead.\n     */\n    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n        return parse(bodyHtml, baseUri);\n    }\n    \n    // builders\n\n    /**\n     * Create a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,\n     * based on a knowledge of the semantics of the incoming tags.\n     * @return a new HTML parser.\n     */\n    public static Parser htmlParser() {\n        return new Parser(new HtmlTreeBuilder());\n    }\n\n    /**\n     * Create a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,\n     * rather creates a simple tree directly from the input.\n     * @return a new simple XML parser.\n     */\n    public static Parser xmlParser() {\n        return new Parser(new XmlTreeBuilder());\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "34",
        "class": "CharacterReader",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        int start = pos;\n\n        OUTER: while (pos < length) {\n            for (int i = 0; i < chars.length; i++) {\n                if (input[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? new String(input, start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = new String(input, pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return new String(input, start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return new String(input, start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "51",
        "class": "CharacterReader",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\nimport java.util.Arrays;\nimport java.util.Locale;\n\n/**\n CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n */\nfinal class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int maxCacheLen = 12;\n\n    private final char[] input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        this.input = input.toCharArray();\n        this.length = this.input.length;\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return pos >= length ? EOF : input[pos];\n    }\n\n    char consume() {\n        char val = pos >= length ? EOF : input[pos];\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return new String(input, pos++, 1);\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(final char... chars) {\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        OUTER: while (pos < remaining) {\n            for (char c : chars) {\n                if (val[pos] == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        final int start = pos;\n        final int remaining = length;\n        final char[] val = input;\n\n        while (pos < remaining) {\n            final char c = val[pos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            pos++;\n        }\n\n        return pos > start ? cacheString(start, pos-start) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = cacheString(pos, length-pos);\n        pos = length;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n\n        return cacheString(start, pos - start);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (pos < length) {\n            char c = input[pos];\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return cacheString(start, pos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input[pos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != input[pos+offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        int scanLength = seq.length();\n        if (scanLength > length - pos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return new String(input, pos, length - pos);\n    }\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private String cacheString(final int start, final int count) {\n        final char[] val = input;\n        final String[] cache = stringCache;\n\n        // limit (no cache):\n        if (count > maxCacheLen)\n            return new String(val, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + val[offset++];\n        }\n\n        // get from cache\n        final int index = hash & cache.length - 1;\n        String cached = cache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(val, start, count);\n            cache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(val, start, count);\n                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    boolean rangeEquals(final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            char one[] = input;\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (one[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "60",
        "class": "TokenQueue",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n/**\n * A character queue with parsing helpers.\n *\n * @author Jonathan Hedley\n */\npublic class TokenQueue {\n    private String queue;\n    private int pos = 0;\n    \n    private static final char ESC = '\\\\'; // escape char for chomp balanced.\n\n    /**\n     Create a new TokenQueue.\n     @param data string of data to back queue.\n     */\n    public TokenQueue(String data) {\n        Validate.notNull(data);\n        queue = data;\n    }\n\n    /**\n     * Is the queue empty?\n     * @return true if no data left in queue.\n     */\n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }\n    \n    private int remainingLength() {\n        return queue.length() - pos;\n    }\n\n    /**\n     * Retrieves but does not remove the first character from the queue.\n     * @return First character, or 0 if empty.\n     */\n    public char peek() {\n        return isEmpty() ? 0 : queue.charAt(pos);\n    }\n\n    /**\n     Add a character to the start of the queue (will be the next character retrieved).\n     @param c character to add\n     */\n    public void addFirst(Character c) {\n        addFirst(c.toString());\n    }\n\n    /**\n     Add a string to the start of the queue.\n     @param seq string to add.\n     */\n    public void addFirst(String seq) {\n        // not very performant, but an edge case\n        queue = seq + queue.substring(pos);\n        pos = 0;\n    }\n\n    /**\n     * Tests if the next characters on the queue match the sequence. Case insensitive.\n     * @param seq String to check queue for.\n     * @return true if the next characters match.\n     */\n    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    /**\n     * Case sensitive match test.\n     * @param seq string to case sensitively check for\n     * @return true if matched, false if not\n     */\n    public boolean matchesCS(String seq) {\n        return queue.startsWith(seq, pos);\n    }\n    \n\n    /**\n     Tests if the next characters match any of the sequences. Case insensitive.\n     @param seq list of strings to case insensitively check for\n     @return true of any matched, false if none did\n     */\n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesStartTag() {\n        // micro opt for matching \"<x\"\n        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetter(queue.charAt(pos+1)));\n    }\n\n    /**\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     */\n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     Tests if queue starts with a whitespace character.\n     @return if starts with whitespace\n     */\n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }\n\n    /**\n     Test if the queue matches a word character (letter or digit).\n     @return if matches a word character\n     */\n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }\n\n    /**\n     * Drops the next character off the queue.\n     */\n    public void advance() {\n        if (!isEmpty()) pos++;\n    }\n\n    /**\n     * Consume one character off queue.\n     * @return first character on queue.\n     */\n    public char consume() {\n        return queue.charAt(pos++);\n    }\n\n    /**\n     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\n     * throw an illegal state exception -- but you should be running match() against that condition.\n     <p>\n     Case insensitive.\n     * @param seq sequence to remove from head of queue.\n     */\n    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }\n\n    /**\n     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n     * @return The matched data consumed from queue.\n     */\n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }\n    \n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.\n     @param seq any number of terminators to consume to. <b>Case insensitive.</b>\n     @return consumed string   \n     */\n    // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this\n    // is is a case sensitive time...\n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n     * @return Data matched from queue.\n     */\n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }\n    \n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }\n\n    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        return out;\n    }\n    \n    /**\n     * Unescaped a \\ escaped string.\n     * @param in backslash escaped string\n     * @return unescaped string\n     */\n    public static String unescape(String in) {\n        StringBuilder out = new StringBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last != 0 && last == ESC)\n                    out.append(c);\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return out.toString();\n    }\n\n    /**\n     * Pulls the next run of whitespace characters of the queue.\n     * @return Whether consuming whitespace or not\n     */\n    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }\n\n    /**\n     * Retrieves the next run of word type (letter or digit) off the queue.\n     * @return String of word characters from queue, or empty string if none.\n     */\n    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }\n    \n    /**\n     * Consume an tag name off the queue (word or :, _, -)\n     * \n     * @return tag name\n     */\n    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n    \n    /**\n     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).\n     * \n     * @return tag name\n     */\n    public String consumeElementSelector() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(\"*|\",\"|\", \"_\", \"-\")))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)\n     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier\n     @return identifier\n     */\n    public String consumeCssIdentifier() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_')))\n            pos++;\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consume an attribute key off the queue (letter, digit, -, _, :\")\n     @return attribute key\n     */\n    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consume and return whatever is left on the queue.\n     @return remained of queue.\n     */\n    public String remainder() {\n        final String remainder = queue.substring(pos, queue.length());\n        pos = queue.length();\n        return remainder;\n    }\n    \n    @Override\n    public String toString() {\n        return queue.substring(pos);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "60",
        "class": "QueryParser",
        "fqdn": "org.jsoup.select",
        "source_code": "package org.jsoup.select;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.TokenQueue;\n\n/**\n * Parses a CSS selector into an Evaluator tree.\n */\npublic class QueryParser {\n    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n    private static final String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"};\n\n    private TokenQueue tq;\n    private String query;\n    private List<Evaluator> evals = new ArrayList<Evaluator>();\n\n    /**\n     * Create a new QueryParser.\n     * @param query CSS query\n     */\n    private QueryParser(String query) {\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }\n\n    /**\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     */\n    public static Evaluator parse(String query) {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n    }\n\n    /**\n     * Parse the query\n     * @return Evaluator\n     */\n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n\n        Evaluator rootEval; // the new topmost evaluator\n        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.\n        Evaluator newEval = parse(subQuery); // the evaluator to add into target evaluator\n        boolean replaceRightMost = false;\n\n        if (evals.size() == 1) {\n            rootEval = currentEval = evals.get(0);\n            // make sure OR (,) has precedence:\n            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                replaceRightMost = true;\n            }\n        }\n        else {\n            rootEval = currentEval = new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        // for most combinators: change the current eval into an AND of the current eval and the new eval\n        if (combinator == '>')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediateParent(currentEval));\n        else if (combinator == ' ')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.Parent(currentEval));\n        else if (combinator == '+')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediatePreviousSibling(currentEval));\n        else if (combinator == '~')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.PreviousSibling(currentEval));\n        else if (combinator == ',') { // group or.\n            CombiningEvaluator.Or or;\n            if (currentEval instanceof CombiningEvaluator.Or) {\n                or = (CombiningEvaluator.Or) currentEval;\n                or.add(newEval);\n            } else {\n                or = new CombiningEvaluator.Or();\n                or.add(currentEval);\n                or.add(newEval);\n            }\n            currentEval = or;\n        }\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval = currentEval;\n        evals.add(rootEval);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq = new StringBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return sq.toString();\n    }\n\n    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":containsData(\"))\n            containsData();\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n\t\telse if (tq.matchChomp(\":nth-child(\"))\n        \tcssNthChild(false, false);\n        else if (tq.matchChomp(\":nth-last-child(\"))\n        \tcssNthChild(true, false);\n        else if (tq.matchChomp(\":nth-of-type(\"))\n        \tcssNthChild(false, true);\n        else if (tq.matchChomp(\":nth-last-of-type(\"))\n        \tcssNthChild(true, true);\n        else if (tq.matchChomp(\":first-child\"))\n        \tevals.add(new Evaluator.IsFirstChild());\n        else if (tq.matchChomp(\":last-child\"))\n        \tevals.add(new Evaluator.IsLastChild());\n        else if (tq.matchChomp(\":first-of-type\"))\n        \tevals.add(new Evaluator.IsFirstOfType());\n        else if (tq.matchChomp(\":last-of-type\"))\n        \tevals.add(new Evaluator.IsLastOfType());\n        else if (tq.matchChomp(\":only-child\"))\n        \tevals.add(new Evaluator.IsOnlyChild());\n        else if (tq.matchChomp(\":only-of-type\"))\n        \tevals.add(new Evaluator.IsOnlyOfType());\n        else if (tq.matchChomp(\":empty\"))\n        \tevals.add(new Evaluator.IsEmpty());\n        else if (tq.matchChomp(\":root\"))\n        \tevals.add(new Evaluator.IsRoot());\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }\n\n    private void byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        evals.add(new Evaluator.Id(id));\n    }\n\n    private void byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        evals.add(new Evaluator.Class(className.trim()));\n    }\n\n    private void byTag() {\n        String tagName = tq.consumeElementSelector();\n\n        Validate.notEmpty(tagName);\n\n        // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n        if (tagName.startsWith(\"*|\")) {\n            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(tagName.trim().toLowerCase()), new Evaluator.TagEndsWith(tagName.replace(\"*|\", \":\").trim().toLowerCase())));\n        } else {\n            // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n            if (tagName.contains(\"|\"))\n                tagName = tagName.replace(\"|\", \":\");\n\n            evals.add(new Evaluator.Tag(tagName.trim()));\n        }\n    }\n\n    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private void allElements() {\n        evals.add(new Evaluator.AllElements());\n    }\n\n    // pseudo selectors :lt, :gt, :eq\n    private void indexLessThan() {\n        evals.add(new Evaluator.IndexLessThan(consumeIndex()));\n    }\n\n    private void indexGreaterThan() {\n        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n    }\n\n    private void indexEquals() {\n        evals.add(new Evaluator.IndexEquals(consumeIndex()));\n    }\n    \n    //pseudo selectors :first-child, :last-child, :nth-child, ...\n    private static final Pattern NTH_AB = Pattern.compile(\"((\\\\+|-)?(\\\\d+)?)n(\\\\s*(\\\\+|-)?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n    private static final Pattern NTH_B  = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\");\n\n\tprivate void cssNthChild(boolean backwards, boolean ofType) {\n\t\tString argS = tq.chompTo(\")\").trim().toLowerCase();\n\t\tMatcher mAB = NTH_AB.matcher(argS);\n\t\tMatcher mB = NTH_B.matcher(argS);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 1;\n\t\t} else if (\"even\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta = 0;\n\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", argS);\n\t\t}\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));\n\t\t}\n\t}\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    // pseudo selector :has(el)\n    private void has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n        evals.add(new StructuralEvaluator.Has(parse(subQuery)));\n    }\n\n    // pseudo selector :contains(text), containsOwn(text)\n    private void contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        if (own)\n            evals.add(new Evaluator.ContainsOwnText(searchText));\n        else\n            evals.add(new Evaluator.ContainsText(searchText));\n    }\n\n    // pseudo selector :containsData(data)\n    private void containsData() {\n        tq.consume(\":containsData\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        evals.add(new Evaluator.ContainsData(searchText));\n    }\n\n    // :matches(regex), matchesOwn(regex)\n    private void matches(boolean own) {\n        tq.consume(own ? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n\n        if (own)\n            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n        else\n            evals.add(new Evaluator.Matches(Pattern.compile(regex)));\n    }\n\n    // :not(selector)\n    private void not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        evals.add(new StructuralEvaluator.Not(parse(subQuery)));\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "18",
        "class": "CharacterReader",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length() - 1);\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return input.substring(start, pos);\n    }\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "56",
        "class": "XmlTreeBuilder",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\n\nimport java.util.List;\n\n/**\n * Use the {@code XmlTreeBuilder} when you want to parse XML without any of the HTML DOM rules being applied to the\n * document.\n * <p>Usage example: {@code Document xmlDoc = Jsoup.parse(html, baseUrl, Parser.xmlParser());}</p>\n *\n * @author Jonathan Hedley\n */\npublic class XmlTreeBuilder extends TreeBuilder {\n    ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n    }\n\n    @Override\n    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        super.initialiseParse(input, baseUri, errors, settings);\n        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        // start tag, end tag, doctype, comment, character, eof\n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: // could put some normalisation here if desired\n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            tokeniser.acknowledgeSelfClosingFlag();\n            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), comment.baseUri(), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node = new TextNode(characterToken.getData(), baseUri);\n        insertNode(node);\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(inputFragment, baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "56",
        "class": "Token",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.BooleanAttribute;\n\n/**\n * Parse tokens for the Tokeniser.\n */\nabstract class Token {\n    TokenType type;\n\n    private Token() {\n    }\n    \n    String tokenType() {\n        return this.getClass().getSimpleName();\n    }\n\n    /**\n     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n     * piece of data, which immediately get GCed.\n     */\n    abstract Token reset();\n\n    static void reset(StringBuilder sb) {\n        if (sb != null) {\n            sb.delete(0, sb.length());\n        }\n    }\n\n    static final class Doctype extends Token {\n        final StringBuilder name = new StringBuilder();\n        final StringBuilder publicIdentifier = new StringBuilder();\n        final StringBuilder systemIdentifier = new StringBuilder();\n        boolean forceQuirks = false;\n\n        Doctype() {\n            type = TokenType.Doctype;\n        }\n\n        @Override\n        Token reset() {\n            reset(name);\n            reset(publicIdentifier);\n            reset(systemIdentifier);\n            forceQuirks = false;\n            return this;\n        }\n\n        String getName() {\n            return name.toString();\n        }\n\n\n        String getPublicIdentifier() {\n            return publicIdentifier.toString();\n        }\n\n        public String getSystemIdentifier() {\n            return systemIdentifier.toString();\n        }\n\n        public boolean isForceQuirks() {\n            return forceQuirks;\n        }\n    }\n\n    static abstract class Tag extends Token {\n        protected String tagName;\n        protected String normalName; // lc version of tag name, for case insensitive tree build\n        private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n        private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n        private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\n        private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\n        private boolean hasPendingAttributeValue = false;\n        boolean selfClosing = false;\n        Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n        @Override\n        Tag reset() {\n            tagName = null;\n            normalName = null;\n            pendingAttributeName = null;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            selfClosing = false;\n            attributes = null;\n            return this;\n        }\n\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                Attribute attribute;\n                if (hasPendingAttributeValue)\n                    attribute = new Attribute(pendingAttributeName,\n                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                else if (hasEmptyAttributeValue)\n                    attribute = new Attribute(pendingAttributeName, \"\");\n                else\n                    attribute = new BooleanAttribute(pendingAttributeName);\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n\n        final void finaliseTag() {\n            // finalises for emit\n            if (pendingAttributeName != null) {\n                // todo: check if attribute name exists; if so, drop and error\n                newAttribute();\n            }\n        }\n\n        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n            Validate.isFalse(tagName == null || tagName.length() == 0);\n            return tagName;\n        }\n\n        final String normalName() { // loses case, used in tree building for working out where in tree it should go\n            return normalName;\n        }\n\n        final Tag name(String name) {\n            tagName = name;\n            normalName = name.toLowerCase();\n            return this;\n        }\n\n        final boolean isSelfClosing() {\n            return selfClosing;\n        }\n\n        @SuppressWarnings({\"TypeMayBeWeakened\"})\n        final Attributes getAttributes() {\n            return attributes;\n        }\n\n        // these appenders are rarely hit in not null state-- caused by null chars.\n        final void appendTagName(String append) {\n            tagName = tagName == null ? append : tagName.concat(append);\n            normalName = tagName.toLowerCase();\n        }\n\n        final void appendTagName(char append) {\n            appendTagName(String.valueOf(append));\n        }\n\n        final void appendAttributeName(String append) {\n            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n        }\n\n        final void appendAttributeName(char append) {\n            appendAttributeName(String.valueOf(append));\n        }\n\n        final void appendAttributeValue(String append) {\n            ensureAttributeValue();\n            if (pendingAttributeValue.length() == 0) {\n                pendingAttributeValueS = append;\n            } else {\n                pendingAttributeValue.append(append);\n            }\n        }\n\n        final void appendAttributeValue(char append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(char[] append) {\n            ensureAttributeValue();\n            pendingAttributeValue.append(append);\n        }\n\n        final void appendAttributeValue(int[] appendCodepoints) {\n            ensureAttributeValue();\n            for (int codepoint : appendCodepoints) {\n                pendingAttributeValue.appendCodePoint(codepoint);\n            }\n        }\n        \n        final void setEmptyAttributeValue() {\n            hasEmptyAttributeValue = true;\n        }\n\n        private void ensureAttributeValue() {\n            hasPendingAttributeValue = true;\n            // if on second hit, we'll need to move to the builder\n            if (pendingAttributeValueS != null) {\n                pendingAttributeValue.append(pendingAttributeValueS);\n                pendingAttributeValueS = null;\n            }\n        }\n    }\n\n    final static class StartTag extends Tag {\n        StartTag() {\n            super();\n            attributes = new Attributes();\n            type = TokenType.StartTag;\n        }\n\n        @Override\n        Tag reset() {\n            super.reset();\n            attributes = new Attributes();\n            // todo - would prefer these to be null, but need to check Element assertions\n            return this;\n        }\n\n        StartTag nameAttr(String name, Attributes attributes) {\n            this.tagName = name;\n            this.attributes = attributes;\n            normalName = tagName.toLowerCase();\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            if (attributes != null && attributes.size() > 0)\n                return \"<\" + name() + \" \" + attributes.toString() + \">\";\n            else\n                return \"<\" + name() + \">\";\n        }\n    }\n\n    final static class EndTag extends Tag{\n        EndTag() {\n            super();\n            type = TokenType.EndTag;\n        }\n\n        @Override\n        public String toString() {\n            return \"</\" + name() + \">\";\n        }\n    }\n\n    final static class Comment extends Token {\n        final StringBuilder data = new StringBuilder();\n        boolean bogus = false;\n\n        @Override\n        Token reset() {\n            reset(data);\n            bogus = false;\n            return this;\n        }\n\n        Comment() {\n            type = TokenType.Comment;\n        }\n\n        String getData() {\n            return data.toString();\n        }\n\n        @Override\n        public String toString() {\n            return \"<!--\" + getData() + \"-->\";\n        }\n    }\n\n    final static class Character extends Token {\n        private String data;\n\n        Character() {\n            super();\n            type = TokenType.Character;\n        }\n\n        @Override\n        Token reset() {\n            data = null;\n            return this;\n        }\n\n        Character data(String data) {\n            this.data = data;\n            return this;\n        }\n\n        String getData() {\n            return data;\n        }\n\n        @Override\n        public String toString() {\n            return getData();\n        }\n    }\n\n    final static class EOF extends Token {\n        EOF() {\n            type = Token.TokenType.EOF;\n        }\n\n        @Override\n        Token reset() {\n            return this;\n        }\n    }\n\n    final boolean isDoctype() {\n        return type == TokenType.Doctype;\n    }\n\n    final Doctype asDoctype() {\n        return (Doctype) this;\n    }\n\n    final boolean isStartTag() {\n        return type == TokenType.StartTag;\n    }\n\n    final StartTag asStartTag() {\n        return (StartTag) this;\n    }\n\n    final boolean isEndTag() {\n        return type == TokenType.EndTag;\n    }\n\n    final EndTag asEndTag() {\n        return (EndTag) this;\n    }\n\n    final boolean isComment() {\n        return type == TokenType.Comment;\n    }\n\n    final Comment asComment() {\n        return (Comment) this;\n    }\n\n    final boolean isCharacter() {\n        return type == TokenType.Character;\n    }\n\n    final Character asCharacter() {\n        return (Character) this;\n    }\n\n    final boolean isEOF() {\n        return type == TokenType.EOF;\n    }\n\n    enum TokenType {\n        Doctype,\n        StartTag,\n        EndTag,\n        Comment,\n        Character,\n        EOF\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "71",
        "class": "QueryParser",
        "fqdn": "org.jsoup.select",
        "source_code": "package org.jsoup.select;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.parser.TokenQueue;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static org.jsoup.internal.Normalizer.normalize;\n\n/**\n * Parses a CSS selector into an Evaluator tree.\n */\npublic class QueryParser {\n    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n    private static final String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"};\n\n    private TokenQueue tq;\n    private String query;\n    private List<Evaluator> evals = new ArrayList<>();\n\n    /**\n     * Create a new QueryParser.\n     * @param query CSS query\n     */\n    private QueryParser(String query) {\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }\n\n    /**\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     */\n    public static Evaluator parse(String query) {\n        try {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n        } catch (IllegalArgumentException e) {\n            throw new Selector.SelectorParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Parse the query\n     * @return Evaluator\n     */\n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n\n        Evaluator rootEval; // the new topmost evaluator\n        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.\n        Evaluator newEval = parse(subQuery); // the evaluator to add into target evaluator\n        boolean replaceRightMost = false;\n\n        if (evals.size() == 1) {\n            rootEval = currentEval = evals.get(0);\n            // make sure OR (,) has precedence:\n            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                replaceRightMost = true;\n            }\n        }\n        else {\n            rootEval = currentEval = new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        // for most combinators: change the current eval into an AND of the current eval and the new eval\n        if (combinator == '>')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediateParent(currentEval));\n        else if (combinator == ' ')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.Parent(currentEval));\n        else if (combinator == '+')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediatePreviousSibling(currentEval));\n        else if (combinator == '~')\n            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.PreviousSibling(currentEval));\n        else if (combinator == ',') { // group or.\n            CombiningEvaluator.Or or;\n            if (currentEval instanceof CombiningEvaluator.Or) {\n                or = (CombiningEvaluator.Or) currentEval;\n                or.add(newEval);\n            } else {\n                or = new CombiningEvaluator.Or();\n                or.add(currentEval);\n                or.add(newEval);\n            }\n            currentEval = or;\n        }\n        else\n            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval = currentEval;\n        evals.add(rootEval);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq = new StringBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(combinators))\n                break;\n            else\n                sq.append(tq.consume());\n        }\n        return sq.toString();\n    }\n\n    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":containsData(\"))\n            containsData();\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n\t\telse if (tq.matchChomp(\":nth-child(\"))\n        \tcssNthChild(false, false);\n        else if (tq.matchChomp(\":nth-last-child(\"))\n        \tcssNthChild(true, false);\n        else if (tq.matchChomp(\":nth-of-type(\"))\n        \tcssNthChild(false, true);\n        else if (tq.matchChomp(\":nth-last-of-type(\"))\n        \tcssNthChild(true, true);\n        else if (tq.matchChomp(\":first-child\"))\n        \tevals.add(new Evaluator.IsFirstChild());\n        else if (tq.matchChomp(\":last-child\"))\n        \tevals.add(new Evaluator.IsLastChild());\n        else if (tq.matchChomp(\":first-of-type\"))\n        \tevals.add(new Evaluator.IsFirstOfType());\n        else if (tq.matchChomp(\":last-of-type\"))\n        \tevals.add(new Evaluator.IsLastOfType());\n        else if (tq.matchChomp(\":only-child\"))\n        \tevals.add(new Evaluator.IsOnlyChild());\n        else if (tq.matchChomp(\":only-of-type\"))\n        \tevals.add(new Evaluator.IsOnlyOfType());\n        else if (tq.matchChomp(\":empty\"))\n        \tevals.add(new Evaluator.IsEmpty());\n        else if (tq.matchChomp(\":root\"))\n        \tevals.add(new Evaluator.IsRoot());\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }\n\n    private void byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        evals.add(new Evaluator.Id(id));\n    }\n\n    private void byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        evals.add(new Evaluator.Class(className.trim()));\n    }\n\n    private void byTag() {\n        String tagName = tq.consumeElementSelector();\n\n        Validate.notEmpty(tagName);\n\n        // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n        if (tagName.startsWith(\"*|\")) {\n            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(normalize(tagName)), new Evaluator.TagEndsWith(normalize(tagName.replace(\"*|\", \":\")))));\n        } else {\n            // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n            if (tagName.contains(\"|\"))\n                tagName = tagName.replace(\"|\", \":\");\n\n            evals.add(new Evaluator.Tag(tagName.trim()));\n        }\n    }\n\n    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n    private void allElements() {\n        evals.add(new Evaluator.AllElements());\n    }\n\n    // pseudo selectors :lt, :gt, :eq\n    private void indexLessThan() {\n        evals.add(new Evaluator.IndexLessThan(consumeIndex()));\n    }\n\n    private void indexGreaterThan() {\n        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n    }\n\n    private void indexEquals() {\n        evals.add(new Evaluator.IndexEquals(consumeIndex()));\n    }\n    \n    //pseudo selectors :first-child, :last-child, :nth-child, ...\n    private static final Pattern NTH_AB = Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n    private static final Pattern NTH_B  = Pattern.compile(\"([+-])?(\\\\d+)\");\n\n\tprivate void cssNthChild(boolean backwards, boolean ofType) {\n\t\tString argS = normalize(tq.chompTo(\")\"));\n\t\tMatcher mAB = NTH_AB.matcher(argS);\n\t\tMatcher mB = NTH_B.matcher(argS);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 1;\n\t\t} else if (\"even\".equals(argS)) {\n\t\t\ta = 2;\n\t\t\tb = 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta = 0;\n\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", argS);\n\t\t}\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));\n\t\t}\n\t}\n\n    private int consumeIndex() {\n        String indexS = tq.chompTo(\")\").trim();\n        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n        return Integer.parseInt(indexS);\n    }\n\n    // pseudo selector :has(el)\n    private void has() {\n        tq.consume(\":has\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n        evals.add(new StructuralEvaluator.Has(parse(subQuery)));\n    }\n\n    // pseudo selector :contains(text), containsOwn(text)\n    private void contains(boolean own) {\n        tq.consume(own ? \":containsOwn\" : \":contains\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n        if (own)\n            evals.add(new Evaluator.ContainsOwnText(searchText));\n        else\n            evals.add(new Evaluator.ContainsText(searchText));\n    }\n\n    // pseudo selector :containsData(data)\n    private void containsData() {\n        tq.consume(\":containsData\");\n        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        evals.add(new Evaluator.ContainsData(searchText));\n    }\n\n    // :matches(regex), matchesOwn(regex)\n    private void matches(boolean own) {\n        tq.consume(own ? \":matchesOwn\" : \":matches\");\n        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n\n        if (own)\n            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n        else\n            evals.add(new Evaluator.Matches(Pattern.compile(regex)));\n    }\n\n    // :not(selector)\n    private void not() {\n        tq.consume(\":not\");\n        String subQuery = tq.chompBalanced('(', ')');\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        evals.add(new StructuralEvaluator.Not(parse(subQuery)));\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "46",
        "class": "Entities",
        "fqdn": "org.jsoup.nodes",
        "source_code": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.parser.Parser;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.CharsetEncoder;\nimport java.util.*;\n\n/**\n * HTML entities, and escape routines.\n * Source: <a href=\"http://www.w3.org/TR/html5/named-character-references.html#named-character-references\">W3C HTML\n * named character references</a>.\n */\npublic class Entities {\n    public enum EscapeMode {\n        /** Restricted entities suitable for XHTML output: lt, gt, amp, and quot only. */\n        xhtml(xhtmlByVal),\n        /** Default HTML output entities. */\n        base(baseByVal),\n        /** Complete HTML entities. */\n        extended(fullByVal);\n\n        private Map<Character, String> map;\n\n        EscapeMode(Map<Character, String> map) {\n            this.map = map;\n        }\n\n        public Map<Character, String> getMap() {\n            return map;\n        }\n    }\n\n    private static final Map<String, Character> full;\n    private static final Map<Character, String> xhtmlByVal;\n    private static final Map<String, Character> base;\n    private static final Map<Character, String> baseByVal;\n    private static final Map<Character, String> fullByVal;\n\n    private Entities() {}\n\n    /**\n     * Check if the input is a known named entity\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity\n     */\n    public static boolean isNamedEntity(String name) {\n        return full.containsKey(name);\n    }\n\n    /**\n     * Check if the input is a known named entity in the base entity set.\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity in the base set\n     * @see #isNamedEntity(String)\n     */\n    public static boolean isBaseNamedEntity(String name) {\n        return base.containsKey(name);\n    }\n\n    /**\n     * Get the Character value of the named entity\n     * @param name named entity (e.g. \"lt\" or \"amp\")\n     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n     */\n    public static Character getCharacterByName(String name) {\n        return full.get(name);\n    }\n    \n    static String escape(String string, Document.OutputSettings out) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        escape(accum, string, out, false, false, false);\n        return accum.toString();\n    }\n\n    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n\n    static String unescape(String string) {\n        return unescape(string, false);\n    }\n\n    /**\n     * Unescape the input string.\n     * @param string to un-HTML-escape\n     * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n     * @return unescaped string\n     */\n    static String unescape(String string, boolean strict) {\n        return Parser.unescapeEntities(string, strict);\n    }\n\n    /*\n     * Provides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.\n     * After KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,\n     * performance may be bad. We can add more encoders for common character sets that are impacted by performance\n     * issues on Android if required.\n     *\n     * Benchmarks:     *\n     * OLD toHtml() impl v New (fastpath) in millis\n     * Wiki: 1895, 16\n     * CNN: 6378, 55\n     * Alterslash: 3013, 28\n     * Jsoup: 167, 2\n     */\n\n    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n        // todo add more charset tests if impacted by Android's bad perf in canEncode\n        switch (charset) {\n            case ascii:\n                return c < 0x80;\n            case utf:\n                return true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above\n            default:\n                return fallback.canEncode(c);\n        }\n    }\n\n    private enum CoreCharset {\n        ascii, utf, fallback;\n\n        private static CoreCharset byName(String name) {\n            if (name.equals(\"US-ASCII\"))\n                return ascii;\n            if (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\n                return utf;\n            return fallback;\n        }\n    }\n\n\n    // xhtml has restricted entities\n    private static final Object[][] xhtmlArray = {\n            {\"quot\", 0x00022},\n            {\"amp\", 0x00026},\n            {\"lt\", 0x0003C},\n            {\"gt\", 0x0003E}\n    };\n\n    static {\n        xhtmlByVal = new HashMap<Character, String>();\n        base = loadEntities(\"entities-base.properties\");  // most common / default\n        baseByVal = toCharacterKey(base);\n        full = loadEntities(\"entities-full.properties\"); // extended and overblown.\n        fullByVal = toCharacterKey(full);\n\n        for (Object[] entity : xhtmlArray) {\n            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n            xhtmlByVal.put(c, ((String) entity[0]));\n        }\n    }\n\n    private static Map<String, Character> loadEntities(String filename) {\n        Properties properties = new Properties();\n        Map<String, Character> entities = new HashMap<String, Character>();\n        try {\n            InputStream in = Entities.class.getResourceAsStream(filename);\n            properties.load(in);\n            in.close();\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n        }\n\n        for (Map.Entry entry: properties.entrySet()) {\n            Character val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\n            String name = (String) entry.getKey();\n            entities.put(name, val);\n        }\n        return entities;\n    }\n\n    private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\n        Map<Character, String> outMap = new HashMap<Character, String>();\n        for (Map.Entry<String, Character> entry: inMap.entrySet()) {\n            Character character = entry.getValue();\n            String name = entry.getKey();\n\n            if (outMap.containsKey(character)) {\n                // dupe, prefer the lower case version\n                if (name.toLowerCase().equals(name))\n                    outMap.put(character, name);\n            } else {\n                outMap.put(character, name);\n            }\n        }\n        return outMap;\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "23",
        "class": "Tokeniser",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Entities;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Readers the input stream into tokens.\n */\nclass Tokeniser {\n    static final char replacementChar = '\\uFFFD'; // replaces null character\n\n    private CharacterReader reader; // html input\n    private ParseErrorList errors; // errors found while tokenising\n\n    private TokeniserState state = TokeniserState.Data; // current tokenisation state\n    private Token emitPending; // the token we are about to emit on next read\n    private boolean isEmitPending = false;\n    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n    StringBuilder dataBuffer; // buffers data looking for </script>\n\n    Token.Tag tagPending; // tag we are building up\n    Token.Doctype doctypePending; // doctype building up\n    Token.Comment commentPending; // comment building up\n    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n    private boolean selfClosingFlagAcknowledged = true;\n\n    Tokeniser(CharacterReader reader, ParseErrorList errors) {\n        this.reader = reader;\n        this.errors = errors;\n    }\n\n    Token read() {\n        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        if (charBuffer.length() > 0) {\n            String str = charBuffer.toString();\n            charBuffer.delete(0, charBuffer.length());\n            return new Token.Character(str);\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes.size() > 0)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }\n\n    void emit(String str) {\n        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n        // does not set isEmitPending; read checks that\n        charBuffer.append(str);\n    }\n\n    void emit(char c) {\n        charBuffer.append(c);\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState state) {\n        this.state = state;\n    }\n\n    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }\n\n    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }\n\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', ' ', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError(\"character outside of valid range\");\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon\"); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending = new Token.Comment();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createDoctypePending() {\n        doctypePending = new Token.Doctype();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        dataBuffer = new StringBuilder();\n    }\n\n    boolean isAppropriateEndTagToken() {\n        return tagPending.tagName.equals(lastStartTag.tagName);\n    }\n\n    String appropriateEndTagName() {\n        return lastStartTag.tagName;\n    }\n\n    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }\n\n    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }\n\n    private void characterReferenceError(String message) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n    }\n\n    private void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), errorMsg));\n    }\n\n    boolean currentNodeInHtmlNS() {\n        // todo: implememnt namespaces correctly\n        return true;\n        // Element currentNode = currentNode();\n        // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "23",
        "class": "CharacterReader",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\n\n/**\n CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n */\nclass CharacterReader {\n    static final char EOF = (char) -1;\n\n    private final String input;\n    private final int length;\n    private int pos = 0;\n    private int mark = 0;\n\n    CharacterReader(String input) {\n        Validate.notNull(input);\n        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n\n        this.input = input;\n        this.length = input.length();\n    }\n\n    int pos() {\n        return pos;\n    }\n\n    boolean isEmpty() {\n        return pos >= length;\n    }\n\n    char current() {\n        return isEmpty() ? EOF : input.charAt(pos);\n    }\n\n    char consume() {\n        char val = isEmpty() ? EOF : input.charAt(pos);\n        pos++;\n        return val;\n    }\n\n    void unconsume() {\n        pos--;\n    }\n\n    void advance() {\n        pos++;\n    }\n\n    void mark() {\n        mark = pos;\n    }\n\n    void rewindToMark() {\n        pos = mark;\n    }\n\n    String consumeAsString() {\n        return input.substring(pos, pos++);\n    }\n\n    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = input.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeToAny(char... seq) {\n        int start = pos;\n\n        OUTER: while (!isEmpty()) {\n            char c = input.charAt(pos);\n            for (char seek : seq) {\n                if (seek == c)\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        return pos > start ? input.substring(start, pos) : \"\";\n    }\n\n    String consumeToEnd() {\n        String data = input.substring(pos, input.length());\n        pos = input.length();\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n                pos++;\n            else\n                break;\n        }\n\n        return input.substring(start, pos);\n    }\n\n\n\n    String consumeHexSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    String consumeDigitSequence() {\n        int start = pos;\n        while (!isEmpty()) {\n            char c = input.charAt(pos);\n            if (c >= '0' && c <= '9')\n                pos++;\n            else\n                break;\n        }\n        return input.substring(start, pos);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && input.charAt(pos) == c;\n\n    }\n\n    boolean matches(String seq) {\n        return input.startsWith(seq, pos);\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        return input.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input.charAt(pos);\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input.charAt(pos);\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase();\n        String hiScan = seq.toUpperCase();\n        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n    }\n\n    @Override\n    public String toString() {\n        return input.substring(pos);\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "74",
        "class": "StringUtil",
        "fqdn": "org.jsoup.helper",
        "source_code": "package org.jsoup.helper;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * A minimal String utility class. Designed for internal jsoup use only.\n */\npublic final class StringUtil {\n    // memoised padding up to 21\n    static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};\n\n    /**\n     * Join a collection of strings by a separator\n     * @param strings collection of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     */\n    public static String join(Collection strings, String sep) {\n        return join(strings.iterator(), sep);\n    }\n\n    /**\n     * Join a collection of strings by a separator\n     * @param strings iterator of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     */\n    public static String join(Iterator strings, String sep) {\n        if (!strings.hasNext())\n            return \"\";\n\n        String start = strings.next().toString();\n        if (!strings.hasNext()) // only one, avoid builder\n            return start;\n\n        StringBuilder sb = new StringBuilder(64).append(start);\n        while (strings.hasNext()) {\n            sb.append(sep);\n            sb.append(strings.next());\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Join an array of strings by a separator\n     * @param strings collection of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     */\n    public static String join(String[] strings, String sep) {\n        return join(Arrays.asList(strings), sep);\n    }\n\n    /**\n     * Returns space padding\n     * @param width amount of padding desired\n     * @return string of spaces * width\n     */\n    public static String padding(int width) {\n        if (width < 0)\n            throw new IllegalArgumentException(\"width must be > 0\");\n\n        if (width < padding.length)\n            return padding[width];\n        char[] out = new char[width];\n        for (int i = 0; i < width; i++)\n            out[i] = ' ';\n        return String.valueOf(out);\n    }\n\n    /**\n     * Tests if a string is blank: null, empty, or only whitespace (\" \", \\r\\n, \\t, etc)\n     * @param string string to test\n     * @return if string is blank\n     */\n    public static boolean isBlank(String string) {\n        if (string == null || string.length() == 0)\n            return true;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!StringUtil.isWhitespace(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests if a string is numeric, i.e. contains only digit characters\n     * @param string string to test\n     * @return true if only digit chars, false if empty or null or contains non-digit chars\n     */\n    public static boolean isNumeric(String string) {\n        if (string == null || string.length() == 0)\n            return false;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!Character.isDigit(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests if a code point is \"whitespace\" as defined in the HTML spec. Used for output HTML.\n     * @param c code point to test\n     * @return true if code point is whitespace, false otherwise\n     * @see #isActuallyWhitespace(int)\n     */\n    public static boolean isWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n    }\n\n    /**\n     * Tests if a code point is \"whitespace\" as defined by what it looks like. Used for Element.text etc.\n     * @param c code point to test\n     * @return true if code point is whitespace, false otherwise\n     */\n    public static boolean isActuallyWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r' || c == 160;\n        // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n    }\n\n        // zero width sp, zw non join, zw join, soft hyphen\n\n    /**\n     * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n     * (e.g. newline, tab) convert to a simple space\n     * @param string content to normalise\n     * @return normalised string\n     */\n    public static String normaliseWhitespace(String string) {\n        StringBuilder sb = StringUtil.stringBuilder();\n        appendNormalisedWhitespace(sb, string, false);\n        return sb.toString();\n    }\n\n    /**\n     * After normalizing the whitespace within a string, appends it to a string builder.\n     * @param accum builder to append to\n     * @param string string to normalize whitespace within\n     * @param stripLeading set to true if you wish to remove any leading whitespace\n     */\n    public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n\n        int len = string.length();\n        int c;\n        for (int i = 0; i < len; i+= Character.charCount(c)) {\n            c = string.codePointAt(i);\n            if (isActuallyWhitespace(c)) {\n                if ((stripLeading && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n            }\n            else {\n                accum.appendCodePoint(c);\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n    }\n\n    public static boolean in(final String needle, final String... haystack) {\n        final int len = haystack.length;\n        for (int i = 0; i < len; i++) {\n            if (haystack[i].equals(needle))\n            return true;\n        }\n        return false;\n    }\n\n    public static boolean inSorted(String needle, String[] haystack) {\n        return Arrays.binarySearch(haystack, needle) >= 0;\n    }\n\n    /**\n     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n     * @param base the existing absolute base URL\n     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n     * @return the resolved absolute URL\n     * @throws MalformedURLException if an error occurred generating the URL\n     */\n    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n        if (relUrl.startsWith(\"?\"))\n            relUrl = base.getPath() + relUrl;\n        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n        if (relUrl.indexOf('.') == 0 && base.getFile().indexOf('/') != 0) {\n            base = new URL(base.getProtocol(), base.getHost(), base.getPort(), \"/\" + base.getFile());\n        }\n        return new URL(base, relUrl);\n    }\n\n    /**\n     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n     * @param baseUrl the existing absolute base URL\n     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n     * @return an absolute URL if one was able to be generated, or the empty string if not\n     */\n    public static String resolve(final String baseUrl, final String relUrl) {\n        URL base;\n        try {\n            try {\n                base = new URL(baseUrl);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n                URL abs = new URL(relUrl);\n                return abs.toExternalForm();\n            }\n            return resolve(base, relUrl).toExternalForm();\n        } catch (MalformedURLException e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Maintains a cached StringBuilder, to minimize new StringBuilder GCs. Prevents it from growing to big per thread.\n     * Care must be taken to not grab more than one in the same stack (not locked or mutexed or anything).\n     * @return an empty StringBuilder\n     */\n    public static StringBuilder stringBuilder() {\n        StringBuilder sb = stringLocal.get();\n        if (sb.length() > MaxCachedBuilderSize) {\n            sb = new StringBuilder(MaxCachedBuilderSize);\n            stringLocal.set(sb);\n        } else {\n            sb.delete(0, sb.length());\n        }\n        return sb;\n\n    }\n\n    private static final int MaxCachedBuilderSize = 8 * 1024;\n    private static final ThreadLocal<StringBuilder> stringLocal = new ThreadLocal<StringBuilder>(){\n        @Override\n        protected StringBuilder initialValue() {\n            return new StringBuilder(MaxCachedBuilderSize);\n        }\n    };\n\n\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "52",
        "class": "XmlTreeBuilder",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.*;\n\nimport java.util.List;\n\n/**\n * Use the {@code XmlTreeBuilder} when you want to parse XML without any of the HTML DOM rules being applied to the\n * document.\n * <p>Usage example: {@code Document xmlDoc = Jsoup.parse(html, baseUrl, Parser.xmlParser());}</p>\n *\n * @author Jonathan Hedley\n */\npublic class XmlTreeBuilder extends TreeBuilder {\n    @Override\n    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n        super.initialiseParse(input, baseUri, errors);\n        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        // start tag, end tag, doctype, comment, character, eof\n        switch (token.type) {\n            case StartTag:\n                insert(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insert(token.asComment());\n                break;\n            case Character:\n                insert(token.asCharacter());\n                break;\n            case Doctype:\n                insert(token.asDoctype());\n                break;\n            case EOF: // could put some normalisation here if desired\n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    private void insertNode(Node node) {\n        currentElement().appendChild(node);\n    }\n\n    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            tokeniser.acknowledgeSelfClosingFlag();\n            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                tag.setSelfClosing();\n        } else {\n            stack.add(el);\n        }\n        return el;\n    }\n\n    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData(), baseUri);\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                String declaration = data.substring(1);\n                insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(\"!\"));\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character characterToken) {\n        Node node = new TextNode(characterToken.getData(), baseUri);\n        insertNode(node);\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors) {\n        initialiseParse(inputFragment, baseUri, errors);\n        runParser();\n        return doc.childNodes();\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "52",
        "class": "DataUtil",
        "fqdn": "org.jsoup.helper",
        "source_code": "package org.jsoup.helper;\n\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.XmlDeclaration;\nimport org.jsoup.parser.Parser;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Internal static utilities for handling data.\n *\n */\npublic final class DataUtil {\n    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n    static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n    private static final int bufferSize = 0x20000; // ~130K.\n    private static final int UNICODE_BOM = 0xFEFF;\n    private static final char[] mimeBoundaryChars =\n            \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n    static final int boundaryLength = 32;\n\n    private DataUtil() {}\n\n    /**\n     * Loads a file to a Document.\n     * @param in file to load\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(File in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readFileToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    /**\n     * Parses a Document from an input steam.\n     * @param in input stream to parse. You will need to close it.\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    /**\n     * Parses a Document from an input steam, using the provided Parser.\n     * @param in input stream to parse. You will need to close it.\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, parser);\n    }\n\n    /**\n     * Writes the input stream to the output stream. Doesn't close them.\n     * @param in input stream to read from\n     * @param out output stream to write to\n     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // look for BOM - overrides any other header or input\n        charsetName = detectCharsetFromBom(byteData, charsetName);\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            if (meta != null) {\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                    foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n            }\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n                if (prolog.name().equals(\"xml\")) {\n                    foundCharset = prolog.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n\n            if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n    /**\n     * Read the input stream into a byte buffer.\n     * @param inStream the input stream to read from\n     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n     * @return the filled byte buffer\n     * @throws IOException if an exception occurs whilst reading from the input stream.\n     */\n    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean capped = maxSize > 0;\n        byte[] buffer = new byte[bufferSize];\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n        int read;\n        int remaining = maxSize;\n\n        while (true) {\n            read = inStream.read(buffer);\n            if (read == -1) break;\n            if (capped) {\n                if (read > remaining) {\n                    outStream.write(buffer, 0, remaining);\n                    break;\n                }\n                remaining -= read;\n            }\n            outStream.write(buffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }\n\n    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n        return readToByteBuffer(inStream, 0);\n    }\n\n    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n            byte[] bytes = new byte[(int) randomAccessFile.length()];\n            randomAccessFile.readFully(bytes);\n            return ByteBuffer.wrap(bytes);\n        } finally {\n            if (randomAccessFile != null)\n                randomAccessFile.close();\n        }\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    /**\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     */\n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }\n\n    private static String validateCharset(String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            // if our this charset matching fails.... we just take the default\n        }\n        return null;\n    }\n\n    /**\n     * Creates a random string, suitable for use as a mime boundary\n     */\n    static String mimeBoundary() {\n        final StringBuilder mime = new StringBuilder(boundaryLength);\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return mime.toString();\n    }\n\n    private static String detectCharsetFromBom(ByteBuffer byteData, String charsetName) {\n        byteData.mark();\n        byte[] bom = new byte[4];\n        if (byteData.remaining() >= bom.length) {\n            byteData.get(bom);\n            byteData.rewind();\n        }\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n            charsetName = \"UTF-32\"; // and I hope it's on your system\n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            charsetName = \"UTF-16\"; // in all Javas\n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            charsetName = \"UTF-8\"; // in all Javas\n            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n        }\n        return charsetName;\n    }\n}\n"
    },
    {
        "project_name": "Jsoup",
        "bug-id": "14",
        "class": "Tokeniser",
        "fqdn": "org.jsoup.parser",
        "source_code": "package org.jsoup.parser;\n\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Entities;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Readers the input stream into tokens.\n */\nclass Tokeniser {\n    static final char replacementChar = '\\uFFFD'; // replaces null character\n\n    private CharacterReader reader; // html input\n    private boolean trackErrors = true;\n    private List<ParseError> errors = new ArrayList<ParseError>(); // errors found while tokenising\n\n    private TokeniserState state = TokeniserState.Data; // current tokenisation state\n    private Token emitPending; // the token we are about to emit on next read\n    private boolean isEmitPending = false;\n    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n    StringBuilder dataBuffer; // buffers data looking for </script>\n\n    Token.Tag tagPending; // tag we are building up\n    Token.Doctype doctypePending; // doctype building up\n    Token.Comment commentPending; // comment building up\n    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n    private boolean selfClosingFlagAcknowledged = true;\n\n    Tokeniser(CharacterReader reader) {\n        this.reader = reader;\n    }\n\n    Token read() {\n        if (!selfClosingFlagAcknowledged) {\n            error(\"Self closing flag not acknowledged\");\n            selfClosingFlagAcknowledged = true;\n        }\n\n        while (!isEmitPending)\n            state.read(this, reader);\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        if (charBuffer.length() > 0) {\n            String str = charBuffer.toString();\n            charBuffer.delete(0, charBuffer.length());\n            return new Token.Character(str);\n        } else {\n            isEmitPending = false;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\n        emitPending = token;\n        isEmitPending = true;\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag;\n            if (startTag.selfClosing)\n                selfClosingFlagAcknowledged = false;\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.attributes.size() > 0)\n                error(\"Attributes incorrectly present on end tag\");\n        }\n    }\n\n    void emit(String str) {\n        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n        // does not set isEmitPending; read checks that\n        charBuffer.append(str);\n    }\n\n    void emit(char c) {\n        charBuffer.append(c);\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState state) {\n        this.state = state;\n    }\n\n    void advanceTransition(TokeniserState state) {\n        reader.advance();\n        this.state = state;\n    }\n\n    void acknowledgeSelfClosingFlag() {\n        selfClosingFlagAcknowledged = true;\n    }\n\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending = new Token.Comment();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createDoctypePending() {\n        doctypePending = new Token.Doctype();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        dataBuffer = new StringBuilder();\n    }\n\n    boolean isAppropriateEndTagToken() {\n        return tagPending.tagName.equals(lastStartTag.tagName);\n    }\n\n\n    boolean isTrackErrors() {\n        return trackErrors;\n    }\n\n    void setTrackErrors(boolean trackErrors) {\n        this.trackErrors = trackErrors;\n    }\n\n    void error(TokeniserState state) {\n        if (trackErrors)\n            errors.add(new ParseError(\"Unexpected character in input\", reader.current(), state, reader.pos()));\n    }\n\n    void eofError(TokeniserState state) {\n        if (trackErrors)\n            errors.add(new ParseError(\"Unexpectedly reached end of file (EOF)\", state, reader.pos()));\n    }\n\n    private void characterReferenceError() {\n        if (trackErrors)\n            errors.add(new ParseError(\"Invalid character reference\", reader.pos()));\n    }\n\n    private void error(String errorMsg) {\n        if (trackErrors)\n            errors.add(new ParseError(errorMsg, reader.pos()));\n    }\n\n    boolean currentNodeInHtmlNS() {\n        // todo: implememnt namespaces correctly\n        return true;\n        // Element currentNode = currentNode();\n        // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n    }\n}\n"
    },
    {
        "project_name": "JacksonCore",
        "bug-id": "1",
        "class": "NumberInput",
        "fqdn": "com.fasterxml.jackson.core.io",
        "source_code": "package com.fasterxml.jackson.core.io;\n\nimport java.math.BigDecimal;\n\npublic final class NumberInput\n{\n    /**\n     * Textual representation of a double constant that can cause nasty problems\n     * with JDK (see http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308).\n     */\n    public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n\n    /**\n     * Constants needed for parsing longs from basic int parsing methods\n     */\n    final static long L_BILLION = 1000000000;\n\n    final static String MIN_LONG_STR_NO_SIGN = String.valueOf(Long.MIN_VALUE).substring(1);\n    final static String MAX_LONG_STR = String.valueOf(Long.MAX_VALUE);\n    \n    /**\n     * Fast method for parsing integers that are known to fit into\n     * regular 32-bit signed int type. This means that length is\n     * between 1 and 9 digits (inclusive)\n     *<p>\n     * Note: public to let unit tests call it\n     */\n    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\n                            num = (num * 10) + (digitChars[offset] - '0');\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }\n\n    /**\n     * Helper method to (more) efficiently parse integer numbers from\n     * String values.\n     */\n    public static int parseInt(String str)\n    {\n        /* Ok: let's keep strategy simple: ignoring optional minus sign,\n         * we'll accept 1 - 9 digits and parse things efficiently;\n         * otherwise just defer to JDK parse functionality.\n         */\n        char c = str.charAt(0);\n        int length = str.length();\n        boolean negative = (c == '-');\n        int offset = 1;\n        // must have 1 - 9 digits after optional sign:\n        // negative?\n        if (negative) {\n            if (length == 1 || length > 10) {\n                return Integer.parseInt(str);\n            }\n            c = str.charAt(offset++);\n        } else {\n            if (length > 9) {\n                return Integer.parseInt(str);\n            }\n        }\n        if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n        }\n        int num = c - '0';\n        if (offset < length) {\n            c = str.charAt(offset++);\n            if (c > '9' || c < '0') {\n                return Integer.parseInt(str);\n            }\n            num = (num * 10) + (c - '0');\n            if (offset < length) {\n                c = str.charAt(offset++);\n                if (c > '9' || c < '0') {\n                    return Integer.parseInt(str);\n                }\n                num = (num * 10) + (c - '0');\n                // Let's just loop if we have more than 3 digits:\n                if (offset < length) {\n                    do {\n                        c = str.charAt(offset++);\n                        if (c > '9' || c < '0') {\n                            return Integer.parseInt(str);\n                        }\n                        num = (num * 10) + (c - '0');\n                    } while (offset < length);\n                }\n            }\n        }\n        return negative ? -num : num;\n    }\n    \n    public static long parseLong(char[] digitChars, int offset, int len)\n    {\n        // Note: caller must ensure length is [10, 18]\n        int len1 = len-9;\n        long val = parseInt(digitChars, offset, len1) * L_BILLION;\n        return val + (long) parseInt(digitChars, offset+len1, 9);\n    }\n\n    public static long parseLong(String str)\n    {\n        /* Ok, now; as the very first thing, let's just optimize case of \"fake longs\";\n         * that is, if we know they must be ints, call int parsing\n         */\n        int length = str.length();\n        if (length <= 9) {\n            return (long) parseInt(str);\n        }\n        // !!! TODO: implement efficient 2-int parsing...\n        return Long.parseLong(str);\n    }\n    \n    /**\n     * Helper method for determining if given String representation of\n     * an integral number would fit in 64-bit Java long or not.\n     * Note that input String must NOT contain leading minus sign (even\n     * if 'negative' is set to true).\n     *\n     * @param negative Whether original number had a minus sign (which is\n     *    NOT passed to this method) or not\n     */\n    public static boolean inLongRange(char[] digitChars, int offset, int len,\n            boolean negative)\n    {\n        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n        int cmpLen = cmpStr.length();\n        if (len < cmpLen) return true;\n        if (len > cmpLen) return false;\n\n        for (int i = 0; i < cmpLen; ++i) {\n            int diff = digitChars[offset+i] - cmpStr.charAt(i);\n            if (diff != 0) {\n                return (diff < 0);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Similar to {@link #inLongRange(char[],int,int,boolean)}, but\n     * with String argument\n     *\n     * @param negative Whether original number had a minus sign (which is\n     *    NOT passed to this method) or not\n     */\n    public static boolean inLongRange(String numberStr, boolean negative)\n    {\n        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n        int cmpLen = cmpStr.length();\n        int actualLen = numberStr.length();\n        if (actualLen < cmpLen) return true;\n        if (actualLen > cmpLen) return false;\n\n        // could perhaps just use String.compareTo()?\n        for (int i = 0; i < cmpLen; ++i) {\n            int diff = numberStr.charAt(i) - cmpStr.charAt(i);\n            if (diff != 0) {\n                return (diff < 0);\n            }\n        }\n        return true;\n    }\n\n    public static int parseAsInt(String input, int defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        // One more thing: use integer parsing for 'simple'\n        int i = 0;\n        if (i < len) { // skip leading sign:\n            char c = input.charAt(0);\n            if (c == '+') { // for plus, actually physically remove\n                input = input.substring(1);\n                len = input.length();\n            } else if (c == '-') { // minus, just skip for checks, must retain\n                ++i;\n            }\n        }\n        for (; i < len; ++i) {\n            char c = input.charAt(i);\n            // if other symbols, parse as Double, coerce\n            if (c > '9' || c < '0') {\n                try {\n                    return (int) parseDouble(input);\n                } catch (NumberFormatException e) {\n                    return defaultValue;\n                }\n            }\n        }\n        try {\n            return Integer.parseInt(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n\n    public static long parseAsLong(String input, long defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        // One more thing: use long parsing for 'simple'\n        int i = 0;\n        if (i < len) { // skip leading sign:\n            char c = input.charAt(0);\n            if (c == '+') { // for plus, actually physically remove\n                input = input.substring(1);\n                len = input.length();\n            } else if (c == '-') { // minus, just skip for checks, must retain\n                ++i;\n            }\n        }\n        for (; i < len; ++i) {\n            char c = input.charAt(i);\n            // if other symbols, parse as Double, coerce\n            if (c > '9' || c < '0') {\n                try {\n                    return (long) parseDouble(input);\n                } catch (NumberFormatException e) {\n                    return defaultValue;\n                }\n            }\n        }\n        try {\n            return Long.parseLong(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n    \n    public static double parseAsDouble(String input, double defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        try {\n            return parseDouble(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n\n    public static double parseDouble(String numStr) throws NumberFormatException\n    {\n        // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n        /* as per [JACKSON-827], let's use MIN_VALUE as it is available on all JDKs; normalized\n         * only in JDK 1.6. In practice, should not really matter.\n         */\n        if (NASTY_SMALL_DOUBLE.equals(numStr)) {\n            return Double.MIN_VALUE;\n        }\n        return Double.parseDouble(numStr);\n    }\n\n    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n    {\n            return new BigDecimal(numStr);\n    }\n\n    public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {\n        return parseBigDecimal(buffer, 0, buffer.length);\n    }\n    \n    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n            throws NumberFormatException\n    {\n            return new BigDecimal(buffer, offset, len);\n    }\n\n}\n"
    },
    {
        "project_name": "JacksonCore",
        "bug-id": "6",
        "class": "JsonPointer",
        "fqdn": "com.fasterxml.jackson.core",
        "source_code": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}\n"
    },
    {
        "project_name": "JacksonCore",
        "bug-id": "5",
        "class": "JsonPointer",
        "fqdn": "com.fasterxml.jackson.core",
        "source_code": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}\n"
    },
    {
        "project_name": "Csv",
        "bug-id": "3",
        "class": "Lexer",
        "fqdn": "org.apache.commons.csv",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\n\nimport java.io.IOException;\n\n/**\n * Abstract lexer class; contains common utility routines shared by lexers\n *\n * @version $Id$\n */\nabstract class Lexer {\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commmentStart;\n\n    final boolean ignoreSurroundingSpaces;\n    final boolean ignoreEmptyLines;\n\n    final CSVFormat format;\n\n    /** The input stream */\n    final ExtendedBufferedReader in;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n        this.format = format;\n        this.in = in;\n        this.delimiter = format.getDelimiter();\n        this.escape = mapNullToDisabled(format.getEscape());\n        this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n        this.commmentStart = mapNullToDisabled(format.getCommentStart());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    private final char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    long getLineNumber() {\n        return in.getLineNumber();\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n                return c;\n            // indicate unexpected char - available from in.getLastChar()\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int c) throws IOException {\n        // check if we have \\r\\n...\n        if (c == CR && in.lookAhead() == LF) {\n            // note: does not change c outside of this method!\n            c = in.read();\n        }\n        return c == LF || c == CR;\n    }\n\n    abstract Token nextToken(Token reusableToken) throws IOException;\n\n    /**\n     * @return true if the given char is a whitespace character\n     */\n    boolean isWhitespace(final int c) {\n        return c != format.getDelimiter() && Character.isWhitespace((char) c);\n    }\n\n    /**\n     * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param c the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int c) {\n        return c == LF || c == CR || c == UNDEFINED;\n    }\n\n    /**\n     * @return true if the given character indicates end of file\n     */\n    boolean isEndOfFile(final int c) {\n        return c == END_OF_STREAM;\n    }\n\n    boolean isDelimiter(final int c) {\n        return c == delimiter;\n    }\n\n    boolean isEscape(final int c) {\n        return c == escape;\n    }\n\n    boolean isQuoteChar(final int c) {\n        return c == quoteChar;\n    }\n\n    boolean isCommentStart(final int c) {\n        return c == commmentStart;\n    }\n}\n"
    },
    {
        "project_name": "Csv",
        "bug-id": "1",
        "class": "ExtendedBufferedReader",
        "fqdn": "org.apache.commons.csv",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * ExtendedBufferedReader\n *\n * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\n') {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n                char ch = buf[i];\n                if (ch == '\\n') {\n                    if ('\\r' != (i > 0 ? buf[i-1]: lastChar)) {\n                        lineCounter++;                        \n                    }\n                } else if (ch == '\\r') {\n                    lineCounter++;\n                }\n            }\n\n            lastChar = buf[offset + len - 1];\n\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n        \n        return len;\n    }\n\n    /**\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s).\n     * This method should only be called when processing a comment, otherwise\n     * information can be lost.\n     * <p>\n     * Increments  {@link #lineCounter}\n     * <p>\n     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF, \n     * otherwise to last character on the line (won't be CR or LF) \n     * \n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        String line = super.readLine();\n\n        if (line != null) {\n            if (line.length() > 0) {\n                lastChar = line.charAt(line.length() - 1);\n            }\n            lineCounter++;\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So\n     * the next call to {@link #read()} will still return this value.\n     * \n     * @return the next character\n     * \n     * @throws IOException if there is an error in reading\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        int c = super.read();\n        super.reset();\n\n        return c;\n    }\n\n    /**\n     * Returns the nof line read\n     *\n     * @return the current-line-number (or -1)\n     */\n    int getLineNumber() {\n        return lineCounter;\n    }\n}\n"
    },
    {
        "project_name": "Csv",
        "bug-id": "6",
        "class": "CSVRecord",
        "fqdn": "org.apache.commons.csv",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        return mapping == null ? true : mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null ? mapping.containsKey(name) : false;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n                map.put(entry.getKey(), values[col]);\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n"
    },
    {
        "project_name": "Csv",
        "bug-id": "10",
        "class": "CSVPrinter",
        "fqdn": "org.apache.commons.csv",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // Hmmm, where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // if (c == ' ' || c == '\\f' || c == '\\t') {\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quotePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet result set\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }\n\n    /**\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n}\n"
    },
    {
        "project_name": "Csv",
        "bug-id": "9",
        "class": "CSVRecord",
        "fqdn": "org.apache.commons.csv",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        return mapping == null || mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null && mapping.containsKey(name);\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n"
    },
    {
        "project_name": "Csv",
        "bug-id": "7",
        "class": "CSVParser",
        "fqdn": "org.apache.commons.csv",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    header = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n"
    },
    {
        "project_name": "Csv",
        "bug-id": "4",
        "class": "CSVParser",
        "fqdn": "org.apache.commons.csv",
        "source_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h4>Creating instances</h4>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * <p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * </p>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n * \n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h4>Parsing record wise</h4>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h4>Parsing into memory</h4>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <p>\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n * </p>\n *\n * <h4>Notes</h4>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(),\n                             charset == null ? Charset.forName(\"UTF-8\") : charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n"
    }
]