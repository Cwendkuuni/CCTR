[
    {
        "project_name": "88_jopenchart",
        "class": "DefaultChart",
        "fqdn": "de.progra.charting",
        "source_code": "package de.progra.charting;\n\nimport de.progra.charting.model.*;\nimport java.awt.*;\nimport de.progra.charting.render.*;\nimport java.util.*;\n\npublic class DefaultChart extends AbstractChart\n{\n    public static int LINEAR_X_LINEAR_Y;\n    public static int NO_COORDINATE_SYSTEM;\n    \n    protected DefaultChart() {\n    }\n    \n    public DefaultChart(final ChartDataModel model, final String title) {\n        this();\n        this.setChartDataModel(model);\n        this.setRowColorModel(new RowColorModel(model));\n        this.setLegend(new Legend(this.getRowColorModel()));\n        this.setTitle(new Title(title));\n    }\n    \n    public DefaultChart(final ChartDataModel model, final String title, final int coord) {\n        this(model, title);\n        if (coord == DefaultChart.LINEAR_X_LINEAR_Y) {\n            this.setCoordSystem(new CoordSystem(model));\n        }\n    }\n    \n    public DefaultChart(final ChartDataModel model, final String title, final int coord, final String xaxis, final String yaxis) {\n        this(model, title, coord);\n        this.getCoordSystem().setXAxisUnit(xaxis);\n        this.getCoordSystem().setYAxisUnit(yaxis);\n    }\n    \n    @Override\n    public Dimension getPreferredSize() {\n        return null;\n    }\n    \n    @Override\n    public void render(final Graphics2D g) {\n        final int width = (int)this.getBounds().getWidth();\n        final int height = (int)this.getBounds().getHeight();\n        final Title t = this.getTitle();\n        final Legend l = this.getLegend();\n        final CoordSystem c = this.getCoordSystem();\n        final Collection renderer = this.getChartRenderer().values();\n        g.setColor(Color.white);\n        g.fillRect(0, 0, width, height);\n        g.setColor(Color.black);\n        int titleheight = 0;\n        int legendwidth = 0;\n        if (t != null) {\n            final Dimension title = t.getPreferredSize();\n            t.setBounds(new Rectangle(width / 2 - (int)(title.getWidth() / 2.0), 0, (int)title.getWidth(), (int)title.getHeight()));\n            t.render(g);\n            titleheight = (int)t.getBounds().getHeight();\n        }\n        if (l != null) {\n            final Dimension legend = l.getPreferredSize();\n            l.setBounds(new Rectangle((int)(width - legend.getWidth()), (int)(height / 2 - legend.getHeight() / 2.0 + titleheight), (int)legend.getWidth(), (int)legend.getHeight()));\n            l.render(g);\n            legendwidth = (int)l.getBounds().getWidth();\n        }\n        if (c != null) {\n            c.setBounds(new Rectangle(0, titleheight, width - legendwidth, height - titleheight));\n        }\n        if (!renderer.isEmpty()) {\n            for (final AbstractChartRenderer cr : renderer) {\n                cr.setBounds(new Rectangle(0, titleheight, width - legendwidth, height - titleheight - 5));\n                cr.render(g);\n            }\n        }\n        if (c != null) {\n            c.render(g);\n        }\n    }\n    \n    static {\n        DefaultChart.LINEAR_X_LINEAR_Y = 0;\n        DefaultChart.NO_COORDINATE_SYSTEM = 1;\n    }\n}\n"
    },
    {
        "project_name": "88_jopenchart",
        "class": "CoordSystemUtilities",
        "fqdn": "de.progra.charting",
        "source_code": "package de.progra.charting;\n\nimport de.progra.charting.model.*;\nimport java.text.*;\nimport java.awt.font.*;\nimport java.awt.geom.*;\nimport java.awt.*;\n\npublic class CoordSystemUtilities\n{\n    protected final int marginOffset = 6;\n    protected CoordSystem c;\n    protected ChartDataModelConstraints constraints;\n    protected ChartDataModelConstraints constraints2;\n    protected ChartDataModel model;\n    \n    public CoordSystemUtilities(final CoordSystem coord, final ChartDataModelConstraints constraints, final ChartDataModelConstraints constraints2, final ChartDataModel model) {\n        this.c = coord;\n        this.constraints = constraints;\n        this.constraints2 = constraints2;\n        this.model = model;\n    }\n    \n    public int computeLeftMargin() {\n        double xmin = this.constraints.getMinimumColumnValue();\n        double xmax = this.constraints.getMaximumColumnValue();\n        if (xmin <= 0.0 && xmax > 0.0) {\n            xmin = Math.abs(xmin);\n            xmax = Math.abs(xmax);\n            final TextLayout layout = new TextLayout(this.c.getYAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n            int maxlmargin = this.computeYAxisLabelWidth() + 6;\n            maxlmargin = Math.max(maxlmargin, (int)layout.getBounds().getWidth() + 6);\n            int margin = (int)(maxlmargin - xmin / (xmin + xmax) * (this.c.getBounds().getWidth() - this.c.getRightMargin()));\n            margin += 5;\n            final int n = margin;\n            this.c.getClass();\n            if (n < 20) {\n                this.c.getClass();\n                margin = 20;\n            }\n            return margin;\n        }\n        this.c.getClass();\n        return 20;\n    }\n    \n    public int computeRightMargin() {\n        final TextLayout layout = new TextLayout(this.c.getXAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n        final double width = layout.getBounds().getWidth();\n        this.c.getClass();\n        final int n = (int)(width + 15.0 / 3.0);\n        this.c.getClass();\n        return Math.max(n, 15);\n    }\n    \n    public int computeTopMargin() {\n        final TextLayout layout = new TextLayout(this.c.getYAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n        final double height = layout.getBounds().getHeight();\n        this.c.getClass();\n        final int n = (int)(height + 15.0 / 3.0 + layout.getDescent());\n        this.c.getClass();\n        return Math.max(n, 15);\n    }\n    \n    public int computeBottomMargin() {\n        double ymin = this.constraints.getMinimumValue().doubleValue();\n        double ymax = this.constraints.getMaximumValue().doubleValue();\n        if (ymin <= 0.0 && ymax > 0.0) {\n            ymin = Math.abs(ymin);\n            ymax = Math.abs(ymax);\n            final TextLayout layout = new TextLayout(this.c.getXAxisUnit(), this.c.getFont(), this.c.getFontRenderContext());\n            int maxbmargin = this.computeXAxisLabelHeight() + 6;\n            maxbmargin = Math.max(maxbmargin, (int)layout.getBounds().getHeight() + 6);\n            int margin = (int)(maxbmargin - ymin / (ymin + ymax) * (this.c.getBounds().getHeight() - this.c.getTopMargin()));\n            margin += 10;\n            final int n = margin;\n            this.c.getClass();\n            if (n < 20) {\n                this.c.getClass();\n                margin = 20;\n            }\n            return margin;\n        }\n        this.c.getClass();\n        return 20;\n    }\n    \n    public int computeXAxisLabelHeight() {\n        final double min = this.constraints.getMinimumColumnValue();\n        final double max = this.constraints.getMaximumColumnValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0.0;\n        int height = 0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        boolean paint = false;\n        final DecimalFormat df = this.c.getXDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                height = Math.max(height, (int)r.getHeight());\n            }\n            paint = !paint;\n        }\n        return height;\n    }\n    \n    public int computeYAxisLabelWidth() {\n        final double min = this.constraints.getMinimumValue().doubleValue();\n        final double max = this.constraints.getMaximumValue().doubleValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0.0;\n        int width = 0;\n        if (this.constraints.getMinimumColumnValue() > 0.0) {\n            xpt = this.constraints.getMinimumColumnValue();\n        }\n        else if (this.constraints.getMaximumColumnValue() < 0.0 && this.c.getSecondYAxis() != null) {\n            xpt = this.constraints.getMaximumColumnValue();\n        }\n        boolean paint = false;\n        final DecimalFormat df = this.c.getYDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        for (double d = min; d <= max; d += tick) {\n            if (paint) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                width = Math.max((int)r.getWidth(), width);\n            }\n            paint = !paint;\n        }\n        return width;\n    }\n    \n    public void drawNumericalXAxisTicks(final Graphics2D g) {\n        final AffineTransform at = this.c.getTransform(0);\n        final double min = this.constraints.getMinimumColumnValue();\n        final double max = this.constraints.getMaximumColumnValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double ypt = 0.0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        final Point2D p = new Point2D.Double(0.0, 0.0);\n        final Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        final DecimalFormat df = this.c.getXDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        boolean paint = false;\n        g.setFont(f);\n        final boolean paintLabels = this.c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(d, ypt);\n            final Point2D v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - 3.0, v.getX(), v.getY() + 3.0);\n            g.draw(ticks);\n            if (paint && paintLabels) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float)(v.getX() - r.getWidth() / 2.0), (float)(v.getY() + r.getHeight() + 6.0));\n            }\n            paint = !paint;\n        }\n    }\n    \n    public void drawXAxisTicks(final Graphics2D g) {\n        final AffineTransform at = this.c.getTransform(0);\n        final int min = (int)this.constraints.getMinimumColumnValue();\n        final int max = (int)this.constraints.getMaximumColumnValue();\n        final double tick = 1.0;\n        double ypt = 0.0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        final Point2D p = new Point2D.Double(0.0, 0.0);\n        Point2D v = null;\n        Point2D oldv = null;\n        final Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        final DecimalFormat df = this.c.getXDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        final boolean paint = false;\n        final boolean paintLabels = this.c.isPaintLabels();\n        g.setFont(f);\n        for (int i = min - 1; i < max; ++i) {\n            p.setLocation(i + 1, ypt);\n            v = at.transform(p, null);\n            ticks.setLine(v.getX(), v.getY() - 3.0, v.getX(), v.getY() + 3.0);\n            if (i + 1 < max) {\n                g.draw(ticks);\n            }\n            if (oldv != null && paintLabels) {\n                final String sb = (String)this.model.getColumnValueAt(i);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float)(oldv.getX() + (v.getX() - oldv.getX()) / 2.0 - r.getWidth() / 2.0), (float)(v.getY() + r.getHeight() + 6.0));\n            }\n            oldv = v;\n        }\n    }\n    \n    public void drawYAxisTicks(final Graphics2D g) {\n        final AffineTransform at = this.c.getTransform(0);\n        final double min = this.constraints.getMinimumValue().doubleValue();\n        final double max = this.constraints.getMaximumValue().doubleValue();\n        final double tick = ChartUtilities.calculateTickSpacing(min, max);\n        double xpt = 0.0;\n        if (this.constraints.getMinimumColumnValue() > 0.0) {\n            xpt = this.constraints.getMinimumColumnValue();\n        }\n        else if (this.constraints.getMaximumColumnValue() < 0.0 && this.c.getSecondYAxis() != null) {\n            xpt = this.constraints.getMaximumColumnValue();\n        }\n        final Point2D p = new Point2D.Double(0.0, 0.0);\n        final Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);\n        boolean paint = false;\n        final DecimalFormat df = this.c.getYDecimalFormat();\n        final FontRenderContext frc = this.c.getFontRenderContext();\n        final Font f = this.c.getFont();\n        final Color backupColor = g.getColor();\n        g.setFont(f);\n        final boolean paintLabels = this.c.isPaintLabels();\n        for (double d = min; d <= max; d += tick) {\n            p.setLocation(xpt, d);\n            final Point2D v = at.transform(p, null);\n            ticks.setLine(v.getX() - 3.0, v.getY(), v.getX() + 3.0, v.getY());\n            g.draw(ticks);\n            if (d != min && !this.c.isPaintOnlyTick()) {\n                final Line2D xax = this.getXAxisLine2D();\n                ticks.setLine(v.getX() + 3.0, v.getY(), xax.getX2(), v.getY());\n                g.setColor(Color.lightGray);\n                g.draw(ticks);\n                g.setColor(backupColor);\n            }\n            if (paintLabels && (paint || !this.c.isPaintAltTick())) {\n                final String sb = df.format(d);\n                final Rectangle2D r = f.getStringBounds(sb, frc);\n                g.drawString(sb, (float)(v.getX() - r.getWidth() - 6.0), (float)(v.getY() + r.getHeight() / 2.0));\n            }\n            paint = !paint;\n        }\n    }\n    \n    public Line2D getXAxisLine2D() {\n        double ypt = 0.0;\n        if (this.constraints.getMinimumValue().doubleValue() > 0.0) {\n            ypt = this.constraints.getMinimumValue().doubleValue();\n        }\n        else if (this.constraints.getMaximumValue().doubleValue() < 0.0) {\n            ypt = this.constraints.getMaximumValue().doubleValue();\n        }\n        final AffineTransform at = this.c.getTransform(0);\n        final Point2D l = at.transform(new Point2D.Double(this.constraints.getMinimumColumnValue(), ypt), null);\n        final Point2D r = at.transform(new Point2D.Double(this.constraints.getMaximumColumnValue(), ypt), null);\n        return new Line2D.Double(l, r);\n    }\n    \n    public Line2D getYAxisLine2D() {\n        double xpt = 0.0;\n        if (this.constraints.getMinimumColumnValue() > 0.0) {\n            xpt = this.constraints.getMinimumColumnValue();\n        }\n        else if (this.constraints.getMaximumColumnValue() < 0.0 && this.c.getSecondYAxis() != null) {\n            xpt = this.constraints.getMaximumColumnValue();\n        }\n        final AffineTransform at = this.c.getTransform(0);\n        final Point2D o = at.transform(new Point2D.Double(xpt, this.constraints.getMaximumValue().doubleValue()), null);\n        final Point2D u = at.transform(new Point2D.Double(xpt, this.constraints.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n    \n    public Line2D getSecondYAxisLine2D() {\n        final double xpt = this.constraints2.getMaximumColumnValue();\n        final AffineTransform at = this.c.getTransform(1);\n        final Point2D o = at.transform(new Point2D.Double(xpt, this.constraints2.getMaximumValue().doubleValue()), null);\n        final Point2D u = at.transform(new Point2D.Double(xpt, this.constraints2.getMinimumValue().doubleValue()), null);\n        return new Line2D.Double(o, u);\n    }\n}\n"
    },
    {
        "project_name": "8_gfarcegestionfa",
        "class": "OracleIdentiteDao",
        "fqdn": "fr.unice.gfarce.dao",
        "source_code": "package fr.unice.gfarce.dao;\n\nimport javax.persistence.*;\nimport java.util.*;\nimport fr.unice.gfarce.identity.*;\n\npublic class OracleIdentiteDao implements IdentiteDao\n{\n    String persistUnitName;\n    @PersistenceContext\n    private EntityManager em;\n    \n    public OracleIdentiteDao() {\n        this.persistUnitName = \"Identite\";\n    }\n    \n    public static OracleIdentiteDao getDAO() {\n        return new OracleIdentiteDao();\n    }\n    \n    @Override\n    public void insert(final Identite identite, final String nomForm, final Calendar dateLimite) {\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            this.em.persist((Object)identite);\n            tx.commit();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n    }\n    \n    @Override\n    public void update(final Identite identite) {\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            final Identite i = (Identite)this.em.find((Class)identite.getClass(), (Object)identite.getId());\n            i.setEmail(identite.getEmail());\n            i.setNom(identite.getNom());\n            i.setPrenom(identite.getPrenom());\n            i.setSex(identite.getSex());\n            i.setType(identite.getType());\n            this.em.merge((Object)identite);\n            tx.commit();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n    }\n    \n    @Override\n    public void delete(final Identite identite) {\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            final Identite ident = (Identite)this.em.find((Class)identite.getClass(), (Object)identite.getId());\n            this.em.remove((Object)ident);\n            tx.commit();\n        }\n        catch (Exception e1) {\n            e1.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n    }\n    \n    public List<Identite> find(final String nom, final String prenom, final String sex, final String email, final Identite.TypeIdentite type) {\n        String a;\n        if (nom == null) {\n            a = \"ident.nom like '%'\";\n        }\n        else {\n            a = \"ident.nom='\" + nom + \"'\";\n        }\n        String b;\n        if (prenom == null) {\n            b = \"ident.prenom like '%'\";\n        }\n        else {\n            b = \"ident.prenom='\" + prenom + \"'\";\n        }\n        String c;\n        if (sex == null) {\n            c = \"ident.sex like '%'\";\n        }\n        else {\n            c = \"ident.sex='\" + sex + \"'\";\n        }\n        String e;\n        if (type == Identite.TypeIdentite.CANDIDAT) {\n            e = \"ident.type= :CANDIDAT\";\n        }\n        else if (type == Identite.TypeIdentite.FORMATEUR) {\n            e = \"ident.type= :FORMATEUR\";\n        }\n        else {\n            e = \"ident.type like '%'\";\n        }\n        final String s = \"select ident from Identite as ident where \" + a + \" and \" + b + \" and \" + c + \" and \" + e;\n        EntityManagerFactory emf = null;\n        this.em = null;\n        EntityTransaction tx = null;\n        List<Identite> list = null;\n        try {\n            emf = Persistence.createEntityManagerFactory(this.persistUnitName);\n            this.em = emf.createEntityManager();\n            tx = this.em.getTransaction();\n            tx.begin();\n            if (type == Identite.TypeIdentite.CANDIDAT) {\n                list = (List<Identite>)this.em.createQuery(s).setParameter(\"CANDIDAT\", (Object)Identite.TypeIdentite.CANDIDAT).getResultList();\n            }\n            else if (type == Identite.TypeIdentite.FORMATEUR) {\n                list = (List<Identite>)this.em.createQuery(s).setParameter(\"FORMATEUR\", (Object)Identite.TypeIdentite.FORMATEUR).getResultList();\n            }\n            else {\n                list = (List<Identite>)this.em.createQuery(s).getResultList();\n            }\n        }\n        catch (Exception e2) {\n            e2.printStackTrace();\n            if (tx != null) {\n                tx.rollback();\n            }\n        }\n        finally {\n            if (this.em != null) {\n                this.em.close();\n            }\n            if (emf != null) {\n                emf.close();\n            }\n        }\n        return list;\n    }\n    \n    @Override\n    public Candidat[] findCandidat(final String nom, final String prenom, final String sex, final String email) {\n        final List<Identite> resultList = this.find(nom, prenom, sex, email, Identite.TypeIdentite.CANDIDAT);\n        if (resultList != null) {\n            final Candidat[] result = resultList.toArray(new Candidat[resultList.size()]);\n            return result;\n        }\n        return null;\n    }\n    \n    @Override\n    public RespFormation[] findRespForm(final String nom, final String prenom, final String sex, final String email) {\n        final List<Identite> resultList = this.find(nom, prenom, sex, email, Identite.TypeIdentite.FORMATEUR);\n        if (resultList != null) {\n            final RespFormation[] result = resultList.toArray(new RespFormation[resultList.size()]);\n            return result;\n        }\n        return null;\n    }\n}\n"
    },
    {
        "project_name": "8_gfarcegestionfa",
        "class": "ModifTableStockage",
        "fqdn": "fr.unice.gfarce.interGraph",
        "source_code": "package fr.unice.gfarce.interGraph;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class ModifTableStockage\n{\n    private int nbColonnes;\n    private int nbLignes;\n    private TableStockage ts;\n    \n    public ModifTableStockage(final TableStockage ts) {\n        this.nbColonnes = 0;\n        this.nbLignes = 0;\n        this.nbColonnes = ts.getColumnCount();\n        this.nbLignes = ts.getRowCount() + 1;\n        this.ts = ts;\n    }\n    \n    public TableStockage ajouterColonne(final String nomNouvelleColonne, final Class<?> type) {\n        ++this.nbColonnes;\n        final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        for (int j = 0; j < this.nbColonnes - 1; ++j) {\n            tableS.setColumnName(j, this.ts.getColumnName(j));\n        }\n        tableS.setColumnName(this.nbColonnes - 1, nomNouvelleColonne);\n        for (int i = 0; i < this.nbLignes - 1; ++i) {\n            for (int k = 0; k < this.nbColonnes - 1; ++k) {\n                tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n            }\n            tableS.setColumnClass(this.nbColonnes - 1, type);\n        }\n        return tableS;\n    }\n    \n    public TableStockage ajouterLigne() {\n        if (this.nbColonnes > 0) {\n            ++this.nbLignes;\n            final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n            for (int j = 0; j < this.nbColonnes; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j));\n            }\n            for (int i = 0; i < this.nbLignes - 2; ++i) {\n                for (int k = 0; k < this.nbColonnes; ++k) {\n                    tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n                }\n            }\n            for (int j = 0; j < this.nbColonnes; ++j) {\n                if (this.ts.getColumnClass(j).equals(String.class)) {\n                    tableS.setValueAt(\"\", this.nbLignes - 2, j);\n                }\n                else if (this.ts.getColumnClass(j).equals(Double.class)) {\n                    tableS.setValueAt(new Double(\"0\"), this.nbLignes - 2, j);\n                }\n                else {\n                    tableS.setValueAt(new Boolean(false), this.nbLignes - 2, j);\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"PAS DE COLONNE\", \"ERREUR\", 0);\n        return this.ts;\n    }\n    \n    public TableStockage supprimerColonne(final int indice) {\n        --this.nbColonnes;\n        final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        for (int j = 0; j < indice; ++j) {\n            tableS.setColumnName(j, this.ts.getColumnName(j));\n        }\n        for (int i = 0; i < this.nbLignes - 1; ++i) {\n            for (int k = 0; k < indice; ++k) {\n                tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n            }\n        }\n        if (indice != this.nbColonnes) {\n            for (int j = indice; j < this.nbColonnes; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j + 1));\n            }\n            for (int i = 0; i < this.nbLignes - 1; ++i) {\n                for (int k = indice; k < this.nbColonnes; ++k) {\n                    tableS.setValueAt(this.ts.getValueAt(i, k + 1), i, k);\n                }\n            }\n        }\n        return tableS;\n    }\n    \n    public TableStockage supprimerLigne(final int indice) {\n        --this.nbLignes;\n        final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        for (int j = 0; j < this.nbColonnes; ++j) {\n            tableS.setColumnName(j, this.ts.getColumnName(j));\n        }\n        for (int i = 0; i < indice; ++i) {\n            for (int k = 0; k < this.nbColonnes; ++k) {\n                tableS.setValueAt(this.ts.getValueAt(i, k), i, k);\n            }\n        }\n        if (indice != this.nbLignes - 1) {\n            for (int i = indice + 1; i < this.nbLignes; ++i) {\n                for (int k = 0; k < this.nbColonnes; ++k) {\n                    tableS.setValueAt(this.ts.getValueAt(i, k), i - 1, k);\n                }\n            }\n        }\n        return tableS;\n    }\n    \n    public TableStockage separerColonne(final int indice) {\n        if (!this.ts.getColumnClass(indice).equals(String.class)) {\n            JOptionPane.showMessageDialog(null, \"non separable: PAS DE TYPE STRING\", \"ERREUR\", 0);\n            return this.ts;\n        }\n        int k = 0;\n        String val = (String)this.ts.getValueAt(0, indice);\n        String val2 = new String();\n        while (val.charAt(k) != ' ' && k != val.length() - 1) {\n            val2 = val2.concat(String.valueOf(val.charAt(k)));\n            ++k;\n        }\n        if (k == val.length() - 1) {\n            val2 = new String();\n            for (k = 0; val.charAt(k) != ' ' && k != val.length() - 1; ++k) {\n                val2 = val2.concat(String.valueOf(val.charAt(k)));\n            }\n        }\n        if (k != val.length() - 1) {\n            ++this.nbColonnes;\n            final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n            val2 = new String();\n            k = 0;\n            for (int j = 0; j < indice; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j));\n            }\n            for (int j = indice + 1; j < this.nbColonnes; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j - 1));\n            }\n            final String colonne = this.ts.getColumnName(indice);\n            final String[] resNP = colonne.split(\" \", 2);\n            final String val1Colonne = resNP[0];\n            String val2Colonne;\n            if (resNP.length > 1) {\n                val2Colonne = resNP[1];\n            }\n            else {\n                val2Colonne = \"\";\n            }\n            tableS.setColumnName(indice, val1Colonne);\n            tableS.setColumnName(indice + 1, val2Colonne);\n            for (int i = 0; i < this.nbLignes - 1; ++i) {\n                for (int l = 0; l < indice; ++l) {\n                    tableS.setValueAt(this.ts.getValueAt(i, l), i, l);\n                }\n                for (int l = indice + 2; l < this.nbColonnes; ++l) {\n                    tableS.setValueAt(this.ts.getValueAt(i, l - 1), i, l);\n                }\n            }\n            String val3 = null;\n            for (int m = 0; m < this.nbLignes - 1; ++m) {\n                val2 = new String();\n                val = (String)this.ts.getValueAt(m, indice);\n                k = 0;\n                if (val.equals(\"\")) {\n                    val2 = \"\";\n                    val3 = \"\";\n                }\n                else {\n                    while (val.charAt(k) != ' ' && k != val.length() - 1) {\n                        val2 = val2.concat(String.valueOf(val.charAt(k)));\n                        ++k;\n                    }\n                    if (k == val.length() - 1) {\n                        val2 = new String();\n                        for (k = 0; val.charAt(k) != ' ' && k != val.length() - 1; ++k) {\n                            val2 = val2.concat(String.valueOf(val.charAt(k)));\n                        }\n                    }\n                    val3 = val.substring(k + 1, val.length());\n                }\n                double int1 = 0.0;\n                double int2 = 0.0;\n                try {\n                    int1 = Double.parseDouble(val2);\n                    tableS.setValueAt(int1, m, indice);\n                }\n                catch (NumberFormatException e) {\n                    tableS.setValueAt(val2, m, indice);\n                }\n                try {\n                    int2 = Double.parseDouble(val3);\n                    tableS.setValueAt(int2, m, indice + 1);\n                }\n                catch (NumberFormatException e) {\n                    tableS.setValueAt(val3, m, indice + 1);\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"PAS SEPARABLE\", \"ERREUR\", 0);\n        return this.ts;\n    }\n    \n    public TableStockage fusionnerColonnes(final int indice) {\n        if (this.nbColonnes <= 1) {\n            JOptionPane.showMessageDialog(null, \"UNE SEULE COLONNE\", \"ERREUR\", 0);\n            return this.ts;\n        }\n        if (!this.ts.getColumnClass(indice).equals(Boolean.class) && !this.ts.getColumnClass(indice + 1).equals(Boolean.class)) {\n            --this.nbColonnes;\n            final TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n            for (int j = 0; j < indice; ++j) {\n                tableS.setColumnName(j, this.ts.getColumnName(j));\n            }\n            final String c1 = this.ts.getColumnName(indice);\n            final String c2 = this.ts.getColumnName(indice + 1);\n            for (int i = indice + 1; i < this.nbColonnes; ++i) {\n                tableS.setColumnName(i, this.ts.getColumnName(i + 1));\n            }\n            tableS.setColumnName(indice, c1.concat(\" \" + c2));\n            for (int k = 0; k < this.nbLignes - 1; ++k) {\n                for (int l = 0; l < indice; ++l) {\n                    tableS.setValueAt(this.ts.getValueAt(k, l), k, l);\n                }\n                final Object d1 = this.ts.getValueAt(k, indice);\n                final Object d2 = this.ts.getValueAt(k, indice + 1);\n                final String s1 = d1.toString();\n                final String s2 = d2.toString();\n                tableS.setValueAt(s1.concat(\" \" + s2), k, indice);\n                for (int m = indice + 1; m < this.nbColonnes; ++m) {\n                    tableS.setValueAt(this.ts.getValueAt(k, m + 1), k, m);\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"PAS DE TYPE STRING\", \"ERREUR\", 0);\n        return this.ts;\n    }\n    \n    public TableStockage colonneMail() {\n        ++this.nbColonnes;\n        final ModifTableStockage mt = new ModifTableStockage(this.ts);\n        TableStockage tableS = new TableStockage(this.nbLignes, this.nbColonnes);\n        tableS = mt.ajouterColonne(\"Envoyer E-Mail a:\", Boolean.class);\n        for (int i = 0; i < this.nbLignes - 1; ++i) {\n            tableS.setValueAt(new Boolean(true), i, this.nbColonnes - 1);\n        }\n        return tableS;\n    }\n    \n    public TableStockage selectMail() {\n        int j;\n        for (j = 0; j < this.nbColonnes && !this.ts.getColumnName(j).equals(\"Envoyer E-Mail a:\"); ++j) {}\n        if (j != this.nbColonnes) {\n            int newNbLignes = 0;\n            for (int i = 0; i < this.nbLignes - 1; ++i) {\n                final Boolean bool = (Boolean)this.ts.getValueAt(i, j);\n                if (bool) {\n                    ++newNbLignes;\n                }\n            }\n            final TableStockage tableS = new TableStockage(newNbLignes + 1, this.nbColonnes);\n            int k = 0;\n            for (int ind = 0; ind < this.nbColonnes; ++ind) {\n                tableS.setColumnName(ind, this.ts.getColumnName(ind));\n            }\n            for (int row = 0; row < this.nbLignes - 1; ++row) {\n                Boolean bool = (Boolean)this.ts.getValueAt(row, j);\n                if (bool) {\n                    for (int column = 0; column < this.nbColonnes; ++column) {\n                        tableS.setValueAt(this.ts.getValueAt(row, column), k, column);\n                        bool = false;\n                    }\n                    ++k;\n                }\n            }\n            return tableS;\n        }\n        JOptionPane.showMessageDialog(null, \"Le mail sera envoye a toute la liste\", \"Information\", 1);\n        return this.ts;\n    }\n}\n"
    },
    {
        "project_name": "98_trans-locator",
        "class": "FoxHuntFrame",
        "fqdn": "Joshua.FoxHunt",
        "source_code": "package Joshua.FoxHunt;\n\nimport java.util.*;\nimport java.awt.event.*;\nimport java.awt.*;\nimport java.io.*;\nimport javax.swing.*;\nimport javax.swing.table.*;\nimport java.text.*;\n\npublic class FoxHuntFrame extends JFrame implements ActionListener\n{\n    JTextField theta;\n    JTextField lat;\n    JTextField lon;\n    JTextField zoom;\n    JButton add;\n    JTable pos;\n    FoxTableModel posModel;\n    HuntDisplay display;\n    JPanel panel1;\n    JPanel panel2;\n    JPanel panel3;\n    JPanel panel;\n    Vector points;\n    Vector fox;\n    \n    public FoxHuntFrame() {\n        super(\"Triangulation\");\n        JFrame.setDefaultLookAndFeelDecorated(true);\n        this.points = new Vector();\n        this.fox = new Vector();\n        this.textPrep();\n        this.tablePrep();\n        this.displayPrep();\n        this.finalPrep();\n        final ImageIcon icon = new ImageIcon(\"icon.gif\");\n        this.setIconImage(icon.getImage());\n        this.setDefaultCloseOperation(3);\n        this.getContentPane().add(this.panel, \"Center\");\n        this.pack();\n        this.setState(6);\n        this.setVisible(true);\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        this.addPoint();\n    }\n    \n    public void addPoint() {\n        final int angle = Integer.parseInt(this.theta.getText());\n        final double LAT = Double.parseDouble(this.lat.getText());\n        final double LON = Double.parseDouble(this.lon.getText());\n        final TrigPoint point = new TrigPoint(LAT, LON, angle);\n        this.points.add(point);\n        this.display.addPoint(point);\n        if (this.points.size() > 1) {\n            final TrigPoint C = this.points.elementAt(this.points.size() - 2);\n            final TrigPoint B = FoxCalc.calcFox(point, C);\n            this.fox.add(B);\n            this.posModel.fireTableDataChanged();\n            this.display.addPoint(B);\n        }\n    }\n    \n    private void finalPrep() {\n        (this.zoom = new JTextField(\"1\")).addActionListener(this);\n        final JLabel zoomL = new JLabel(\"Zoom\");\n        final JPanel zoomP = new JPanel(new GridLayout(1, 2));\n        zoomP.add(zoomL);\n        zoomP.add(this.zoom);\n        (this.panel3 = new JPanel(new BorderLayout())).add(this.zoom, \"North\");\n        this.panel3.add(this.display, \"Center\");\n        this.panel = new JPanel(new BorderLayout());\n        final JSplitPane controls = new JSplitPane(1, this.panel1, this.panel2);\n        final JSplitPane map = new JSplitPane(0, controls, this.panel3);\n        map.setDividerLocation(0.25);\n        (this.panel = new JPanel(new BorderLayout())).add(map, \"Center\");\n    }\n    \n    private void textPrep() {\n        this.theta = new JTextField(3);\n        this.lat = new JTextField(9);\n        this.lon = new JTextField(10);\n        (this.add = new JButton(\"Add It!!!\")).addActionListener(this);\n        final JLabel thetaL = new JLabel(\"Theta in Degrees\");\n        final JLabel latL = new JLabel(\"Lat. dd*mm.mmm\");\n        final JLabel lonL = new JLabel(\"lon. ddd*mm.mmm\");\n        (this.panel1 = new JPanel(new GridLayout(4, 2))).add(thetaL);\n        this.panel1.add(this.theta);\n        this.panel1.add(latL);\n        this.panel1.add(this.lat);\n        this.panel1.add(lonL);\n        this.panel1.add(this.lon);\n        this.panel1.add(this.add);\n    }\n    \n    private void tablePrep() {\n        this.posModel = new FoxTableModel();\n        this.pos = new JTable(this.posModel);\n        final JScrollPane scroll = new JScrollPane(this.pos);\n        this.pos.setPreferredScrollableViewportSize(new Dimension(500, 70));\n        (this.panel2 = new JPanel(new BorderLayout())).add(scroll, \"Center\");\n    }\n    \n    private void displayPrep() {\n        this.display = new HuntDisplay();\n        this.loadLandmarks();\n    }\n    \n    private void loadLandmarks() {\n        try {\n            final File file = new File(\"./landmarks.cfg\");\n            final FileInputStream inFile = new FileInputStream(file);\n            final BufferedReader in = new BufferedReader(new InputStreamReader(inFile));\n            String input = \"\";\n            int NUM = 0;\n            if ((input = in.readLine()) != null) {\n                final String num = input.substring(4);\n                NUM = Integer.parseInt(num);\n            }\n            int numAtFile = 0;\n            int numAtLat = 0;\n            int numAtLon = 0;\n            final String[] iconFile = new String[NUM];\n            final double[] lat = new double[NUM];\n            final double[] lon = new double[NUM];\n            while ((input = in.readLine()) != null) {\n                if (input.startsWith(\"FILE\")) {\n                    iconFile[numAtFile] = input.substring(4);\n                    ++numAtFile;\n                }\n                else if (input.startsWith(\"LAT\")) {\n                    lat[numAtLat] = Double.parseDouble(input.substring(4));\n                    ++numAtLat;\n                }\n                else {\n                    if (!input.startsWith(\"LON\")) {\n                        continue;\n                    }\n                    lon[numAtLon] = Double.parseDouble(input.substring(4));\n                    ++numAtLon;\n                }\n            }\n            for (int a = 0; a < NUM; ++a) {\n                this.display.addLandMark(new Landmark(lat[a], lon[a], new ImageIcon(iconFile[a])));\n            }\n            in.close();\n            inFile.close();\n        }\n        catch (FileNotFoundException e) {\n            this.error(\"Can't Find the file\");\n        }\n        catch (IOException e2) {\n            this.error(\"Error communicating with the file\");\n        }\n    }\n    \n    private void error(final String text) {\n        final Object[] options = { \"Abort\", \"Continue\" };\n        final int ans = JOptionPane.showOptionDialog(this, text, \"Error\", 0, 0, null, options, options[0]);\n        if (ans == 0 | ans == -1) {\n            System.exit(1);\n        }\n    }\n    \n    class FoxTableModel extends AbstractTableModel\n    {\n        String[] colNames;\n        \n        FoxTableModel() {\n            this.colNames = new String[] { \"Lattitude\", \"Longitude\" };\n        }\n        \n        @Override\n        public int getColumnCount() {\n            return this.colNames.length;\n        }\n        \n        @Override\n        public int getRowCount() {\n            return FoxHuntFrame.this.fox.size();\n        }\n        \n        @Override\n        public String getColumnName(final int col) {\n            return this.colNames[col];\n        }\n        \n        @Override\n        public Object getValueAt(final int row, final int col) {\n            final DecimalFormat formatter = new DecimalFormat(\"###.##############\");\n            final TrigPoint point = FoxHuntFrame.this.fox.elementAt(row);\n            if (col == 0) {\n                final String output = formatter.format(point.getY());\n                return output;\n            }\n            final String output = formatter.format(point.getX());\n            return output;\n        }\n        \n        @Override\n        public Class getColumnClass(final int col) {\n            return this.getValueAt(0, col).getClass();\n        }\n        \n        @Override\n        public boolean isCellEditable(final int row, final int col) {\n            return false;\n        }\n    }\n}\n"
    },
    {
        "project_name": "98_trans-locator",
        "class": "HuntDisplay",
        "fqdn": "Joshua.FoxHunt",
        "source_code": "package Joshua.FoxHunt;\n\nimport javax.swing.*;\nimport java.util.*;\nimport java.awt.image.*;\nimport java.awt.*;\n\npublic class HuntDisplay extends JComponent\n{\n    Vector points;\n    Vector landmarks;\n    Dimension minSize;\n    Dimension prefSize;\n    \n    public HuntDisplay() {\n        this.points = new Vector();\n        this.landmarks = new Vector();\n        this.setBackground(Color.WHITE);\n        this.minSize = new Dimension(50, 50);\n        this.prefSize = new Dimension(200, 200);\n    }\n    \n    @Override\n    public Dimension getPreferredSize() {\n        return this.prefSize;\n    }\n    \n    @Override\n    public Dimension getMinimumSize() {\n        return this.minSize;\n    }\n    \n    public void addPoint(final TrigPoint point) {\n        this.points.add(new TrigPoint(point.getY() / 90.0, point.getX() / 180.0, point.getTheta(), point.isFox()));\n        this.repaint();\n    }\n    \n    public void addLandMark(final Landmark landmark) {\n        this.landmarks.add(new Landmark(landmark.getLat() / 90.0, landmark.getLon() / 180.0, landmark.getIcon()));\n        this.repaint();\n    }\n    \n    public void paintComponent(final Graphics g) {\n        super.paintComponent(g);\n        final Color point = Color.BLACK;\n        final Color fox = Color.GREEN;\n        final TrigPoint[] trigpoints = new TrigPoint[this.points.size()];\n        for (int a = 0; a < this.points.size(); ++a) {\n            trigpoints[a] = this.points.elementAt(a);\n        }\n        final Landmark[] landMarks = new Landmark[this.landmarks.size()];\n        if (this.landmarks.size() != 0) {\n            for (int z = 0; z < this.points.size(); ++z) {\n                landMarks[z] = this.landmarks.elementAt(z);\n            }\n        }\n        double trigPointAvgX = 0.0;\n        for (int b = 0; b < trigpoints.length; ++b) {\n            trigPointAvgX += trigpoints[b].getX();\n        }\n        trigPointAvgX /= trigpoints.length;\n        double trigPointAvgY = 0.0;\n        for (int b2 = 0; b2 < trigpoints.length; ++b2) {\n            trigPointAvgY += trigpoints[b2].getY();\n        }\n        trigPointAvgY /= trigpoints.length;\n        final double xAdd = 0.5 - trigPointAvgX;\n        final double yAdd = 0.5 - trigPointAvgY;\n        for (int t = 0; t < trigpoints.length; ++t) {\n            if (trigpoints[t].isFox()) {\n                g.setColor(fox);\n            }\n            else {\n                g.setColor(point);\n            }\n            final int X = (int)((trigpoints[t].getX() + xAdd) * this.getWidth());\n            final int Y = (int)((trigpoints[t].getY() + yAdd) * this.getHeight());\n            g.fillOval(X, Y, 5, 5);\n        }\n        g.setColor(this.getForeground());\n        if (this.landmarks.size() != 0) {\n            for (int l = 0; l < landMarks.length; ++l) {\n                final int X = (int)((landMarks[l].getLon() + xAdd) * this.getWidth());\n                final int Y = (int)((landMarks[l].getLat() + yAdd) * this.getHeight());\n                final Image image = landMarks[l].getIcon().getImage();\n                g.drawImage(image, X, Y, 10, 10, this.getBackground(), this);\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "90_dcparseargs",
        "class": "ArgsParser",
        "fqdn": "de.devcity.parseargs",
        "source_code": "package de.devcity.parseargs;\n\nimport de.devcity.parseargs.arguments.*;\nimport java.util.*;\n\npublic class ArgsParser\n{\n    public static final String SHORT_ARGUMENT_INDICATOR = \"-\";\n    public static final String LONG_ARGUMENT_INDICATOR = \"--\";\n    private String[] args;\n    private String[] innerArgs;\n    \n    public ArgsParser() {\n    }\n    \n    public ArgsParser(final String[] args) {\n        this.setArgs(args);\n    }\n    \n    public int getArgsCount() {\n        return this.args.length;\n    }\n    \n    public String[] getArgs() {\n        return this.args;\n    }\n    \n    public void setArgs(final String[] args) {\n        if (args == null) {\n            throw new NullPointerException(\"args[] cannot be null.\");\n        }\n        this.args = new String[args.length];\n        this.innerArgs = new String[args.length];\n        for (int i = 0; i < args.length; ++i) {\n            this.args[i] = args[i];\n            this.innerArgs[i] = args[i];\n        }\n    }\n    \n    public int getArgsLeftCount() {\n        int result = 0;\n        for (int i = 0; i < this.innerArgs.length; ++i) {\n            if (this.innerArgs[i] != null) {\n                ++result;\n            }\n        }\n        return result;\n    }\n    \n    public SwitchArgument parseSwitchArgument(final String key) {\n        final boolean isLongKey = key.length() > 1;\n        if (isLongKey) {\n            final String searchFor = \"--\" + key;\n            for (int i = 0; i < this.args.length; ++i) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].equals(searchFor)) {\n                    this.innerArgs[i] = null;\n                    return new SwitchArgument(i, key, true);\n                }\n            }\n        }\n        else {\n            for (int i = 0; i < this.args.length; ++i) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].length() > 1 && this.innerArgs[i].startsWith(\"-\") && !this.innerArgs[i].startsWith(\"--\")) {\n                    final int index = this.innerArgs[i].lastIndexOf(key);\n                    if (index > 0) {\n                        final String before = this.innerArgs[i].substring(0, index);\n                        final String after = this.innerArgs[i].substring(index + 1, this.innerArgs[i].length());\n                        this.innerArgs[i] = before + after;\n                        if (this.innerArgs[i].replace(\"-\", \" \").trim().length() == 0) {\n                            this.innerArgs[i] = null;\n                        }\n                        return new SwitchArgument(i, key, true);\n                    }\n                }\n            }\n        }\n        return new SwitchArgument(-1, key, false);\n    }\n    \n    public ParameterArgument parseParameterArgument(final String key) {\n        final boolean isLongKey = key.length() > 1;\n        if (isLongKey) {\n            final String searchFor = \"--\" + key;\n            int i = 0;\n            while (i < this.innerArgs.length) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].equals(searchFor)) {\n                    if (this.innerArgs.length > i + 1 && this.innerArgs[i] != null && this.innerArgs[i + 1] != null) {\n                        final String value = this.innerArgs[i + 1];\n                        this.innerArgs[i] = null;\n                        this.innerArgs[i + 1] = null;\n                        return new ParameterArgument(i, key, value);\n                    }\n                    return null;\n                }\n                else {\n                    ++i;\n                }\n            }\n        }\n        else {\n            for (int i = 0; i < this.args.length; ++i) {\n                if (this.innerArgs[i] != null && this.innerArgs[i].length() > 1 && this.innerArgs[i].startsWith(\"-\") && !this.innerArgs[i].startsWith(\"--\")) {\n                    final int index = this.innerArgs[i].indexOf(key);\n                    if (index > 0) {\n                        if (index + 1 != this.innerArgs[i].length()) {\n                            final String before = this.innerArgs[i].substring(0, index);\n                            final String value2 = this.innerArgs[i].substring(index + 1, this.innerArgs[i].length());\n                            this.innerArgs[i] = before;\n                            if (this.innerArgs[i].replace(\"-\", \" \").trim().length() == 0) {\n                                this.innerArgs[i] = null;\n                            }\n                            return new ParameterArgument(i, key, value2);\n                        }\n                        if (this.innerArgs.length > i + 1 && this.innerArgs[i] != null && this.innerArgs[i + 1] != null) {\n                            final String before = this.innerArgs[i].substring(0, index);\n                            final String after = this.innerArgs[i].substring(index + 1, this.innerArgs[i].length());\n                            this.innerArgs[i] = before + after;\n                            if (this.innerArgs[i].replace(\"-\", \" \").trim().length() == 0) {\n                                this.innerArgs[i] = null;\n                            }\n                            final String value3 = this.innerArgs[i + 1];\n                            this.innerArgs[i + 1] = null;\n                            return new ParameterArgument(i, key, value3);\n                        }\n                        return null;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    \n    public List<StringArgument> parseStringArgument() {\n        final List<StringArgument> result = new ArrayList<StringArgument>();\n        for (int i = 0; i < this.args.length; ++i) {\n            if (this.innerArgs[i] != null) {\n                result.add(new StringArgument(i, this.innerArgs[i]));\n                this.innerArgs[i] = null;\n            }\n        }\n        return result;\n    }\n}\n"
    },
    {
        "project_name": "69_lhamacaw",
        "class": "MacawWorkBench",
        "fqdn": "macaw.presentationLayer",
        "source_code": "package macaw.presentationLayer;\n\nimport macaw.businessLayer.*;\nimport macaw.persistenceLayer.demo.*;\nimport macaw.persistenceLayer.production.*;\nimport javax.swing.border.*;\nimport macaw.system.*;\nimport javax.swing.*;\nimport java.awt.*;\nimport macaw.io.*;\nimport java.awt.event.*;\n\npublic class MacawWorkBench implements ActionListener\n{\n    private SessionProperties sessionProperties;\n    private JDialog dialog;\n    private JButton editConstants;\n    private JButton editVariables;\n    private JButton exportVariableData;\n    private JButton exit;\n    \n    public static void main(final String[] arguments) {\n        final String dbUser = null;\n        final String dbPassword = null;\n        try {\n            final SessionProperties sessionProperties = new SessionProperties();\n            final StartupOptions startupOptions = (StartupOptions)sessionProperties.getProperty(\"startupOptions\");\n            startupOptions.processCommandLineArguments(arguments);\n            final User currentUser = new User(\"jsmith\", \"cool\");\n            sessionProperties.setProperty(\"currentUser\", currentUser);\n            if (startupOptions.useDemo()) {\n                final DemonstrationCurationService database = new DemonstrationCurationService(false);\n                final DemonstrationRetrievalService demonstratinRetrievalService = new DemonstrationRetrievalService(sessionProperties);\n                sessionProperties.setProperty(\"retrievalService\", demonstratinRetrievalService);\n                sessionProperties.setProperty(\"database\", database);\n            }\n            else {\n                final ProductionCurationService database2 = new ProductionCurationService(sessionProperties);\n                final ProductionRetrievalService macawRetrievalAPI = new ProductionRetrievalService(sessionProperties);\n                sessionProperties.setProperty(\"retrievalService\", macawRetrievalAPI);\n                sessionProperties.setProperty(\"database\", database2);\n            }\n            int numberOfAttempts;\n            LoginDialog loginDialog;\n            for (numberOfAttempts = 0, numberOfAttempts = 0; numberOfAttempts < 3; ++numberOfAttempts) {\n                loginDialog = new LoginDialog(sessionProperties, numberOfAttempts);\n                loginDialog.show();\n                if (loginDialog.isLoginSuccessful()) {\n                    break;\n                }\n                if (loginDialog.isCancelled()) {\n                    System.exit(0);\n                }\n            }\n            if (numberOfAttempts == 3) {\n                System.exit(0);\n            }\n            final MacawWorkBench macawWorkBench = new MacawWorkBench(sessionProperties);\n            macawWorkBench.show();\n        }\n        catch (Exception exception) {\n            exception.printStackTrace(System.out);\n        }\n    }\n    \n    public MacawWorkBench(final SessionProperties sessionProperties) {\n        this.sessionProperties = sessionProperties;\n        final UserInterfaceFactory userInterfaceFactory = sessionProperties.getUserInterfaceFactory();\n        this.dialog = userInterfaceFactory.createDialog();\n        final String dialogTitle = MacawMessages.getMessage(\"macawWorkBench.title\");\n        this.dialog.setTitle(dialogTitle);\n        final JPanel panel = userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = userInterfaceFactory.createGridBagConstraints();\n        panelGC.anchor = 18;\n        panelGC.fill = 2;\n        panelGC.weightx = 1.0;\n        final JTextArea instructionsArea = userInterfaceFactory.createImmutableTextArea(3, 20);\n        final String instructionsText = MacawMessages.getMessage(\"macawWorkBench.instructions\");\n        instructionsArea.setText(instructionsText);\n        instructionsArea.setBorder(LineBorder.createGrayLineBorder());\n        panel.add(instructionsArea, panelGC);\n        final GridBagConstraints gridBagConstraints = panelGC;\n        ++gridBagConstraints.gridy;\n        panelGC.anchor = 10;\n        panelGC.fill = 0;\n        panelGC.weightx = 0.0;\n        panel.add(this.createButtonPanel(userInterfaceFactory), panelGC);\n        this.dialog.getContentPane().add(panel);\n        this.dialog.setModal(true);\n        this.dialog.setSize(300, 300);\n    }\n    \n    private JPanel createButtonPanel(final UserInterfaceFactory userInterfaceFactory) {\n        final JPanel panel = userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = userInterfaceFactory.createGridBagConstraints();\n        panelGC.ipady = 10;\n        panelGC.insets = new Insets(2, 2, 2, 2);\n        panelGC.fill = 0;\n        panelGC.weightx = 1.0;\n        final String editConstantsText = MacawMessages.getMessage(\"macawWorkBench.editConstants\");\n        this.editConstants = userInterfaceFactory.createButton(editConstantsText);\n        final String editConstantsInformationText = MacawMessages.getMessage(\"macawWorkBench.editConstants.instructions\");\n        this.editConstants.setToolTipText(editConstantsInformationText);\n        this.editConstants.addActionListener(this);\n        panel.add(this.editConstants, panelGC);\n        final GridBagConstraints gridBagConstraints = panelGC;\n        ++gridBagConstraints.gridy;\n        final String editVariablesText = MacawMessages.getMessage(\"macawWorkBench.editVariables\");\n        (this.editVariables = userInterfaceFactory.createButton(editVariablesText)).addActionListener(this);\n        final String editVariablesInformationText = MacawMessages.getMessage(\"macawWorkBench.editVariables.instructions\");\n        this.editVariables.setToolTipText(editVariablesInformationText);\n        panel.add(this.editVariables, panelGC);\n        final GridBagConstraints gridBagConstraints2 = panelGC;\n        ++gridBagConstraints2.gridy;\n        final String exportVariableText = MacawMessages.getMessage(\"macawWorkBench.exportVariableData\");\n        (this.exportVariableData = userInterfaceFactory.createButton(exportVariableText)).addActionListener(this);\n        final String exportVariableInformationText = MacawMessages.getMessage(\"macawWorkBench.exportVariableData.instructions\");\n        this.exportVariableData.setToolTipText(exportVariableInformationText);\n        panel.add(this.exportVariableData, panelGC);\n        final GridBagConstraints gridBagConstraints3 = panelGC;\n        ++gridBagConstraints3.gridy;\n        final String exitText = MacawMessages.getMessage(\"general.buttons.exit\");\n        (this.exit = userInterfaceFactory.createButton(exitText)).addActionListener(this);\n        panel.add(this.exit, panelGC);\n        return panel;\n    }\n    \n    public void show() {\n        this.dialog.setVisible(true);\n    }\n    \n    private void editConstants() {\n        final VariableConstantsEditor variableConstantsEditor = new VariableConstantsEditor(this.sessionProperties, true);\n        variableConstantsEditor.show();\n    }\n    \n    private void editVariables() {\n        final MacawVariableBrowser macawVariableBrowser = new MacawVariableBrowser(this.sessionProperties);\n        macawVariableBrowser.show();\n    }\n    \n    private void exportVariableData() {\n        final ExportVariablesToMacawXML exportToDSSFormat = new ExportVariablesToMacawXML(this.sessionProperties);\n        exportToDSSFormat.export();\n    }\n    \n    private void exit() {\n        System.exit(0);\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent event) {\n        final Object button = event.getSource();\n        if (button == this.editConstants) {\n            this.editConstants();\n        }\n        else if (button == this.editVariables) {\n            this.editVariables();\n        }\n        else if (button == this.exportVariableData) {\n            this.exportVariableData();\n        }\n        else {\n            this.exit();\n        }\n    }\n}\n"
    },
    {
        "project_name": "69_lhamacaw",
        "class": "DisplayableListPanel",
        "fqdn": "macaw.util",
        "source_code": "package macaw.util;\n\nimport macaw.businessLayer.*;\nimport java.awt.*;\nimport macaw.system.*;\nimport javax.swing.*;\nimport java.util.*;\nimport java.awt.event.*;\n\npublic class DisplayableListPanel implements ActionListener\n{\n    private boolean isNewRecord;\n    private ArrayList<Displayable> masterList;\n    private SessionProperties sessionProperties;\n    private Log log;\n    private String panelTitleText;\n    private String currentUserID;\n    private UserInterfaceFactory userInterfaceFactory;\n    private DisplayableListParentForm parentForm;\n    private DisplayableListItemSelector listItemSelector;\n    private DisplayableListItemAdder listItemAdder;\n    private DisplayableListItemEditor listItemEditor;\n    private DisplayableListItemViewer listItemViewer;\n    private DisplayableListItemDeleter listItemDeleter;\n    private String listOwnerName;\n    private boolean allowWriteAccess;\n    private boolean allowRecordEditing;\n    private ArrayList<Displayable> masterSourceVariableCollection;\n    private JPanel panel;\n    private DisplayableList displayableList;\n    private JButton select;\n    private JButton add;\n    private JButton edit;\n    private JButton view;\n    private JButton delete;\n    \n    public DisplayableListPanel(final SessionProperties sessionProperties, final DisplayableListParentForm parentForm, final String panelTitleText, final boolean allowWriteAccess) {\n        this.init(sessionProperties, parentForm, panelTitleText, allowWriteAccess, allowWriteAccess);\n    }\n    \n    public DisplayableListPanel(final SessionProperties sessionProperties, final DisplayableListParentForm parentForm, final String panelTitleText, final boolean allowWriteAccess, final boolean allowRecordEditing) {\n        this.init(sessionProperties, parentForm, panelTitleText, allowWriteAccess, allowRecordEditing);\n    }\n    \n    private void init(final SessionProperties sessionProperties, final DisplayableListParentForm parentForm, final String panelTitleText, final boolean allowWriteAccess, final boolean allowRecordEditing) {\n        this.sessionProperties = sessionProperties;\n        this.log = sessionProperties.getLog();\n        this.parentForm = parentForm;\n        this.panelTitleText = panelTitleText;\n        this.allowWriteAccess = allowWriteAccess;\n        this.allowRecordEditing = allowRecordEditing;\n        this.userInterfaceFactory = sessionProperties.getUserInterfaceFactory();\n        final User currentUser = (User)sessionProperties.getProperty(\"currentUser\");\n        this.currentUserID = currentUser.getUserID();\n        this.masterList = new ArrayList<Displayable>();\n        this.displayableList = new DisplayableList(this.userInterfaceFactory);\n        final String selectText = MacawMessages.getMessage(\"general.buttons.select\");\n        (this.select = this.userInterfaceFactory.createButton(selectText)).addActionListener(this);\n        final String addText = MacawMessages.getMessage(\"general.buttons.add\");\n        (this.add = this.userInterfaceFactory.createButton(addText)).addActionListener(this);\n        final String editText = MacawMessages.getMessage(\"general.buttons.edit\");\n        (this.edit = this.userInterfaceFactory.createButton(editText)).addActionListener(this);\n        final String viewText = MacawMessages.getMessage(\"general.buttons.view\");\n        (this.view = this.userInterfaceFactory.createButton(viewText)).addActionListener(this);\n        final String deleteText = MacawMessages.getMessage(\"general.buttons.delete\");\n        (this.delete = this.userInterfaceFactory.createButton(deleteText)).addActionListener(this);\n    }\n    \n    private void buildUI() {\n        this.panel = this.userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = this.userInterfaceFactory.createGridBagConstraints();\n        final JLabel titleLabel = this.userInterfaceFactory.createLabel(this.panelTitleText);\n        this.panel.add(titleLabel, panelGC);\n        final GridBagConstraints gridBagConstraints = panelGC;\n        ++gridBagConstraints.gridy;\n        panelGC.fill = 1;\n        panelGC.weightx = 100.0;\n        panelGC.weighty = 100.0;\n        final JScrollPane scrollPane = this.displayableList.getListScrollPane();\n        this.panel.add(scrollPane, panelGC);\n        final GridBagConstraints gridBagConstraints2 = panelGC;\n        ++gridBagConstraints2.gridy;\n        panelGC.anchor = 14;\n        panelGC.fill = 0;\n        panelGC.weightx = 0.0;\n        panelGC.weighty = 0.0;\n        this.panel.add(this.createControlButtonPanel(), panelGC);\n    }\n    \n    private JPanel createControlButtonPanel() {\n        final JPanel panel = this.userInterfaceFactory.createPanel();\n        final GridBagConstraints panelGC = this.userInterfaceFactory.createGridBagConstraints();\n        if (this.listItemSelector != null && this.allowWriteAccess) {\n            panel.add(this.select, panelGC);\n            final GridBagConstraints gridBagConstraints = panelGC;\n            ++gridBagConstraints.gridx;\n        }\n        if (this.listItemAdder != null) {\n            panel.add(this.add, panelGC);\n            final GridBagConstraints gridBagConstraints2 = panelGC;\n            ++gridBagConstraints2.gridx;\n        }\n        if (this.allowRecordEditing && this.listItemEditor != null) {\n            panel.add(this.edit, panelGC);\n            final GridBagConstraints gridBagConstraints3 = panelGC;\n            ++gridBagConstraints3.gridx;\n        }\n        else if (this.listItemViewer != null) {\n            panel.add(this.view, panelGC);\n            final GridBagConstraints gridBagConstraints4 = panelGC;\n            ++gridBagConstraints4.gridx;\n        }\n        if (this.listItemDeleter != null) {\n            panel.add(this.delete, panelGC);\n        }\n        return panel;\n    }\n    \n    public void setNewRecord(final boolean isNewRecord) {\n        this.isNewRecord = isNewRecord;\n        this.updateButtonStates();\n    }\n    \n    public JPanel getPanel() {\n        this.buildUI();\n        return this.panel;\n    }\n    \n    public void setDisplayableListItemSelector(final DisplayableListItemSelector listItemSelector) {\n        this.listItemSelector = listItemSelector;\n    }\n    \n    public void setDisplayableListItemAdder(final DisplayableListItemAdder listItemAdder) {\n        this.listItemAdder = listItemAdder;\n    }\n    \n    public void setDisplayableListItemEditor(final DisplayableListItemEditor listItemEditor) {\n        this.listItemEditor = listItemEditor;\n    }\n    \n    public void setDisplayableListItemViewer(final DisplayableListItemViewer listItemViewer) {\n        this.listItemViewer = listItemViewer;\n    }\n    \n    public void setDisplayableListItemDeleter(final DisplayableListItemDeleter listItemDeleter) {\n        this.listItemDeleter = listItemDeleter;\n    }\n    \n    public void addListItem() {\n        try {\n            if (this.listItemAdder == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingAdder\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_ADDER, errorMessage);\n                throw exception;\n            }\n            this.parentForm.commitChanges();\n            this.listItemAdder.addItems(this.listOwnerName, this.displayableList);\n            this.updateButtonStates();\n        }\n        catch (MacawException exception2) {\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(exception2);\n        }\n    }\n    \n    private void editSelectedListItem() {\n        if (!this.displayableList.itemsAreSelected()) {\n            final String errorMessage = MacawMessages.getMessage(\"general.error.unselectedItems\");\n            final Log log = (Log)this.sessionProperties.getProperty(\"log\");\n            log.displayErrorDialog(errorMessage);\n            return;\n        }\n        try {\n            if (this.listItemEditor == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingEditor\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_EDITOR, errorMessage);\n                throw exception;\n            }\n            this.parentForm.commitChanges();\n            final Displayable selectedListItem = this.displayableList.getSelectedItem();\n            final String oldDisplayName = selectedListItem.getDisplayName();\n            this.listItemEditor.editListItem(this.listOwnerName, selectedListItem, this.displayableList);\n        }\n        catch (MacawException exception2) {\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(exception2);\n        }\n    }\n    \n    private void viewSelectedListItem() {\n        if (!this.displayableList.itemsAreSelected()) {\n            final String errorMessage = MacawMessages.getMessage(\"general.error.unselectedItems\");\n            final Log log = (Log)this.sessionProperties.getProperty(\"log\");\n            log.displayErrorDialog(errorMessage);\n            return;\n        }\n        try {\n            if (this.listItemViewer == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingViewer\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_SELECTOR, errorMessage);\n                throw exception;\n            }\n            final Displayable selectedListItem = this.displayableList.getSelectedItem();\n            this.listItemViewer.viewListItem(selectedListItem);\n        }\n        catch (MacawException exception2) {\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(exception2);\n        }\n    }\n    \n    public void deleteSelectedListItems() {\n        if (!this.displayableList.itemsAreSelected()) {\n            final String errorMessage = MacawMessages.getMessage(\"general.error.unselectedItems\");\n            final Log log = this.sessionProperties.getLog();\n            log.displayErrorDialog(errorMessage);\n            return;\n        }\n        try {\n            this.parentForm.commitChanges();\n            if (this.listItemDeleter == null) {\n                final String errorMessage = MacawMessages.getMessage(\"displayListPanel.error.missingDeleter\");\n                final MacawException exception = new MacawException(MacawErrorType.MISSING_DISPLAY_LIST_DELETER, errorMessage);\n                throw exception;\n            }\n            final String dialogTitle = MacawMessages.getMessage(\"general.warning.title\");\n            final String warningMessage = MacawMessages.getMessage(\"general.warning.deletionIsPermanent\");\n            final int result = JOptionPane.showConfirmDialog(null, warningMessage, dialogTitle, 0, 2);\n            if (result != 0) {\n                return;\n            }\n            this.listItemDeleter.deleteListItems(this.listOwnerName, this.displayableList);\n            this.updateButtonStates();\n        }\n        catch (MacawException exception2) {\n            this.log.displayErrorDialog(exception2);\n        }\n    }\n    \n    private void selectListItems() {\n        try {\n            this.listItemSelector.selectListItems(this.listOwnerName, this.displayableList);\n            this.updateButtonStates();\n        }\n        catch (MacawException exception) {\n            this.log.displayErrorDialog(exception);\n        }\n    }\n    \n    public void updateButtonStates() {\n        if (this.allowWriteAccess) {\n            if (this.isNewRecord) {\n                this.add.setEnabled(false);\n                this.delete.setEnabled(false);\n                this.edit.setEnabled(false);\n                this.view.setEnabled(false);\n                this.select.setEnabled(false);\n            }\n            else {\n                this.add.setEnabled(true);\n                this.select.setEnabled(true);\n                if (this.displayableList.isEmpty()) {\n                    this.delete.setEnabled(false);\n                    if (this.allowRecordEditing) {\n                        this.edit.setEnabled(false);\n                    }\n                    else {\n                        this.view.setEnabled(false);\n                    }\n                }\n                else {\n                    this.delete.setEnabled(true);\n                    if (this.allowRecordEditing) {\n                        this.edit.setEnabled(true);\n                    }\n                    else {\n                        this.view.setEnabled(true);\n                    }\n                }\n            }\n        }\n        else {\n            this.add.setEnabled(false);\n            this.delete.setEnabled(false);\n            if (this.displayableList.isEmpty()) {\n                this.view.setEnabled(false);\n            }\n            else if (!this.isNewRecord) {\n                this.view.setEnabled(true);\n            }\n        }\n    }\n    \n    public void setDisplayableItems(final ArrayList<Displayable> masterList) {\n        this.masterList = masterList;\n        this.displayableList.setDisplayItems(masterList);\n        this.updateButtonStates();\n    }\n    \n    public void save() {\n        this.masterList.clear();\n        final ArrayList<Displayable> currentList = this.displayableList.getAllItems();\n        this.masterList.addAll(currentList);\n    }\n    \n    public ArrayList<Displayable> getAllListItems() {\n        return this.displayableList.getAllItems();\n    }\n    \n    public void setListOwnerName(final String listOwnerName) {\n        this.listOwnerName = listOwnerName;\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent event) {\n        final Object button = event.getSource();\n        if (button == this.select) {\n            this.selectListItems();\n        }\n        else if (button == this.add) {\n            this.addListItem();\n        }\n        else if (button == this.edit) {\n            this.editSelectedListItem();\n        }\n        else if (button == this.view) {\n            this.viewSelectedListItem();\n        }\n        else if (button == this.delete) {\n            this.deleteSelectedListItems();\n        }\n    }\n}\n"
    },
    {
        "project_name": "31_xisemele",
        "class": "OperationsHelperImpl",
        "fqdn": "net.sf.xisemele.impl",
        "source_code": "package net.sf.xisemele.impl;\n\nimport org.w3c.dom.*;\nimport java.util.*;\n\nclass OperationsHelperImpl implements OperationsHelper\n{\n    private static final long serialVersionUID = 1L;\n    \n    @Override\n    public List<Node> children(final Node node) {\n        final ArrayList<Node> children = new ArrayList<Node>();\n        final NodeList nodeList = node.getChildNodes();\n        for (int index = 0; index < nodeList.getLength(); ++index) {\n            final Node item = nodeList.item(index);\n            if (item.getNodeType() == 1) {\n                children.add(item);\n            }\n        }\n        return children;\n    }\n    \n    @Override\n    public Node find(final Document document, final String path) {\n        final String[] names = path.split(\"/\");\n        Node found = null;\n        if (names.length > 0 && names[0].equals(document.getDocumentElement().getNodeName())) {\n            found = document.getDocumentElement();\n            NodeList nodeList = found.getChildNodes();\n            for (int nameIndex = 1; nameIndex < names.length; ++nameIndex) {\n                for (int nodeIndex = 0; nodeIndex < nodeList.getLength(); ++nodeIndex) {\n                    if (nodeList.item(nodeIndex).getNodeName().equals(names[nameIndex])) {\n                        found = nodeList.item(nodeIndex);\n                        nodeList = found.getChildNodes();\n                        break;\n                    }\n                }\n            }\n        }\n        if (found != null && found.getNodeName().equals(names[names.length - 1])) {\n            return found;\n        }\n        return null;\n    }\n    \n    @Override\n    public Node nodeWithName(final List<Node> nodes, final String name) {\n        for (final Node node : nodes) {\n            if (node.getNodeName().equals(name)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public List<Node> sublistWithName(final List<Node> nodes, final String name) {\n        final ArrayList<Node> sublist = new ArrayList<Node>();\n        for (final Node node : nodes) {\n            if (node.getNodeName().equals(name)) {\n                sublist.add(node);\n            }\n        }\n        return sublist;\n    }\n}\n"
    },
    {
        "project_name": "40_glengineer",
        "class": "GroupAgent",
        "fqdn": "glengineer.agents",
        "source_code": "package glengineer.agents;\n\nimport glengineer.agents.settings.*;\nimport java.util.*;\nimport glengineer.*;\nimport javax.swing.*;\nimport glengineer.agents.setters.*;\n\npublic abstract class GroupAgent extends Agent\n{\n    protected LinkedList<Agent> childrenAgents;\n    \n    public GroupAgent() {\n        this.childrenAgents = new LinkedList<Agent>();\n        this.settings = new Settings();\n    }\n    \n    @Override\n    public String getFirstName() {\n        if (this.childrenAgents.isEmpty()) {\n            return null;\n        }\n        final Iterator<Agent> i = this.childrenAgents.iterator();\n        while (i.hasNext()) {\n            final String result = i.next().getFirstName();\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public String getLastName() {\n        if (this.childrenAgents.isEmpty()) {\n            return null;\n        }\n        final Iterator<Agent> i = this.childrenAgents.descendingIterator();\n        while (i.hasNext()) {\n            final String result = i.next().getLastName();\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public boolean isComponent(final String componentName) {\n        return false;\n    }\n    \n    @Override\n    public boolean isGroup(final String firstName, final String lastName) {\n        return this.getFirstName().equals(firstName) && this.getLastName().equals(lastName);\n    }\n    \n    @Override\n    public boolean isGap() {\n        return false;\n    }\n    \n    @Override\n    public boolean equals(final Agent agent) {\n        return agent.isGroup(this.getFirstName(), this.getLastName());\n    }\n    \n    public void addAgent(final Agent agent) {\n        if (agent == null) {\n            throw new IllegalArgumentException(\"Cannot add null agents.\");\n        }\n        this.childrenAgents.add(agent);\n    }\n    \n    public List<Agent> getChildren() {\n        return Collections.unmodifiableList((List<? extends Agent>)this.childrenAgents);\n    }\n    \n    public int getNumberOfChildren() {\n        return this.childrenAgents.size();\n    }\n    \n    public ComponentAgent getComponent(final String name) {\n        for (final Agent child : this.childrenAgents) {\n            if (child.isComponent(name)) {\n                return (ComponentAgent)child;\n            }\n        }\n        throw new IllegalArgumentException(\"component \" + name + \" in the \" + this + \" not found\");\n    }\n    \n    public GroupAgent getGroup(final String firstName, final String lastName) {\n        for (final Agent child : this.childrenAgents) {\n            if (child.isGroup(firstName, lastName)) {\n                return (GroupAgent)child;\n            }\n        }\n        throw new IllegalArgumentException(\"the group <\" + firstName + \",\" + lastName + \"> in the \" + this + \" not found\");\n    }\n    \n    @Override\n    public ComponentAgent findDependingComponentByName(final String componentName) {\n        ComponentAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingComponentByName(componentName);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public GroupAgent findDependingGroupByNames(final String firstName, final String lastName) {\n        if (this.isGroup(firstName, lastName)) {\n            return this;\n        }\n        GroupAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingGroupByNames(firstName, lastName);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public ParallelGroupAgent findDependingParallelGroupByNames(final String firstName, final String lastName) {\n        if (this.isGroup(firstName, lastName) && this instanceof ParallelGroupAgent) {\n            return (ParallelGroupAgent)this;\n        }\n        GroupAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingParallelGroupByNames(firstName, lastName);\n            if (result != null) {\n                return (ParallelGroupAgent)result;\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public SequentialGroupAgent findDependingSequentialGroupByNames(final String firstName, final String lastName) {\n        if (this.isGroup(firstName, lastName) && this instanceof SequentialGroupAgent) {\n            return (SequentialGroupAgent)this;\n        }\n        GroupAgent result = null;\n        for (final Agent child : this.childrenAgents) {\n            result = child.findDependingSequentialGroupByNames(firstName, lastName);\n            if (result != null) {\n                return (SequentialGroupAgent)result;\n            }\n        }\n        return null;\n    }\n    \n    public void removeGapsFromParallelGroups() {\n        this.passTheCallToSubgroups();\n        this.removeGapsFromParallelSubgroupsWithOtherContent();\n        this.replaceParallelSubgroupsWithGapsByTheirSingleGaps();\n        this.replaceContinuousSequencesOfGapsBySingleGaps();\n        this.replaceGroupsWithSingleElementsByThatElements();\n    }\n    \n    private void passTheCallToSubgroups() {\n        for (final Agent child : this.childrenAgents) {\n            if (child instanceof GroupAgent) {\n                ((GroupAgent)child).removeGapsFromParallelGroups();\n            }\n        }\n    }\n    \n    private void removeGapsFromParallelSubgroupsWithOtherContent() {\n        for (final Agent child : this.childrenAgents) {\n            if (child instanceof ParallelGroupAgent) {\n                final ParallelGroupAgent parallel = (ParallelGroupAgent)child;\n                if (parallel.containsGapsOnly()) {\n                    continue;\n                }\n                parallel.removeAllGaps();\n            }\n        }\n    }\n    \n    private void replaceParallelSubgroupsWithGapsByTheirSingleGaps() {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (child instanceof ParallelGroupAgent) {\n                final ParallelGroupAgent parallel = (ParallelGroupAgent)child;\n                final Agent gap = parallel.getGapsType();\n                if (gap == null) {\n                    continue;\n                }\n                li.set(gap);\n            }\n        }\n    }\n    \n    private void replaceContinuousSequencesOfGapsBySingleGaps() {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (!child.isGap()) {\n                continue;\n            }\n            final Agent currentGap = child;\n            while (li.hasNext()) {\n                final Agent nextGap = li.next();\n                if (!nextGap.isGap()) {\n                    break;\n                }\n                if (!nextGap.equals(currentGap)) {\n                    throw new IllegalArgumentException(\"A sequence of gaps possessing different types was found in a group.\");\n                }\n                li.remove();\n            }\n        }\n    }\n    \n    private void replaceGroupsWithSingleElementsByThatElements() {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (child instanceof GroupAgent) {\n                final GroupAgent nextSubgroup = (GroupAgent)child;\n                if (nextSubgroup.getNumberOfChildren() != 1) {\n                    continue;\n                }\n                li.set(nextSubgroup.getChildren().get(0));\n            }\n        }\n    }\n    \n    public void replaceTemporaryGapsByRealGaps(final GroupLayoutEngineer.TemporaryGapsToGaps map) {\n        final ListIterator<Agent> li = this.childrenAgents.listIterator();\n        while (li.hasNext()) {\n            final Agent child = li.next();\n            if (child instanceof GroupAgent) {\n                ((GroupAgent)child).replaceTemporaryGapsByRealGaps(map);\n            }\n            if (child instanceof TemporaryGapAgent) {\n                li.set(map.gap((TemporaryGapAgent)child));\n            }\n        }\n    }\n    \n    @Override\n    public void addContentToGroup(final GroupLayout.Group parentGroup, final GroupCreatorAndElementAdder creatorAndAdder) {\n        creatorAndAdder.addGroupToGroup(this.groupContent(creatorAndAdder), this.settings, parentGroup);\n    }\n    \n    public abstract GroupLayout.Group groupContent(final GroupCreatorAndElementAdder p0);\n    \n    public abstract FunctionsOnGroup getFunctionsOnGroupImplemenation();\n    \n    public void addGapBefore(final GapAgent gap, final Agent element) {\n        if (this.childrenAgents.isEmpty()) {\n            this.childrenAgents.add(gap);\n            return;\n        }\n        final ListIterator<Agent> iter = this.childrenAgents.listIterator();\n        while (iter.hasNext()) {\n            if (iter.next().equals(element)) {\n                iter.previous();\n                iter.add(gap);\n                return;\n            }\n        }\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + this.toString() + \" not found\");\n    }\n    \n    public void addGapAfter(final GapAgent gap, final Agent element) {\n        if (this.childrenAgents.isEmpty()) {\n            this.childrenAgents.add(gap);\n            return;\n        }\n        final ListIterator<Agent> iter = this.childrenAgents.listIterator();\n        while (iter.hasNext()) {\n            if (iter.next().equals(element)) {\n                iter.add(gap);\n                return;\n            }\n        }\n        throw new IllegalArgumentException(\"the \" + element.toString() + \" in the \" + this.toString() + \" not found\");\n    }\n    \n    protected static class FunctionsOnGroupAndElementImplementation implements FunctionsOnGroupAndElement\n    {\n        protected GroupAgent parentGroupAgent;\n        protected Agent elementAgent;\n        \n        public FunctionsOnGroupAndElementImplementation(final GroupAgent parent, final Agent element) {\n            this.parentGroupAgent = parent;\n            this.elementAgent = element;\n        }\n        \n        @Override\n        public void addPrecedingGap(final int size) {\n            this.parentGroupAgent.addGapBefore(new GapAgent(size), this.elementAgent);\n        }\n        \n        @Override\n        public void addPrecedingGap(final int min, final int pref, final int max) {\n            this.parentGroupAgent.addGapBefore(new GapAgent(min, pref, max), this.elementAgent);\n        }\n        \n        @Override\n        public void addFollowingGap(final int size) {\n            this.parentGroupAgent.addGapAfter(new GapAgent(size), this.elementAgent);\n        }\n        \n        @Override\n        public void addFollowingGap(final int min, final int pref, final int max) {\n            this.parentGroupAgent.addGapAfter(new GapAgent(min, pref, max), this.elementAgent);\n        }\n    }\n}\n"
    },
    {
        "project_name": "40_glengineer",
        "class": "Block",
        "fqdn": "glengineer.blocks",
        "source_code": "package glengineer.blocks;\n\nimport glengineer.positions.*;\nimport java.util.*;\n\npublic abstract class Block extends CharTable\n{\n    protected Scheme scheme;\n    \n    public Block(final Scheme scheme, final int x1, final int y1, final int x2, final int y2) {\n        if (x1 < 0 || y1 < 0 || x1 > x2 || y1 > y2 || x2 > scheme.x2 || y2 > scheme.y2) {\n            throw new IllegalArgumentException(\"improper block definition: \" + x1 + \",\" + y1 + \", \" + x2 + \",\" + y2 + \".\");\n        }\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.scheme = scheme;\n    }\n    \n    public Block(final Scheme scheme, final CharPosition p1, final CharPosition p2) {\n        this(scheme, p1.x, p1.y, p2.x, p2.y);\n    }\n    \n    public Block(final Scheme scheme) {\n        this.x1 = 0;\n        this.y1 = 0;\n        this.x2 = scheme.x2;\n        this.y2 = scheme.y2;\n        this.scheme = scheme;\n    }\n    \n    public abstract Block subblock(final int p0, final int p1, final int p2, final int p3);\n    \n    @Override\n    public char charAt(final int x, final int y) {\n        try {\n            return this.scheme.lines[y].charAt(x);\n        }\n        catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"char position \" + new CharPosition(x, y) + \" out of block.\\n\" + this);\n        }\n    }\n    \n    @Override\n    public String textAt(final int x1, final int x2, final int y) {\n        try {\n            return this.scheme.lines[y].substring(x1, x2);\n        }\n        catch (RuntimeException re) {\n            throw new IllegalArgumentException(\"Improper subline coodinates.\");\n        }\n    }\n    \n    public boolean containsOnlyOneWord() {\n        if (this.isTrivial()) {\n            throw new IllegalArgumentException(\"cannot search in a trivial block\");\n        }\n        final HWordPosition firstWord = this.firstWord_Horizontally();\n        if (firstWord.y == this.y2) {\n            throw new IllegalArgumentException(\"cannot verify unicity of an word in an empty block\");\n        }\n        final WordPosition lastWord = this.lastWord_Horizontally();\n        return firstWord.equals(lastWord);\n    }\n    \n    public abstract List<Block> extractSequentialSubblocks();\n    \n    public abstract List<Block> extractParallelSubblocks();\n    \n    @Override\n    public String toString() {\n        String result = \"Block(\" + this.x1 + \",\" + this.y1 + \", \" + this.x2 + \",\" + this.y2 + \"):\\n\";\n        final int frameWidth = this.x2 - this.x1 + 4;\n        final char[] line = new char[frameWidth];\n        Arrays.fill(line, '#');\n        final String lineString = \" \" + new String(line);\n        result = result.concat(lineString + \"\\n\");\n        for (int y = this.y1; y < this.y2; ++y) {\n            result = result.concat(\" # \" + this.scheme.textAt(this.x1, this.x2, y) + \" #\\n\");\n        }\n        result = result.concat(lineString);\n        return result;\n    }\n    \n    public String getUpperLine() {\n        return this.textAt(this.x1, this.x2, this.y1);\n    }\n}\n"
    },
    {
        "project_name": "82_ipcalculator",
        "class": "WhoIS",
        "fqdn": "ipac",
        "source_code": "package ipac;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nimport java.net.*;\nimport java.io.*;\n\npublic class WhoIS extends JPanel implements ActionListener\n{\n    String WHOIS_NAME;\n    String WHOIS_ADDRESS;\n    int WHOIS_PORT;\n    JTextField queryTextField;\n    JButton queryButton;\n    JButton resetButton;\n    JCheckBox lowercaseD;\n    boolean booleanD;\n    JRadioButton lowercaseL;\n    JRadioButton uppercaseL;\n    JRadioButton lowercaseM;\n    JRadioButton uppercaseM;\n    JRadioButton lowercaseX;\n    JRadioButton resetRadioButton;\n    ButtonGroup radioButtonGroup;\n    JPopupMenu popupMenu;\n    JComboBox inverseQueries;\n    JList miscList;\n    \n    public WhoIS() {\n        this.WHOIS_NAME = \"APNIC\";\n        this.WHOIS_ADDRESS = \"whois.apnic.net\";\n        this.WHOIS_PORT = 43;\n        this.radioButtonGroup = new ButtonGroup();\n        final JPanel WhoISPanel = new JPanel();\n        WhoISPanel.setLayout(new BoxLayout(WhoISPanel, 1));\n        this.createPopupMenu();\n        WhoISPanel.add(this.queryPanel());\n        WhoISPanel.add(this.additionalQueriesPanel());\n        WhoISPanel.add(this.queryHintsPanel());\n        this.setBackground(Color.WHITE);\n        this.add(WhoISPanel);\n    }\n    \n    private JPanel queryPanel() {\n        final JPanel queryPanel = new JPanel();\n        queryPanel.setLayout(new FlowLayout(0));\n        final JLabel queryLabel = new JLabel(\"Search for : \");\n        queryPanel.add(queryLabel);\n        (this.queryTextField = new JTextField(40)).addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(final MouseEvent e) {\n                this.checkForTriggerEvent(e);\n            }\n            \n            @Override\n            public void mouseReleased(final MouseEvent e) {\n                this.checkForTriggerEvent(e);\n            }\n            \n            private void checkForTriggerEvent(final MouseEvent e) {\n                if (e.isPopupTrigger()) {\n                    WhoIS.this.popupMenu.show(e.getComponent(), e.getX(), e.getY());\n                }\n            }\n        });\n        this.queryTextField.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(final KeyEvent e) {\n                if (e.getKeyCode() == 10) {\n                    WhoIS.this.startQuery();\n                }\n            }\n        });\n        this.queryTextField.setToolTipText(\"Enter Whois database object you would like to query\");\n        queryPanel.add(this.queryTextField);\n        (this.queryButton = new JButton(\"Query\")).addActionListener(this);\n        queryPanel.add(this.queryButton);\n        (this.resetButton = new JButton(\"Reset\")).addActionListener(this);\n        queryPanel.add(this.resetButton);\n        this.queryTextField.setRequestFocusEnabled(true);\n        queryPanel.setBackground(Color.WHITE);\n        return queryPanel;\n    }\n    \n    private JPanel additionalQueriesPanel() {\n        final JPanel additionalQueriesPanel = new JPanel();\n        additionalQueriesPanel.setLayout(new FlowLayout(0));\n        additionalQueriesPanel.add(this.IPAddressLookups());\n        additionalQueriesPanel.add(this.MiscellaneousQueries());\n        additionalQueriesPanel.setBackground(Color.WHITE);\n        return additionalQueriesPanel;\n    }\n    \n    private JPanel IPAddressLookups() {\n        final JPanel LookupPanel = new JPanel();\n        LookupPanel.setLayout(new BoxLayout(LookupPanel, 1));\n        this.lowercaseL = new JRadioButton(\"1st level less specific\");\n        this.radioButtonGroup.add(this.lowercaseL);\n        LookupPanel.add(this.lowercaseL);\n        this.uppercaseL = new JRadioButton(\"All less specific\");\n        this.radioButtonGroup.add(this.uppercaseL);\n        LookupPanel.add(this.uppercaseL);\n        this.lowercaseM = new JRadioButton(\"1st level more specific\");\n        this.radioButtonGroup.add(this.lowercaseM);\n        LookupPanel.add(this.lowercaseM);\n        this.uppercaseM = new JRadioButton(\"All more specific\");\n        this.radioButtonGroup.add(this.uppercaseM);\n        LookupPanel.add(this.uppercaseM);\n        this.lowercaseX = new JRadioButton(\"Exact match only\");\n        this.radioButtonGroup.add(this.lowercaseX);\n        LookupPanel.add(this.lowercaseX);\n        final Action actionListener = new AbstractAction(\"Associated reverse domain\") {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                WhoIS.this.booleanD = ((JCheckBox)evt.getSource()).isSelected();\n            }\n        };\n        LookupPanel.add(this.lowercaseD = new JCheckBox(actionListener));\n        this.resetRadioButton = new JRadioButton(\"Reset Radio Button\");\n        this.radioButtonGroup.add(this.resetRadioButton);\n        LookupPanel.setBackground(Color.WHITE);\n        this.lowercaseL.setBackground(Color.WHITE);\n        this.uppercaseL.setBackground(Color.WHITE);\n        this.lowercaseM.setBackground(Color.WHITE);\n        this.uppercaseM.setBackground(Color.WHITE);\n        this.lowercaseX.setBackground(Color.WHITE);\n        this.lowercaseD.setBackground(Color.WHITE);\n        final String toolTipText = \"Use these options to view IP address blocks that match or are larger than the IP address or range you wish to query\";\n        this.lowercaseL.setToolTipText(toolTipText);\n        this.uppercaseL.setToolTipText(toolTipText);\n        this.lowercaseM.setToolTipText(toolTipText);\n        this.uppercaseM.setToolTipText(toolTipText);\n        this.lowercaseX.setToolTipText(toolTipText);\n        this.lowercaseD.setToolTipText(toolTipText);\n        return LookupPanel;\n    }\n    \n    private JPanel MiscellaneousQueries() {\n        final JPanel MiscPanel = new JPanel();\n        MiscPanel.setLayout(new BoxLayout(MiscPanel, 1));\n        final JLabel inverseLabel = new JLabel(\"Inverse Queries\");\n        MiscPanel.add(inverseLabel);\n        (this.inverseQueries = new JComboBox()).addItem(\"None\");\n        this.inverseQueries.addItem(\"admin-c\");\n        this.inverseQueries.addItem(\"admin-c,tech-c,zone-c\");\n        this.inverseQueries.addItem(\"author\");\n        this.inverseQueries.addItem(\"cross-mnt\");\n        this.inverseQueries.addItem(\"cross-nfy\");\n        this.inverseQueries.addItem(\"local-as\");\n        this.inverseQueries.addItem(\"mbrs-by-ref\");\n        this.inverseQueries.addItem(\"member-of\");\n        this.inverseQueries.addItem(\"mnt-by\");\n        this.inverseQueries.addItem(\"mnt-lower\");\n        this.inverseQueries.addItem(\"mnt-nfy\");\n        this.inverseQueries.addItem(\"mnt-routes\");\n        this.inverseQueries.addItem(\"notify\");\n        this.inverseQueries.addItem(\"nserver\");\n        this.inverseQueries.addItem(\"origin\");\n        this.inverseQueries.addItem(\"person\");\n        this.inverseQueries.addItem(\"referral-by\");\n        this.inverseQueries.addItem(\"rev-srv\");\n        this.inverseQueries.addItem(\"sub-dom\");\n        this.inverseQueries.addItem(\"tech-c\");\n        this.inverseQueries.addItem(\"upd-to\");\n        this.inverseQueries.addItem(\"zone-c\");\n        this.inverseQueries.setToolTipText(\"Searching for objects in the \" + this.WHOIS_NAME + \" Whois Database that have an attribute matching\" + \" the attribute type chosen from the inverse lookup scroll \" + \"list and the query text given by the user\");\n        MiscPanel.add(this.inverseQueries);\n        final JLabel miscLabel = new JLabel(\"Object Types\");\n        MiscPanel.add(miscLabel);\n        final String[] items = { \"All\", \"as-block\", \"as-set\", \"aut-num\", \"domain\", \"filter-set\", \"inet-rtr\", \"inet6num\", \"inetnum\", \"irt\", \"key-cert\", \"mntner\", \"peering-set\", \"person\", \"role\", \"route\", \"route-set\", \"rtr-set\" };\n        (this.miscList = new JList((E[])items)).setSelectedIndex(0);\n        this.miscList.setToolTipText(\"Limit your search to particular types of objects\");\n        final JScrollPane scrollingList = new JScrollPane(this.miscList);\n        MiscPanel.add(scrollingList);\n        MiscPanel.setBackground(Color.WHITE);\n        this.inverseQueries.setBackground(Color.WHITE);\n        return MiscPanel;\n    }\n    \n    private JPanel queryHintsPanel() {\n        final JPanel queryHintsPanel = new JPanel();\n        queryHintsPanel.setLayout(new FlowLayout(1));\n        final JPanel innerPanel = new JPanel();\n        innerPanel.setLayout(new BoxLayout(innerPanel, 1));\n        final JLabel queryHintsText1 = new JLabel(\"Query hints \");\n        final JLabel emptyLabel = new JLabel(\"EMPTY LABEL\");\n        emptyLabel.setForeground(Color.WHITE);\n        final JLabel queryHintsText2 = new JLabel(\"* Include \\\"AS\\\" in front of an AS number.\");\n        final JLabel queryHintsText3 = new JLabel(\"Example: AS4808\");\n        final JLabel queryHintsText4 = new JLabel(\"* Include \\\"-t\\\" (template only) or \\\"-v\\\" (template and description) in front of an object name to view the template.\");\n        final JLabel queryHintsText5 = new JLabel(\"Example: -t inetnum\");\n        innerPanel.add(queryHintsText1);\n        innerPanel.add(emptyLabel);\n        innerPanel.add(queryHintsText2);\n        innerPanel.add(queryHintsText3);\n        innerPanel.add(queryHintsText4);\n        innerPanel.add(queryHintsText5);\n        queryHintsPanel.setBackground(Color.WHITE);\n        innerPanel.setBackground(Color.WHITE);\n        queryHintsPanel.add(innerPanel);\n        return queryHintsPanel;\n    }\n    \n    private void createPopupMenu() {\n        this.popupMenu = new JPopupMenu();\n        final JMenuItem cut = new JMenuItem(\"Cut\");\n        final JMenuItem copy = new JMenuItem(\"Copy\");\n        final JMenuItem paste = new JMenuItem(\"Paste\");\n        final JMenuItem selectAll = new JMenuItem(\"Select All\");\n        this.popupMenu.add(cut);\n        this.popupMenu.add(copy);\n        this.popupMenu.add(paste);\n        this.popupMenu.add(selectAll);\n        cut.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.cut();\n            }\n        });\n        copy.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.copy();\n            }\n        });\n        paste.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.paste();\n            }\n        });\n        selectAll.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                WhoIS.this.queryTextField.selectAll();\n            }\n        });\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent e) {\n        if (e.getSource() == this.queryButton) {\n            this.startQuery();\n        }\n        else if (e.getSource() == this.resetButton) {\n            this.reset();\n        }\n    }\n    \n    private void startQuery() {\n        if (this.getQuery().length() < 1) {\n            this.displayError(\"No Query Detected\");\n        }\n        else {\n            this.query(this.getQuery());\n        }\n    }\n    \n    private void displayError(final String error) {\n        JOptionPane.showMessageDialog(this, error, \"Error\", 0);\n    }\n    \n    private void query(final String query) {\n        try {\n            final Socket connection = new Socket(this.WHOIS_ADDRESS, this.WHOIS_PORT);\n            final PrintStream out = new PrintStream(connection.getOutputStream());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line = \"\";\n            out.println(query);\n            String output = \"\";\n            while ((line = in.readLine()) != null) {\n                output = output + line + \"\\n\";\n            }\n            new WhoISOutput(output);\n            output = \"\";\n        }\n        catch (UnknownHostException e) {\n            this.displayError(\"Unknown Whois host: \" + this.WHOIS_ADDRESS);\n        }\n        catch (IOException e2) {\n            this.displayError(\"Whois server could not be contacted.\\nPlease check your internet connection.\");\n        }\n    }\n    \n    private String getQuery() {\n        String query = this.queryTextField.getText().trim();\n        final String iqs = this.inverseQueries.getSelectedItem().toString();\n        if (!iqs.equals(\"None\")) {\n            query = \"-i \" + iqs + \" \" + query;\n        }\n        if (this.lowercaseL.isSelected()) {\n            query = \"-l \" + query;\n        }\n        else if (this.uppercaseL.isSelected()) {\n            query = \"-L \" + query;\n        }\n        else if (this.lowercaseM.isSelected()) {\n            query = \"-m \" + query;\n        }\n        else if (this.uppercaseM.isSelected()) {\n            query = \"-M \" + query;\n        }\n        else if (this.lowercaseX.isSelected()) {\n            query = \"-x \" + query;\n        }\n        if (this.booleanD) {\n            query = \"-d \" + query;\n        }\n        String miscQueries = \"\";\n        final Object[] selected = this.miscList.getSelectedValues();\n        for (int i = 0; i < selected.length; ++i) {\n            if (selected[i] != \"All\") {\n                miscQueries = miscQueries + selected[i] + \",\";\n            }\n        }\n        if (miscQueries != \"\") {\n            miscQueries = miscQueries.substring(0, miscQueries.length() - 1);\n            query = \"-T \" + miscQueries + \" \" + query;\n        }\n        return query;\n    }\n    \n    public void reset() {\n        this.queryTextField.setText(\"\");\n        this.resetRadioButton.setSelected(true);\n        this.lowercaseD.setSelected(false);\n        this.inverseQueries.setSelectedIndex(0);\n        this.miscList.setSelectedIndex(0);\n    }\n}\n"
    },
    {
        "project_name": "82_ipcalculator",
        "class": "BinaryCalculate",
        "fqdn": "ipac",
        "source_code": "package ipac;\n\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class BinaryCalculate\n{\n    boolean isIPv4;\n    boolean isIPv6;\n    String currentIP;\n    String fullReassembler;\n    String DELIMITER;\n    int lengthOfToken;\n    String IPRangeAddress;\n    String usableRange;\n    int semiCol;\n    String prefix;\n    BigInteger totalIPAddresses;\n    int MAXPREFIX;\n    \n    public BinaryCalculate() {\n        this.isIPv4 = false;\n        this.isIPv6 = false;\n        this.currentIP = \"\";\n        this.fullReassembler = \"\";\n        this.DELIMITER = \"\";\n        this.lengthOfToken = 0;\n        this.IPRangeAddress = \"\";\n        this.usableRange = \"\";\n        this.semiCol = 0;\n        this.prefix = \"\";\n        this.MAXPREFIX = 0;\n    }\n    \n    public String addBinary(String num1, String num2) {\n        boolean carry = false;\n        int size1 = num1.length() - 1;\n        int size2 = num2.length() - 1;\n        String sum = \"\";\n        if (size2 > size1) {\n            final String s = num1;\n            num1 = num2;\n            num2 = s;\n            final int n = size1;\n            size1 = size2;\n            size2 = n;\n        }\n        while (size2 >= 0) {\n            if (num1.charAt(size1) == '0' && num2.charAt(size2) == '0') {\n                if (!carry) {\n                    sum = \"0\" + sum;\n                }\n                else {\n                    sum = \"1\" + sum;\n                }\n                carry = false;\n            }\n            else if (num1.charAt(size1) == '1' && num2.charAt(size2) == '0') {\n                if (!carry) {\n                    sum = \"1\" + sum;\n                }\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            }\n            else if (num1.charAt(size1) == '0' && num2.charAt(size2) == '1') {\n                if (!carry) {\n                    sum = \"1\" + sum;\n                }\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            }\n            else if (num1.charAt(size1) == '1' && num2.charAt(size2) == '1') {\n                if (!carry) {\n                    sum = \"0\" + sum;\n                }\n                else {\n                    sum = \"1\" + sum;\n                }\n                carry = true;\n            }\n            --size1;\n            --size2;\n        }\n        while (size1 >= 0) {\n            if (num1.charAt(size1) == '0') {\n                if (!carry) {\n                    sum = \"0\" + sum;\n                }\n                else {\n                    sum = \"1\" + sum;\n                }\n                carry = false;\n            }\n            else if (num1.charAt(size1) == '1') {\n                if (!carry) {\n                    sum = \"1\" + sum;\n                }\n                else {\n                    sum = \"0\" + sum;\n                    carry = true;\n                }\n            }\n            --size1;\n        }\n        if (carry) {\n            sum = \"1\" + sum;\n        }\n        return sum;\n    }\n    \n    public String subBinary(final String num1, final String num2) {\n        String diff = \"\";\n        String twosComp = \"\";\n        for (int size = num1.length() - 1; size >= 0; --size) {\n            if (num1.charAt(size) == '0') {\n                twosComp = \"1\" + twosComp;\n            }\n            else {\n                twosComp = \"0\" + twosComp;\n            }\n        }\n        twosComp = \"0\" + twosComp;\n        twosComp = this.addBinary(twosComp, \"1\");\n        diff = this.addBinary(twosComp, num2);\n        return diff.substring(1);\n    }\n    \n    public String IPCalculate(final String IP, final String IPPrefix) {\n        String outputText = \"\";\n        this.checkIPType(IP.length() - 1);\n        final String subnet = this.convert(IP);\n        final String netmask = this.getNetmask(IPPrefix);\n        this.calculate(IP, IPPrefix);\n        outputText = outputText + \"Total Range: \" + this.IPRangeAddress + \"\\n\";\n        outputText = outputText + \"Usable Range: \" + this.usableRange + \"\\n\";\n        final NumberFormat formatter = new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\n        outputText += \"\\n\";\n        outputText = outputText + \"Total usable IP Addresses : \" + formatter.format(this.totalIPAddresses) + \"\\n\";\n        outputText = outputText + \"Subnet: \" + subnet + \"\\n\";\n        outputText = outputText + \"Binary Subnet: \" + this.getBinaryIP(IP) + \"\\n\";\n        outputText = outputText + \"Broadcast Address: \" + this.currentIP + \"\\n\";\n        outputText = outputText + \"Prefix: \" + this.prefix + \"\\n\";\n        this.checkIPType(netmask.length() - 1);\n        final String outputNetmask = this.convert(netmask);\n        outputText = outputText + \"Netmask: \" + outputNetmask + \"\\n\";\n        final String binaryNetmask = this.getBinaryIP(netmask);\n        outputText = outputText + \"Binary Netmask: \" + binaryNetmask;\n        return outputText;\n    }\n    \n    private String getBinaryIP(final String binaryIP) {\n        String output = \"\";\n        this.checkIPType(binaryIP.length() - 1);\n        for (int i = 0; i < this.MAXPREFIX; ++i) {\n            output += binaryIP.charAt(i);\n            if (i == this.semiCol) {\n                if (i != binaryIP.length() - 1) {\n                    output += this.DELIMITER;\n                }\n                this.semiCol += this.lengthOfToken;\n            }\n        }\n        return output;\n    }\n    \n    private String getNetmask(final String binaryIP) {\n        String invertedIPPrefix = \"\";\n        for (int i = 0; i < this.MAXPREFIX; ++i) {\n            if (binaryIP.charAt(i) == '0') {\n                invertedIPPrefix += \"1\";\n            }\n            else {\n                invertedIPPrefix += \"0\";\n            }\n        }\n        return invertedIPPrefix;\n    }\n    \n    private void calculate(String subnet, final String noOfIPAddresses) {\n        this.currentIP = \"\";\n        final String number1 = subnet;\n        String usableIP = \"\";\n        final String IP = this.addBinary(subnet, noOfIPAddresses);\n        this.checkIPType(subnet.length() - 1);\n        String addSubBinary = \"\";\n        for (int i = 0; i < this.MAXPREFIX - 1; ++i) {\n            addSubBinary += \"0\";\n        }\n        addSubBinary += \"1\";\n        subnet = this.addBinary(addSubBinary, subnet);\n        usableIP = this.convert(subnet);\n        subnet = this.subBinary(addSubBinary, subnet);\n        this.checkIPType(subnet.length() - 1);\n        this.currentIP = this.convert(subnet);\n        this.fullReassembler = \"\";\n        this.semiCol = this.lengthOfToken - 1;\n        this.IPRangeAddress = this.currentIP + \" -- \";\n        this.usableRange = usableIP + \" -- \";\n        this.currentIP = \"\";\n        String currentIPString = \"\";\n        if (IP.length() > 128) {\n            this.IPRangeAddress += \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\n            this.currentIP = \"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\";\n        }\n        else if (IP.length() > 32 && IP.length() < 128) {\n            this.IPRangeAddress += \"255.255.255.255\";\n            this.currentIP = \"255.255.255.255\";\n        }\n        else {\n            final String IPRangeEnd = this.subBinary(addSubBinary, IP);\n            final String endIP = this.convert(IPRangeEnd);\n            this.usableRange += endIP;\n            this.checkIPType(subnet.length() - 1);\n            this.currentIP = this.convert(IP);\n            this.IPRangeAddress += this.currentIP;\n        }\n        currentIPString = this.subBinary(number1, this.convertToBinary(this.currentIP));\n        this.totalIPAddresses = new BigInteger(currentIPString, 2);\n        this.totalIPAddresses = this.totalIPAddresses.add(new BigInteger(\"1\"));\n        int prefixInt = 0;\n        if (this.totalIPAddresses.doubleValue() < 2.0) {\n            prefixInt = this.MAXPREFIX;\n        }\n        else if (this.totalIPAddresses.doubleValue() == 2.0) {\n            prefixInt = this.MAXPREFIX - 2;\n        }\n        else if (this.isIPv6) {\n            final String currentIPString2 = currentIPString.substring(0, 64);\n            final BigInteger totalIPAddresses1 = new BigInteger(currentIPString2, 2);\n            double prefixInt2 = 0.0;\n            if (totalIPAddresses1.doubleValue() > 0.0) {\n                prefixInt2 = Math.log(totalIPAddresses1.doubleValue()) / Math.log(2.0);\n            }\n            final String currentIPString3 = currentIPString.substring(64, 128);\n            final BigInteger totalIPAddresses2 = new BigInteger(currentIPString3, 2);\n            final double prefixInt3 = Math.log(totalIPAddresses2.doubleValue()) / Math.log(2.0);\n            prefixInt = this.MAXPREFIX - (int)Math.ceil(prefixInt2) - (int)Math.round(prefixInt3);\n        }\n        else if (this.isIPv4) {\n            prefixInt = this.MAXPREFIX - (int)Math.ceil(Math.log(this.totalIPAddresses.doubleValue()) / Math.log(2.0));\n        }\n        this.prefix = \"/\" + prefixInt;\n        this.totalIPAddresses = this.totalIPAddresses.subtract(new BigInteger(\"2\"));\n    }\n    \n    public void prefixInPrefixCalculate(String IP, final String IPPrefix, final int noPrefix, final String endPrefix) {\n        try {\n            final String[][] output = new String[noPrefix + 8][2];\n            this.checkIPType(IP.length() - 1);\n            final String subnet = this.convert(IP);\n            final String netmask = this.getNetmask(IPPrefix);\n            this.calculate(IP, IPPrefix);\n            for (int i = 0; i < noPrefix; ++i) {\n                this.calculate(IP, IPPrefix);\n                output[i][0] = this.getStartIP() + \" \" + this.prefix;\n                output[i][1] = this.IPRangeAddress;\n                IP = this.addBinary(this.fullReassembler.substring(this.MAXPREFIX, this.fullReassembler.length()), Integer.toBinaryString(1));\n                this.fullReassembler = \"\";\n            }\n            output[noPrefix + 1][0] = \"Total usable IP Addresses :\";\n            final NumberFormat formatter = new DecimalFormat(\"###,###,###,###,###,###,###,###,###,###,###,###,###\");\n            output[noPrefix + 1][1] = formatter.format(this.totalIPAddresses.multiply(new BigInteger(noPrefix + \"\"))) + \" \";\n            output[noPrefix + 2][0] = \"Subnet:\";\n            output[noPrefix + 2][1] = subnet;\n            final StringTokenizer subnetTokens = new StringTokenizer(this.convertToBinary(subnet), this.DELIMITER);\n            String paddedSubnet = \"\";\n            while (subnetTokens.hasMoreTokens()) {\n                String unpaddedSubnet;\n                for (unpaddedSubnet = subnetTokens.nextToken(); unpaddedSubnet.length() < this.lengthOfToken; unpaddedSubnet = \"0\" + unpaddedSubnet) {}\n                paddedSubnet += unpaddedSubnet;\n            }\n            output[noPrefix + 3][0] = \"Binary Subnet:\";\n            output[noPrefix + 3][1] = this.getBinaryIP(paddedSubnet);\n            output[noPrefix + 4][0] = \"Broadcast Address:\";\n            output[noPrefix + 4][1] = this.currentIP;\n            output[noPrefix + 5][0] = \"Prefix:\";\n            output[noPrefix + 5][1] = endPrefix;\n            this.checkIPType(netmask.length() - 1);\n            output[noPrefix + 6][0] = \"Netmask\";\n            output[noPrefix + 6][1] = this.convert(netmask);\n            output[noPrefix + 7][0] = \"Binary Netmask:\";\n            output[noPrefix + 7][1] = this.getBinaryIP(netmask);\n            new Output(output);\n        }\n        catch (OutOfMemoryError e) {\n            new IPv4().displayError(\"Your computer does not have sufficent memory to process this query.\");\n        }\n    }\n    \n    private void checkIPType(final int size1) {\n        if (size1 == 31) {\n            this.isIPv4 = true;\n            this.lengthOfToken = 8;\n            this.DELIMITER = \".\";\n            this.MAXPREFIX = 32;\n        }\n        else if (size1 == 127) {\n            this.isIPv6 = true;\n            this.lengthOfToken = 16;\n            this.DELIMITER = \":\";\n            this.MAXPREFIX = 128;\n        }\n        this.semiCol = this.lengthOfToken - 1;\n    }\n    \n    private String convert(final String binaryIP) {\n        String outputIP = \"\";\n        String reassembler = \"\";\n        for (int i = 0; i < binaryIP.length(); ++i) {\n            reassembler += binaryIP.charAt(i);\n            this.fullReassembler += binaryIP.charAt(i);\n            if (i == this.semiCol) {\n                if (this.isIPv4) {\n                    outputIP += Integer.parseInt(reassembler, 2);\n                    reassembler = \"\";\n                }\n                else if (this.isIPv6) {\n                    outputIP += Integer.toHexString(Integer.parseInt(reassembler, 2));\n                    reassembler = \"\";\n                }\n                if (i != binaryIP.length() - 1) {\n                    outputIP += this.DELIMITER;\n                }\n                this.semiCol += this.lengthOfToken;\n            }\n        }\n        return outputIP;\n    }\n    \n    private String convertToBinary(final String IP) {\n        final StringTokenizer octetToken = new StringTokenizer(IP);\n        String output = \"\";\n        int radix = 0;\n        if (this.isIPv4) {\n            radix = 10;\n        }\n        else if (this.isIPv6) {\n            radix = 16;\n        }\n        while (octetToken.hasMoreTokens()) {\n            String out;\n            for (out = Integer.toBinaryString(Integer.parseInt(octetToken.nextToken(\".:\"), radix)); out.length() < this.lengthOfToken; out = \"0\" + out) {}\n            output += out;\n        }\n        return output;\n    }\n    \n    private String getStartIP() {\n        final StringTokenizer tokens = new StringTokenizer(this.IPRangeAddress, \" -\");\n        return tokens.nextToken();\n    }\n}\n"
    },
    {
        "project_name": "29_apbsmem",
        "class": "PlotAxis",
        "fqdn": "jahuwaldt.plot",
        "source_code": "package jahuwaldt.plot;\n\nimport java.io.*;\nimport java.text.*;\nimport java.awt.*;\n\npublic abstract class PlotAxis implements Cloneable, Serializable\n{\n    private static final boolean DEBUG = false;\n    public static final int kTick = 5;\n    public static final int kNoGrid = 0;\n    public static final int kTickMarksOnly = 1;\n    public static final int kMajorGrid = 2;\n    protected boolean manualLB;\n    protected boolean manualUB;\n    protected boolean manualQuant;\n    protected double xA;\n    protected double xB;\n    protected double aLB;\n    protected double aUB;\n    protected double quantum;\n    protected int gridStyle;\n    protected PlotAxisScale scale;\n    protected NumberFormat nf;\n    protected String label;\n    \n    protected PlotAxis() {\n        this.xA = 1.0;\n        this.xB = 1.0;\n        this.aLB = Double.MAX_VALUE;\n        this.aUB = -1.7976931348623157E308;\n        this.gridStyle = 1;\n        this.scale = new LinearAxisScale();\n        this.nf = NumberFormat.getInstance();\n    }\n    \n    protected PlotAxis(final String label, final PlotAxisScale scale, final NumberFormat nf, final int gridStyle) {\n        this.xA = 1.0;\n        this.xB = 1.0;\n        this.aLB = Double.MAX_VALUE;\n        this.aUB = -1.7976931348623157E308;\n        this.gridStyle = 1;\n        this.scale = new LinearAxisScale();\n        this.nf = NumberFormat.getInstance();\n        this.label = label;\n        if (scale != null) {\n            this.scale = scale;\n        }\n        if (nf != null) {\n            this.nf = nf;\n        }\n        this.gridStyle = gridStyle;\n    }\n    \n    public void setLabel(final String newLabel) {\n        this.label = newLabel;\n    }\n    \n    public String getLabel() {\n        return this.label;\n    }\n    \n    public void setScale(final PlotAxisScale scale) {\n        if (scale == null) {\n            this.scale = new LinearAxisScale();\n        }\n        else {\n            this.scale = scale;\n        }\n    }\n    \n    public PlotAxisScale getScale() {\n        return this.scale;\n    }\n    \n    public void setNumberFormat(final NumberFormat format) {\n        if (format == null) {\n            this.nf = NumberFormat.getInstance();\n        }\n        else {\n            this.nf = format;\n        }\n    }\n    \n    public NumberFormat getNumberFormat() {\n        return this.nf;\n    }\n    \n    public void setGridStyle(final int style) {\n        this.gridStyle = style;\n    }\n    \n    public int getGridStyle() {\n        return this.gridStyle;\n    }\n    \n    public void manualLowerBounds(final boolean flag) {\n        this.manualLB = flag;\n    }\n    \n    public void setLowerBounds(final double value) {\n        this.aLB = value;\n    }\n    \n    public double getLowerBounds() {\n        return this.aLB;\n    }\n    \n    public String lowerBoundsAsString() {\n        return this.nf.format((float)this.aLB);\n    }\n    \n    public void manualUpperBounds(final boolean flag) {\n        this.manualUB = flag;\n    }\n    \n    public void setUpperBounds(final double value) {\n        this.aUB = value;\n    }\n    \n    public double getUpperBounds() {\n        return this.aUB;\n    }\n    \n    public String upperBoundsAsString() {\n        return this.nf.format((float)this.aUB);\n    }\n    \n    public void manualTickStepSize(final boolean flag) {\n        this.manualQuant = flag;\n    }\n    \n    public void setTickStepSize(final double value) {\n        this.quantum = value;\n    }\n    \n    public double getTickStepSize() {\n        return this.quantum;\n    }\n    \n    public abstract void setAxisBounds(final PlotRunList p0);\n    \n    public void setSize(final Rectangle plotFrame) {\n        this.setAxisTickLimits();\n        this.resizeAxis(plotFrame);\n    }\n    \n    protected void setAxisTickLimits() {\n        if (this.manualQuant) {\n            return;\n        }\n        boolean lbf = this.manualLB;\n        boolean ubf = this.manualUB;\n        double sign = 1.0;\n        double lb = this.aLB;\n        double ub = this.aUB;\n        final double delta = this.aUB - this.aLB;\n        if (delta < 0.0) {\n            sign = -1.0;\n            final double temp = lb;\n            lb = ub;\n            ub = temp;\n            final boolean btemp = lbf;\n            lbf = ubf;\n            ubf = btemp;\n        }\n        final AxisLimitData limData = this.scale.findGoodLimits(lb, ub);\n        if (!this.manualLB) {\n            if (sign > 0.0) {\n                this.aLB = limData.lb;\n            }\n            else {\n                this.aLB = limData.ub;\n            }\n        }\n        if (!this.manualUB) {\n            if (sign > 0.0) {\n                this.aUB = limData.ub;\n            }\n            else {\n                this.aUB = limData.lb;\n            }\n        }\n        this.quantum = sign * limData.quantum;\n    }\n    \n    protected abstract void resizeAxis(final Rectangle p0);\n    \n    public abstract void draw(final Graphics p0, final Component p1, final Rectangle p2);\n    \n    public int scaleCoord(final double x) {\n        return (int)(this.xA * this.scale.func(x) + this.xB);\n    }\n    \n    public Object clone() {\n        PlotAxis newObject = null;\n        try {\n            newObject = (PlotAxis)super.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        return newObject;\n    }\n}\n"
    },
    {
        "project_name": "95_celwars2009",
        "class": "MP3",
        "fqdn": "",
        "source_code": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class MP3 extends Thread\n{\n    AudioInputStream in;\n    AudioInputStream din;\n    String filename;\n    \n    public MP3(final String filename) {\n        this.in = null;\n        this.din = null;\n        this.filename = \"\";\n        this.filename = filename;\n        this.start();\n    }\n    \n    @Override\n    public void run() {\n        AudioInputStream din = null;\n        try {\n            final File file = new File(this.filename);\n            final AudioInputStream in = AudioSystem.getAudioInputStream(file);\n            final AudioFormat baseFormat = in.getFormat();\n            final AudioFormat decodedFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, baseFormat.getSampleRate(), 16, baseFormat.getChannels(), baseFormat.getChannels() * 2, baseFormat.getSampleRate(), false);\n            din = AudioSystem.getAudioInputStream(decodedFormat, in);\n            final DataLine.Info info = new DataLine.Info(SourceDataLine.class, decodedFormat);\n            final SourceDataLine line = (SourceDataLine)AudioSystem.getLine(info);\n            if (line != null) {\n                line.open(decodedFormat);\n                final byte[] data = new byte[4096];\n                line.start();\n                int nBytesRead;\n                while ((nBytesRead = din.read(data, 0, data.length)) != -1) {\n                    line.write(data, 0, nBytesRead);\n                }\n                line.drain();\n                line.stop();\n                line.close();\n                din.close();\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n            if (din != null) {\n                try {\n                    din.close();\n                }\n                catch (IOException ex) {}\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "47_dvd-homevideo",
        "class": "Capture",
        "fqdn": "",
        "source_code": "import java.io.*;\n\npublic class Capture implements Runnable\n{\n    private int m_Minutes;\n    private int m_Seconds;\n    private GUI m_GUI;\n    private Thread m_Thread;\n    private boolean m_Error;\n    private String m_BaseErr;\n    private String m_dvgrab;\n    \n    public Capture() {\n        this.m_BaseErr = \"Capture Error - \";\n        this.m_dvgrab = \"dvgrab --autosplit --size 0 --format raw --opendml --buffers 200 dv/dv_file-\";\n    }\n    \n    public Capture(final int min, final int sec, final GUI DVD_GUI) {\n        this.m_BaseErr = \"Capture Error - \";\n        this.m_dvgrab = \"dvgrab --autosplit --size 0 --format raw --opendml --buffers 200 dv/dv_file-\";\n        this.m_Minutes = min;\n        this.m_Seconds = sec;\n        this.m_GUI = DVD_GUI;\n    }\n    \n    public boolean init() {\n        if (this.m_GUI.menuChkThread.isSelected()) {\n            (this.m_Thread = new Thread(this)).setPriority(10);\n            this.m_Thread.start();\n            return false;\n        }\n        this.DV_Capture();\n        return this.m_Error | this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/dvgrab.log\");\n    }\n    \n    @Override\n    public void run() {\n        this.DV_Capture();\n    }\n    \n    public void DV_Capture() {\n        File CreateOutDir = new File(this.m_GUI.strOutputDir);\n        if (CreateOutDir.exists() && CreateOutDir.isDirectory()) {\n            final int response = this.m_GUI.MessageBox(\"The Output Directory \" + this.m_GUI.strOutputDir + \" already exists!\" + \"\\nWould you like to delete it?\");\n            if (response == 0) {\n                try {\n                    final String rm = \"rm -fr \" + this.m_GUI.strOutputDir;\n                    final String[] rm_cmd = { \"/bin/sh\", \"-c\", rm };\n                    final Process remove_dir = Runtime.getRuntime().exec(rm_cmd, null);\n                    remove_dir.waitFor();\n                }\n                catch (IOException ex) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex.toString(), 0);\n                    ex.printStackTrace();\n                }\n                catch (InterruptedException ex2) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"dvd-homevideo thread was interrupted\\n\" + ex2.toString(), 0);\n                    ex2.printStackTrace();\n                }\n            }\n            else {\n                this.m_GUI.MessageBox(\"Please choose a different name for your\\ntitle or move the directory to another location.\", 2);\n                this.m_GUI.blnBegin = false;\n                this.m_Error = true;\n            }\n        }\n        else if (CreateOutDir.exists() && !CreateOutDir.isDirectory()) {\n            final int response = this.m_GUI.MessageBox(\"There exists a file with the Output directory name\\nat this location!  Would you like to delete it?\");\n            if (response == 0) {\n                try {\n                    final String rm = \"rm -fr \" + this.m_GUI.strOutputDir;\n                    final String[] rm_cmd = { \"/bin/sh\", \"-c\", rm };\n                    final Process remove_dir = Runtime.getRuntime().exec(rm_cmd, null);\n                    remove_dir.waitFor();\n                }\n                catch (IOException ex) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex.toString(), 0);\n                    ex.printStackTrace();\n                }\n                catch (InterruptedException ex2) {\n                    SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                    this.m_GUI.MessageBox(this.m_BaseErr + \"dvd-homevideo thread was interrupted\\n\" + ex2.toString(), 0);\n                    ex2.printStackTrace();\n                }\n            }\n            else {\n                this.m_GUI.MessageBox(\"Please choose a different name for your\\ntitle or move the file to another location.\", 2);\n                this.m_GUI.blnBegin = false;\n            }\n        }\n        if (this.m_GUI.blnBegin) {\n            CreateOutDir.mkdir();\n            CreateOutDir = new File(this.m_GUI.strOutputDir + \"/DVD\");\n            CreateOutDir.mkdir();\n            CreateOutDir = new File(this.m_GUI.strOutputDir + \"/log\");\n            CreateOutDir.mkdir();\n            CreateOutDir = new File(this.m_GUI.strOutputDir + \"/dv\");\n            CreateOutDir.mkdir();\n            try {\n                final String[] dvgrab_cmd = { \"/bin/sh\", \"-c\", this.m_dvgrab };\n                final Process p = Runtime.getRuntime().exec(dvgrab_cmd, null, new File(this.m_GUI.strOutputDir));\n                final BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                final BufferedReader err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                final BufferedWriter out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/dvgrab.log\"));\n                final BufferedWriter err_out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/dvgrab.err\"));\n                if (err_in.ready()) {\n                    final String line = err_in.readLine();\n                    if (line.equals(\"/bin/sh: dvgrab: command not found\")) {\n                        this.m_GUI.MessageBox(\"Could not locate dvgrab in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                        in.close();\n                        out.close();\n                        err_in.close();\n                        err_out.close();\n                        this.m_Error = true;\n                    }\n                    else {\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                this.m_GUI.lblCapture.setEnabled(true);\n                this.m_GUI.prgCapture.setEnabled(true);\n                this.m_GUI.lblCaptureProg.setEnabled(true);\n                final long start = System.currentTimeMillis();\n                final int total = this.m_Minutes * 60 * 1000 + this.m_Seconds * 1000 + 5000;\n                final long end = start + total;\n                long current = System.currentTimeMillis();\n                int diff = (int)(current - start);\n                final int track = 0;\n                while (diff / total < 1) {\n                    this.m_GUI.prgCapture.setValue((int)(diff / total * 100.0));\n                    this.m_GUI.lblCaptureProg.setText(Integer.toString((int)(diff / total * 100.0)) + \"%\");\n                    current = System.currentTimeMillis();\n                    diff = (int)(current - start);\n                    String line = in.readLine();\n                    if (err_in.ready()) {\n                        line = err_in.readLine();\n                        if (line.equals(\"Error: no camera exists\")) {\n                            this.m_GUI.MessageBox(\"It appears that your camcorder is not connected to your computer!\", 0);\n                            final String rm2 = \"rm -fr \" + this.m_GUI.strOutputDir;\n                            final String[] rm_cmd2 = { \"/bin/sh\", \"-c\", rm2 };\n                            final Process remove_dir2 = Runtime.getRuntime().exec(rm_cmd2, null);\n                            remove_dir2.waitFor();\n                            in.close();\n                            out.close();\n                            err_in.close();\n                            err_out.close();\n                            this.m_Error = true;\n                        }\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                in.close();\n                out.close();\n                err_in.close();\n                err_out.close();\n                p.destroy();\n                this.m_GUI.prgCapture.setValue(100);\n                this.m_GUI.prgCapture.setValue(100);\n                this.m_GUI.lblCaptureProg.setText(\"100%\");\n                this.m_GUI.prgCapture.setEnabled(false);\n                this.m_GUI.lblCapture.setEnabled(false);\n                this.m_GUI.lblCaptureProg.setEnabled(false);\n                Thread.sleep(2000L);\n            }\n            catch (IOException ex3) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex3);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex3.toString(), 0);\n                ex3.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (NullPointerException ex4) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex4);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Error executing Runtime.getRuntime().exec()\\n\" + ex4.toString(), 0);\n                ex4.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (IllegalArgumentException ex5) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex5);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Illegal argument sent to Runtime.getRuntime().exec()\\n\" + ex5.toString(), 0);\n                ex5.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (Exception ex6) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex6);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Unknown Error occurred\\n\" + ex6.toString(), 0);\n                ex6.printStackTrace();\n                this.m_Error = true;\n            }\n        }\n    }\n}\n"
    },
    {
        "project_name": "47_dvd-homevideo",
        "class": "Menu",
        "fqdn": "",
        "source_code": "import java.util.*;\nimport java.io.*;\n\npublic class Menu implements Runnable\n{\n    private String strTitle;\n    private String strPicPath;\n    private String strAudioPath;\n    private String strTextFilePath;\n    private String dvd_menu;\n    private String[] titles;\n    private boolean pal_menu;\n    private String baseErr;\n    private String[] video_files;\n    private GUI m_GUI;\n    private Thread m_Thread;\n    private boolean m_Error;\n    \n    public Menu() {\n        this.dvd_menu = \"dvd-menu\";\n        this.titles = new String[50];\n        this.baseErr = \"Menu Error - \";\n    }\n    \n    public Menu(final String title, final String TextFilePath, final boolean isPAL, final GUI DVD_GUI) {\n        this.dvd_menu = \"dvd-menu\";\n        this.titles = new String[50];\n        this.baseErr = \"Menu Error - \";\n        this.strTitle = title;\n        this.strTextFilePath = TextFilePath;\n        this.pal_menu = isPAL;\n        this.m_GUI = DVD_GUI;\n    }\n    \n    public Menu(final String title, final String picPath, final String audioPath, final String TextFilePath, final boolean isPAL, final GUI DVD_GUI) {\n        this.dvd_menu = \"dvd-menu\";\n        this.titles = new String[50];\n        this.baseErr = \"Menu Error - \";\n        this.strTitle = title;\n        this.strPicPath = picPath;\n        this.strAudioPath = audioPath;\n        this.strTextFilePath = TextFilePath;\n        this.pal_menu = isPAL;\n        this.m_GUI = DVD_GUI;\n    }\n    \n    public boolean init() {\n        (this.m_Thread = new Thread(this)).start();\n        try {\n            this.m_Thread.join();\n        }\n        catch (InterruptedException ex) {\n            ex.printStackTrace();\n        }\n        return this.m_Error || this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/dvd-menu.log\");\n    }\n    \n    @Override\n    public void run() {\n        this.DVDMainMenu();\n    }\n    \n    public void DVDMainMenu() {\n        final File ListDir = new File(this.m_GUI.strOutputDir);\n        final FilenameFilter filter = new FilenameFilter() {\n            boolean ret_val = true;\n            \n            @Override\n            public boolean accept(final File dir, final String name) {\n                if (name.endsWith(\"vob\")) {\n                    if (!name.equals(\"menu.vob\")) {\n                        this.ret_val = true;\n                    }\n                    else {\n                        this.ret_val = false;\n                    }\n                }\n                else {\n                    this.ret_val = false;\n                }\n                return this.ret_val;\n            }\n        };\n        this.video_files = ListDir.list(filter);\n        this.m_GUI.lblAuthor.setEnabled(true);\n        this.m_GUI.lblAuthorProg.setEnabled(true);\n        this.m_GUI.prgAuthor.setEnabled(true);\n        this.m_GUI.prgAuthor.setIndeterminate(true);\n        String menu_options;\n        if (this.strPicPath == null && this.strAudioPath == null) {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir;\n        }\n        else if (this.strPicPath.equals(\"\") && this.strAudioPath != null) {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir + \" -a \" + this.strAudioPath;\n        }\n        else if (this.strPicPath != null && this.strAudioPath.equals(\"\")) {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir + \" -b \" + this.strPicPath;\n        }\n        else {\n            menu_options = \" -c -D -n '\" + this.strTitle + \"' -o \" + this.m_GUI.strOutputDir + \" -a \" + this.strAudioPath + \" -b \" + this.strPicPath;\n        }\n        int i = 0;\n        if (this.strTextFilePath.equals(\"\") || this.strTextFilePath == null) {\n            while (i < this.video_files.length) {\n                menu_options = menu_options + \" -f \" + this.m_GUI.strOutputDir + \"/\" + this.video_files[i].substring(0, 11) + \".vob -t \" + this.strTitle + \"_\" + (i + 1);\n                ++i;\n            }\n        }\n        else {\n            try {\n                final BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(this.m_GUI.txtTextFile.getText())));\n                i = 0;\n                String line;\n                while ((line = in.readLine()) != null) {\n                    this.titles[i] = line;\n                    ++i;\n                }\n                int num_blanks = 0;\n                for (i = 0; i < this.titles.length; ++i) {\n                    if (this.titles[i].equals(\"BLANK\")) {\n                        ++num_blanks;\n                    }\n                    if (this.titles[i].equals(\"DONE\")) {\n                        break;\n                    }\n                }\n                final int num_lines = i;\n                if (num_lines - num_blanks > 10) {\n                    this.m_GUI.MessageBox(\"Your text file can only have a maximumof 10 titles!  Please edit your text file and rerundvd-homevideo.\", 1);\n                    this.m_Error = true;\n                }\n                else if (num_lines == this.video_files.length) {\n                    for (i = 0; i < this.video_files.length; ++i) {\n                        if (!this.titles[i].equals(\"BLANK\") && !this.titles[i].equals(\"DONE\")) {\n                            menu_options = menu_options + \" -t \" + this.titles[i] + \" -f \" + this.m_GUI.strOutputDir + \"/\" + this.video_files[i].substring(0, 11) + \".vob\";\n                        }\n                        else {\n                            if (this.titles[i].equals(\"DONE\")) {\n                                break;\n                            }\n                            menu_options = menu_options + \" -f \" + this.m_GUI.strOutputDir + \"/\" + this.video_files[i].substring(0, 11) + \".vob\";\n                        }\n                    }\n                }\n                else {\n                    this.m_GUI.MessageBox(\"It appears that your text file is not\\nformatted correctly.  You currently have\\n\" + (this.video_files.length + 1) + \" vob files, \\n\" + \"however your text file is showing\\n\" + num_lines + \" lines.\", 1);\n                    this.m_Error = true;\n                }\n            }\n            catch (FileNotFoundException ex) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                this.m_GUI.MessageBox(\"Can not find \" + this.m_GUI.txtTextFile + \"\\n\" + ex.toString(), 0);\n                ex.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (IOException ex2) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                this.m_GUI.MessageBox(this.baseErr + \"IO Error\\n\" + ex2.toString(), 0);\n                ex2.printStackTrace();\n                this.m_Error = true;\n            }\n        }\n        if (this.pal_menu) {\n            menu_options += \" -p\";\n        }\n        this.dvd_menu = this.dvd_menu + menu_options + \" 2>&1\";\n        this.m_GUI.txtAreaOutput.append(this.dvd_menu + \"\\n\");\n        try {\n            final String[] dvd_menu_cmd = { \"/bin/sh\", \"-c\", this.dvd_menu };\n            Process p = Runtime.getRuntime().exec(dvd_menu_cmd, null, new File(this.m_GUI.strOutputDir));\n            final BufferedReader in2 = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            final BufferedReader err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n            String line2;\n            while ((line2 = in2.readLine()) != null) {\n                if (line2.equals(\"/bin/sh: dvd-menu: command not found\")) {\n                    this.m_GUI.MessageBox(\"Could not locate dvd-menu in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                    in2.close();\n                    err_in.close();\n                    this.m_Error = true;\n                }\n                final StringTokenizer st = new StringTokenizer(line2);\n                if (st.hasMoreTokens() && !st.nextToken().equals(\"Frame#\")) {\n                    this.m_GUI.txtAreaOutput.append(line2 + \"\\n\");\n                    this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                }\n            }\n            p.waitFor();\n            p = Runtime.getRuntime().exec(\"mv dvd-menu.log log/\", null, new File(this.m_GUI.strOutputDir));\n            final File CreateOutDir = new File(this.m_GUI.strOutputDir + \"/dvd_fs\");\n            if (CreateOutDir.exists() && CreateOutDir.isDirectory()) {\n                CreateOutDir.delete();\n            }\n            Thread.sleep(2000L);\n        }\n        catch (IOException ex2) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n            this.m_GUI.MessageBox(this.baseErr + \"IO Error\\n\" + ex2.toString(), 0);\n            ex2.printStackTrace();\n            this.m_Error = true;\n        }\n        catch (InterruptedException ex3) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex3);\n            this.m_GUI.MessageBox(this.baseErr + \"dvd-homevideo thread was interrupted\\n\" + ex3.toString(), 0);\n            ex3.printStackTrace();\n            this.m_Error = true;\n        }\n    }\n    \n    public boolean createXML() {\n        final File xmlFile = new File(this.m_GUI.strOutputDir + \"/vmgm.xml\");\n        final File ListDir = new File(this.m_GUI.strOutputDir);\n        final FilenameFilter filter = new FilenameFilter() {\n            boolean ret_val = true;\n            \n            @Override\n            public boolean accept(final File dir, final String name) {\n                if (name.endsWith(\"vob\")) {\n                    if (!name.equals(\"menu.vob\")) {\n                        this.ret_val = true;\n                    }\n                    else {\n                        this.ret_val = false;\n                    }\n                }\n                else {\n                    this.ret_val = false;\n                }\n                return this.ret_val;\n            }\n        };\n        this.video_files = ListDir.list(filter);\n        try {\n            final BufferedWriter writer = new BufferedWriter(new FileWriter(xmlFile));\n            writer.write(\"<dvdauthor dest=\\\"\" + this.m_GUI.strOutputDir + \"/DVD/\\\" jumppad=\\\"0\\\">\");\n            writer.newLine();\n            writer.write(\"\\t<vmgm>\");\n            writer.newLine();\n            writer.write(\"\\t\\t<menus>\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t<pgc entry=\\\"title\\\" >\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t\\t<vob file=\\\"\" + this.m_GUI.strOutputDir + \"/menu.vob\\\" pause=\\\"inf\\\" />\");\n            writer.newLine();\n            if (this.titles[0] == null) {\n                for (int i = 1; i <= this.video_files.length; ++i) {\n                    writer.write(\"\\t\\t\\t\\t<button>jump title \" + i + \";</button>\");\n                    writer.newLine();\n                }\n            }\n            else {\n                for (int i = 1; i < this.titles.length; ++i) {\n                    if (!this.titles[i - 1].equals(\"BLANK\") && !this.titles[i - 1].equals(\"DONE\")) {\n                        writer.write(\"\\t\\t\\t\\t<button>jump title \" + i + \";</button>\");\n                        writer.newLine();\n                    }\n                    else if (this.titles[i - 1].equals(\"DONE\")) {\n                        break;\n                    }\n                }\n            }\n            writer.write(\"\\t\\t\\t\\t<post> jump vmgm menu 1; </post>\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t</pgc>\");\n            writer.newLine();\n            writer.write(\"\\t\\t</menus>\");\n            writer.newLine();\n            writer.write(\"\\t</vmgm>\");\n            writer.newLine();\n            writer.write(\"\\t<titleset>\");\n            writer.newLine();\n            writer.write(\"\\t<titles>\");\n            writer.newLine();\n            int i;\n            for (i = 1; i < this.video_files.length; ++i) {\n                writer.write(\"\\t\\t<pgc>\");\n                writer.newLine();\n                writer.write(\"\\t\\t\\t<vob file=\\\"\" + this.video_files[i - 1] + \"\\\" />\");\n                writer.newLine();\n                writer.write(\"\\t\\t\\t<post>jump title \" + (i + 1) + \";</post>\");\n                writer.newLine();\n                writer.write(\"\\t\\t</pgc>\");\n                writer.newLine();\n            }\n            writer.write(\"\\t\\t<pgc>\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t<vob file=\\\"\" + this.video_files[i - 1] + \"\\\" />\");\n            writer.newLine();\n            writer.write(\"\\t\\t\\t<post>call vmgm menu 1;</post>\");\n            writer.newLine();\n            writer.write(\"\\t\\t</pgc>\");\n            writer.newLine();\n            writer.write(\"\\t</titles>\");\n            writer.newLine();\n            writer.write(\"\\t</titleset>\");\n            writer.newLine();\n            writer.write(\"</dvdauthor>\");\n            writer.newLine();\n            writer.close();\n        }\n        catch (IOException ex) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n            this.m_GUI.MessageBox(this.baseErr + \"IO Error\\n\" + ex.toString(), 0);\n            ex.printStackTrace();\n            return true;\n        }\n        return false;\n    }\n}\n"
    },
    {
        "project_name": "47_dvd-homevideo",
        "class": "Convert",
        "fqdn": "",
        "source_code": "import java.util.*;\nimport java.io.*;\n\npublic class Convert implements Runnable\n{\n    private int m_Quality;\n    private double m_fps;\n    private String m_Format;\n    private String m_AspectRatio;\n    private String m_flags;\n    private String m_bitrate;\n    protected String[] video_files;\n    private GUI m_GUI;\n    private Thread m_Thread;\n    private boolean m_Error;\n    private int thread_track;\n    private String m_BaseErr;\n    private String m_transcode;\n    private String mplex;\n    \n    public Convert(final String format, final String aspectRatio, final GUI DVD_GUI) {\n        this.m_bitrate = \"8500\";\n        this.m_BaseErr = \"Transcoding Error - \";\n        this.m_transcode = \"transcode -i dv/inp -m test1.ac3 -o test1 -w bitr -x dv,dv -F flags -y mpeg2enc,raw -N 0x2000 -b 256 --encode_fields b -E 48000,16,2 -J resample --export_prof format --export_fps frames/s --export_asr aspectRatio -j 0,8,0,8 --print_status 30\";\n        this.mplex = \"mplex -f 8 -V -o inp.vob inp.m2v inp.ac3\";\n        if (format.equals(\"dvd-ntsc\")) {\n            this.m_fps = 29.97;\n        }\n        else {\n            this.m_fps = 25.0;\n        }\n        this.m_GUI = DVD_GUI;\n        this.m_Format = format;\n        this.m_AspectRatio = aspectRatio;\n        this.thread_track = 0;\n    }\n    \n    public Convert(final int quality, final String format, final String aspectRatio, final GUI DVD_GUI) {\n        this.m_bitrate = \"8500\";\n        this.m_BaseErr = \"Transcoding Error - \";\n        this.m_transcode = \"transcode -i dv/inp -m test1.ac3 -o test1 -w bitr -x dv,dv -F flags -y mpeg2enc,raw -N 0x2000 -b 256 --encode_fields b -E 48000,16,2 -J resample --export_prof format --export_fps frames/s --export_asr aspectRatio -j 0,8,0,8 --print_status 30\";\n        this.mplex = \"mplex -f 8 -V -o inp.vob inp.m2v inp.ac3\";\n        if (format.equals(\"dvd-ntsc\")) {\n            this.m_fps = 29.97;\n        }\n        else {\n            this.m_fps = 25.0;\n        }\n        this.m_GUI = DVD_GUI;\n        this.m_Quality = quality;\n        this.m_Format = format;\n        this.m_AspectRatio = aspectRatio;\n        this.thread_track = 0;\n    }\n    \n    public boolean init() {\n        if (this.m_GUI.menuChkThread.isSelected()) {\n            (this.m_Thread = new Thread(this)).start();\n            try {\n                this.m_Thread.join();\n            }\n            catch (InterruptedException ex) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Could not join Convert.java thread\\n\" + ex.toString(), 0);\n                ex.printStackTrace();\n                this.m_Error = true;\n            }\n        }\n        else {\n            this.Transcode();\n        }\n        return this.m_Error || this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/transcode.log\") || this.m_GUI.ErrorCheck(this.m_GUI.strOutputDir + \"/log/mplex.log\");\n    }\n    \n    @Override\n    public void run() {\n        this.Transcode();\n    }\n    \n    public void Transcode() {\n        final File ListDir = new File(this.m_GUI.strOutputDir + \"/dv/\");\n        if (this.m_Quality == 0) {\n            this.m_flags = \"'8, -c -q 2 -4 1 -2 1 -H -K file=matrix.txt -R 2'\";\n        }\n        else if (this.m_Quality == 1) {\n            this.m_flags = \"'8, -c -q 4 -4 2 -2 2 -K file=matrix.txt -R 1'\";\n        }\n        else {\n            this.m_flags = \"'8, -c -q 6 -4 3 -2 3 -N 0.5 -E -10 -K tmpgenc -R 0'\";\n        }\n        this.m_transcode = this.m_transcode.replaceAll(\"flags\", this.m_flags);\n        this.m_transcode = this.m_transcode.replaceAll(\"bitr\", this.m_bitrate);\n        this.m_transcode = this.m_transcode.replaceAll(\"format\", this.m_Format);\n        this.m_transcode = this.m_transcode.replaceAll(\"aspectRatio\", this.m_AspectRatio);\n        this.m_transcode = this.m_transcode.replaceAll(\"frames/s\", String.valueOf(this.m_fps));\n        this.matrix();\n        this.m_GUI.lblConvert.setEnabled(true);\n        this.m_GUI.prgConvert.setEnabled(true);\n        this.m_GUI.lblConvertProg.setEnabled(true);\n        double cummulative_time = 0.0;\n        double current_time = 0.0;\n        final double[] average_fps = { 0.0, 0.0, 0.0, 0.0, -1.0 };\n        final int total_time = (int)this.m_GUI.spnMinutes.getValue() * 60 + (int)this.m_GUI.spnSeconds.getValue();\n        while (this.thread_track < ListDir.list().length) {\n            this.video_files = ListDir.list();\n            try {\n                if (this.thread_track == 0) {\n                    this.m_transcode = this.m_transcode.replaceAll(\"inp\", this.video_files[this.thread_track]);\n                    this.m_transcode = this.m_transcode.replaceAll(\"test1\", this.video_files[this.thread_track].substring(0, 11));\n                    this.mplex = this.mplex.replaceAll(\"inp\", this.video_files[this.thread_track].substring(0, 11));\n                }\n                else {\n                    this.m_transcode = this.m_transcode.replaceAll(this.video_files[this.thread_track - 1], this.video_files[this.thread_track]);\n                    this.m_transcode = this.m_transcode.replaceAll(this.video_files[this.thread_track - 1].substring(0, 11), this.video_files[this.thread_track].substring(0, 11));\n                    this.mplex = this.mplex.replaceAll(this.video_files[this.thread_track - 1].substring(0, 11), this.video_files[this.thread_track].substring(0, 11));\n                }\n            }\n            catch (StringIndexOutOfBoundsException ex) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Are there non-standard (not .dv)\" + \"\\nfiles in the dv directory?\\n\" + ex.toString(), 0);\n                ex.printStackTrace();\n                this.m_Error = true;\n            }\n            try {\n                final String[] transcode_cmd = { \"/bin/sh\", \"-c\", this.m_transcode };\n                Process p = Runtime.getRuntime().exec(transcode_cmd, null, new File(this.m_GUI.strOutputDir));\n                BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                BufferedReader err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                BufferedWriter out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/transcode.log\"));\n                BufferedWriter err_out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/transcode.err\"));\n                out.write(this.m_transcode);\n                out.newLine();\n                if (err_in.ready()) {\n                    final String line = err_in.readLine();\n                    if (line.equals(\"/bin/sh: transcode: command not found\")) {\n                        this.m_GUI.MessageBox(\"Could not locate transcode in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                        in.close();\n                        out.close();\n                        err_in.close();\n                        err_out.close();\n                        this.m_Error = true;\n                    }\n                    else {\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                int k = 0;\n                String line;\n                while ((line = in.readLine()) != null) {\n                    final StringTokenizer st = new StringTokenizer(line);\n                    if (st.hasMoreTokens() && st.nextToken().equals(\"encoding\")) {\n                        st.nextToken();\n                        st.nextToken();\n                        average_fps[k % 5] = Double.valueOf(st.nextToken());\n                        st.nextToken();\n                        st.nextToken();\n                        final StringTokenizer time = new StringTokenizer(st.nextToken(), \":,\");\n                        if (time.hasMoreTokens()) {\n                            final int hour = Integer.valueOf(time.nextToken());\n                            final int min = Integer.valueOf(time.nextToken());\n                            final int sec = Integer.valueOf(time.nextToken());\n                            current_time = hour * 3600 + min * 60 + sec + cummulative_time;\n                            this.m_GUI.prgConvert.setValue((int)(current_time / total_time * 100.0));\n                            this.m_GUI.lblConvertProg.setText(String.valueOf((int)(current_time / total_time * 100.0)) + \"%\");\n                            double fps_sum = 0.0;\n                            if (average_fps[4] != -1.0) {\n                                for (int j = 0; j < 5; ++j) {\n                                    fps_sum += average_fps[j];\n                                }\n                                fps_sum /= 5.0;\n                                final int time_remaining = (int)((total_time - current_time) * (int)this.m_fps / fps_sum);\n                                final int captureTipHour = time_remaining / 3600;\n                                final int captureTipMinute = (time_remaining - 3600 * captureTipHour) / 60;\n                                if (captureTipHour == 0 && captureTipMinute < 5) {\n                                    this.m_GUI.prgConvert.setToolTipText(\"Less than 5 minutes remaining\");\n                                }\n                                else if (captureTipMinute < 10) {\n                                    this.m_GUI.prgConvert.setToolTipText(captureTipHour + \":0\" + captureTipMinute + \" Remaining\");\n                                }\n                                else {\n                                    this.m_GUI.prgConvert.setToolTipText(captureTipHour + \":\" + captureTipMinute + \" Remaining\");\n                                }\n                            }\n                            this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                            this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                            out.write(line);\n                            out.newLine();\n                        }\n                        else {\n                            this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                            this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                            out.write(line);\n                            out.newLine();\n                        }\n                        ++k;\n                    }\n                }\n                while ((line = err_in.readLine()) != null) {\n                    this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                    this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                    out.write(line);\n                    out.newLine();\n                }\n                in.close();\n                out.close();\n                err_in.close();\n                err_out.close();\n                cummulative_time = current_time;\n                final String[] mplex_cmd = { \"/bin/sh\", \"-c\", this.mplex };\n                p = Runtime.getRuntime().exec(mplex_cmd, null, new File(this.m_GUI.strOutputDir));\n                in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                err_in = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n                out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/mplex.log\"));\n                err_out = new BufferedWriter(new FileWriter(this.m_GUI.strOutputDir + \"/log/mplex.err\"));\n                if (err_in.ready()) {\n                    line = err_in.readLine();\n                    if (line.equals(\"/bin/sh: mplex: command not found\")) {\n                        this.m_GUI.MessageBox(\"Could not locate mplex in your path.\\nPlease install all necessary dependencies\\nand rerun dvd-homevideo.\", 0);\n                        in.close();\n                        out.close();\n                        err_in.close();\n                        err_out.close();\n                        this.m_Error = true;\n                    }\n                    else {\n                        this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                        out.write(line);\n                        out.newLine();\n                    }\n                }\n                while ((line = err_in.readLine()) != null) {\n                    this.m_GUI.txtAreaOutput.append(line + \"\\n\");\n                    this.m_GUI.txtAreaOutput.setCaretPosition(this.m_GUI.txtAreaOutput.getDocument().getLength());\n                    out.write(line);\n                    out.newLine();\n                }\n                in.close();\n                out.close();\n                err_in.close();\n                err_out.close();\n                Thread.sleep(2000L);\n            }\n            catch (IOException ex2) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex2);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex2.toString(), 0);\n                ex2.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (NullPointerException ex3) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex3);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Error executing Runtime.getRuntime().exec()\\n\" + ex3.toString(), 0);\n                ex3.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (IllegalArgumentException ex4) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex4);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Illegal argument sent to Runtime.getRuntime().exec()\\n\" + ex4.toString(), 0);\n                ex4.printStackTrace();\n                this.m_Error = true;\n            }\n            catch (Exception ex5) {\n                SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex5);\n                this.m_GUI.MessageBox(this.m_BaseErr + \"Unknown Error occurred\\n\" + ex5.toString(), 0);\n                ex5.printStackTrace();\n                this.m_Error = true;\n            }\n            ++this.thread_track;\n        }\n        this.m_GUI.prgConvert.setValue(100);\n        this.m_GUI.lblConvertProg.setText(\"100%\");\n        this.m_GUI.prgConvert.setEnabled(false);\n        this.m_GUI.lblConvert.setEnabled(false);\n        this.m_GUI.lblConvertProg.setEnabled(false);\n    }\n    \n    public void matrix() {\n        try {\n            final FileWriter fw = new FileWriter(this.m_GUI.strOutputDir + \"/\" + \"matrix.txt\");\n            final BufferedWriter wr = new BufferedWriter(fw);\n            wr.write(\"# High resolution INTRA table\\n\");\n            wr.write(\"8,16,18,20,24,25,26,30\\n\");\n            wr.write(\"16,16,20,23,25,26,30,30\\n\");\n            wr.write(\"18,20,22,24,26,28,29,31\\n\");\n            wr.write(\"20,21,23,24,26,28,31,31\\n\");\n            wr.write(\"21,23,24,25,28,30,30,33\\n\");\n            wr.write(\"23,24,25,28,30,30,33,36\\n\");\n            wr.write(\"24,25,26,29,29,31,34,38\\n\");\n            wr.write(\"25,26,28,29,31,34,38,42\\n\");\n            wr.write(\"# TMPEGEnc NON-INTRA table\\n\");\n            wr.write(\"16,17,18,19,20,21,22,23\\n\");\n            wr.write(\"17,18,19,20,21,22,23,24\\n\");\n            wr.write(\"18,19,20,21,22,23,24,25\\n\");\n            wr.write(\"19,20,21,22,23,24,26,27\\n\");\n            wr.write(\"20,21,22,23,25,26,27,28\\n\");\n            wr.write(\"21,22,23,24,26,27,28,30\\n\");\n            wr.write(\"22,23,24,26,27,28,30,31\\n\");\n            wr.write(\"23,24,25,27,28,30,31,33\\n\");\n            wr.close();\n            fw.close();\n        }\n        catch (IOException ex) {\n            SaveStackTrace.printTrace(this.m_GUI.strOutputDir, ex);\n            this.m_GUI.MessageBox(this.m_BaseErr + \"IO Error\\n\" + ex.toString(), 0);\n            ex.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n"
    },
    {
        "project_name": "43_lilith",
        "class": "AccessEvent",
        "fqdn": "de.huxhorn.lilith.data.access",
        "source_code": "package de.huxhorn.lilith.data.access;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class AccessEvent implements Serializable\n{\n    private static final long serialVersionUID = -716078283933754505L;\n    private Long timeStamp;\n    private LoggerContext loggerContext;\n    private String requestURI;\n    private String requestURL;\n    private String remoteHost;\n    private String remoteUser;\n    private String protocol;\n    private String method;\n    private String serverName;\n    private String remoteAddress;\n    private Map<String, String> requestHeaders;\n    private Map<String, String> responseHeaders;\n    private Map<String, String[]> requestParameters;\n    private int localPort;\n    private int statusCode;\n    \n    public Long getTimeStamp() {\n        return this.timeStamp;\n    }\n    \n    public void setTimeStamp(final Long timeStamp) {\n        this.timeStamp = timeStamp;\n    }\n    \n    public LoggerContext getLoggerContext() {\n        return this.loggerContext;\n    }\n    \n    public void setLoggerContext(final LoggerContext loggerContext) {\n        this.loggerContext = loggerContext;\n    }\n    \n    public String getRequestURI() {\n        return this.requestURI;\n    }\n    \n    public void setRequestURI(final String requestURI) {\n        this.requestURI = requestURI;\n    }\n    \n    public String getRequestURL() {\n        return this.requestURL;\n    }\n    \n    public void setRequestURL(final String requestURL) {\n        this.requestURL = requestURL;\n    }\n    \n    public String getRemoteHost() {\n        return this.remoteHost;\n    }\n    \n    public void setRemoteHost(final String remoteHost) {\n        this.remoteHost = remoteHost;\n    }\n    \n    public String getRemoteUser() {\n        return this.remoteUser;\n    }\n    \n    public void setRemoteUser(final String remoteUser) {\n        this.remoteUser = remoteUser;\n    }\n    \n    public String getProtocol() {\n        return this.protocol;\n    }\n    \n    public void setProtocol(final String protocol) {\n        this.protocol = protocol;\n    }\n    \n    public String getMethod() {\n        return this.method;\n    }\n    \n    public void setMethod(final String method) {\n        this.method = method;\n    }\n    \n    public String getServerName() {\n        return this.serverName;\n    }\n    \n    public void setServerName(final String serverName) {\n        this.serverName = serverName;\n    }\n    \n    public String getRemoteAddress() {\n        return this.remoteAddress;\n    }\n    \n    public void setRemoteAddress(final String remoteAddress) {\n        this.remoteAddress = remoteAddress;\n    }\n    \n    public Map<String, String> getRequestHeaders() {\n        return this.requestHeaders;\n    }\n    \n    public void setRequestHeaders(final Map<String, String> requestHeaders) {\n        this.requestHeaders = requestHeaders;\n    }\n    \n    public Map<String, String> getResponseHeaders() {\n        return this.responseHeaders;\n    }\n    \n    public void setResponseHeaders(final Map<String, String> responseHeaders) {\n        this.responseHeaders = responseHeaders;\n    }\n    \n    public Map<String, String[]> getRequestParameters() {\n        return this.requestParameters;\n    }\n    \n    public void setRequestParameters(final Map<String, String[]> requestParameters) {\n        this.requestParameters = requestParameters;\n    }\n    \n    public int getLocalPort() {\n        return this.localPort;\n    }\n    \n    public void setLocalPort(final int localPort) {\n        this.localPort = localPort;\n    }\n    \n    public int getStatusCode() {\n        return this.statusCode;\n    }\n    \n    public void setStatusCode(final int statusCode) {\n        this.statusCode = statusCode;\n    }\n    \n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final AccessEvent event = (AccessEvent)o;\n        if (this.localPort != event.localPort) {\n            return false;\n        }\n        if (this.statusCode != event.statusCode) {\n            return false;\n        }\n        Label_0088: {\n            if (this.loggerContext != null) {\n                if (this.loggerContext.equals(event.loggerContext)) {\n                    break Label_0088;\n                }\n            }\n            else if (event.loggerContext == null) {\n                break Label_0088;\n            }\n            return false;\n        }\n        Label_0121: {\n            if (this.method != null) {\n                if (this.method.equals(event.method)) {\n                    break Label_0121;\n                }\n            }\n            else if (event.method == null) {\n                break Label_0121;\n            }\n            return false;\n        }\n        Label_0154: {\n            if (this.protocol != null) {\n                if (this.protocol.equals(event.protocol)) {\n                    break Label_0154;\n                }\n            }\n            else if (event.protocol == null) {\n                break Label_0154;\n            }\n            return false;\n        }\n        Label_0187: {\n            if (this.remoteAddress != null) {\n                if (this.remoteAddress.equals(event.remoteAddress)) {\n                    break Label_0187;\n                }\n            }\n            else if (event.remoteAddress == null) {\n                break Label_0187;\n            }\n            return false;\n        }\n        Label_0220: {\n            if (this.remoteHost != null) {\n                if (this.remoteHost.equals(event.remoteHost)) {\n                    break Label_0220;\n                }\n            }\n            else if (event.remoteHost == null) {\n                break Label_0220;\n            }\n            return false;\n        }\n        Label_0253: {\n            if (this.remoteUser != null) {\n                if (this.remoteUser.equals(event.remoteUser)) {\n                    break Label_0253;\n                }\n            }\n            else if (event.remoteUser == null) {\n                break Label_0253;\n            }\n            return false;\n        }\n        Label_0286: {\n            if (this.requestHeaders != null) {\n                if (this.requestHeaders.equals(event.requestHeaders)) {\n                    break Label_0286;\n                }\n            }\n            else if (event.requestHeaders == null) {\n                break Label_0286;\n            }\n            return false;\n        }\n        Label_0319: {\n            if (this.requestURI != null) {\n                if (this.requestURI.equals(event.requestURI)) {\n                    break Label_0319;\n                }\n            }\n            else if (event.requestURI == null) {\n                break Label_0319;\n            }\n            return false;\n        }\n        Label_0352: {\n            if (this.requestURL != null) {\n                if (this.requestURL.equals(event.requestURL)) {\n                    break Label_0352;\n                }\n            }\n            else if (event.requestURL == null) {\n                break Label_0352;\n            }\n            return false;\n        }\n        Label_0385: {\n            if (this.responseHeaders != null) {\n                if (this.responseHeaders.equals(event.responseHeaders)) {\n                    break Label_0385;\n                }\n            }\n            else if (event.responseHeaders == null) {\n                break Label_0385;\n            }\n            return false;\n        }\n        Label_0418: {\n            if (this.serverName != null) {\n                if (this.serverName.equals(event.serverName)) {\n                    break Label_0418;\n                }\n            }\n            else if (event.serverName == null) {\n                break Label_0418;\n            }\n            return false;\n        }\n        if (this.timeStamp != null) {\n            if (!this.timeStamp.equals(event.timeStamp)) {\n                return false;\n            }\n        }\n        else if (event.timeStamp != null) {\n            return false;\n        }\n        return true;\n        b = false;\n        return b;\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = (this.timeStamp != null) ? this.timeStamp.hashCode() : 0;\n        result = 31 * result + ((this.loggerContext != null) ? this.loggerContext.hashCode() : 0);\n        result = 31 * result + ((this.requestURI != null) ? this.requestURI.hashCode() : 0);\n        result = 31 * result + ((this.requestURL != null) ? this.requestURL.hashCode() : 0);\n        result = 31 * result + ((this.remoteHost != null) ? this.remoteHost.hashCode() : 0);\n        result = 31 * result + ((this.remoteUser != null) ? this.remoteUser.hashCode() : 0);\n        result = 31 * result + ((this.protocol != null) ? this.protocol.hashCode() : 0);\n        result = 31 * result + ((this.method != null) ? this.method.hashCode() : 0);\n        result = 31 * result + ((this.serverName != null) ? this.serverName.hashCode() : 0);\n        result = 31 * result + ((this.remoteAddress != null) ? this.remoteAddress.hashCode() : 0);\n        result = 31 * result + this.localPort;\n        result = 31 * result + this.statusCode;\n        return result;\n    }\n    \n    @Override\n    public String toString() {\n        final StringBuilder result = new StringBuilder();\n        result.append(\"AccessEvent[\");\n        result.append(\"loggerContext=\").append(this.loggerContext).append(\", \");\n        result.append(\"timeStamp=\").append(this.timeStamp);\n        result.append(\"]\");\n        return result.toString();\n    }\n}\n"
    },
    {
        "project_name": "86_at-robots2-j",
        "class": "RobotRenderer",
        "fqdn": "net.virtualinfinity.atrobots.gui.renderers",
        "source_code": "package net.virtualinfinity.atrobots.gui.renderers;\n\nimport java.util.*;\nimport java.awt.*;\nimport java.awt.geom.*;\nimport net.virtualinfinity.atrobots.measures.*;\nimport net.virtualinfinity.atrobots.snapshots.*;\n\npublic class RobotRenderer implements SnapshotRenderer<RobotSnapshot>\n{\n    private boolean showStatusBars;\n    private boolean renderDead;\n    private boolean showName;\n    private boolean fillShield;\n    private static final Color HEAT_COLOR1;\n    private static final Color HEAT_COLOR2;\n    \n    public RobotRenderer() {\n        this.showStatusBars = true;\n        this.renderDead = true;\n        this.showName = true;\n        this.fillShield = true;\n    }\n    \n    @Override\n    public void render(final Graphics2D g2d, final RobotSnapshot robotSnapshot, final Set<Integer> selectedRobotIds) {\n        if (!this.isRenderDead() && robotSnapshot.isDead()) {\n            return;\n        }\n        this.paintBody(g2d, robotSnapshot);\n        if (!robotSnapshot.isDead()) {\n            this.paintShield(g2d, robotSnapshot);\n            this.paintTurret(g2d, robotSnapshot);\n            if (this.isShowStatusBars()) {\n                this.paintArmor(g2d, robotSnapshot);\n                this.paintHeat(g2d, robotSnapshot);\n            }\n            if (this.isShowName()) {\n                this.paintName(g2d, robotSnapshot);\n            }\n        }\n        if (selectedRobotIds.contains(robotSnapshot.getId())) {\n            this.paintSelection(g2d, robotSnapshot);\n        }\n    }\n    \n    public boolean isRenderDead() {\n        return this.renderDead;\n    }\n    \n    public void setRenderDead(final boolean renderDead) {\n        this.renderDead = renderDead;\n    }\n    \n    public boolean isShowStatusBars() {\n        return this.showStatusBars;\n    }\n    \n    public void setShowStatusBars(final boolean showStatusBars) {\n        this.showStatusBars = showStatusBars;\n    }\n    \n    public boolean isShowName() {\n        return this.showName;\n    }\n    \n    public void setShowName(final boolean showName) {\n        this.showName = showName;\n    }\n    \n    public boolean isFillShield() {\n        return this.fillShield;\n    }\n    \n    public void setFillShield(final boolean fillShield) {\n        this.fillShield = fillShield;\n    }\n    \n    private void paintSelection(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(new Color(1.0f, 1.0f, 0.0f, 0.25f));\n        final Ellipse2D.Double s = new Ellipse2D.Double();\n        s.setFrameFromCenter(robotSnapshot.getX(), robotSnapshot.getY(), robotSnapshot.getX() + 30.0, robotSnapshot.getY() + 30.0);\n        g2d.fill(s);\n    }\n    \n    private void paintShield(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        if (robotSnapshot.isActiveShield()) {\n            final Ellipse2D.Double s = new Ellipse2D.Double();\n            s.setFrameFromCenter(robotSnapshot.getX(), robotSnapshot.getY(), robotSnapshot.getX() + 15.0, robotSnapshot.getY() + 15.0);\n            if (this.isFillShield()) {\n                g2d.setPaint(new RadialGradientPaint(robotSnapshot.getPositionVector().toPoint2D(), 15.0f, new float[] { 0.0f, 0.75f, 1.0f }, new Color[] { new Color(0.5f, 0.5f, 0.0f, 0.8f), new Color(0.0f, 0.0f, 0.5f, 0.1f), Color.white }));\n                g2d.fill(s);\n                g2d.fill(s);\n            }\n            else {\n                g2d.setPaint(new Color(0.8f, 0.6f, 1.0f));\n                g2d.draw(s);\n            }\n        }\n    }\n    \n    private void paintName(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(Color.yellow);\n        g2d.drawString(robotSnapshot.getName(), (float)(robotSnapshot.getX() - g2d.getFontMetrics().getStringBounds(robotSnapshot.getName(), g2d).getWidth() / 2.0), (float)(robotSnapshot.getY() - 10.0));\n    }\n    \n    private void paintHeat(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        final Rectangle2D.Double rect = new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 35.0, 100.0, 10.0);\n        g2d.setPaint(new GradientPaint((float)rect.getMinX(), (float)rect.getMinY(), RobotRenderer.HEAT_COLOR1, (float)rect.getMaxX(), (float)rect.getMinY(), RobotRenderer.HEAT_COLOR2));\n        if (!robotSnapshot.isDead()) {\n            g2d.fill(new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 35.0, robotSnapshot.getTemperature().getLogScale() * 0.2, 10.0));\n        }\n        g2d.draw(rect);\n    }\n    \n    private void paintArmor(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(new Color(0.0f, 0.0f, 1.0f, 0.6f));\n        g2d.fill(new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 20.0, robotSnapshot.getArmor(), 10.0));\n        g2d.setPaint(new Color(0.0f, 1.0f, 0.0f, 0.6f));\n        g2d.draw(new Rectangle2D.Double(robotSnapshot.getX() - 50.0, robotSnapshot.getY() + 20.0, 100.0, 10.0));\n    }\n    \n    private void paintTurret(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        g2d.setPaint(Color.white);\n        g2d.draw(new Line2D.Double(robotSnapshot.getX(), robotSnapshot.getY(), robotSnapshot.getX() + robotSnapshot.getTurretHeading().cosine() * 5.0, robotSnapshot.getY() + robotSnapshot.getTurretHeading().sine() * 5.0));\n    }\n    \n    private void paintBody(final Graphics2D g2d, final RobotSnapshot robotSnapshot) {\n        final Stroke stroke = g2d.getStroke();\n        if (robotSnapshot.isDead()) {\n            final BasicStroke basicStroke = new BasicStroke(1.0f, 1, 0, 10.0f, new float[] { 5.0f, 5.0f }, 0.0f);\n            g2d.setStroke(basicStroke);\n            g2d.setPaint(Color.orange.darker().darker());\n        }\n        else {\n            g2d.setPaint(Color.red);\n        }\n        final GeneralPath path = new GeneralPath();\n        path.moveTo(robotSnapshot.getX() + robotSnapshot.getHeading().cosine() * 15.0, robotSnapshot.getY() + robotSnapshot.getHeading().sine() * 15.0);\n        final AbsoluteAngle cc = robotSnapshot.getHeading().counterClockwise(RelativeAngle.fromBygrees(160));\n        final AbsoluteAngle c = robotSnapshot.getHeading().clockwise(RelativeAngle.fromBygrees(160));\n        path.lineTo(robotSnapshot.getX() + cc.cosine() * 9.0, robotSnapshot.getY() + cc.sine() * 9.0);\n        path.lineTo(robotSnapshot.getX(), robotSnapshot.getY());\n        path.lineTo(robotSnapshot.getX() + c.cosine() * 9.0, robotSnapshot.getY() + c.sine() * 9.0);\n        path.closePath();\n        if (robotSnapshot.isDead()) {\n            g2d.draw(path);\n        }\n        else {\n            g2d.fill(path);\n        }\n        g2d.setStroke(stroke);\n    }\n    \n    static {\n        HEAT_COLOR1 = new Color(1.0f, 0.0f, 0.0f, 0.1f);\n        HEAT_COLOR2 = Color.yellow;\n    }\n}\n"
    },
    {
        "project_name": "87_jaw-br",
        "class": "Abrir",
        "fqdn": "jaw.entrada",
        "source_code": "package jaw.entrada;\n\nimport jaw.gui.*;\nimport jaw.*;\nimport javax.swing.filechooser.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport java.io.*;\n\npublic class Abrir\n{\n    public String xml;\n    public ProcessarEntidades form;\n    public static final int ABRIR_XML = 10;\n    public static final int ABRIR = 20;\n    \n    public Abrir(final ProcessarEntidades form, final String arquivo) {\n        this.xml = \"\";\n        this.form = form;\n        if (arquivo.endsWith(\".jaw.xml\")) {\n            this.abrirXML(arquivo);\n        }\n        else {\n            this.abrirSerializado(arquivo);\n        }\n    }\n    \n    public Abrir(final ProcessarEntidades form, final int tipoAbrir) {\n        this.xml = \"\";\n        this.form = form;\n        final JFileChooser escolhedor = new JFileChooser();\n        escolhedor.setCurrentDirectory(new File(Main.configuracao.getCaminhoDosProjetos()));\n        if (tipoAbrir == 10) {\n            escolhedor.setFileFilter(new Filtro2());\n        }\n        if (tipoAbrir == 20) {\n            escolhedor.setFileFilter(new Filtro());\n        }\n        escolhedor.showOpenDialog(null);\n        if (escolhedor.getSelectedFile() == null) {\n            return;\n        }\n        final String arquivo = escolhedor.getSelectedFile().getAbsolutePath();\n        if (tipoAbrir == 20) {\n            this.abrirSerializado(arquivo);\n        }\n        if (tipoAbrir == 10) {\n            this.abrirXML(arquivo);\n        }\n    }\n    \n    private void abrirSerializado(final String arquivo) {\n        if (arquivo.endsWith(\".jaw\")) {\n            try {\n                this.form.setNomeArquivoSalvo(arquivo);\n                this.form.setEntidades(new Serializacao().abrir(arquivo));\n            }\n            catch (Exception e) {\n                JOptionPane.showMessageDialog(null, \"Arquivo jaw corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3§\\u00c3£o!\", \"Abrir Arquivo jaw\", 0);\n                Main.janelaPrincipal.log(e.toString());\n            }\n        }\n        else {\n            JOptionPane.showMessageDialog(null, \"Arquivo jaw corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3§\\u00c3£o!\", \"Abrir Arquivo jaw\", 0);\n        }\n    }\n    \n    private void abrirXML(final String arquivo) {\n        if (arquivo.endsWith(\".jaw.xml\")) {\n            try {\n                this.form.setNomeArquivoSalvo(arquivo);\n                final Reader leitor = new FileReader(arquivo);\n                this.form.setEntidades(new SerializacaoXML().xml2Entidades(leitor));\n            }\n            catch (Exception e) {\n                JOptionPane.showMessageDialog(null, \"Arquivo xml corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3§\\u00c3£o!\", \"Importa\\u00c3§\\u00c3£o XML\", 0);\n                Main.janelaPrincipal.log(e.toString());\n            }\n        }\n        else {\n            JOptionPane.showMessageDialog(null, \"Arquivo xml corrompido ou incompat\\u00c3\\u00advel com aplica\\u00c3§\\u00c3£o!\", \"Importa\\u00c3§\\u00c3£o XML\", 0);\n        }\n    }\n    \n    private class Filtro2 extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw.xml\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"XML JAW files\";\n        }\n    }\n    \n    private class Filtro extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"JAW files\";\n        }\n    }\n}\n"
    },
    {
        "project_name": "87_jaw-br",
        "class": "Salvar",
        "fqdn": "jaw.entrada",
        "source_code": "package jaw.entrada;\n\nimport jaw.metamodelo.*;\nimport jaw.gui.*;\nimport java.util.*;\nimport jaw.*;\nimport javax.swing.filechooser.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport java.io.*;\n\npublic class Salvar\n{\n    private boolean vela;\n    private String arquivo;\n    public String xml;\n    public List<Entidade> entidade;\n    public static final int SALVAR_XML = 10;\n    public static final int SALVAR = 20;\n    public static final int SALVAR_COMO = 30;\n    \n    public Salvar(final ProcessarEntidades form, final int tipoSalvar) {\n        this.vela = false;\n        this.arquivo = \"\";\n        this.xml = \"\";\n        this.entidade = new Vector<Entidade>();\n        try {\n            this.entidade = form.getEntidades();\n        }\n        catch (Exception ex) {\n            Main.janelaPrincipal.log(ex.toString());\n            return;\n        }\n        final JFileChooser escolhedor = new JFileChooser();\n        escolhedor.setCurrentDirectory(new File(Main.configuracao.getCaminhoDosProjetos()));\n        if (tipoSalvar == 10) {\n            escolhedor.setFileFilter(new Filtro2());\n        }\n        if (tipoSalvar == 20 || tipoSalvar == 30) {\n            escolhedor.setFileFilter(new Filtro());\n        }\n        if (tipoSalvar == 10 || tipoSalvar == 30 || (tipoSalvar == 20 && form.getNomeArquivoSalvo().equals(\"Novo Projeto\"))) {\n            escolhedor.showSaveDialog(form);\n            this.vela = true;\n        }\n        if (escolhedor.getSelectedFile() == null && form.getName().equals(\"\")) {\n            return;\n        }\n        if (this.vela) {\n            if (escolhedor.getSelectedFile() == null) {\n                return;\n            }\n            this.arquivo = escolhedor.getSelectedFile().getAbsolutePath();\n        }\n        else {\n            this.arquivo = form.getNomeArquivoSalvo();\n        }\n        if (tipoSalvar == 20 || tipoSalvar == 30) {\n            if (!this.arquivo.endsWith(\".jaw\") && this.vela) {\n                form.setNomeArquivoSalvo(this.arquivo += \".jaw\");\n                this.vela = false;\n            }\n            else {\n                this.arquivo = form.getNomeArquivoSalvo();\n            }\n            System.out.println(form.getNomeArquivoSalvo());\n            final Serializacao salvar = new Serializacao();\n            try {\n                if (salvar.salvar(this.entidade, this.arquivo)) {\n                    JOptionPane.showMessageDialog(form, \"Arquivo salvo com sucesso!\", \"Jaw - Salvar\", 1);\n                }\n            }\n            catch (Exception ex2) {\n                JOptionPane.showMessageDialog(null, \"N\\u00c3£o foi poss\\u00c3\\u00advel salvar esse arquivo\\n Verifique o formato das entidades !\", \"Salvando Arquivo\", 0);\n                Main.janelaPrincipal.log(ex2.toString());\n            }\n        }\n        if (tipoSalvar == 10) {\n            if (!this.arquivo.endsWith(\".jaw.xml\")) {\n                this.arquivo += \".jaw.xml\";\n            }\n            final SerializacaoXML serializaXML = new SerializacaoXML();\n            this.xml = serializaXML.entidades2XML(this.entidade);\n            try {\n                final FileWriter escrevedor = new FileWriter(this.arquivo);\n                escrevedor.write(this.xml);\n                escrevedor.flush();\n                escrevedor.close();\n                JOptionPane.showMessageDialog(form, \"Arquivo Exportado com sucesso!\", \"Jaw - Salvar\", 1);\n            }\n            catch (Exception e) {\n                JOptionPane.showMessageDialog(form, \"N\\u00c3£o foi poss\\u00c3\\u00advel salvar esse arquivo\\n Verifique o formato das entidades !\", \"Salvando Arquivo\", 0);\n                Main.janelaPrincipal.log(e.toString());\n            }\n        }\n    }\n    \n    private class Filtro2 extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw.xml\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"XML JAW files\";\n        }\n    }\n    \n    private class Filtro extends FileFilter\n    {\n        @Override\n        public boolean accept(final File f) {\n            return f.isDirectory() || f.getName().toLowerCase().endsWith(\".jaw\");\n        }\n        \n        @Override\n        public String getDescription() {\n            return \"JAW files\";\n        }\n    }\n}\n"
    },
    {
        "project_name": "twitter4j",
        "class": "ExceptionDiagnosis",
        "fqdn": "twitter4j",
        "source_code": "package twitter4j;\n\nimport java.io.*;\n\nfinal class ExceptionDiagnosis implements Serializable\n{\n    int stackLineHash;\n    int lineNumberHash;\n    String hexString;\n    Throwable th;\n    private static final long serialVersionUID = 453958937114285988L;\n    \n    ExceptionDiagnosis(final Throwable th) {\n        this(th, new String[0]);\n    }\n    \n    ExceptionDiagnosis(final Throwable th, final String[] inclusionFilter) {\n        this.hexString = \"\";\n        this.th = th;\n        final StackTraceElement[] stackTrace = th.getStackTrace();\n        this.stackLineHash = 0;\n        this.lineNumberHash = 0;\n        for (int i = stackTrace.length - 1; i >= 0; --i) {\n            final StackTraceElement line = stackTrace[i];\n            for (final String filter : inclusionFilter) {\n                if (line.getClassName().startsWith(filter)) {\n                    final int hash = line.getClassName().hashCode() + line.getMethodName().hashCode();\n                    this.stackLineHash = 31 * this.stackLineHash + hash;\n                    this.lineNumberHash = 31 * this.lineNumberHash + line.getLineNumber();\n                    break;\n                }\n            }\n        }\n        this.hexString = this.hexString + this.toHexString(this.stackLineHash) + \"-\" + this.toHexString(this.lineNumberHash);\n        if (null != th.getCause()) {\n            this.hexString = this.hexString + \" \" + new ExceptionDiagnosis(th.getCause(), inclusionFilter).asHexString();\n        }\n    }\n    \n    int getStackLineHash() {\n        return this.stackLineHash;\n    }\n    \n    int getLineNumberHash() {\n        return this.lineNumberHash;\n    }\n    \n    String asHexString() {\n        return this.hexString;\n    }\n    \n    private String toHexString(final int value) {\n        final String str = \"0000000\" + Integer.toHexString(value);\n        return str.substring(str.length() - 8, str.length());\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final ExceptionDiagnosis that = (ExceptionDiagnosis)o;\n        return this.lineNumberHash == that.lineNumberHash && this.stackLineHash == that.stackLineHash;\n    }\n    \n    public int hashCode() {\n        int result = this.stackLineHash;\n        result = 31 * result + this.lineNumberHash;\n        return result;\n    }\n    \n    public String toString() {\n        return \"ExceptionDiagnosis{stackLineHash=\" + this.stackLineHash + \", lineNumberHash=\" + this.lineNumberHash + '}';\n    }\n}\n"
    },
    {
        "project_name": "78_caloriecount",
        "class": "SimpleComboBox",
        "fqdn": "com.lts.swing.combobox",
        "source_code": "package com.lts.swing.combobox;\n\nimport javax.swing.*;\n\npublic class SimpleComboBox extends JComboBox\n{\n    private static final long serialVersionUID = 1L;\n    private SimpleComboBoxModel mySimpleModel;\n    \n    public SimpleComboBox(final SimpleComboBoxModel model) {\n        super(model);\n    }\n    \n    @Override\n    public void setModel(final ComboBoxModel model) {\n        if (model instanceof SimpleComboBoxModel) {\n            this.mySimpleModel = (SimpleComboBoxModel)model;\n        }\n        super.setModel(model);\n    }\n    \n    public Object getSelectedValue() {\n        if (null == this.mySimpleModel) {\n            return null;\n        }\n        return this.mySimpleModel.getSelectedValue();\n    }\n    \n    public void setSelectedValue(final Object value) {\n        this.mySimpleModel.setSelectedValue(value);\n    }\n    \n    public int getSelectedInt() {\n        final Object o = this.getSelectedValue();\n        if (null == o) {\n            return -1;\n        }\n        if (o instanceof Integer) {\n            final Integer ival = (Integer)o;\n            return ival;\n        }\n        if (o instanceof Long) {\n            final Long lval = (Long)o;\n            return (int)(Object)lval;\n        }\n        if (o instanceof Short) {\n            final Short sval = (Short)o;\n            return sval;\n        }\n        if (o instanceof Byte) {\n            final Byte bval = (Byte)o;\n            return bval;\n        }\n        throw new IllegalArgumentException();\n    }\n    \n    public long getSelectedLong() {\n        final Object o = this.getSelectedValue();\n        if (null == o) {\n            return -1L;\n        }\n        if (o instanceof Integer) {\n            final Integer ival = (Integer)o;\n            return ival;\n        }\n        if (o instanceof Long) {\n            final Long lval = (Long)o;\n            return lval;\n        }\n        if (o instanceof Short) {\n            final Short sval = (Short)o;\n            return sval;\n        }\n        if (o instanceof Byte) {\n            final Byte bval = (Byte)o;\n            return bval;\n        }\n        throw new IllegalArgumentException();\n    }\n}\n"
    },
    {
        "project_name": "78_caloriecount",
        "class": "SimpleKeyListenerHelper",
        "fqdn": "com.lts.event",
        "source_code": "package com.lts.event;\n\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class SimpleKeyListenerHelper extends ListenerHelper implements KeyListener\n{\n    private Component component;\n    \n    public SimpleKeyListenerHelper(final Component component) {\n        component.addKeyListener(this);\n        this.component = component;\n    }\n    \n    public void detach() {\n        if (null != this.component) {\n            this.component.removeKeyListener(this);\n            this.component = null;\n        }\n    }\n    \n    @Override\n    public void notifyListener(final Object o, final int type, final Object data) {\n        final SimpleKeyListener listener = (SimpleKeyListener)o;\n        switch (type) {\n            case 10: {\n                listener.enter(this.component);\n                break;\n            }\n            case 155: {\n                listener.insert(this.component);\n                break;\n            }\n            case 127: {\n                listener.delete(this.component);\n                break;\n            }\n            case 9: {\n                listener.tab(this.component);\n                break;\n            }\n        }\n    }\n    \n    @Override\n    public void keyPressed(final KeyEvent event) {\n        switch (event.getKeyCode()) {\n            case 9:\n            case 10:\n            case 127:\n            case 155: {\n                this.fire(event.getKeyCode());\n                break;\n            }\n        }\n    }\n    \n    @Override\n    public void keyReleased(final KeyEvent arg0) {\n    }\n    \n    @Override\n    public void keyTyped(final KeyEvent event) {\n    }\n}\n"
    },
    {
        "project_name": "63_objectexplorer",
        "class": "AttributeModelComparator",
        "fqdn": "de.paragon.explorer.model",
        "source_code": "package de.paragon.explorer.model;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class AttributeModelComparator implements Comparator<AttributeModel>, Serializable\n{\n    private static final String A_AS_STRING = \"a\";\n    private static final long serialVersionUID = -8846334934584145381L;\n    \n    @Override\n    public int compare(final AttributeModel o1, final AttributeModel o2) {\n        int value = -1;\n        if (o1 != null && o2 != null) {\n            value = o1.getName().compareToIgnoreCase(o2.getName());\n            if (value < 0 && o1.getName().compareToIgnoreCase(\"a\") < 0 && o2.getName().compareToIgnoreCase(\"a\") >= 0) {\n                return 1;\n            }\n            if (value > 0 && o2.getName().compareToIgnoreCase(\"a\") < 0 && o1.getName().compareToIgnoreCase(\"a\") >= 0) {\n                return -1;\n            }\n        }\n        return value;\n    }\n}\n"
    },
    {
        "project_name": "17_inspirento",
        "class": "XmlElement",
        "fqdn": "com.allenstudio.ir.util",
        "source_code": "package com.allenstudio.ir.util;\n\nimport java.util.*;\n\npublic class XmlElement extends Observable implements Cloneable\n{\n    String name;\n    String data;\n    Hashtable<String, String> attributes;\n    List<XmlElement> subElements;\n    XmlElement parent;\n    \n    public XmlElement() {\n        this.subElements = new Vector<XmlElement>();\n        this.attributes = new Hashtable<String, String>(10);\n    }\n    \n    public XmlElement(final String name) {\n        this.name = name;\n        this.attributes = new Hashtable<String, String>(10);\n        this.subElements = new Vector<XmlElement>();\n        this.data = \"\";\n    }\n    \n    public XmlElement(final String name, final Hashtable<String, String> attributes) {\n        this.name = name;\n        this.attributes = attributes;\n        this.subElements = new Vector<XmlElement>();\n    }\n    \n    public XmlElement(final String name, final String data) {\n        this.name = name;\n        this.data = data;\n        this.subElements = new Vector<XmlElement>();\n        this.attributes = new Hashtable<String, String>(10);\n    }\n    \n    public Object addAttribute(final String name, final String value) {\n        if (value != null && name != null) {\n            final Object returnValue = this.attributes.put(name, value);\n            return returnValue;\n        }\n        return null;\n    }\n    \n    public String getAttribute(final String name) {\n        return this.attributes.get(name);\n    }\n    \n    public String getAttribute(final String name, final String defaultValue) {\n        if (this.getAttribute(name) == null) {\n            this.addAttribute(name, defaultValue);\n        }\n        return this.getAttribute(name);\n    }\n    \n    public Hashtable<String, String> getAttributes() {\n        return this.attributes;\n    }\n    \n    public void setAttributes(final Hashtable<String, String> attrs) {\n        this.attributes = attrs;\n    }\n    \n    public Enumeration getAttributeNames() {\n        return this.attributes.keys();\n    }\n    \n    public boolean addElement(final XmlElement e) {\n        e.setParent(this);\n        return this.subElements.add(e);\n    }\n    \n    public XmlElement removeElement(final XmlElement e) {\n        XmlElement child = null;\n        for (int i = 0; i < this.subElements.size(); ++i) {\n            child = this.subElements.get(i);\n            if (child == e) {\n                this.subElements.remove(i);\n            }\n        }\n        return child;\n    }\n    \n    public XmlElement removeElement(final int index) {\n        return this.subElements.remove(index);\n    }\n    \n    public void removeAllElements() {\n        this.subElements.clear();\n    }\n    \n    public void removeFromParent() {\n        if (this.parent == null) {\n            return;\n        }\n        this.parent.removeElement(this);\n        this.parent = null;\n    }\n    \n    public void append(final XmlElement e) {\n        e.removeFromParent();\n        this.addElement(e);\n    }\n    \n    public void insertElement(final XmlElement e, final int index) {\n        e.removeFromParent();\n        this.subElements.add(index, e);\n        e.setParent(this);\n    }\n    \n    public List getElements() {\n        return this.subElements;\n    }\n    \n    public int count() {\n        return this.subElements.size();\n    }\n    \n    public XmlElement getElement(String path) {\n        int i = path.indexOf(46);\n        if (i == 0) {\n            path = path.substring(1);\n            i = path.indexOf(46);\n        }\n        String topName;\n        String subName;\n        if (i > 0) {\n            topName = path.substring(0, i);\n            subName = path.substring(i + 1);\n        }\n        else {\n            topName = path;\n            subName = null;\n        }\n        int j = 0;\n        while (j < this.subElements.size()) {\n            if (this.subElements.get(j).getName().equals(topName)) {\n                if (subName != null) {\n                    return this.subElements.get(j).getElement(subName);\n                }\n                return this.subElements.get(j);\n            }\n            else {\n                ++j;\n            }\n        }\n        return null;\n    }\n    \n    public XmlElement getElement(final int index) {\n        return this.subElements.get(index);\n    }\n    \n    public XmlElement addSubElement(String path) {\n        XmlElement parent = this;\n        while (path.indexOf(46) != -1) {\n            final String name = path.substring(0, path.indexOf(46));\n            path = path.substring(path.indexOf(46) + 1);\n            if (name.length() == 0) {\n                continue;\n            }\n            if (parent.getElement(name) != null) {\n                parent = parent.getElement(name);\n            }\n            else {\n                final XmlElement child = new XmlElement(name);\n                parent.addElement(child);\n                parent = child;\n            }\n        }\n        final XmlElement child = new XmlElement(path);\n        parent.addElement(child);\n        return child;\n    }\n    \n    public XmlElement addSubElement(final XmlElement e) {\n        e.setParent(this);\n        this.subElements.add(e);\n        return e;\n    }\n    \n    public XmlElement addSubElement(final String name, final String data) {\n        final XmlElement e = new XmlElement(name);\n        e.setData(data);\n        e.setParent(this);\n        this.subElements.add(e);\n        return e;\n    }\n    \n    public void setParent(final XmlElement parent) {\n        this.parent = parent;\n    }\n    \n    public XmlElement getParent() {\n        return this.parent;\n    }\n    \n    public void setData(final String d) {\n        this.data = d;\n    }\n    \n    public String getData() {\n        return this.data;\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n    \n    public static void printNode(final XmlElement node, final String indent) {\n        final String data = node.getData();\n        if (data == null || data.equals(\"\")) {\n            System.out.println(indent + node.getName());\n        }\n        else {\n            System.out.println(indent + node.getName() + \" = '\" + data + \"'\");\n        }\n        final Enumeration enumeration = node.getAttributes().keys();\n        while (enumeration.hasMoreElements()) {\n            final String key = enumeration.nextElement();\n            final String value = node.getAttribute(key);\n            System.out.println(indent + key + \":\" + value);\n        }\n        final List subs = node.getElements();\n        final Iterator it = subs.iterator();\n        while (it.hasNext()) {\n            printNode(it.next(), indent + \"    \");\n        }\n    }\n    \n    public Object clone() {\n        try {\n            final XmlElement clone = (XmlElement)super.clone();\n            if (this.attributes != null) {\n                clone.setAttributes((Hashtable<String, String>)this.getAttributes().clone());\n            }\n            if (this.subElements != null) {\n                clone.subElements = new Vector<XmlElement>();\n                final List childs = this.getElements();\n                for (final XmlElement child : childs) {\n                    clone.addSubElement((XmlElement)child.clone());\n                }\n            }\n            return clone;\n        }\n        catch (CloneNotSupportedException cnse) {\n            throw new InternalError(\"Could not clone XmlElement: \" + cnse);\n        }\n    }\n    \n    public void setName(final String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void notifyObservers() {\n        this.setChanged();\n        super.notifyObservers();\n    }\n    \n    private boolean equals(final Object obj1, final Object obj2) {\n        boolean equal = false;\n        if (obj1 == null && obj2 == null) {\n            equal = true;\n        }\n        else if (obj1 != null && obj2 != null) {\n            equal = obj1.equals(obj2);\n        }\n        return equal;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        boolean equal = false;\n        if (obj != null && obj instanceof XmlElement) {\n            final XmlElement other = (XmlElement)obj;\n            if (this.equals(this.attributes, other.attributes) && this.equals(this.data, other.data) && this.equals(this.name, other.name) && this.equals(this.subElements, other.subElements)) {\n                equal = true;\n            }\n        }\n        return equal;\n    }\n    \n    @Override\n    public int hashCode() {\n        int hashCode = 23;\n        if (this.attributes != null) {\n            hashCode += this.attributes.hashCode() * 13;\n        }\n        if (this.data != null) {\n            hashCode += this.data.hashCode() * 17;\n        }\n        if (this.name != null) {\n            hashCode += this.name.hashCode() * 29;\n        }\n        if (this.subElements != null) {\n            hashCode += this.subElements.hashCode() * 57;\n        }\n        return hashCode;\n    }\n}\n"
    },
    {
        "project_name": "17_inspirento",
        "class": "MainMenu",
        "fqdn": "com.allenstudio.ir.ui",
        "source_code": "package com.allenstudio.ir.ui;\n\nimport com.allenstudio.ir.core.*;\nimport com.allenstudio.ir.util.*;\nimport java.util.*;\nimport javax.swing.*;\nimport java.net.*;\n\npublic class MainMenu extends JMenuBar implements InspirentoWidget\n{\n    private static final String LABEL_SUFFIX = \"Label\";\n    private static final String ICON_SUFFIX = \"Icon\";\n    private static final String SHORTCUT_SUFFIX = \"Shortcut\";\n    private InspirentoMediator mediator;\n    \n    public MainMenu(final InspirentoMediator mediator) {\n        this.mediator = null;\n        this.mediator = mediator;\n        final String[] arr$;\n        final String[] menus = arr$ = InspirentoUtilities.tokenize(UIResources.getString(\"menu\"));\n        for (final String menu : arr$) {\n            this.add(this.createMenu(menu));\n        }\n    }\n    \n    private JMenu createMenu(final String menu) {\n        JMenu jMenu = null;\n        try {\n            final String tempLabel = UIResources.getString(menu + \"Label\");\n            if (tempLabel.length() > 2 && tempLabel.charAt(tempLabel.length() - 2) == '*') {\n                jMenu = new JMenu(tempLabel.substring(0, tempLabel.length() - 2));\n                jMenu.setMnemonic(tempLabel.charAt(tempLabel.length() - 1));\n            }\n            else {\n                jMenu = new JMenu(tempLabel);\n            }\n            final String[] arr$;\n            final String[] items = arr$ = InspirentoUtilities.tokenize(UIResources.getString(menu));\n            for (final String item : arr$) {\n                if (!\"-\".equals(item)) {\n                    if (item.length() > 1 && item.charAt(item.length() - 1) == '>') {\n                        jMenu.add(this.createMenu(item.substring(0, item.length() - 1)));\n                    }\n                    else if (item.charAt(0) == '#') {\n                        final String itemLabel = UIResources.getString(item.substring(1) + \"Label\");\n                        JCheckBoxMenuItem jMenuItem = null;\n                        if (itemLabel.length() > 2 && itemLabel.charAt(itemLabel.length() - 2) == '*') {\n                            jMenuItem = new JCheckBoxMenuItem(itemLabel.substring(0, itemLabel.length() - 2));\n                            jMenuItem.setMnemonic(itemLabel.charAt(itemLabel.length() - 1));\n                        }\n                        else {\n                            jMenuItem = new JCheckBoxMenuItem(itemLabel);\n                        }\n                        this.addShortcutAndIcon(jMenuItem, item);\n                        jMenu.add(jMenuItem);\n                    }\n                    else {\n                        final String itemLabel = UIResources.getString(item + \"Label\");\n                        JMenuItem jMenuItem2 = null;\n                        if (itemLabel.length() > 2 && itemLabel.charAt(itemLabel.length() - 2) == '*') {\n                            jMenuItem2 = new JMenuItem(itemLabel.substring(0, itemLabel.length() - 2));\n                            jMenuItem2.setMnemonic(itemLabel.charAt(itemLabel.length() - 1));\n                        }\n                        else {\n                            jMenuItem2 = new JMenuItem(itemLabel);\n                        }\n                        this.addShortcutAndIcon(jMenuItem2, item);\n                        jMenu.add(jMenuItem2);\n                    }\n                }\n                else {\n                    jMenu.addSeparator();\n                }\n            }\n        }\n        catch (MissingResourceException e) {\n            System.out.println(\"Cannot load certain menu label(s).\\n\" + e);\n            System.exit(2);\n        }\n        return jMenu;\n    }\n    \n    private void addShortcutAndIcon(final JMenuItem item, final String key) {\n        try {\n            final String shortcut = UIResources.getString(key + \"Shortcut\");\n            item.setAccelerator(KeyStroke.getKeyStroke(shortcut));\n        }\n        catch (MissingResourceException ex) {}\n        try {\n            final String path = UIResources.getString(key + \"Icon\");\n            final URL url = this.getClass().getResource(path);\n            if (url != null) {\n                item.setIcon(new ImageIcon(url));\n            }\n            else {\n                System.out.println(\"Warning: icon file lost!\");\n            }\n        }\n        catch (MissingResourceException ex2) {}\n    }\n    \n    @Override\n    public void changed() {\n    }\n}\n"
    },
    {
        "project_name": "64_jtailgui",
        "class": "JTailPanel",
        "fqdn": "fr.pingtimeout.jtail.gui.view",
        "source_code": "package fr.pingtimeout.jtail.gui.view;\n\nimport fr.pingtimeout.jtail.util.*;\nimport fr.pingtimeout.jtail.gui.controller.*;\nimport java.awt.event.*;\nimport java.awt.*;\nimport java.util.*;\nimport fr.pingtimeout.jtail.gui.model.*;\nimport javax.swing.*;\nimport javax.swing.table.*;\n\npublic class JTailPanel extends JPanel implements Observer\n{\n    final JTailModel model;\n    final JScrollPane scrollPane;\n    final JScrollBar verticalScrollBar;\n    final JTable dataTable;\n    final DefaultTableModel tableModel;\n    final int characterHeight;\n    private int maxCharacterWidth;\n    \n    public JTailPanel(final JTailModel model) {\n        JTailLogger.debug(\"Building a new JTailPanel\");\n        (this.model = model).addObserver(this);\n        this.verticalScrollBar = new JScrollBar();\n        this.tableModel = new DefaultTableModel(new String[] { \"#\", \"\" }, 0) {\n            @Override\n            public boolean isCellEditable(final int row, final int col) {\n                return false;\n            }\n        };\n        this.dataTable = new JTable(this.tableModel);\n        (this.scrollPane = new JScrollPane(this.dataTable)).setVerticalScrollBarPolicy(21);\n        this.scrollPane.setHorizontalScrollBarPolicy(30);\n        this.verticalScrollBar.addAdjustmentListener(new ScrollBarAdjustmentController(this, this.model));\n        this.addComponentListener(new JTailSizeController(this, this.model));\n        this.setLayout(new BorderLayout());\n        this.add(this.scrollPane, \"Center\");\n        this.add(this.verticalScrollBar, \"East\");\n        final FontMetrics metrics = this.dataTable.getFontMetrics(this.dataTable.getFont());\n        this.characterHeight = metrics.getHeight() - 1;\n        this.maxCharacterWidth = metrics.stringWidth(\"0\") + 2;\n    }\n    \n    public int getCharacterHeight() {\n        return this.characterHeight;\n    }\n    \n    public JScrollBar getVerticalScrollBar() {\n        return this.verticalScrollBar;\n    }\n    \n    @Override\n    public void update(final Observable observable, final Object arg) {\n        if (observable == this.model) {\n            final JTailModelEvent event = (JTailModelEvent)arg;\n            JTailLogger.debug(\"JTailPanel just received a notification : \" + arg);\n            if (event.type == JTailModelEvent.Type.RESIZED) {\n                JTailLogger.debug(\"The window has beed resized\");\n                final BoundedRangeModel rangeModel = this.verticalScrollBar.getModel();\n                rangeModel.setValueIsAdjusting(true);\n                rangeModel.setMinimum(event.minLine);\n                rangeModel.setValue(event.firstLine);\n                rangeModel.setExtent(event.nbDisplayedLines);\n                rangeModel.setMaximum(event.maxLine);\n                rangeModel.setValueIsAdjusting(false);\n                if (event.minLine == event.firstLine && event.maxLine == event.nbDisplayedLines) {\n                    this.verticalScrollBar.setEnabled(false);\n                }\n                else if (!this.verticalScrollBar.isEnabled()) {\n                    this.verticalScrollBar.setEnabled(true);\n                }\n                this.updateDataTable(this.model.getLineNumbers(), this.model.getContent());\n            }\n            else if (event.type == JTailModelEvent.Type.SCROLLED) {\n                JTailLogger.debug(\"The user scrolled the file\");\n                final String lineNumbers = this.model.getLineNumbers();\n                this.updateDataTable(this.model.getLineNumbers(), this.model.getContent());\n            }\n        }\n    }\n    \n    private void updateDataTable(final String lineNumbers, final String lines) {\n        while (this.tableModel.getRowCount() > 0) {\n            this.tableModel.removeRow(0);\n        }\n        final String[] lineNumbersArray = lineNumbers.split(\"\\n\");\n        final String[] linesArray = lines.split(\"\\n\");\n        for (int i = 0; i < lineNumbersArray.length; ++i) {\n            final String lineNumberTmp = lineNumbersArray[i];\n            final String lineTmp = (i < linesArray.length) ? linesArray[i] : \"\";\n            this.tableModel.addRow(new String[] { lineNumberTmp, lineTmp });\n        }\n        this.dataTable.setAutoResizeMode(3);\n        JTailLogger.debug(\"Resizing column widths\");\n        JTailLogger.debug(\"DataTable width : {}\", this.dataTable.getWidth());\n        JTailLogger.debug(\"Highest line number : {}\", lineNumbersArray[lineNumbersArray.length - 1]);\n        final TableColumn numbersColumn = this.dataTable.getColumnModel().getColumn(0);\n        final TableColumn linesColumn = this.dataTable.getColumnModel().getColumn(1);\n        final int numbersColumnWidth = lineNumbersArray[lineNumbersArray.length - 1].length() * this.maxCharacterWidth;\n        final int linesColumnWidth = this.dataTable.getWidth() - numbersColumnWidth;\n        JTailLogger.debug(\"numbersColumnWidth : {}\", numbersColumnWidth);\n        JTailLogger.debug(\"linesColumnWidth : {}\", linesColumnWidth);\n        numbersColumn.setPreferredWidth(numbersColumnWidth);\n        linesColumn.setPreferredWidth(linesColumnWidth);\n    }\n}\n"
    },
    {
        "project_name": "64_jtailgui",
        "class": "IndexFileAction",
        "fqdn": "fr.pingtimeout.jtail.gui.action",
        "source_code": "package fr.pingtimeout.jtail.gui.action;\n\nimport java.awt.event.*;\nimport fr.pingtimeout.jtail.util.*;\nimport java.awt.*;\nimport javax.swing.*;\nimport fr.pingtimeout.jtail.gui.message.*;\nimport fr.pingtimeout.jtail.gui.controller.*;\nimport fr.pingtimeout.jtail.io.index.*;\nimport java.util.*;\nimport fr.pingtimeout.jtail.io.*;\nimport fr.pingtimeout.jtail.gui.model.*;\nimport java.io.*;\n\npublic class IndexFileAction extends JTailAbstractAction implements Observer\n{\n    private static final ResourceBundle bundle;\n    private static final ImageIcon OPEN_ICON;\n    private final JTailMainModel jTailMainModel;\n    private final OpenFileModel openFileModel;\n    \n    public IndexFileAction(final JTailMainModel jTailMainModel, final OpenFileModel openFileModel) {\n        super(IndexFileAction.bundle.getString(\"action.open.label\"), IndexFileAction.bundle.getString(\"action.open.tooltip\"), IndexFileAction.bundle.getString(\"action.open.mnemonic\"), IndexFileAction.bundle.getString(\"action.open.accelerator\"), IndexFileAction.OPEN_ICON);\n        this.jTailMainModel = jTailMainModel;\n        this.openFileModel = openFileModel;\n    }\n    \n    @Override\n    public void actionPerformed(final ActionEvent actionEvent) {\n        JTailLogger.debug(\"File : {}\", this.openFileModel.getFile());\n        JTailLogger.debug(\"Index type : {}\", this.openFileModel.getIndexType());\n        Component dialog;\n        for (dialog = (Component)actionEvent.getSource(); !(dialog instanceof JDialog); dialog = dialog.getParent()) {}\n        dialog.setVisible(false);\n        if (this.openFileModel.getFile() == null) {\n            InformationHandler.handle(true, UIMessage.INFO_NO_FILE_SELECTED, new Object[0]);\n            return;\n        }\n        Class<? extends FileIndex> indexerClass = null;\n        switch (this.openFileModel.getIndexType()) {\n            case MEMORY_BASED: {\n                indexerClass = RamFileIndex.class;\n                break;\n            }\n            case FILE_BASED: {\n                indexerClass = RomFileIndex.class;\n                break;\n            }\n        }\n        FileIndexer fileIndexer;\n        try {\n            fileIndexer = new FileIndexer(this.openFileModel.getFile(), indexerClass);\n            fileIndexer.addObserver(this);\n        }\n        catch (FileNotFoundException e) {\n            ExceptionHandler.handle(e, UIMessage.ERROR_FILE_NOT_FOUND, this.openFileModel.getFile().getName());\n            return;\n        }\n        final FileIndexerWorker fileIndexerWorker = new FileIndexerWorker(fileIndexer);\n        fileIndexerWorker.execute();\n    }\n    \n    @Override\n    public void update(final Observable o, final Object arg) {\n        JTailLogger.debug(\"Notification received : {} emitted by {}\", arg, o);\n        if ((int)arg == 100) {\n            final FileIndexer fileIndexer = (FileIndexer)o;\n            final File file = fileIndexer.getFile();\n            try {\n                final LineReader lineReader = new LineReader(file, fileIndexer.getIndex());\n                final JTailModel model = new JTailModel(file, lineReader);\n                this.jTailMainModel.add(model);\n            }\n            catch (FileNotFoundException e) {\n                ExceptionHandler.handle(e, UIMessage.ERROR_FILE_NOT_FOUND, file.getName());\n            }\n            catch (Exception e2) {\n                ExceptionHandler.handle(e2, UIMessage.ERROR_GENERIC_MESSAGE, new Object[0]);\n            }\n        }\n    }\n    \n    static {\n        bundle = ResourceBundle.getBundle(\"fr.pingtimeout.jtail.gui.language\");\n        OPEN_ICON = new ImageIcon(OpenFileAction.class.getResource(\"add16.png\"));\n    }\n}\n"
    },
    {
        "project_name": "xmlenc",
        "class": "XMLEncoder",
        "fqdn": "org.znerd.xmlenc",
        "source_code": "package org.znerd.xmlenc;\n\nimport java.io.*;\n\npublic class XMLEncoder\n{\n    private static final char[] DECLARATION_START;\n    private static final int DECLARATION_START_LENGTH;\n    private static final char[] DECLARATION_END;\n    private static final int DECLARATION_END_LENGTH;\n    private static final char[] ESC_GREATER_THAN;\n    private static final char[] ESC_LESS_THAN;\n    private static final char[] ESC_AMPERSAND;\n    private static final char[] ESC_APOSTROPHE;\n    private static final char[] ESC_QUOTE;\n    private static final char[] AMPERSAND_HASH;\n    private static final char[] EQUALS_APOSTROPHE;\n    private static final char[] EQUALS_QUOTE;\n    private final String _encoding;\n    private final char[] _encodingCharArray;\n    private final boolean _sevenBitEncoding;\n    \n    public static final XMLEncoder getEncoder(final String encoding) throws IllegalArgumentException, UnsupportedEncodingException {\n        return new XMLEncoder(encoding);\n    }\n    \n    public XMLEncoder(final String encoding) throws IllegalArgumentException, UnsupportedEncodingException {\n        if (encoding == null) {\n            throw new IllegalArgumentException(\"encoding == null\");\n        }\n        final String ucEncoding = encoding.toUpperCase();\n        if (ucEncoding.equals(\"UTF-8\") || ucEncoding.equals(\"UTF-16\")) {\n            this._sevenBitEncoding = false;\n        }\n        else {\n            if (!ucEncoding.equals(\"US-ASCII\") && !ucEncoding.equals(\"ASCII\") && !ucEncoding.startsWith(\"ISO-8859-\")) {\n                throw new UnsupportedEncodingException(encoding);\n            }\n            this._sevenBitEncoding = true;\n        }\n        this._encoding = encoding;\n        this._encodingCharArray = encoding.toCharArray();\n    }\n    \n    public String getEncoding() {\n        return this._encoding;\n    }\n    \n    public void declaration(final Writer out) throws NullPointerException, IOException {\n        out.write(XMLEncoder.DECLARATION_START, 0, XMLEncoder.DECLARATION_START_LENGTH);\n        out.write(this._encodingCharArray);\n        out.write(XMLEncoder.DECLARATION_END, 0, XMLEncoder.DECLARATION_END_LENGTH);\n    }\n    \n    public void text(final Writer out, final String text, final boolean escapeAmpersands) throws NullPointerException, InvalidXMLException, IOException {\n        this.text(out, text.toCharArray(), 0, text.length(), escapeAmpersands);\n    }\n    \n    public void text(final Writer out, final char[] ch, final int start, final int length, final boolean escapeAmpersands) throws NullPointerException, IndexOutOfBoundsException, InvalidXMLException, IOException {\n        final int end = start + length;\n        int lastEscaped = start;\n        for (int i = start; i < end; ++i) {\n            final int c = ch[i];\n            if ((c < 63 || c > 127) && (c < 39 || c > 59) && (c < 32 || c > 37) && (c != 38 || escapeAmpersands) && (c <= 127 || this._sevenBitEncoding) && c != 10 && c != 13 && c != 61) {\n                if (c != 9) {\n                    out.write(ch, lastEscaped, i - lastEscaped);\n                    if (c == 60) {\n                        out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n                    }\n                    else if (c == 62) {\n                        out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n                    }\n                    else if (c == 38) {\n                        out.write(XMLEncoder.ESC_AMPERSAND, 0, 5);\n                    }\n                    else {\n                        if (c <= 127) {\n                            throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n                        }\n                        out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n                        out.write(Integer.toString(c));\n                        out.write(59);\n                    }\n                    lastEscaped = i + 1;\n                }\n            }\n        }\n        out.write(ch, lastEscaped, end - lastEscaped);\n    }\n    \n    public void text(final Writer out, final char c) throws InvalidXMLException, IOException {\n        if ((c >= '?' && c <= '\\u007f') || (c >= '\\'' && c <= ';') || (c >= ' ' && c <= '%') || c == '&' || (c > '\\u007f' && !this._sevenBitEncoding) || c == '\\n' || c == '\\r' || c == '=' || c == '\\t') {\n            out.write(c);\n        }\n        else if (c == '<') {\n            out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n        }\n        else if (c == '>') {\n            out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n        }\n        else {\n            if (c <= '\\u007f') {\n                throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n            }\n            out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n            out.write(Integer.toString(c));\n            out.write(59);\n        }\n    }\n    \n    public void text(final Writer out, final char c, final boolean escapeAmpersands) throws InvalidXMLException, IOException {\n        if ((c >= '?' && c <= '\\u007f') || (c >= '\\'' && c <= ';') || (c >= ' ' && c <= '%') || (c == '&' && escapeAmpersands) || (c > '\\u007f' && !this._sevenBitEncoding) || c == '\\n' || c == '\\r' || c == '=' || c == '\\t') {\n            out.write(c);\n        }\n        else if (c == '<') {\n            out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n        }\n        else if (c == '>') {\n            out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n        }\n        else if (c == '&') {\n            out.write(XMLEncoder.ESC_AMPERSAND, 0, 5);\n        }\n        else {\n            if (c <= '\\u007f') {\n                throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n            }\n            out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n            out.write(Integer.toString(c));\n            out.write(59);\n        }\n    }\n    \n    public void whitespace(final Writer out, final String s) throws NullPointerException, InvalidXMLException, IOException {\n        final char[] ch = s.toCharArray();\n        final int length = ch.length;\n        this.whitespace(out, ch, 0, length);\n    }\n    \n    public void whitespace(final Writer out, final char[] ch, final int start, final int length) throws NullPointerException, IndexOutOfBoundsException, InvalidXMLException, IOException {\n        XMLChecker.checkS(ch, start, length);\n        out.write(ch, start, length);\n    }\n    \n    public void attribute(final Writer out, final String name, final String value, final char quotationMark, final boolean escapeAmpersands) throws NullPointerException, IOException {\n        final char[] ch = value.toCharArray();\n        final int length = ch.length;\n        final int start = 0;\n        final int end = start + length;\n        int lastEscaped = 0;\n        boolean useQuote;\n        if (quotationMark == '\\\"') {\n            useQuote = true;\n        }\n        else {\n            if (quotationMark != '\\'') {\n                final String error = \"Character 0x\" + Integer.toHexString(quotationMark) + \" ('\" + quotationMark + \"') is not a valid quotation mark.\";\n                throw new IllegalArgumentException(error);\n            }\n            useQuote = false;\n        }\n        out.write(32);\n        out.write(name);\n        if (useQuote) {\n            out.write(XMLEncoder.EQUALS_QUOTE, 0, 2);\n        }\n        else {\n            out.write(XMLEncoder.EQUALS_APOSTROPHE, 0, 2);\n        }\n        for (int i = start; i < end; ++i) {\n            final int c = ch[i];\n            if ((c < 63 || c > 127) && (c < 40 || c > 59) && (c < 32 || c > 37 || c == 34) && (c != 38 || escapeAmpersands) && (c <= 127 || this._sevenBitEncoding) && (useQuote || c != 34) && (!useQuote || c != 39) && c != 10 && c != 13 && c != 61) {\n                if (c != 9) {\n                    out.write(ch, lastEscaped, i - lastEscaped);\n                    if (c == 60) {\n                        out.write(XMLEncoder.ESC_LESS_THAN, 0, 4);\n                    }\n                    else if (c == 62) {\n                        out.write(XMLEncoder.ESC_GREATER_THAN, 0, 4);\n                    }\n                    else if (c == 34) {\n                        out.write(XMLEncoder.ESC_QUOTE, 0, 6);\n                    }\n                    else if (c == 39) {\n                        out.write(XMLEncoder.ESC_APOSTROPHE, 0, 6);\n                    }\n                    else if (c == 38) {\n                        out.write(XMLEncoder.ESC_AMPERSAND, 0, 5);\n                    }\n                    else {\n                        if (c <= 127) {\n                            throw new InvalidXMLException(\"The character 0x\" + Integer.toHexString(c) + \" is not valid.\");\n                        }\n                        out.write(XMLEncoder.AMPERSAND_HASH, 0, 2);\n                        out.write(Integer.toString(c));\n                        out.write(59);\n                    }\n                    lastEscaped = i + 1;\n                }\n            }\n        }\n        out.write(ch, lastEscaped, length - lastEscaped);\n        out.write(quotationMark);\n    }\n    \n    static {\n        DECLARATION_START = \"<?xml version=\\\"1.0\\\" encoding=\\\"\".toCharArray();\n        DECLARATION_START_LENGTH = XMLEncoder.DECLARATION_START.length;\n        DECLARATION_END = \"\\\"?>\".toCharArray();\n        DECLARATION_END_LENGTH = XMLEncoder.DECLARATION_END.length;\n        ESC_GREATER_THAN = new char[] { '&', 'g', 't', ';' };\n        ESC_LESS_THAN = new char[] { '&', 'l', 't', ';' };\n        ESC_AMPERSAND = new char[] { '&', 'a', 'm', 'p', ';' };\n        ESC_APOSTROPHE = new char[] { '&', 'a', 'p', 'o', 's', ';' };\n        ESC_QUOTE = new char[] { '&', 'q', 'u', 'o', 't', ';' };\n        AMPERSAND_HASH = new char[] { '&', '#' };\n        EQUALS_APOSTROPHE = new char[] { '=', '\\'' };\n        EQUALS_QUOTE = new char[] { '=', '\\\"' };\n    }\n}\n"
    },
    {
        "project_name": "79_twfbplayer",
        "class": "SimpleSector",
        "fqdn": "de.outstare.fortbattleplayer.model.impl",
        "source_code": "package de.outstare.fortbattleplayer.model.impl;\n\nimport java.util.*;\nimport de.outstare.fortbattleplayer.model.*;\n\npublic class SimpleSector implements Sector\n{\n    private final int height;\n    private final boolean defenderSpawn;\n    private final boolean attackerSpawn;\n    private final int attackBonus;\n    private final int defendBonus;\n    private final boolean flag;\n    private final int classBonus;\n    private final CharacterClass classType;\n    private CombatantSide occupier;\n    private int occupierCount;\n    private final Set<Area> areas;\n    private final Set<SectorObserver> observers;\n    \n    public SimpleSector(final int height, final boolean defenderSpawn, final boolean attackerSpawn, final int attackerBonus, final int defenderBonus, final boolean flag, final int classBonus, final CharacterClass bonusClass) {\n        this.occupier = null;\n        this.occupierCount = 0;\n        this.areas = new HashSet<Area>();\n        this.observers = new HashSet<SectorObserver>();\n        this.height = height;\n        this.defenderSpawn = defenderSpawn;\n        this.attackerSpawn = attackerSpawn;\n        this.attackBonus = attackerBonus;\n        this.defendBonus = defenderBonus;\n        this.flag = flag;\n        this.classBonus = classBonus;\n        this.classType = bonusClass;\n    }\n    \n    @Override\n    public void free() {\n        if (this.occupierCount > 0) {\n            --this.occupierCount;\n        }\n        assert this.occupierCount >= 0 : \"more combatants lefts this sector than enter it\";\n        if (this.occupierCount == 0) {\n            this.occupier = null;\n            this.occupierChanged();\n        }\n    }\n    \n    private void occupierChanged() {\n        for (final SectorObserver observer : this.observers) {\n            observer.occupierChanged();\n        }\n    }\n    \n    @Override\n    public void gainControl(final CombatantSide side) {\n        ++this.occupierCount;\n        if (this.occupier != side) {\n            this.occupier = side;\n            this.occupierChanged();\n        }\n    }\n    \n    @Override\n    public CombatantSide getOccupier() {\n        return this.occupier;\n    }\n    \n    @Override\n    public boolean isOccupied() {\n        return this.occupier != null;\n    }\n    \n    @Override\n    public int getHeight() {\n        return this.height;\n    }\n    \n    public boolean isDefenderSpawn() {\n        return this.defenderSpawn;\n    }\n    \n    public boolean isAttackerSpawn() {\n        return this.attackerSpawn;\n    }\n    \n    public boolean isFlag() {\n        return this.flag;\n    }\n    \n    @Override\n    public SectorBonus getBonus(final CharacterClass charClass) {\n        return new SectorBonus(this.getAttackBonus(charClass), this.getDefenseBonus(charClass), this.getDamageBonus());\n    }\n    \n    protected int getDamageBonus() {\n        return this.getBonusFromWeapons(SectorBonus.BonusType.DAMAGE);\n    }\n    \n    private int getBonusFromWeapons(final SectorBonus.BonusType type) {\n        int bonus = 0;\n        for (final Area area : this.areas) {\n            if (area.isOccupied()) {\n                final Combatant combatant = area.getOccupier();\n                final Weapon weapon = combatant.getWeapon();\n                final int sectorBonus = weapon.getSectorBonus(type);\n                if (sectorBonus != 0) {\n                    bonus = sectorBonus;\n                    break;\n                }\n                continue;\n            }\n        }\n        return bonus;\n    }\n    \n    protected int getAttackBonus(final CharacterClass charClass) {\n        int bonus = this.attackBonus + this.classBonus(charClass);\n        bonus += this.getBonusFromWeapons(SectorBonus.BonusType.ATTACK);\n        return bonus;\n    }\n    \n    protected int getDefenseBonus(final CharacterClass charClass) {\n        int bonus = this.defendBonus + this.classBonus(charClass);\n        bonus += this.getBonusFromWeapons(SectorBonus.BonusType.DEFENSE);\n        return bonus;\n    }\n    \n    protected int classBonus(final CharacterClass charClass) {\n        if (this.classType != charClass) {\n            return 0;\n        }\n        return this.classBonus;\n    }\n    \n    @Override\n    public Set<Area> getAreas() {\n        return this.areas;\n    }\n    \n    @Override\n    public void _addArea(final Area area) {\n        this.areas.add(area);\n    }\n    \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = 31 * result + ((this.areas == null) ? 0 : this.areas.hashCode());\n        result = 31 * result + this.attackBonus;\n        result = 31 * result + (this.attackerSpawn ? 1231 : 1237);\n        result = 31 * result + this.classBonus;\n        result = 31 * result + ((this.classType == null) ? 0 : this.classType.hashCode());\n        result = 31 * result + this.defendBonus;\n        result = 31 * result + (this.defenderSpawn ? 1231 : 1237);\n        result = 31 * result + (this.flag ? 1231 : 1237);\n        result = 31 * result + this.height;\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof SimpleSector)) {\n            return false;\n        }\n        final SimpleSector other = (SimpleSector)obj;\n        if (this.areas == null) {\n            if (other.areas != null) {\n                return false;\n            }\n        }\n        else if (!this.areas.equals(other.areas)) {\n            return false;\n        }\n        return this.attackBonus == other.attackBonus && this.attackerSpawn == other.attackerSpawn && this.classBonus == other.classBonus && this.classType == other.classType && this.defendBonus == other.defendBonus && this.defenderSpawn == other.defenderSpawn && this.flag == other.flag && this.height == other.height;\n    }\n    \n    @Override\n    public void addObserver(final SectorObserver observer) {\n        this.observers.add(observer);\n    }\n    \n    @Override\n    public void removeObserver(final SectorObserver observer) {\n        this.observers.remove(observer);\n    }\n}\n"
    },
    {
        "project_name": "36_schemaspy",
        "class": "TableMeta",
        "fqdn": "net.sourceforge.schemaspy.model.xml",
        "source_code": "package net.sourceforge.schemaspy.model.xml;\n\nimport java.util.logging.*;\nimport java.util.*;\nimport org.w3c.dom.*;\n\npublic class TableMeta\n{\n    private final String name;\n    private final String comments;\n    private final List<TableColumnMeta> columns;\n    private final String remoteCatalog;\n    private final String remoteSchema;\n    private static final Logger logger;\n    \n    TableMeta(final Node tableNode) {\n        this.columns = new ArrayList<TableColumnMeta>();\n        final NamedNodeMap attribs = tableNode.getAttributes();\n        this.name = attribs.getNamedItem(\"name\").getNodeValue();\n        Node node = attribs.getNamedItem(\"comments\");\n        if (node == null) {\n            node = attribs.getNamedItem(\"remarks\");\n        }\n        if (node != null) {\n            final String tmp = node.getNodeValue().trim();\n            this.comments = ((tmp.length() == 0) ? null : tmp);\n        }\n        else {\n            this.comments = null;\n        }\n        node = attribs.getNamedItem(\"remoteSchema\");\n        this.remoteSchema = ((node == null) ? null : node.getNodeValue().trim());\n        node = attribs.getNamedItem(\"remoteCatalog\");\n        this.remoteCatalog = ((node == null) ? null : node.getNodeValue().trim());\n        TableMeta.logger.fine(\"Found XML table metadata for \" + this.name + \" remoteCatalog: \" + this.remoteCatalog + \" remoteSchema: \" + this.remoteSchema + \" comments: \" + this.comments);\n        final NodeList columnNodes = ((Element)tableNode.getChildNodes()).getElementsByTagName(\"column\");\n        for (int i = 0; i < columnNodes.getLength(); ++i) {\n            final Node colNode = columnNodes.item(i);\n            this.columns.add(new TableColumnMeta(colNode));\n        }\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n    \n    public String getComments() {\n        return this.comments;\n    }\n    \n    public List<TableColumnMeta> getColumns() {\n        return this.columns;\n    }\n    \n    public String getRemoteCatalog() {\n        return this.remoteCatalog;\n    }\n    \n    public String getRemoteSchema() {\n        return this.remoteSchema;\n    }\n    \n    static {\n        logger = Logger.getLogger(TableMeta.class.getName());\n    }\n}\n"
    },
    {
        "project_name": "73_fim1",
        "class": "UpdateUserPanel",
        "fqdn": "osa.ora.server.admin.ui",
        "source_code": "package osa.ora.server.admin.ui;\n\nimport osa.ora.server.admin.*;\nimport osa.ora.server.beans.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nimport java.util.*;\n\npublic class UpdateUserPanel extends JPanel\n{\n    AdminApp adminApp;\n    ControlPanel controlPanel;\n    private JButton jButton1;\n    private JButton jButton2;\n    private JButton jButton3;\n    private JButton jButton4;\n    private JCheckBox jCheckBox1;\n    private JCheckBox jCheckBox2;\n    private JCheckBox jCheckBox3;\n    private JComboBox jComboBox1;\n    private JComboBox jComboBox2;\n    private JLabel jLabel1;\n    private JLabel jLabel2;\n    private JLabel jLabel3;\n    private JLabel jLabel4;\n    private JLabel jLabel5;\n    private JLabel jLabel6;\n    private JTextField jTextField1;\n    private JTextField jTextField2;\n    private JTextField jTextField3;\n    private JTextField jTextField4;\n    \n    public UpdateUserPanel(final AdminApp adminApp, final ControlPanel controlPanel) {\n        this.adminApp = adminApp;\n        this.controlPanel = controlPanel;\n        this.initComponents();\n    }\n    \n    public void updateModel() {\n        this.jComboBox1.setModel(new DefaultComboBoxModel<Group>(this.adminApp.getGroups()));\n        this.reset();\n        if (this.adminApp.getGroups() != null && this.adminApp.getGroups().size() > 0) {\n            this.jComboBox2.setModel(new DefaultComboBoxModel<User>(this.adminApp.getGroups().get(0).getUsers()));\n            if (this.adminApp.getGroups().get(0).getUsers() != null && this.adminApp.getGroups().get(0).getUsers().size() > 0) {\n                final User user = this.adminApp.getGroups().get(0).getUsers().get(0);\n                this.fillUser(user);\n            }\n            else {\n                this.reset();\n            }\n        }\n        else {\n            this.jComboBox2.setModel(new DefaultComboBoxModel<Group>(this.adminApp.getGroups()));\n        }\n    }\n    \n    private void initComponents() {\n        this.jLabel1 = new JLabel();\n        this.jLabel2 = new JLabel();\n        this.jLabel3 = new JLabel();\n        this.jCheckBox1 = new JCheckBox();\n        this.jCheckBox2 = new JCheckBox();\n        this.jCheckBox3 = new JCheckBox();\n        this.jLabel4 = new JLabel();\n        this.jComboBox1 = new JComboBox();\n        this.jTextField2 = new JTextField();\n        this.jTextField3 = new JTextField();\n        this.jButton1 = new JButton();\n        this.jButton2 = new JButton();\n        this.jComboBox2 = new JComboBox();\n        this.jButton3 = new JButton();\n        this.jButton4 = new JButton();\n        this.jLabel5 = new JLabel();\n        this.jTextField1 = new JTextField();\n        this.jTextField4 = new JTextField();\n        this.jLabel6 = new JLabel();\n        this.setLayout(null);\n        this.jLabel1.setText(\"Username:\");\n        this.add(this.jLabel1);\n        this.jLabel1.setBounds(10, 50, 90, 14);\n        this.jLabel2.setText(\"Login Email:\");\n        this.add(this.jLabel2);\n        this.jLabel2.setBounds(10, 140, 100, 14);\n        this.jLabel3.setText(\"Phone:\");\n        this.add(this.jLabel3);\n        this.jLabel3.setBounds(10, 170, 110, 14);\n        this.jCheckBox1.setText(\"Show User Status To Others\");\n        this.add(this.jCheckBox1);\n        this.jCheckBox1.setBounds(30, 200, 260, 23);\n        this.jCheckBox2.setText(\"User Can Only Start Chat With Others\");\n        this.add(this.jCheckBox2);\n        this.jCheckBox2.setBounds(30, 220, 250, 23);\n        this.jCheckBox3.setText(\"Can be a Member of Chat Rooms\");\n        this.add(this.jCheckBox3);\n        this.jCheckBox3.setBounds(30, 240, 260, 23);\n        this.jLabel4.setText(\"User Group:\");\n        this.add(this.jLabel4);\n        this.jLabel4.setBounds(10, 20, 90, 14);\n        this.jComboBox1.setModel(new DefaultComboBoxModel<String>(new String[] { \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\" }));\n        this.jComboBox1.addItemListener(new ItemListener() {\n            @Override\n            public void itemStateChanged(final ItemEvent evt) {\n                UpdateUserPanel.this.jComboBox1ItemStateChanged(evt);\n            }\n        });\n        this.add(this.jComboBox1);\n        this.jComboBox1.setBounds(90, 20, 170, 20);\n        this.add(this.jTextField2);\n        this.jTextField2.setBounds(90, 140, 170, 20);\n        this.add(this.jTextField3);\n        this.jTextField3.setBounds(90, 170, 170, 20);\n        this.jButton1.setIcon(new ImageIcon(this.getClass().getResource(\"/images/close.jpg\")));\n        this.jButton1.setText(\"Cancel\");\n        this.jButton1.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton1ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton1);\n        this.jButton1.setBounds(80, 350, 100, 30);\n        this.jButton2.setIcon(new ImageIcon(this.getClass().getResource(\"/images/trash.png\")));\n        this.jButton2.setText(\"Delete\");\n        this.jButton2.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton2ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton2);\n        this.jButton2.setBounds(30, 310, 100, 30);\n        this.jComboBox2.setModel(new DefaultComboBoxModel<String>(new String[] { \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\" }));\n        this.jComboBox2.addItemListener(new ItemListener() {\n            @Override\n            public void itemStateChanged(final ItemEvent evt) {\n                UpdateUserPanel.this.jComboBox2ItemStateChanged(evt);\n            }\n        });\n        this.add(this.jComboBox2);\n        this.jComboBox2.setBounds(90, 50, 170, 20);\n        this.jButton3.setIcon(new ImageIcon(this.getClass().getResource(\"/images/login.gif\")));\n        this.jButton3.setText(\"Reset Password\");\n        this.jButton3.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton3ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton3);\n        this.jButton3.setBounds(30, 270, 210, 30);\n        this.jButton4.setIcon(new ImageIcon(this.getClass().getResource(\"/images/online.png\")));\n        this.jButton4.setText(\"Update\");\n        this.jButton4.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent evt) {\n                UpdateUserPanel.this.jButton4ActionPerformed(evt);\n            }\n        });\n        this.add(this.jButton4);\n        this.jButton4.setBounds(140, 310, 100, 30);\n        this.jLabel5.setText(\"Title:\");\n        this.add(this.jLabel5);\n        this.jLabel5.setBounds(10, 110, 80, 14);\n        this.add(this.jTextField1);\n        this.jTextField1.setBounds(90, 80, 170, 20);\n        this.add(this.jTextField4);\n        this.jTextField4.setBounds(90, 110, 170, 20);\n        this.jLabel6.setText(\"Username:\");\n        this.add(this.jLabel6);\n        this.jLabel6.setBounds(10, 80, 80, 14);\n    }\n    \n    private void jButton1ActionPerformed(final ActionEvent evt) {\n        this.controlPanel.getParentDialog().setVisible(false);\n        this.reset();\n    }\n    \n    private void jButton2ActionPerformed(final ActionEvent evt) {\n        final Group group = (Group)this.jComboBox1.getSelectedItem();\n        User user = (User)this.jComboBox2.getSelectedItem();\n        final int index = this.jComboBox2.getSelectedIndex();\n        if (user == null || index == -1) {\n            JOptionPane.showMessageDialog(this, \"Can't identify selected User!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        try {\n            user = this.adminApp.delUser(user);\n            if (user != null) {\n                group.getUsers().remove(index);\n                this.reset();\n                if (this.jComboBox2.getModel().getSize() > 0) {\n                    this.jComboBox2.setSelectedIndex(0);\n                    this.jComboBox2.validate();\n                }\n                else {\n                    this.jComboBox1.setSelectedIndex(0);\n                    this.jComboBox1.validate();\n                    this.jComboBox1ItemStateChanged(null);\n                }\n                JOptionPane.showMessageDialog(this, \"User Deleted Successfully!\");\n            }\n            else {\n                JOptionPane.showMessageDialog(this, \"Server Error!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            }\n        }\n        catch (Exception ex) {\n            System.out.println(\"Error \" + ex);\n            JOptionPane.showMessageDialog(this, \"Error Happen \" + ex.getMessage(), \"Error\", 0, this.adminApp.getErrorIcon());\n        }\n    }\n    \n    private void jButton3ActionPerformed(final ActionEvent evt) {\n        User user = (User)this.jComboBox2.getSelectedItem();\n        if (user == null) {\n            JOptionPane.showMessageDialog(this, \"Can't identify selected User!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        try {\n            user = this.adminApp.resetUserPass(user);\n            if (user != null) {\n                JOptionPane.showMessageDialog(this, \"User Password Reset Successfully!\");\n            }\n            else {\n                JOptionPane.showMessageDialog(this, \"Server Error!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            }\n        }\n        catch (Exception ex) {\n            System.out.println(\"Error \" + ex);\n            JOptionPane.showMessageDialog(this, \"Error Happen \" + ex.getMessage(), \"Error\", 0, this.adminApp.getErrorIcon());\n        }\n    }\n    \n    private void jButton4ActionPerformed(final ActionEvent evt) {\n        final Group group = (Group)this.jComboBox1.getSelectedItem();\n        User user = (User)this.jComboBox2.getSelectedItem();\n        final int index = this.jComboBox2.getSelectedIndex();\n        if (user == null) {\n            JOptionPane.showMessageDialog(this, \"Can't identify selected User!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        if (this.jTextField1.getText() == null || this.jTextField1.getText().equals(\"\")) {\n            JOptionPane.showMessageDialog(this, \"Please Enter User Name\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        if (this.jTextField2.getText() == null || this.jTextField2.getText().equals(\"\")) {\n            JOptionPane.showMessageDialog(this, \"Please Enter User email\", \"Error\", 0, this.adminApp.getErrorIcon());\n            return;\n        }\n        for (int i = 0; i < this.adminApp.getGroups().size(); ++i) {\n            final Vector<User> tempUsers = this.adminApp.getGroups().get(i).getUsers();\n            for (int n = 0; n < tempUsers.size(); ++n) {\n                if (user.getId() != tempUsers.get(n).getId() && this.jTextField2.getText().equals(tempUsers.get(n).getEmail())) {\n                    JOptionPane.showMessageDialog(this, \"User with Same email Already Exist!\", \"Error\", 0, this.adminApp.getErrorIcon());\n                    return;\n                }\n            }\n        }\n        try {\n            user.setName(this.jTextField1.getText());\n            user.setEmail(this.jTextField2.getText());\n            user.setDirectPhone(this.jTextField3.getText());\n            if (this.jTextField3.getText() == null || \"\".equals(this.jTextField3.getText())) {\n                user.setDirectPhone(\"N/A\");\n            }\n            else {\n                user.setDirectPhone(this.jTextField3.getText());\n            }\n            if (this.jTextField4.getText() == null || \"\".equals(this.jTextField4.getText())) {\n                user.setJobTitle(\"N/A\");\n            }\n            else {\n                user.setJobTitle(this.jTextField4.getText());\n            }\n            user.setShowMyStatus(this.jCheckBox1.isSelected());\n            user.setOnlyStartChat(this.jCheckBox2.isSelected());\n            user.setCanJoinChatRoom(this.jCheckBox3.isSelected());\n            user = this.adminApp.updateUser(user);\n            if (user != null) {\n                group.getUsers().set(index, user);\n                if (this.jComboBox2.getModel().getSize() > 0) {\n                    this.jComboBox2.setSelectedIndex(0);\n                }\n                this.jComboBox2.validate();\n                JOptionPane.showMessageDialog(this, \"User Updated Successfully!\");\n            }\n            else {\n                JOptionPane.showMessageDialog(this, \"Server Error!\", \"Error\", 0, this.adminApp.getErrorIcon());\n            }\n        }\n        catch (Exception ex) {\n            System.out.println(\"Error \" + ex);\n            JOptionPane.showMessageDialog(this, \"Error Happen \" + ex.getMessage(), \"Error\", 0, this.adminApp.getErrorIcon());\n        }\n    }\n    \n    private void jComboBox1ItemStateChanged(final ItemEvent evt) {\n        final Group group = (Group)this.jComboBox1.getSelectedItem();\n        this.jComboBox2.setModel(new DefaultComboBoxModel<User>(group.getUsers()));\n        if (group.getUsers() != null && group.getUsers().size() > 0) {\n            final User user = group.getUsers().get(0);\n            this.fillUser(user);\n        }\n        else {\n            this.reset();\n        }\n    }\n    \n    private void reset() {\n        this.jTextField1.setText(\"\");\n        this.jTextField2.setText(\"\");\n        this.jTextField3.setText(\"\");\n        this.jTextField4.setText(\"\");\n        this.jCheckBox1.setSelected(false);\n        this.jCheckBox2.setSelected(false);\n        this.jCheckBox3.setSelected(false);\n    }\n    \n    private void fillUser(final User user) {\n        this.jTextField1.setText(user.getName());\n        this.jTextField2.setText(user.getEmail());\n        this.jTextField3.setText(user.getDirectPhone());\n        this.jTextField4.setText(user.getJobTitle());\n        this.jCheckBox1.setSelected(user.isShowMyStatus());\n        this.jCheckBox2.setSelected(user.isOnlyStartChat());\n        this.jCheckBox3.setSelected(user.isCanJoinChatRoom());\n    }\n    \n    private void jComboBox2ItemStateChanged(final ItemEvent evt) {\n        final User user = (User)this.jComboBox2.getSelectedItem();\n        if (user != null) {\n            this.fillUser(user);\n        }\n        else {\n            this.reset();\n        }\n    }\n}\n"
    },
    {
        "project_name": "73_fim1",
        "class": "FontChooserDialog",
        "fqdn": "osa.ora.server.client.ui.utils",
        "source_code": "package osa.ora.server.client.ui.utils;\n\nimport javax.swing.*;\nimport java.io.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\nclass FontChooserDialog extends JDialog\n{\n    private Font initialFont;\n    private JFontChooser chooserPane;\n    \n    public FontChooserDialog(final Component c, final String title, final boolean modal, final JFontChooser chooserPane, final ActionListener okListener, final ActionListener cancelListener) {\n        super(JOptionPane.getFrameForComponent(c), title, modal);\n        final String okString = UIManager.getString(\"ColorChooser.okText\");\n        final String cancelString = UIManager.getString(\"ColorChooser.cancelText\");\n        final String resetString = UIManager.getString(\"ColorChooser.resetText\");\n        final JPanel buttonPane = new JPanel();\n        buttonPane.setLayout(new FlowLayout(1));\n        final JButton okButton = new JButton(okString);\n        this.getRootPane().setDefaultButton(okButton);\n        okButton.setActionCommand(\"OK\");\n        if (okListener != null) {\n            okButton.addActionListener(okListener);\n        }\n        okButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                FontChooserDialog.this.setVisible(false);\n            }\n        });\n        buttonPane.add(okButton);\n        final JButton cancelButton = new JButton(cancelString);\n        final Action cancelKeyAction = new AbstractAction() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n            }\n        };\n        final KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke('\\u001b');\n        final InputMap inputMap = cancelButton.getInputMap(2);\n        final ActionMap actionMap = cancelButton.getActionMap();\n        if (inputMap != null && actionMap != null) {\n            inputMap.put(cancelKeyStroke, \"cancel\");\n            actionMap.put(\"cancel\", cancelKeyAction);\n        }\n        cancelButton.setActionCommand(\"cancel\");\n        if (cancelListener != null) {\n            cancelButton.addActionListener(cancelListener);\n        }\n        cancelButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                FontChooserDialog.this.setVisible(false);\n            }\n        });\n        buttonPane.add(cancelButton);\n        final JButton resetButton = new JButton(resetString);\n        resetButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(final ActionEvent e) {\n                FontChooserDialog.this.reset();\n            }\n        });\n        final int mnemonic = UIManager.getInt(\"ColorChooser.resetMnemonic\");\n        if (mnemonic != -1) {\n            resetButton.setMnemonic(mnemonic);\n        }\n        buttonPane.add(resetButton);\n        this.chooserPane = chooserPane;\n        final Container contentPane = this.getContentPane();\n        contentPane.setLayout(new BorderLayout());\n        contentPane.add(chooserPane, \"Center\");\n        contentPane.add(buttonPane, \"South\");\n        this.pack();\n        this.setLocationRelativeTo(c);\n    }\n    \n    @Override\n    public void setVisible(final boolean visible) {\n        if (visible) {\n            this.initialFont = this.chooserPane.getFont();\n        }\n        super.setVisible(visible);\n    }\n    \n    public void reset() {\n        this.chooserPane.setFont(this.initialFont);\n    }\n    \n    static class Closer extends WindowAdapter implements Serializable\n    {\n        @Override\n        public void windowClosing(final WindowEvent e) {\n            final Window w = e.getWindow();\n            w.setVisible(false);\n        }\n    }\n    \n    static class DisposeOnClose extends ComponentAdapter implements Serializable\n    {\n        @Override\n        public void componentHidden(final ComponentEvent e) {\n            final Window w = (Window)e.getComponent();\n            w.dispose();\n        }\n    }\n}\n"
    },
    {
        "project_name": "41_follow",
        "class": "SearchableTextPane",
        "fqdn": "ghm.follow.search",
        "source_code": "package ghm.follow.search;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport javax.swing.plaf.*;\nimport java.util.logging.*;\nimport java.util.*;\nimport javax.swing.text.*;\n\npublic class SearchableTextPane extends JTextArea\n{\n    private Logger log;\n    private int lastSearchPos;\n    private String lastSearchTerm;\n    private final DefaultHighlighter.DefaultHighlightPainter wordPainter;\n    \n    public SearchableTextPane(final Font font, final int tabSize) {\n        this.log = Logger.getLogger(SearchableTextPane.class.getName());\n        this.lastSearchPos = -1;\n        this.wordPainter = new DefaultHighlighter.DefaultHighlightPainter(Color.YELLOW);\n        this.setFont(font);\n        this.setTabSize(tabSize);\n    }\n    \n    @Override\n    public boolean getScrollableTracksViewportWidth() {\n        final Component parent = this.getParent();\n        final ComponentUI ui = this.getUI();\n        return parent == null || ui.getPreferredSize(this).width <= parent.getSize().width;\n    }\n    \n    public List<LineResult> highlight(final String term, final int flags) {\n        List<LineResult> lineResults = new ArrayList<LineResult>();\n        this.removeHighlights();\n        if (term != null && term.length() > 0) {\n            try {\n                final Document doc = this.getDocument();\n                final String text = doc.getText(0, doc.getLength());\n                final List<WordResult> searchResults = new SearchEngine(flags).search(term, text);\n                lineResults = this.convertWords2Lines(searchResults);\n                for (final LineResult lineResult : lineResults) {\n                    final List<WordResult> wordResults = lineResult.getWordResults();\n                    for (final WordResult wordResult : wordResults) {\n                        final int wordStart = wordResult.start;\n                        final int wordEnd = wordResult.end;\n                        this.addHighlight(wordStart, wordEnd - wordStart);\n                        Thread.yield();\n                    }\n                }\n            }\n            catch (BadLocationException e) {\n                this.log.log(Level.SEVERE, \"BadLocationException in SearchableTextPane\", e);\n                lineResults = new ArrayList<LineResult>();\n            }\n        }\n        return lineResults;\n    }\n    \n    private void addHighlight(final int start, final int length) throws BadLocationException {\n        this.getHighlighter().addHighlight(start, start + length, this.wordPainter);\n    }\n    \n    public void removeHighlights() {\n        this.getHighlighter().removeAllHighlights();\n    }\n    \n    public int search(final String term) {\n        if (term != null && term.length() > 0) {\n            if (term.equals(this.lastSearchTerm)) {\n                int pos = 0;\n                if (this.lastSearchPos != -1) {\n                    pos = this.lastSearchPos + this.lastSearchTerm.length();\n                }\n                this.lastSearchPos = this.search(this.lastSearchTerm, pos);\n            }\n            else {\n                this.lastSearchPos = this.search(term, 0);\n            }\n        }\n        if (this.lastSearchPos == -1) {\n            this.lastSearchTerm = null;\n        }\n        else {\n            this.lastSearchTerm = term;\n        }\n        return this.lastSearchPos;\n    }\n    \n    public int search(final String term, final int startPos) {\n        int pos = 0;\n        try {\n            final Document doc = this.getDocument();\n            final String text = doc.getText(0, doc.getLength());\n            pos = text.indexOf(term, startPos);\n        }\n        catch (BadLocationException e) {\n            this.log.log(Level.WARNING, \"BadLocationException in SearchableTextPane\", e);\n            pos = -1;\n        }\n        return pos;\n    }\n    \n    private List<LineResult> convertWords2Lines(final List<WordResult> words) throws BadLocationException {\n        final ArrayList<LineResult> lines = new ArrayList<LineResult>();\n        LineResult tempLine = null;\n        int lastLine = -1;\n        for (final WordResult word : words) {\n            final int line = this.getLineOfOffset(word.start);\n            if (line != lastLine) {\n                if (tempLine != null) {\n                    lines.add(tempLine);\n                }\n                final Element elem = Utilities.getParagraphElement(this, word.start);\n                final int lineStart = elem.getStartOffset();\n                final int lineEnd = elem.getEndOffset();\n                tempLine = new LineResult(line, lineStart, lineEnd);\n            }\n            this.updateWordResult(word, tempLine);\n            lastLine = line;\n            Thread.yield();\n        }\n        if (tempLine != null) {\n            lines.add(tempLine);\n        }\n        return lines;\n    }\n    \n    private void updateWordResult(final WordResult wordResult, final LineResult lineResult) throws BadLocationException {\n        lineResult.addWord(wordResult);\n        final int line = this.getLineOfOffset(wordResult.start);\n        wordResult.parent.lineNumber = line + 1;\n        final int lineOffset = this.getLineStartOffset(line);\n        wordResult.setLineOffset(lineOffset);\n    }\n}\n"
    },
    {
        "project_name": "41_follow",
        "class": "TabbedPane",
        "fqdn": "ghm.follow.gui",
        "source_code": "package ghm.follow.gui;\n\nimport javax.swing.*;\nimport ghm.follow.config.*;\nimport java.awt.*;\nimport java.io.*;\n\npublic class TabbedPane extends JTabbedPane\n{\n    private FollowAppAttributes attributes;\n    \n    public TabbedPane(final FollowAppAttributes attributes) {\n        super(attributes.getTabPlacement());\n        this.attributes = null;\n        this.attributes = attributes;\n    }\n    \n    @Override\n    public Component findComponentAt(final int x, final int y) {\n        if (!this.contains(x, y)) {\n            return null;\n        }\n        for (int ncomponents = this.getComponentCount(), i = 0; i < ncomponents; ++i) {\n            Component comp = this.getComponentAt(i);\n            if (comp != null) {\n                if (comp instanceof Container) {\n                    if (comp.isVisible()) {\n                        comp = ((Container)comp).findComponentAt(x - comp.getX(), y - comp.getY());\n                    }\n                }\n                else {\n                    comp = comp.getComponentAt(x - comp.getX(), y - comp.getY());\n                }\n                if (comp != null && comp.isVisible()) {\n                    return comp;\n                }\n            }\n        }\n        return this;\n    }\n    \n    @Override\n    public void setSelectedIndex(final int index) {\n        super.setSelectedIndex(index);\n        this.handleSelectedFile();\n    }\n    \n    public void setSelectedComponent(final FileFollowingPane pane) {\n        super.setSelectedComponent(pane);\n        this.handleSelectedFile();\n    }\n    \n    @Override\n    public void removeTabAt(final int index) {\n        super.removeTabAt(index);\n        this.handleSelectedFile();\n    }\n    \n    private void handleSelectedFile() {\n        final FileFollowingPane pane = (FileFollowingPane)this.getSelectedComponent();\n        if (pane != null) {\n            final File parent = pane.getFollowedFile().getParentFile();\n            this.attributes.setLastFileChooserDirectory(parent);\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "NumericEntityUnescaper",
        "fqdn": "org.apache.commons.lang3.text.translate",
        "source_code": "package org.apache.commons.lang3.text.translate;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class NumericEntityUnescaper extends CharSequenceTranslator\n{\n    private final EnumSet<OPTION> options;\n    \n    public NumericEntityUnescaper(final OPTION... options) {\n        if (options.length > 0) {\n            this.options = EnumSet.copyOf(Arrays.asList(options));\n        }\n        else {\n            this.options = EnumSet.copyOf(Arrays.asList(OPTION.semiColonRequired));\n        }\n    }\n    \n    public boolean isSet(final OPTION option) {\n        return this.options != null && this.options.contains(option);\n    }\n    \n    @Override\n    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n        final int seqEnd = input.length();\n        if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n            final char firstChar = input.charAt(start);\n            if (firstChar == 'x' || firstChar == 'X') {\n                ++start;\n                isHex = true;\n                if (start == seqEnd) {\n                    return 0;\n                }\n            }\n            int end;\n            for (end = start; end < seqEnd && ((input.charAt(end) >= '0' && input.charAt(end) <= '9') || (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') || (input.charAt(end) >= 'A' && input.charAt(end) <= 'F')); ++end) {}\n            final boolean semiNext = end != seqEnd && input.charAt(end) == ';';\n            if (!semiNext) {\n                if (this.isSet(OPTION.semiColonRequired)) {\n                    return 0;\n                }\n                if (this.isSet(OPTION.errorIfNoSemiColon)) {\n                    throw new IllegalArgumentException(\"Semi-colon required at end of numeric entity\");\n                }\n            }\n            int entityValue;\n            try {\n                if (isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                }\n                else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            }\n            catch (NumberFormatException nfe) {\n                return 0;\n            }\n            if (entityValue > 65535) {\n                final char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            }\n            else {\n                out.write(entityValue);\n            }\n            return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n        }\n        return 0;\n    }\n    \n    public enum OPTION\n    {\n        semiColonRequired, \n        semiColonOptional, \n        errorIfNoSemiColon;\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "LocaleUtils",
        "fqdn": "org.apache.commons.lang3",
        "source_code": "package org.apache.commons.lang3;\n\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class LocaleUtils\n{\n    private static final ConcurrentMap<String, List<Locale>> cLanguagesByCountry;\n    private static final ConcurrentMap<String, List<Locale>> cCountriesByLanguage;\n    \n    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return new Locale(\"\", \"\");\n        }\n        if (str.contains(\"#\")) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n        if (ch0 != '_') {\n            final String[] split = str.split(\"_\", -1);\n            final int occurrences = split.length - 1;\n            switch (occurrences) {\n                case 0: {\n                    if (StringUtils.isAllLowerCase(str) && (len == 2 || len == 3)) {\n                        return new Locale(str);\n                    }\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                case 1: {\n                    if (StringUtils.isAllLowerCase(split[0]) && (split[0].length() == 2 || split[0].length() == 3) && split[1].length() == 2 && StringUtils.isAllUpperCase(split[1])) {\n                        return new Locale(split[0], split[1]);\n                    }\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                case 2: {\n                    if (StringUtils.isAllLowerCase(split[0]) && (split[0].length() == 2 || split[0].length() == 3) && (split[1].length() == 0 || (split[1].length() == 2 && StringUtils.isAllUpperCase(split[1]))) && split[2].length() > 0) {\n                        return new Locale(split[0], split[1], split[2]);\n                    }\n                    break;\n                }\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len < 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch2 = str.charAt(1);\n        final char ch3 = str.charAt(2);\n        if (!Character.isUpperCase(ch2) || !Character.isUpperCase(ch3)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len < 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    \n    public static List<Locale> localeLookupList(final Locale locale) {\n        return localeLookupList(locale, locale);\n    }\n    \n    public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) {\n        final List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList((List<? extends Locale>)list);\n    }\n    \n    public static List<Locale> availableLocaleList() {\n        return SyncAvoid.AVAILABLE_LOCALE_LIST;\n    }\n    \n    public static Set<Locale> availableLocaleSet() {\n        return SyncAvoid.AVAILABLE_LOCALE_SET;\n    }\n    \n    public static boolean isAvailableLocale(final Locale locale) {\n        return availableLocaleList().contains(locale);\n    }\n    \n    public static List<Locale> languagesByCountry(final String countryCode) {\n        if (countryCode == null) {\n            return Collections.emptyList();\n        }\n        List<Locale> langs = LocaleUtils.cLanguagesByCountry.get(countryCode);\n        if (langs == null) {\n            langs = new ArrayList<Locale>();\n            final List<Locale> locales = availableLocaleList();\n            for (int i = 0; i < locales.size(); ++i) {\n                final Locale locale = locales.get(i);\n                if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) {\n                    langs.add(locale);\n                }\n            }\n            langs = Collections.unmodifiableList((List<? extends Locale>)langs);\n            LocaleUtils.cLanguagesByCountry.putIfAbsent(countryCode, langs);\n            langs = LocaleUtils.cLanguagesByCountry.get(countryCode);\n        }\n        return langs;\n    }\n    \n    public static List<Locale> countriesByLanguage(final String languageCode) {\n        if (languageCode == null) {\n            return Collections.emptyList();\n        }\n        List<Locale> countries = LocaleUtils.cCountriesByLanguage.get(languageCode);\n        if (countries == null) {\n            countries = new ArrayList<Locale>();\n            final List<Locale> locales = availableLocaleList();\n            for (int i = 0; i < locales.size(); ++i) {\n                final Locale locale = locales.get(i);\n                if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) {\n                    countries.add(locale);\n                }\n            }\n            countries = Collections.unmodifiableList((List<? extends Locale>)countries);\n            LocaleUtils.cCountriesByLanguage.putIfAbsent(languageCode, countries);\n            countries = LocaleUtils.cCountriesByLanguage.get(languageCode);\n        }\n        return countries;\n    }\n    \n    static {\n        cLanguagesByCountry = new ConcurrentHashMap<String, List<Locale>>();\n        cCountriesByLanguage = new ConcurrentHashMap<String, List<Locale>>();\n    }\n    \n    static class SyncAvoid\n    {\n        private static final List<Locale> AVAILABLE_LOCALE_LIST;\n        private static final Set<Locale> AVAILABLE_LOCALE_SET;\n        \n        static {\n            final List<Locale> list = new ArrayList<Locale>(Arrays.asList(Locale.getAvailableLocales()));\n            AVAILABLE_LOCALE_LIST = Collections.unmodifiableList((List<? extends Locale>)list);\n            AVAILABLE_LOCALE_SET = Collections.unmodifiableSet((Set<? extends Locale>)new HashSet<Locale>(list));\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "BooleanUtils",
        "fqdn": "org.apache.commons.lang3",
        "source_code": "package org.apache.commons.lang3;\n\nimport org.apache.commons.lang3.math.*;\n\npublic class BooleanUtils\n{\n    public static Boolean negate(final Boolean bool) {\n        if (bool == null) {\n            return null;\n        }\n        return ((boolean)bool) ? Boolean.FALSE : Boolean.TRUE;\n    }\n    \n    public static boolean isTrue(final Boolean bool) {\n        return Boolean.TRUE.equals(bool);\n    }\n    \n    public static boolean isNotTrue(final Boolean bool) {\n        return !isTrue(bool);\n    }\n    \n    public static boolean isFalse(final Boolean bool) {\n        return Boolean.FALSE.equals(bool);\n    }\n    \n    public static boolean isNotFalse(final Boolean bool) {\n        return !isFalse(bool);\n    }\n    \n    public static boolean toBoolean(final Boolean bool) {\n        return bool != null && bool;\n    }\n    \n    public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) {\n        if (bool == null) {\n            return valueIfNull;\n        }\n        return bool;\n    }\n    \n    public static boolean toBoolean(final int value) {\n        return value != 0;\n    }\n    \n    public static Boolean toBooleanObject(final int value) {\n        return (value == 0) ? Boolean.FALSE : Boolean.TRUE;\n    }\n    \n    public static Boolean toBooleanObject(final Integer value) {\n        if (value == null) {\n            return null;\n        }\n        return (value == 0) ? Boolean.FALSE : Boolean.TRUE;\n    }\n    \n    public static boolean toBoolean(final int value, final int trueValue, final int falseValue) {\n        if (value == trueValue) {\n            return true;\n        }\n        if (value == falseValue) {\n            return false;\n        }\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n    \n    public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return true;\n            }\n            if (falseValue == null) {\n                return false;\n            }\n        }\n        else {\n            if (value.equals(trueValue)) {\n                return true;\n            }\n            if (value.equals(falseValue)) {\n                return false;\n            }\n        }\n        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n    }\n    \n    public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) {\n        if (value == trueValue) {\n            return Boolean.TRUE;\n        }\n        if (value == falseValue) {\n            return Boolean.FALSE;\n        }\n        if (value == nullValue) {\n            return null;\n        }\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n    \n    public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n        if (value == null) {\n            if (trueValue == null) {\n                return Boolean.TRUE;\n            }\n            if (falseValue == null) {\n                return Boolean.FALSE;\n            }\n            if (nullValue == null) {\n                return null;\n            }\n        }\n        else {\n            if (value.equals(trueValue)) {\n                return Boolean.TRUE;\n            }\n            if (value.equals(falseValue)) {\n                return Boolean.FALSE;\n            }\n            if (value.equals(nullValue)) {\n                return null;\n            }\n        }\n        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n    }\n    \n    public static int toInteger(final boolean bool) {\n        return bool ? 1 : 0;\n    }\n    \n    public static Integer toIntegerObject(final boolean bool) {\n        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n    }\n    \n    public static Integer toIntegerObject(final Boolean bool) {\n        if (bool == null) {\n            return null;\n        }\n        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n    }\n    \n    public static int toInteger(final boolean bool, final int trueValue, final int falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static Integer toIntegerObject(final boolean bool, final Integer trueValue, final Integer falseValue) {\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n        if (bool == null) {\n            return nullValue;\n        }\n        return bool ? trueValue : falseValue;\n    }\n    \n    public static Boolean toBooleanObject(final String str) {\n        if (str == \"true\") {\n            return Boolean.TRUE;\n        }\n        if (str == null) {\n            return null;\n        }\n        switch (str.length()) {\n            case 1: {\n                final char ch0 = str.charAt(0);\n                if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') {\n                    return Boolean.TRUE;\n                }\n                if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n            case 2: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                if ((ch0 == 'o' || ch0 == 'O') && (ch2 == 'n' || ch2 == 'N')) {\n                    return Boolean.TRUE;\n                }\n                if ((ch0 == 'n' || ch0 == 'N') && (ch2 == 'o' || ch2 == 'O')) {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n            case 3: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                final char ch3 = str.charAt(2);\n                if ((ch0 == 'y' || ch0 == 'Y') && (ch2 == 'e' || ch2 == 'E') && (ch3 == 's' || ch3 == 'S')) {\n                    return Boolean.TRUE;\n                }\n                if ((ch0 == 'o' || ch0 == 'O') && (ch2 == 'f' || ch2 == 'F') && (ch3 == 'f' || ch3 == 'F')) {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n            case 4: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                final char ch3 = str.charAt(2);\n                final char ch4 = str.charAt(3);\n                if ((ch0 == 't' || ch0 == 'T') && (ch2 == 'r' || ch2 == 'R') && (ch3 == 'u' || ch3 == 'U') && (ch4 == 'e' || ch4 == 'E')) {\n                    return Boolean.TRUE;\n                }\n                break;\n            }\n            case 5: {\n                final char ch0 = str.charAt(0);\n                final char ch2 = str.charAt(1);\n                final char ch3 = str.charAt(2);\n                final char ch4 = str.charAt(3);\n                final char ch5 = str.charAt(4);\n                if ((ch0 == 'f' || ch0 == 'F') && (ch2 == 'a' || ch2 == 'A') && (ch3 == 'l' || ch3 == 'L') && (ch4 == 's' || ch4 == 'S') && (ch5 == 'e' || ch5 == 'E')) {\n                    return Boolean.FALSE;\n                }\n                break;\n            }\n        }\n        return null;\n    }\n    \n    public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {\n        if (str == null) {\n            if (trueString == null) {\n                return Boolean.TRUE;\n            }\n            if (falseString == null) {\n                return Boolean.FALSE;\n            }\n            if (nullString == null) {\n                return null;\n            }\n        }\n        else {\n            if (str.equals(trueString)) {\n                return Boolean.TRUE;\n            }\n            if (str.equals(falseString)) {\n                return Boolean.FALSE;\n            }\n            if (str.equals(nullString)) {\n                return null;\n            }\n        }\n        throw new IllegalArgumentException(\"The String did not match any specified value\");\n    }\n    \n    public static boolean toBoolean(final String str) {\n        return toBooleanObject(str) == Boolean.TRUE;\n    }\n    \n    public static boolean toBoolean(final String str, final String trueString, final String falseString) {\n        if (str == trueString) {\n            return true;\n        }\n        if (str == falseString) {\n            return false;\n        }\n        if (str != null) {\n            if (str.equals(trueString)) {\n                return true;\n            }\n            if (str.equals(falseString)) {\n                return false;\n            }\n        }\n        throw new IllegalArgumentException(\"The String did not match either specified value\");\n    }\n    \n    public static String toStringTrueFalse(final Boolean bool) {\n        return toString(bool, \"true\", \"false\", null);\n    }\n    \n    public static String toStringOnOff(final Boolean bool) {\n        return toString(bool, \"on\", \"off\", null);\n    }\n    \n    public static String toStringYesNo(final Boolean bool) {\n        return toString(bool, \"yes\", \"no\", null);\n    }\n    \n    public static String toString(final Boolean bool, final String trueString, final String falseString, final String nullString) {\n        if (bool == null) {\n            return nullString;\n        }\n        return bool ? trueString : falseString;\n    }\n    \n    public static String toStringTrueFalse(final boolean bool) {\n        return toString(bool, \"true\", \"false\");\n    }\n    \n    public static String toStringOnOff(final boolean bool) {\n        return toString(bool, \"on\", \"off\");\n    }\n    \n    public static String toStringYesNo(final boolean bool) {\n        return toString(bool, \"yes\", \"no\");\n    }\n    \n    public static String toString(final boolean bool, final String trueString, final String falseString) {\n        return bool ? trueString : falseString;\n    }\n    \n    public static boolean and(final boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (!element) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static Boolean and(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return and(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n    \n    public static boolean or(final boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final boolean element : array) {\n            if (element) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public static Boolean or(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n    \n    public static boolean xor(final boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        boolean result = false;\n        for (final boolean element : array) {\n            result ^= element;\n        }\n        return result;\n    }\n    \n    public static Boolean xor(final Boolean... array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n\n    @Test\n    public void testToBoolean() {\n        assertTrue(BooleanUtils.toBoolean(1, 1, 0));\n        assertFalse(BooleanUtils.toBoolean(0, 1, 0));\n        try {\n            BooleanUtils.toBoolean(2, 1, 0);\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match either specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToBooleanWithInteger() {\n        assertTrue(BooleanUtils.toBoolean(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0)));\n        assertFalse(BooleanUtils.toBoolean(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0)));\n        try {\n            BooleanUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(0));\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match either specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToBooleanObject() {\n        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(1, 1, 0, -1));\n        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(0, 1, 0, -1));\n        assertNull(BooleanUtils.toBooleanObject(-1, 1, 0, -1));\n        try {\n            BooleanUtils.toBooleanObject(2, 1, 0, -1);\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match any specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToBooleanObjectWithInteger() {\n        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0), null));\n        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0), null));\n        assertNull(BooleanUtils.toBooleanObject(null, Integer.valueOf(1), Integer.valueOf(0), null));\n        try {\n            BooleanUtils.toBooleanObject(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(0), null);\n            fail(\"Expected IllegalArgumentException to be thrown\");\n        } catch (IllegalArgumentException ex) {\n            assertEquals(\"The Integer did not match any specified value\", ex.getMessage());\n        }\n    }\n    \n    @Test\n    public void testToInteger() {\n        assertEquals(1, BooleanUtils.toInteger(true));\n        assertEquals(0, BooleanUtils.toInteger(false));\n    }\n    \n    @Test\n    public void testToIntegerObjectWithBoolean() {\n        assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(true));\n        assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(false));\n    }\n    \n    @Test\n    public void testToIntegerObjectWithNullableBoolean() {\n        assertEquals(Integer.valueOf(1), BooleanUtils.toIntegerObject(Boolean.TRUE));\n        assertEquals(Integer.valueOf(0), BooleanUtils.toIntegerObject(Boolean.FALSE));\n        assertNull(BooleanUtils.toIntegerObject(null));\n    }\n    \n    @Test\n    public void testToIntegerWithValue() {\n        assertEquals(1, BooleanUtils.toInteger(true, 1, 0));\n        assertEquals(0, BooleanUtils.toInteger(false, 1, 0));\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "Validate",
        "fqdn": "org.apache.commons.lang3",
        "source_code": "package org.apache.commons.lang3;\n\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class Validate\n{\n    private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE = \"The value %s is not in the specified exclusive range of %s to %s\";\n    private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE = \"The value %s is not in the specified inclusive range of %s to %s\";\n    private static final String DEFAULT_MATCHES_PATTERN_EX = \"The string %s does not match the pattern %s\";\n    private static final String DEFAULT_IS_NULL_EX_MESSAGE = \"The validated object is null\";\n    private static final String DEFAULT_IS_TRUE_EX_MESSAGE = \"The validated expression is false\";\n    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE = \"The validated array contains null element at index: %d\";\n    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE = \"The validated collection contains null element at index: %d\";\n    private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = \"The validated character sequence is blank\";\n    private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = \"The validated array is empty\";\n    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE = \"The validated character sequence is empty\";\n    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = \"The validated collection is empty\";\n    private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = \"The validated map is empty\";\n    private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = \"The validated array index is invalid: %d\";\n    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE = \"The validated character sequence index is invalid: %d\";\n    private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE = \"The validated collection index is invalid: %d\";\n    private static final String DEFAULT_VALID_STATE_EX_MESSAGE = \"The validated state is false\";\n    private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = \"Cannot assign a %s to a %s\";\n    private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = \"Expected type: %s, actual: %s\";\n    \n    public static void isTrue(final boolean expression, final String message, final long value) {\n        if (!expression) {\n            throw new IllegalArgumentException(String.format(message, value));\n        }\n    }\n    \n    public static void isTrue(final boolean expression, final String message, final double value) {\n        if (!expression) {\n            throw new IllegalArgumentException(String.format(message, value));\n        }\n    }\n    \n    public static void isTrue(final boolean expression, final String message, final Object... values) {\n        if (!expression) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void isTrue(final boolean expression) {\n        if (!expression) {\n            throw new IllegalArgumentException(\"The validated expression is false\");\n        }\n    }\n    \n    public static <T> T notNull(final T object) {\n        return notNull(object, \"The validated object is null\", new Object[0]);\n    }\n    \n    public static <T> T notNull(final T object, final String message, final Object... values) {\n        if (object == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        return object;\n    }\n    \n    public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) {\n        if (array == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return array;\n    }\n    \n    public static <T> T[] notEmpty(final T[] array) {\n        return notEmpty(array, \"The validated array is empty\", new Object[0]);\n    }\n    \n    public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) {\n        if (collection == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (collection.isEmpty()) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return collection;\n    }\n    \n    public static <T extends Collection<?>> T notEmpty(final T collection) {\n        return notEmpty(collection, \"The validated collection is empty\", new Object[0]);\n    }\n    \n    public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) {\n        if (map == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (map.isEmpty()) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return map;\n    }\n    \n    public static <T extends Map<?, ?>> T notEmpty(final T map) {\n        return notEmpty(map, \"The validated map is empty\", new Object[0]);\n    }\n    \n    public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) {\n        if (chars == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (chars.length() == 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return chars;\n    }\n    \n    public static <T extends CharSequence> T notEmpty(final T chars) {\n        return notEmpty(chars, \"The validated character sequence is empty\", new Object[0]);\n    }\n    \n    public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) {\n        if (chars == null) {\n            throw new NullPointerException(String.format(message, values));\n        }\n        if (StringUtils.isBlank(chars)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n        return chars;\n    }\n    \n    public static <T extends CharSequence> T notBlank(final T chars) {\n        return notBlank(chars, \"The validated character sequence is blank\", new Object[0]);\n    }\n    \n    public static <T> T[] noNullElements(final T[] array, final String message, final Object... values) {\n        notNull(array);\n        for (int i = 0; i < array.length; ++i) {\n            if (array[i] == null) {\n                final Object[] values2 = ArrayUtils.add(values, i);\n                throw new IllegalArgumentException(String.format(message, values2));\n            }\n        }\n        return array;\n    }\n    \n    public static <T> T[] noNullElements(final T[] array) {\n        return noNullElements(array, \"The validated array contains null element at index: %d\", new Object[0]);\n    }\n    \n    public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) {\n        notNull(iterable);\n        int i = 0;\n        final Iterator<?> it = iterable.iterator();\n        while (it.hasNext()) {\n            if (it.next() == null) {\n                final Object[] values2 = ArrayUtils.addAll(values, i);\n                throw new IllegalArgumentException(String.format(message, values2));\n            }\n            ++i;\n        }\n        return iterable;\n    }\n    \n    public static <T extends Iterable<?>> T noNullElements(final T iterable) {\n        return noNullElements(iterable, \"The validated collection contains null element at index: %d\", new Object[0]);\n    }\n    \n    public static <T> T[] validIndex(final T[] array, final int index, final String message, final Object... values) {\n        notNull(array);\n        if (index < 0 || index >= array.length) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return array;\n    }\n    \n    public static <T> T[] validIndex(final T[] array, final int index) {\n        return validIndex(array, index, \"The validated array index is invalid: %d\", new Object[] { index });\n    }\n    \n    public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) {\n        notNull(collection);\n        if (index < 0 || index >= collection.size()) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return collection;\n    }\n    \n    public static <T extends Collection<?>> T validIndex(final T collection, final int index) {\n        return validIndex(collection, index, \"The validated collection index is invalid: %d\", new Object[] { index });\n    }\n    \n    public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) {\n        notNull(chars);\n        if (index < 0 || index >= chars.length()) {\n            throw new IndexOutOfBoundsException(String.format(message, values));\n        }\n        return chars;\n    }\n    \n    public static <T extends CharSequence> T validIndex(final T chars, final int index) {\n        return validIndex(chars, index, \"The validated character sequence index is invalid: %d\", new Object[] { index });\n    }\n    \n    public static void validState(final boolean expression) {\n        if (!expression) {\n            throw new IllegalStateException(\"The validated state is false\");\n        }\n    }\n    \n    public static void validState(final boolean expression, final String message, final Object... values) {\n        if (!expression) {\n            throw new IllegalStateException(String.format(message, values));\n        }\n    }\n    \n    public static void matchesPattern(final CharSequence input, final String pattern) {\n        if (!Pattern.matches(pattern, input)) {\n            throw new IllegalArgumentException(String.format(\"The string %s does not match the pattern %s\", input, pattern));\n        }\n    }\n    \n    public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {\n        if (!Pattern.matches(pattern, input)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) {\n        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void inclusiveBetween(final long start, final long end, final long value) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void inclusiveBetween(final long start, final long end, final long value, final String message) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static void inclusiveBetween(final double start, final double end, final double value) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified inclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void inclusiveBetween(final double start, final double end, final double value, final String message) {\n        if (value < start || value > end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) {\n        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void exclusiveBetween(final long start, final long end, final long value) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void exclusiveBetween(final long start, final long end, final long value, final String message) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static void exclusiveBetween(final double start, final double end, final double value) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(\"The value %s is not in the specified exclusive range of %s to %s\", value, start, end));\n        }\n    }\n    \n    public static void exclusiveBetween(final double start, final double end, final double value, final String message) {\n        if (value <= start || value >= end) {\n            throw new IllegalArgumentException(String.format(message, new Object[0]));\n        }\n    }\n    \n    public static void isInstanceOf(final Class<?> type, final Object obj) {\n        if (!type.isInstance(obj)) {\n            throw new IllegalArgumentException(String.format(\"Expected type: %s, actual: %s\", type.getName(), (obj == null) ? \"null\" : obj.getClass().getName()));\n        }\n    }\n    \n    public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {\n        if (!type.isInstance(obj)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n    \n    public static void isAssignableFrom(final Class<?> superType, final Class<?> type) {\n        if (!superType.isAssignableFrom(type)) {\n            throw new IllegalArgumentException(String.format(\"Cannot assign a %s to a %s\", (type == null) ? \"null\" : type.getName(), superType.getName()));\n        }\n    }\n    \n    public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {\n        if (!superType.isAssignableFrom(type)) {\n            throw new IllegalArgumentException(String.format(message, values));\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "HashCodeBuilder",
        "fqdn": "org.apache.commons.lang3.builder",
        "source_code": "package org.apache.commons.lang3.builder;\n\nimport org.apache.commons.lang3.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class HashCodeBuilder implements Builder<Integer>\n{\n    private static final ThreadLocal<Set<IDKey>> REGISTRY;\n    private final int iConstant;\n    private int iTotal;\n    \n    static Set<IDKey> getRegistry() {\n        return HashCodeBuilder.REGISTRY.get();\n    }\n    \n    static boolean isRegistered(final Object value) {\n        final Set<IDKey> registry = getRegistry();\n        return registry != null && registry.contains(new IDKey(value));\n    }\n    \n    private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients, final String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            final Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (final Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName()) && field.getName().indexOf(36) == -1 && (useTransients || !Modifier.isTransient(field.getModifiers())) && !Modifier.isStatic(field.getModifiers())) {\n                    try {\n                        final Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    }\n                    catch (IllegalAccessException e) {\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        }\n        finally {\n            unregister(object);\n        }\n    }\n    \n    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, new String[0]);\n    }\n    \n    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object, final boolean testTransients) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null, new String[0]);\n    }\n    \n    public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) {\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }\n    \n    public static int reflectionHashCode(final Object object, final boolean testTransients) {\n        return reflectionHashCode(17, 37, object, testTransients, null, new String[0]);\n    }\n    \n    public static int reflectionHashCode(final Object object, final Collection<String> excludeFields) {\n        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n    \n    public static int reflectionHashCode(final Object object, final String... excludeFields) {\n        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n    }\n    \n    static void register(final Object value) {\n        synchronized (HashCodeBuilder.class) {\n            if (getRegistry() == null) {\n                HashCodeBuilder.REGISTRY.set(new HashSet<IDKey>());\n            }\n        }\n        getRegistry().add(new IDKey(value));\n    }\n    \n    static void unregister(final Object value) {\n        Set<IDKey> registry = getRegistry();\n        if (registry != null) {\n            registry.remove(new IDKey(value));\n            synchronized (HashCodeBuilder.class) {\n                registry = getRegistry();\n                if (registry != null && registry.isEmpty()) {\n                    HashCodeBuilder.REGISTRY.remove();\n                }\n            }\n        }\n    }\n    \n    public HashCodeBuilder() {\n        this.iTotal = 0;\n        this.iConstant = 37;\n        this.iTotal = 17;\n    }\n    \n    public HashCodeBuilder(final int initialOddNumber, final int multiplierOddNumber) {\n        this.iTotal = 0;\n        if (initialOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n        }\n        if (multiplierOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n        }\n        this.iConstant = multiplierOddNumber;\n        this.iTotal = initialOddNumber;\n    }\n    \n    public HashCodeBuilder append(final boolean value) {\n        this.iTotal = this.iTotal * this.iConstant + (value ? 0 : 1);\n        return this;\n    }\n    \n    public HashCodeBuilder append(final boolean[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final boolean element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final byte value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final byte[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final byte element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final char value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final char[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final char element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final double value) {\n        return this.append(Double.doubleToLongBits(value));\n    }\n    \n    public HashCodeBuilder append(final double[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final double element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final float value) {\n        this.iTotal = this.iTotal * this.iConstant + Float.floatToIntBits(value);\n        return this;\n    }\n    \n    public HashCodeBuilder append(final float[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final float element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final int value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final int[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final int element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final long value) {\n        this.iTotal = this.iTotal * this.iConstant + (int)(value ^ value >> 32);\n        return this;\n    }\n    \n    public HashCodeBuilder append(final long[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final long element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final Object object) {\n        if (object == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else if (object.getClass().isArray()) {\n            if (object instanceof long[]) {\n                this.append((long[])object);\n            }\n            else if (object instanceof int[]) {\n                this.append((int[])object);\n            }\n            else if (object instanceof short[]) {\n                this.append((short[])object);\n            }\n            else if (object instanceof char[]) {\n                this.append((char[])object);\n            }\n            else if (object instanceof byte[]) {\n                this.append((byte[])object);\n            }\n            else if (object instanceof double[]) {\n                this.append((double[])object);\n            }\n            else if (object instanceof float[]) {\n                this.append((float[])object);\n            }\n            else if (object instanceof boolean[]) {\n                this.append((boolean[])object);\n            }\n            else {\n                this.append((Object[])object);\n            }\n        }\n        else {\n            this.iTotal = this.iTotal * this.iConstant + object.hashCode();\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final Object[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final Object element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder append(final short value) {\n        this.iTotal = this.iTotal * this.iConstant + value;\n        return this;\n    }\n    \n    public HashCodeBuilder append(final short[] array) {\n        if (array == null) {\n            this.iTotal *= this.iConstant;\n        }\n        else {\n            for (final short element : array) {\n                this.append(element);\n            }\n        }\n        return this;\n    }\n    \n    public HashCodeBuilder appendSuper(final int superHashCode) {\n        this.iTotal = this.iTotal * this.iConstant + superHashCode;\n        return this;\n    }\n    \n    public int toHashCode() {\n        return this.iTotal;\n    }\n    \n    @Override\n    public Integer build() {\n        return this.toHashCode();\n    }\n    \n    @Override\n    public int hashCode() {\n        return this.toHashCode();\n    }\n    \n    static {\n        REGISTRY = new ThreadLocal<Set<IDKey>>();\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "CompareToBuilder",
        "fqdn": "org.apache.commons.lang3.builder",
        "source_code": "package org.apache.commons.lang3.builder;\n\nimport org.apache.commons.lang3.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class CompareToBuilder implements Builder<Integer>\n{\n    private int comparison;\n    \n    public CompareToBuilder() {\n        this.comparison = 0;\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs) {\n        return reflectionCompare(lhs, rhs, false, null, new String[0]);\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) {\n        return reflectionCompare(lhs, rhs, compareTransients, null, new String[0]);\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields) {\n        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields) {\n        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n    }\n    \n    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) {\n        if (lhs == rhs) {\n            return 0;\n        }\n        if (lhs == null || rhs == null) {\n            throw new NullPointerException();\n        }\n        Class<?> lhsClazz = lhs.getClass();\n        if (!lhsClazz.isInstance(rhs)) {\n            throw new ClassCastException();\n        }\n        final CompareToBuilder compareToBuilder = new CompareToBuilder();\n        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n            lhsClazz = lhsClazz.getSuperclass();\n            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        }\n        return compareToBuilder.toComparison();\n    }\n    \n    private static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields) {\n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; ++i) {\n            final Field f = fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) && f.getName().indexOf(36) == -1 && (useTransients || !Modifier.isTransient(f.getModifiers())) && !Modifier.isStatic(f.getModifiers())) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                }\n                catch (IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }\n    \n    public CompareToBuilder appendSuper(final int superCompareTo) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = superCompareTo;\n        return this;\n    }\n    \n    public CompareToBuilder append(final Object lhs, final Object rhs) {\n        return this.append(lhs, rhs, null);\n    }\n    \n    public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.getClass().isArray()) {\n            if (lhs instanceof long[]) {\n                this.append((long[])lhs, (long[])rhs);\n            }\n            else if (lhs instanceof int[]) {\n                this.append((int[])lhs, (int[])rhs);\n            }\n            else if (lhs instanceof short[]) {\n                this.append((short[])lhs, (short[])rhs);\n            }\n            else if (lhs instanceof char[]) {\n                this.append((char[])lhs, (char[])rhs);\n            }\n            else if (lhs instanceof byte[]) {\n                this.append((byte[])lhs, (byte[])rhs);\n            }\n            else if (lhs instanceof double[]) {\n                this.append((double[])lhs, (double[])rhs);\n            }\n            else if (lhs instanceof float[]) {\n                this.append((float[])lhs, (float[])rhs);\n            }\n            else if (lhs instanceof boolean[]) {\n                this.append((boolean[])lhs, (boolean[])rhs);\n            }\n            else {\n                this.append((Object[])lhs, (Object[])rhs, comparator);\n            }\n        }\n        else if (comparator == null) {\n            final Comparable<Object> comparable = (Comparable<Object>)lhs;\n            this.comparison = comparable.compareTo(rhs);\n        }\n        else {\n            this.comparison = comparator.compare(lhs, rhs);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final long lhs, final long rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final int lhs, final int rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final short lhs, final short rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final char lhs, final char rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final byte lhs, final byte rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n        return this;\n    }\n    \n    public CompareToBuilder append(final double lhs, final double rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = Double.compare(lhs, rhs);\n        return this;\n    }\n    \n    public CompareToBuilder append(final float lhs, final float rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        this.comparison = Float.compare(lhs, rhs);\n        return this;\n    }\n    \n    public CompareToBuilder append(final boolean lhs, final boolean rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (!lhs) {\n            this.comparison = -1;\n        }\n        else {\n            this.comparison = 1;\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs) {\n        return this.append(lhs, rhs, null);\n    }\n    \n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i], comparator);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final long[] lhs, final long[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final int[] lhs, final int[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final short[] lhs, final short[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final char[] lhs, final char[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final double[] lhs, final double[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final float[] lhs, final float[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n        if (this.comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            this.comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            this.comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.comparison = ((lhs.length < rhs.length) ? -1 : 1);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && this.comparison == 0; ++i) {\n            this.append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n    \n    public int toComparison() {\n        return this.comparison;\n    }\n    \n    @Override\n    public Integer build() {\n        return this.toComparison();\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "ExtendedMessageFormat",
        "fqdn": "org.apache.commons.lang3.text",
        "source_code": "package org.apache.commons.lang3.text;\n\nimport java.text.*;\nimport java.util.*;\nimport org.apache.commons.lang3.*;\nimport java.io.*;\n\npublic class ExtendedMessageFormat extends MessageFormat\n{\n    private static final long serialVersionUID = -2362048321261811743L;\n    private static final int HASH_SEED = 31;\n    private static final String DUMMY_PATTERN = \"\";\n    private static final String ESCAPED_QUOTE = \"''\";\n    private static final char START_FMT = ',';\n    private static final char END_FE = '}';\n    private static final char START_FE = '{';\n    private static final char QUOTE = '\\'';\n    private String toPattern;\n    private final Map<String, ? extends FormatFactory> registry;\n    \n    public ExtendedMessageFormat(final String pattern) {\n        this(pattern, Locale.getDefault());\n    }\n    \n    public ExtendedMessageFormat(final String pattern, final Locale locale) {\n        this(pattern, locale, null);\n    }\n    \n    public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) {\n        this(pattern, Locale.getDefault(), registry);\n    }\n    \n    public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry) {\n        super(\"\");\n        this.setLocale(locale);\n        this.registry = registry;\n        this.applyPattern(pattern);\n    }\n    \n    @Override\n    public String toPattern() {\n        return this.toPattern;\n    }\n    \n    @Override\n    public final void applyPattern(final String pattern) {\n        if (this.registry == null) {\n            super.applyPattern(pattern);\n            this.toPattern = super.toPattern();\n            return;\n        }\n        final ArrayList<Format> foundFormats = new ArrayList<Format>();\n        final ArrayList<String> foundDescriptions = new ArrayList<String>();\n        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n        final ParsePosition pos = new ParsePosition(0);\n        final char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n                case '\\'': {\n                    this.appendQuotedString(pattern, pos, stripCustom, true);\n                    continue;\n                }\n                case '{': {\n                    ++fmtCount;\n                    this.seekNonWs(pattern, pos);\n                    final int start = pos.getIndex();\n                    final int index = this.readArgumentIndex(pattern, this.next(pos));\n                    stripCustom.append('{').append(index);\n                    this.seekNonWs(pattern, pos);\n                    Format format = null;\n                    String formatDescription = null;\n                    if (c[pos.getIndex()] == ',') {\n                        formatDescription = this.parseFormatDescription(pattern, this.next(pos));\n                        format = this.getFormat(formatDescription);\n                        if (format == null) {\n                            stripCustom.append(',').append(formatDescription);\n                        }\n                    }\n                    foundFormats.add(format);\n                    foundDescriptions.add((format == null) ? null : formatDescription);\n                    Validate.isTrue(foundFormats.size() == fmtCount);\n                    Validate.isTrue(foundDescriptions.size() == fmtCount);\n                    if (c[pos.getIndex()] != '}') {\n                        throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n                    }\n                    break;\n                }\n            }\n            stripCustom.append(c[pos.getIndex()]);\n            this.next(pos);\n        }\n        super.applyPattern(stripCustom.toString());\n        this.toPattern = this.insertFormats(super.toPattern(), foundDescriptions);\n        if (this.containsElements(foundFormats)) {\n            final Format[] origFormats = this.getFormats();\n            int i = 0;\n            for (final Format f : foundFormats) {\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n                ++i;\n            }\n            super.setFormats(origFormats);\n        }\n    }\n    \n    @Override\n    public void setFormat(final int formatElementIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void setFormats(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (ObjectUtils.notEqual(this.getClass(), obj.getClass())) {\n            return false;\n        }\n        final ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n        return !ObjectUtils.notEqual(this.toPattern, rhs.toPattern) && !ObjectUtils.notEqual(this.registry, rhs.registry);\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + ObjectUtils.hashCode(this.registry);\n        result = 31 * result + ObjectUtils.hashCode(this.toPattern);\n        return result;\n    }\n    \n    private Format getFormat(final String desc) {\n        if (this.registry != null) {\n            String name = desc;\n            String args = null;\n            final int i = desc.indexOf(44);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            final FormatFactory factory = (FormatFactory)this.registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, this.getLocale());\n            }\n        }\n        return null;\n    }\n    \n    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        this.seekNonWs(pattern, pos);\n        final StringBuilder result = new StringBuilder();\n        boolean error = false;\n        while (!error && pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            Label_0149: {\n                if (Character.isWhitespace(c)) {\n                    this.seekNonWs(pattern, pos);\n                    c = pattern.charAt(pos.getIndex());\n                    if (c != ',' && c != '}') {\n                        error = true;\n                        break Label_0149;\n                    }\n                }\n                if ((c == ',' || c == '}') && result.length() > 0) {\n                    try {\n                        return Integer.parseInt(result.toString());\n                    }\n                    catch (NumberFormatException ex) {}\n                }\n                error = !Character.isDigit(c);\n                result.append(c);\n            }\n            this.next(pos);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\"Invalid format argument index at position \" + start + \": \" + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n    \n    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        this.seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        while (pos.getIndex() < pattern.length()) {\n            switch (pattern.charAt(pos.getIndex())) {\n                case '{': {\n                    ++depth;\n                    break;\n                }\n                case '}': {\n                    if (--depth == 0) {\n                        return pattern.substring(text, pos.getIndex());\n                    }\n                    break;\n                }\n                case '\\'': {\n                    this.getQuotedString(pattern, pos, false);\n                    break;\n                }\n            }\n            this.next(pos);\n        }\n        throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n    \n    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {\n        if (!this.containsElements(customPatterns)) {\n            return pattern;\n        }\n        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        final ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            final char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n                case '\\'': {\n                    this.appendQuotedString(pattern, pos, sb, false);\n                    continue;\n                }\n                case '{': {\n                    ++depth;\n                    sb.append('{').append(this.readArgumentIndex(pattern, this.next(pos)));\n                    if (depth == 1) {\n                        ++fe;\n                        final String customPattern = customPatterns.get(fe);\n                        if (customPattern == null) {\n                            continue;\n                        }\n                        sb.append(',').append(customPattern);\n                        continue;\n                    }\n                    continue;\n                }\n                case '}': {\n                    --depth;\n                    break;\n                }\n            }\n            sb.append(c);\n            this.next(pos);\n        }\n        return sb.toString();\n    }\n    \n    private void seekNonWs(final String pattern, final ParsePosition pos) {\n        int len = 0;\n        final char[] buffer = pattern.toCharArray();\n        do {\n            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }\n    \n    private ParsePosition next(final ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n    \n    private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) {\n        final int start = pos.getIndex();\n        final char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == '\\'') {\n            this.next(pos);\n            return (appendTo == null) ? null : appendTo.append('\\'');\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); ++i) {\n            if (escapingOn && pattern.substring(i).startsWith(\"''\")) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append('\\'');\n                pos.setIndex(i + \"''\".length());\n                lastHold = pos.getIndex();\n            }\n            else {\n                switch (c[pos.getIndex()]) {\n                    case '\\'': {\n                        this.next(pos);\n                        return (appendTo == null) ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    }\n                    default: {\n                        this.next(pos);\n                        break;\n                    }\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n    }\n    \n    private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn) {\n        this.appendQuotedString(pattern, pos, null, escapingOn);\n    }\n    \n    private boolean containsElements(final Collection<?> coll) {\n        if (coll == null || coll.isEmpty()) {\n            return false;\n        }\n        for (final Object name : coll) {\n            if (name != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "DurationFormatUtils",
        "fqdn": "org.apache.commons.lang3.time",
        "source_code": "package org.apache.commons.lang3.time;\n\nimport org.apache.commons.lang3.*;\nimport java.util.*;\n\npublic class DurationFormatUtils\n{\n    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\";\n    static final Object y;\n    static final Object M;\n    static final Object d;\n    static final Object H;\n    static final Object m;\n    static final Object s;\n    static final Object S;\n    \n    public static String formatDurationHMS(final long durationMillis) {\n        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n    }\n    \n    public static String formatDurationISO(final long durationMillis) {\n        return formatDuration(durationMillis, \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\", false);\n    }\n    \n    public static String formatDuration(final long durationMillis, final String format) {\n        return formatDuration(durationMillis, format, true);\n    }\n    \n    public static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros) {\n        final Token[] tokens = lexx(format);\n        long days = 0L;\n        long hours = 0L;\n        long minutes = 0L;\n        long seconds = 0L;\n        long milliseconds = durationMillis;\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.d)) {\n            days = milliseconds / 86400000L;\n            milliseconds -= days * 86400000L;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.H)) {\n            hours = milliseconds / 3600000L;\n            milliseconds -= hours * 3600000L;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.m)) {\n            minutes = milliseconds / 60000L;\n            milliseconds -= minutes * 60000L;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.s)) {\n            seconds = milliseconds / 1000L;\n            milliseconds -= seconds * 1000L;\n        }\n        return format(tokens, 0L, 0L, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n    \n    public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {\n        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n        if (suppressLeadingZeroElements) {\n            duration = \" \" + duration;\n            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = (duration = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\"));\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n                    }\n                }\n            }\n            if (duration.length() != 0) {\n                duration = duration.substring(1);\n            }\n        }\n        if (suppressTrailingZeroElements) {\n            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n                    }\n                }\n            }\n        }\n        duration = \" \" + duration;\n        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n        return duration.trim();\n    }\n    \n    public static String formatPeriodISO(final long startMillis, final long endMillis) {\n        return formatPeriod(startMillis, endMillis, \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\", false, TimeZone.getDefault());\n    }\n    \n    public static String formatPeriod(final long startMillis, final long endMillis, final String format) {\n        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n    }\n    \n    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) {\n        final Token[] tokens = lexx(format);\n        final Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        final Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n        int milliseconds = end.get(14) - start.get(14);\n        int seconds = end.get(13) - start.get(13);\n        int minutes = end.get(12) - start.get(12);\n        int hours = end.get(11) - start.get(11);\n        int days = end.get(5) - start.get(5);\n        int months = end.get(2) - start.get(2);\n        int years = end.get(1) - start.get(1);\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            --seconds;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            --minutes;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            --hours;\n        }\n        while (hours < 0) {\n            hours += 24;\n            --days;\n        }\n        if (Token.containsTokenWithValue(tokens, DurationFormatUtils.M)) {\n            while (days < 0) {\n                days += start.getActualMaximum(5);\n                --months;\n                start.add(2, 1);\n            }\n            while (months < 0) {\n                months += 12;\n                --years;\n            }\n            if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.y) && years != 0) {\n                while (years != 0) {\n                    months += 12 * years;\n                    years = 0;\n                }\n            }\n        }\n        else {\n            if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.y)) {\n                int target = end.get(1);\n                if (months < 0) {\n                    --target;\n                }\n                while (start.get(1) != target) {\n                    days += start.getActualMaximum(6) - start.get(6);\n                    if (start instanceof GregorianCalendar && start.get(2) == 1 && start.get(5) == 29) {\n                        ++days;\n                    }\n                    start.add(1, 1);\n                    days += start.get(6);\n                }\n                years = 0;\n            }\n            while (start.get(2) != end.get(2)) {\n                days += start.getActualMaximum(5);\n                start.add(2, 1);\n            }\n            months = 0;\n            while (days < 0) {\n                days += start.getActualMaximum(5);\n                --months;\n                start.add(2, 1);\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, DurationFormatUtils.s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n    \n    static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes, final long seconds, final long milliseconds, final boolean padWithZeros) {\n        final StringBuilder buffer = new StringBuilder();\n        boolean lastOutputSeconds = false;\n        for (final Token token : tokens) {\n            final Object value = token.getValue();\n            final int count = token.getCount();\n            if (value instanceof StringBuilder) {\n                buffer.append(value.toString());\n            }\n            else if (value == DurationFormatUtils.y) {\n                buffer.append(paddedValue(years, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.M) {\n                buffer.append(paddedValue(months, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.d) {\n                buffer.append(paddedValue(days, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.H) {\n                buffer.append(paddedValue(hours, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.m) {\n                buffer.append(paddedValue(minutes, padWithZeros, count));\n                lastOutputSeconds = false;\n            }\n            else if (value == DurationFormatUtils.s) {\n                buffer.append(paddedValue(seconds, padWithZeros, count));\n                lastOutputSeconds = true;\n            }\n            else if (value == DurationFormatUtils.S) {\n                if (lastOutputSeconds) {\n                    final int width = padWithZeros ? Math.max(3, count) : 3;\n                    buffer.append(paddedValue(milliseconds, true, width));\n                }\n                else {\n                    buffer.append(paddedValue(milliseconds, padWithZeros, count));\n                }\n                lastOutputSeconds = false;\n            }\n        }\n        return buffer.toString();\n    }\n    \n    private static String paddedValue(final long value, final boolean padWithZeros, final int count) {\n        final String longString = Long.toString(value);\n        return padWithZeros ? StringUtils.leftPad(longString, count, '0') : longString;\n    }\n    \n    static Token[] lexx(final String format) {\n        final ArrayList<Token> list = new ArrayList<Token>(format.length());\n        boolean inLiteral = false;\n        StringBuilder buffer = null;\n        Token previous = null;\n        for (int i = 0; i < format.length(); ++i) {\n            final char ch = format.charAt(i);\n            if (inLiteral && ch != '\\'') {\n                buffer.append(ch);\n            }\n            else {\n                Object value = null;\n                switch (ch) {\n                    case '\\'': {\n                        if (inLiteral) {\n                            buffer = null;\n                            inLiteral = false;\n                            break;\n                        }\n                        buffer = new StringBuilder();\n                        list.add(new Token(buffer));\n                        inLiteral = true;\n                        break;\n                    }\n                    case 'y': {\n                        value = DurationFormatUtils.y;\n                        break;\n                    }\n                    case 'M': {\n                        value = DurationFormatUtils.M;\n                        break;\n                    }\n                    case 'd': {\n                        value = DurationFormatUtils.d;\n                        break;\n                    }\n                    case 'H': {\n                        value = DurationFormatUtils.H;\n                        break;\n                    }\n                    case 'm': {\n                        value = DurationFormatUtils.m;\n                        break;\n                    }\n                    case 's': {\n                        value = DurationFormatUtils.s;\n                        break;\n                    }\n                    case 'S': {\n                        value = DurationFormatUtils.S;\n                        break;\n                    }\n                    default: {\n                        if (buffer == null) {\n                            buffer = new StringBuilder();\n                            list.add(new Token(buffer));\n                        }\n                        buffer.append(ch);\n                        break;\n                    }\n                }\n                if (value != null) {\n                    if (previous != null && previous.getValue() == value) {\n                        previous.increment();\n                    }\n                    else {\n                        final Token token = new Token(value);\n                        list.add(token);\n                        previous = token;\n                    }\n                    buffer = null;\n                }\n            }\n        }\n        if (inLiteral) {\n            throw new IllegalArgumentException(\"Unmatched quote in format: \" + format);\n        }\n        return list.toArray(new Token[list.size()]);\n    }\n    \n    static {\n        y = \"y\";\n        M = \"M\";\n        d = \"d\";\n        H = \"H\";\n        m = \"m\";\n        s = \"s\";\n        S = \"S\";\n    }\n    \n    static class Token\n    {\n        private final Object value;\n        private int count;\n        \n        static boolean containsTokenWithValue(final Token[] tokens, final Object value) {\n            for (int sz = tokens.length, i = 0; i < sz; ++i) {\n                if (tokens[i].getValue() == value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        Token(final Object value) {\n            this.value = value;\n            this.count = 1;\n        }\n        \n        Token(final Object value, final int count) {\n            this.value = value;\n            this.count = count;\n        }\n        \n        void increment() {\n            ++this.count;\n        }\n        \n        int getCount() {\n            return this.count;\n        }\n        \n        Object getValue() {\n            return this.value;\n        }\n        \n        @Override\n        public boolean equals(final Object obj2) {\n            if (!(obj2 instanceof Token)) {\n                return false;\n            }\n            final Token tok2 = (Token)obj2;\n            if (this.value.getClass() != tok2.value.getClass()) {\n                return false;\n            }\n            if (this.count != tok2.count) {\n                return false;\n            }\n            if (this.value instanceof StringBuilder) {\n                return this.value.toString().equals(tok2.value.toString());\n            }\n            if (this.value instanceof Number) {\n                return this.value.equals(tok2.value);\n            }\n            return this.value == tok2.value;\n        }\n        \n        @Override\n        public int hashCode() {\n            return this.value.hashCode();\n        }\n        \n        @Override\n        public String toString() {\n            return StringUtils.repeat(this.value.toString(), this.count);\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-lang",
        "class": "FastDateFormat",
        "fqdn": "org.apache.commons.lang3.time",
        "source_code": "package org.apache.commons.lang3.time;\n\nimport java.util.*;\nimport java.text.*;\n\npublic class FastDateFormat extends Format implements DateParser, DatePrinter\n{\n    private static final long serialVersionUID = 2L;\n    public static final int FULL = 0;\n    public static final int LONG = 1;\n    public static final int MEDIUM = 2;\n    public static final int SHORT = 3;\n    private static final FormatCache<FastDateFormat> cache;\n    private final FastDatePrinter printer;\n    private final FastDateParser parser;\n    \n    public static FastDateFormat getInstance() {\n        return FastDateFormat.cache.getInstance();\n    }\n    \n    public static FastDateFormat getInstance(final String pattern) {\n        return FastDateFormat.cache.getInstance(pattern, null, null);\n    }\n    \n    public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone) {\n        return FastDateFormat.cache.getInstance(pattern, timeZone, null);\n    }\n    \n    public static FastDateFormat getInstance(final String pattern, final Locale locale) {\n        return FastDateFormat.cache.getInstance(pattern, null, locale);\n    }\n    \n    public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getInstance(pattern, timeZone, locale);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style) {\n        return FastDateFormat.cache.getDateInstance(style, null, null);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style, final Locale locale) {\n        return FastDateFormat.cache.getDateInstance(style, null, locale);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone) {\n        return FastDateFormat.cache.getDateInstance(style, timeZone, null);\n    }\n    \n    public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getDateInstance(style, timeZone, locale);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style) {\n        return FastDateFormat.cache.getTimeInstance(style, null, null);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style, final Locale locale) {\n        return FastDateFormat.cache.getTimeInstance(style, null, locale);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone) {\n        return FastDateFormat.cache.getTimeInstance(style, timeZone, null);\n    }\n    \n    public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getTimeInstance(style, timeZone, locale);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle) {\n        return FastDateFormat.cache.getDateTimeInstance(dateStyle, timeStyle, null, null);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale) {\n        return FastDateFormat.cache.getDateTimeInstance(dateStyle, timeStyle, null, locale);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone) {\n        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n    }\n    \n    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {\n        return FastDateFormat.cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);\n    }\n    \n    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) {\n        this(pattern, timeZone, locale, null);\n    }\n    \n    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale, final Date centuryStart) {\n        this.printer = new FastDatePrinter(pattern, timeZone, locale);\n        this.parser = new FastDateParser(pattern, timeZone, locale, centuryStart);\n    }\n    \n    @Override\n    public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n        return this.printer.format(obj, toAppendTo, pos);\n    }\n    \n    @Override\n    public String format(final long millis) {\n        return this.printer.format(millis);\n    }\n    \n    @Override\n    public String format(final Date date) {\n        return this.printer.format(date);\n    }\n    \n    @Override\n    public String format(final Calendar calendar) {\n        return this.printer.format(calendar);\n    }\n    \n    @Override\n    public StringBuffer format(final long millis, final StringBuffer buf) {\n        return this.printer.format(millis, buf);\n    }\n    \n    @Override\n    public StringBuffer format(final Date date, final StringBuffer buf) {\n        return this.printer.format(date, buf);\n    }\n    \n    @Override\n    public StringBuffer format(final Calendar calendar, final StringBuffer buf) {\n        return this.printer.format(calendar, buf);\n    }\n    \n    @Override\n    public Date parse(final String source) throws ParseException {\n        return this.parser.parse(source);\n    }\n    \n    @Override\n    public Date parse(final String source, final ParsePosition pos) {\n        return this.parser.parse(source, pos);\n    }\n    \n    @Override\n    public Object parseObject(final String source, final ParsePosition pos) {\n        return this.parser.parseObject(source, pos);\n    }\n    \n    @Override\n    public String getPattern() {\n        return this.printer.getPattern();\n    }\n    \n    @Override\n    public TimeZone getTimeZone() {\n        return this.printer.getTimeZone();\n    }\n    \n    @Override\n    public Locale getLocale() {\n        return this.printer.getLocale();\n    }\n    \n    public int getMaxLengthEstimate() {\n        return this.printer.getMaxLengthEstimate();\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (!(obj instanceof FastDateFormat)) {\n            return false;\n        }\n        final FastDateFormat other = (FastDateFormat)obj;\n        return this.printer.equals(other.printer);\n    }\n    \n    @Override\n    public int hashCode() {\n        return this.printer.hashCode();\n    }\n    \n    @Override\n    public String toString() {\n        return \"FastDateFormat[\" + this.printer.getPattern() + \",\" + this.printer.getLocale() + \",\" + this.printer.getTimeZone().getID() + \"]\";\n    }\n    \n    protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {\n        return this.printer.applyRules(calendar, buf);\n    }\n    \n    static {\n        cache = new FormatCache<FastDateFormat>() {\n            @Override\n            protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {\n                return new FastDateFormat(pattern, timeZone, locale);\n            }\n        };\n    }\n}\n"
    },
    {
        "project_name": "4_rif",
        "class": "WebServiceDescriptor",
        "fqdn": "com.densebrain.rif.server.transport",
        "source_code": "package com.densebrain.rif.server.transport;\n\npublic class WebServiceDescriptor\n{\n    String targetNamespace;\n    String typesNamespace;\n    Class serviceClazz;\n    \n    public WebServiceDescriptor(final Class serviceClazz, final String targetNamespace, final String typesNamespace) {\n        this.serviceClazz = serviceClazz;\n        this.targetNamespace = targetNamespace;\n        this.typesNamespace = typesNamespace;\n    }\n    \n    public Class getServiceClazz() {\n        return this.serviceClazz;\n    }\n    \n    public void setServiceClazz(final Class serviceClazz) {\n        this.serviceClazz = serviceClazz;\n    }\n    \n    public String getTargetNamespace() {\n        return this.targetNamespace;\n    }\n    \n    public void setTargetNamespace(final String targetNamespace) {\n        this.targetNamespace = targetNamespace;\n    }\n    \n    public String getTypesNamespace() {\n        return this.typesNamespace;\n    }\n    \n    public void setTypesNamespace(final String typesNamespace) {\n        this.typesNamespace = typesNamespace;\n    }\n    \n    @Override\n    public int hashCode() {\n        final int PRIME = 31;\n        int result = 1;\n        result = 31 * result + ((this.serviceClazz == null) ? 0 : this.serviceClazz.hashCode());\n        return result;\n    }\n    \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (this.getClass() != obj.getClass()) {\n            return false;\n        }\n        final WebServiceDescriptor other = (WebServiceDescriptor)obj;\n        if (this.serviceClazz == null) {\n            if (other.serviceClazz != null) {\n                return false;\n            }\n        }\n        else if (this.serviceClazz != other.serviceClazz) {\n            return false;\n        }\n        return true;\n    }\n}\n"
    },
    {
        "project_name": "91_classviewer",
        "class": "SAXDirParser",
        "fqdn": "com.jstevh.viewer",
        "source_code": "package com.jstevh.viewer;\n\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\n\npublic class SAXDirParser extends DefaultHandler\n{\n    public String webData;\n    private static HashMap<String, String> directory;\n    private static StringList localPackages;\n    private static String localBrowser;\n    private static String file_editor;\n    private static boolean lineNumAccepted;\n    private static String lineNumParam;\n    private boolean check;\n    private boolean local;\n    private int level;\n    private String location;\n    \n    public String getWebData() {\n        return this.webData;\n    }\n    \n    public SAXDirParser() throws Exception {\n        this.webData = \"\";\n    }\n    \n    @Override\n    public void startElement(final String namespace, final String local, final String qname, final Attributes atts) throws SAXException {\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\n            this.check = true;\n            this.level = 0;\n        }\n        if (qname.compareTo(\"Editor\") == 0) {\n            this.check = true;\n            this.level = 10;\n        }\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\n            this.check = true;\n            this.level = 11;\n        }\n        if (qname.compareTo(\"parameter\") == 0) {\n            this.check = true;\n            this.level = 12;\n        }\n        if (qname.compareTo(\"Group\") == 0) {\n            this.level = 2;\n            this.check = false;\n        }\n        if (qname.compareTo(\"Web\") == 0) {\n            this.check = true;\n            this.level = 30;\n        }\n        if (qname.compareTo(\"Local\") == 0) {\n            this.check = true;\n            this.level = 31;\n        }\n        if (qname.compareTo(\"Names\") == 0) {\n            this.check = true;\n        }\n        if (qname.compareTo(\"pkg\") == 0) {\n            this.level = 4;\n        }\n    }\n    \n    @Override\n    public void characters(final char[] charArray, final int start, final int length) {\n        if (this.check && this.level >= 0) {\n            String tempStr = \"\";\n            for (int i = start; i < start + length; ++i) {\n                tempStr += charArray[i];\n            }\n            if (this.level == 0) {\n                SAXDirParser.localBrowser = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 10) {\n                SAXDirParser.file_editor = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 11) {\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\n                    SAXDirParser.lineNumAccepted = true;\n                }\n                else {\n                    SAXDirParser.lineNumAccepted = false;\n                }\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 12) {\n                SAXDirParser.lineNumParam = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 30) {\n                this.location = tempStr;\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 31) {\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\n                    this.local = true;\n                }\n                else {\n                    this.local = false;\n                }\n                this.check = false;\n                this.level = -1;\n            }\n            if (this.level == 4 && tempStr.trim().compareTo(\"\") != 0) {\n                if (tempStr.endsWith(\".\")) {\n                    tempStr = tempStr.substring(0, tempStr.length() - 1);\n                }\n                SAXDirParser.directory.put(tempStr, this.location);\n                if (this.local) {\n                    SAXDirParser.localPackages.add(tempStr);\n                }\n            }\n        }\n    }\n    \n    @Override\n    public void endElement(final String namespace, final String local, final String qname) throws SAXException {\n        if (qname.compareTo(\"Group\") == 0) {\n            this.check = false;\n        }\n    }\n    \n    public static HashMap getDirectory() {\n        return (HashMap)SAXDirParser.directory.clone();\n    }\n    \n    public static StringList getLocalPackages() {\n        if (SAXDirParser.localPackages.isEmpty()) {\n            return null;\n        }\n        return SAXDirParser.localPackages.clone();\n    }\n    \n    public static String getLocalBrowser() {\n        return SAXDirParser.localBrowser;\n    }\n    \n    public static String getEditor() {\n        return SAXDirParser.file_editor;\n    }\n    \n    public static boolean acceptsLineNumber() {\n        return SAXDirParser.lineNumAccepted;\n    }\n    \n    public static String lineNumberParameter() {\n        return SAXDirParser.lineNumParam;\n    }\n    \n    public static void main(final String[] args) throws Exception {\n        final SAXParserFactory saxFactory = SAXParserFactory.newInstance();\n        final SAXParser myParser = saxFactory.newSAXParser();\n        final XMLReader myReader = myParser.getXMLReader();\n        myReader.setContentHandler(new SAXDirParser());\n        myReader.parse(\"packagedirectory.xml\");\n        System.out.println(\"test directory, test gives \" + SAXDirParser.directory.get(\"java.lang\"));\n        System.out.println(\"test directory, test gives \" + SAXDirParser.directory.get(\"javax.swing.border\"));\n        System.out.println(\"test local browser, test gives \" + SAXDirParser.localBrowser);\n    }\n    \n    static {\n        SAXDirParser.directory = new HashMap<String, String>();\n        SAXDirParser.localPackages = new StringList();\n        SAXDirParser.localBrowser = \"\";\n        SAXDirParser.file_editor = \"\";\n        SAXDirParser.lineNumAccepted = false;\n        SAXDirParser.lineNumParam = \"\";\n    }\n}\n"
    },
    {
        "project_name": "91_classviewer",
        "class": "ClassInfo",
        "fqdn": "com.jstevh.viewer",
        "source_code": "package com.jstevh.viewer;\n\nimport javax.swing.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\n\npublic class ClassInfo\n{\n    public static boolean debug;\n    private boolean statusAbstract;\n    private Class c;\n    private DirManager dirMan;\n    private static int count;\n    private static int length;\n    public static final int NO_OBJECT_METHODS = 1;\n    public static final int NO_INHERITED_METHODS = 2;\n    private String[] cMethods;\n    private String[] fndMethods;\n    protected String[] knownPackages;\n    \n    public boolean isAbstract() {\n        return this.statusAbstract;\n    }\n    \n    public boolean isInterface() {\n        return this.c.isInterface();\n    }\n    \n    public String getClassName() {\n        return this.c.getName();\n    }\n    \n    public String getClassPackage() {\n        return (this.c.getPackage() != null) ? this.c.getPackage().getName() : null;\n    }\n    \n    public String getSuperClassName() {\n        if (this.c != Object.class && !this.c.isInterface()) {\n            return this.c.getSuperclass().getName();\n        }\n        return null;\n    }\n    \n    private ClassInfo() {\n        this.c = WindowConstants.class;\n        this.fndMethods = null;\n    }\n    \n    public ClassInfo(final String name) throws ClassNotFoundException {\n        this.c = WindowConstants.class;\n        this.fndMethods = null;\n        this.c = this.getClass(name);\n        if (this.c == null) {\n            throw new ClassNotFoundException();\n        }\n        final Method[] m = this.c.getMethods();\n        final Object[] obj = null;\n        this.cMethods = getData(m);\n        if (this.cMethods != null) {\n            if (this.c != Object.class) {\n                final StringList tempList = new StringList();\n                ClassInfo.count = 0;\n                while (ClassInfo.count < this.cMethods.length) {\n                    if (this.cMethods[ClassInfo.count].indexOf(\"Object.\") == -1) {\n                        tempList.add(this.cMethods[ClassInfo.count]);\n                    }\n                    ++ClassInfo.count;\n                }\n                this.cMethods = tempList.toArray();\n            }\n            ClassInfo.count = 0;\n            while (ClassInfo.count < this.cMethods.length) {\n                if (!this.statusAbstract && this.cMethods[ClassInfo.count].indexOf(\"abstract\") != -1) {\n                    this.statusAbstract = true;\n                }\n                ++ClassInfo.count;\n            }\n        }\n    }\n    \n    public ClassInfo(final String name, final DirManager locManager) throws ClassNotFoundException {\n        this.c = WindowConstants.class;\n        this.fndMethods = null;\n        this.dirMan = locManager;\n        this.knownPackages = this.dirMan.getPackageList();\n        this.c = this.getClass(name);\n        if (this.c == null) {\n            throw new ClassNotFoundException();\n        }\n        final Method[] m = this.c.getMethods();\n        final Object[] obj = null;\n        this.cMethods = getData(m);\n        if (this.cMethods != null) {\n            if (this.c != Object.class) {\n                final StringList tempList = new StringList();\n                ClassInfo.count = 0;\n                while (ClassInfo.count < this.cMethods.length) {\n                    if (this.cMethods[ClassInfo.count].indexOf(\"Object.\") == -1) {\n                        tempList.add(this.cMethods[ClassInfo.count]);\n                    }\n                    ++ClassInfo.count;\n                }\n                this.cMethods = tempList.toArray();\n            }\n            ClassInfo.count = 0;\n            while (ClassInfo.count < this.cMethods.length) {\n                if (!this.statusAbstract && this.cMethods[ClassInfo.count].indexOf(\"abstract\") != -1) {\n                    this.statusAbstract = true;\n                }\n                ++ClassInfo.count;\n            }\n        }\n    }\n    \n    public String[] printFields() {\n        final Field[] f = this.c.getFields();\n        ClassInfo.length = f.length;\n        String[] StringData = null;\n        if (ClassInfo.length > 0) {\n            StringData = new String[ClassInfo.length];\n            final Object obj = new Object();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            ClassInfo.count = 0;\n            while (ClassInfo.count < ClassInfo.length) {\n                try {\n                    final String tempStr = f[ClassInfo.count] + \"=\" + f[ClassInfo.count].get(obj);\n                    StringData[ClassInfo.count] = tempStr;\n                    if (ClassInfo.debug) {\n                        System.out.println(tempStr);\n                    }\n                }\n                catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                    final String tempStr = f[ClassInfo.count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\n                    StringData[ClassInfo.count] = tempStr;\n                }\n                catch (IllegalArgumentException j) {\n                    j.printStackTrace();\n                    final String tempStr = f[ClassInfo.count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\n                    StringData[ClassInfo.count] = tempStr;\n                }\n                ++ClassInfo.count;\n            }\n        }\n        else if (ClassInfo.debug) {\n            System.out.println(\"No public fields.\");\n        }\n        return StringData;\n    }\n    \n    public String[] printMethods() {\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        String[] tempArray = null;\n        if (this.cMethods != null) {\n            tempArray = new String[this.cMethods.length];\n            System.arraycopy(this.cMethods, 0, tempArray, 0, this.cMethods.length);\n        }\n        if (ClassInfo.debug && tempArray == null) {\n            System.out.println(\"No public methods.\");\n        }\n        else {\n            this.printArray(tempArray);\n        }\n        return tempArray;\n    }\n    \n    public String[] printMethods(final int param) {\n        if (this.cMethods == null) {\n            return null;\n        }\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        String[] data = this.cMethods;\n        final StringList tempList = new StringList();\n        for (int i = 0; i < this.cMethods.length; ++i) {\n            if (this.cMethods[i].indexOf(this.getClassName() + '.') != -1) {\n                tempList.add(this.cMethods[i]);\n            }\n        }\n        if (!tempList.isEmpty()) {\n            data = tempList.toArray();\n        }\n        else {\n            data = null;\n        }\n        if (ClassInfo.debug && data == null) {\n            System.out.println(\"No public methods.\");\n        }\n        else {\n            this.printArray(data);\n        }\n        return data;\n    }\n    \n    public String[] printConstructors() {\n        final Constructor[] constr = this.c.getConstructors();\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        final String[] data = getData(constr);\n        if (ClassInfo.debug && data == null) {\n            System.out.println(\"No public constructors.\");\n        }\n        else {\n            this.printArray(data);\n        }\n        return data;\n    }\n    \n    public String[] printInterfaces() {\n        Class[] inter = this.c.getInterfaces();\n        if (ClassInfo.debug) {\n            System.out.println(\"****************************************\");\n        }\n        String[] data = getData(inter);\n        if (this.c != Object.class && !this.c.isInterface()) {\n            Class superC = this.c.getSuperclass();\n            final TreeSet<String> hInterfaces = new TreeSet<String>();\n            int i = 0;\n            if (data != null) {\n                for (i = 0; i < data.length; ++i) {\n                    hInterfaces.add(data[i]);\n                }\n            }\n            while (superC != null && superC != Object.class) {\n                inter = superC.getInterfaces();\n                if (ClassInfo.debug) {\n                    System.out.println(\"****************************************\");\n                }\n                data = getData(inter);\n                if (data != null) {\n                    for (i = 0; i < data.length; ++i) {\n                        hInterfaces.add(data[i]);\n                    }\n                }\n                superC = superC.getSuperclass();\n            }\n            if (hInterfaces.size() != 0) {\n                data = new String[hInterfaces.size()];\n                final Iterator it = hInterfaces.iterator();\n                i = 0;\n                while (it.hasNext()) {\n                    data[i] = it.next();\n                    ++i;\n                }\n            }\n        }\n        if (ClassInfo.debug && data == null) {\n            System.out.println(\"No interfaces.\");\n        }\n        else {\n            this.printArray(data);\n        }\n        return data;\n    }\n    \n    public static String[] getData(final Member[] m) {\n        ClassInfo.length = m.length;\n        if (ClassInfo.length == 0) {\n            return null;\n        }\n        final String[] StringData = new String[ClassInfo.length];\n        ClassInfo.count = 0;\n        while (ClassInfo.count < m.length) {\n            final String tempStr = m[ClassInfo.count].toString();\n            StringData[ClassInfo.count] = tempStr;\n            ++ClassInfo.count;\n        }\n        return StringData;\n    }\n    \n    public static String[] getData(final Class[] m) {\n        ClassInfo.length = m.length;\n        if (ClassInfo.length == 0) {\n            return null;\n        }\n        final String[] StringData = new String[ClassInfo.length];\n        ClassInfo.count = 0;\n        while (ClassInfo.count < m.length) {\n            final String tempStr = m[ClassInfo.count].getName();\n            StringData[ClassInfo.count] = tempStr;\n            ++ClassInfo.count;\n        }\n        return StringData;\n    }\n    \n    public String[] srchMethods(final String tempStr) {\n        if (tempStr == null) {\n            return null;\n        }\n        this.fndMethods = StringTools.searchStrings(this.cMethods, tempStr);\n        if (this.fndMethods != null) {\n            final String[] tempArray = new String[this.fndMethods.length];\n            System.arraycopy(this.fndMethods, 0, tempArray, 0, this.fndMethods.length);\n            return tempArray;\n        }\n        return null;\n    }\n    \n    public String[] srchMethods(final String tempStr, final String[] index) {\n        if (tempStr == null) {\n            return null;\n        }\n        this.fndMethods = StringTools.searchStrings(this.cMethods, index, tempStr);\n        if (this.fndMethods != null) {\n            final String[] tempArray = new String[this.fndMethods.length];\n            System.arraycopy(this.fndMethods, 0, tempArray, 0, this.fndMethods.length);\n            return tempArray;\n        }\n        return null;\n    }\n    \n    public MethodData getFoundMethod(final int pos) {\n        if (this.fndMethods == null || pos > this.fndMethods.length) {\n            return null;\n        }\n        return new MethodData() {\n            String tempStr = this.tempStr.substring(this.begin + 1, this.tempStr.length());\n            String tempStr2;\n            String className = this.tempStr.substring(0, this.end);\n            String methodName = this.tempStr.substring(this.end + 1, this.tempStr.length());\n            int begin = this.tempStr.indexOf(\"(\");\n            int end = this.tempStr.lastIndexOf(\".\", this.begin);\n            Class methClass;\n            \n            {\n                this.tempStr = ClassInfo.this.fndMethods[pos];\n                this.end = this.tempStr.indexOf(\")\");\n                this.tempStr = this.tempStr.substring(0, this.end + 1);\n                this.begin = this.tempStr.lastIndexOf(\" \");\n                if (ClassInfo.debug) {\n                    System.out.println(\"className=\" + this.className);\n                }\n                this.methClass = tryClass(this.className);\n                if (ClassInfo.debug) {\n                    System.out.println(\"methClass=\" + this.methClass);\n                }\n            }\n            \n            @Override\n            public String getMethPackage() {\n                if (this.methClass == null) {\n                    return null;\n                }\n                return (this.methClass.getPackage() != null) ? this.methClass.getPackage().getName() : null;\n            }\n            \n            @Override\n            public String getMethClass() {\n                if (this.methClass == null) {\n                    return null;\n                }\n                return this.methClass.getName();\n            }\n            \n            @Override\n            public String getMethName() {\n                return this.methodName;\n            }\n        };\n    }\n    \n    private void printArray(final Object[] array) {\n        if (!ClassInfo.debug) {\n            return;\n        }\n        ClassInfo.length = array.length;\n        if (ClassInfo.length == 0) {\n            return;\n        }\n        ClassInfo.count = 0;\n        while (ClassInfo.count < ClassInfo.length) {\n            System.out.println(array[ClassInfo.count]);\n            ++ClassInfo.count;\n        }\n    }\n    \n    private Class getClass(final String name) {\n        Class tempClass = null;\n        tempClass = tryClass(name);\n        if (tempClass == null) {\n            for (int i = 0; i < this.knownPackages.length; ++i) {\n                final String tempStr = this.knownPackages[i] + name;\n                tempClass = tryClass(tempStr);\n                if (tempClass != null) {\n                    break;\n                }\n            }\n        }\n        return tempClass;\n    }\n    \n    private static Class tryClass(final String name) {\n        Class tempClass = null;\n        try {\n            if (name != null) {\n                tempClass = Class.forName(name.trim());\n            }\n        }\n        catch (ClassNotFoundException e) {\n            return null;\n        }\n        catch (NoClassDefFoundError f) {\n            return null;\n        }\n        return tempClass;\n    }\n    \n    private void printClassInfo() {\n        this.printMethods();\n        if (!this.c.isInterface()) {\n            this.printConstructors();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            this.printInterfaces();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            if (this.statusAbstract) {\n                System.out.println(\"Abstract \" + this.c);\n            }\n            else {\n                System.out.println(this.c.getName());\n            }\n            if (this.c != Object.class) {\n                System.out.println(\"Superclass is \" + this.c.getSuperclass().getName() + \".\");\n            }\n        }\n        else {\n            this.printFields();\n            if (ClassInfo.debug) {\n                System.out.println(\"****************************************\");\n            }\n            System.out.println(this.c.getName() + \" is an interface.\");\n        }\n    }\n    \n    public static void main(final String[] args) throws Exception {\n        final long t1 = System.currentTimeMillis();\n        ClassInfo.debug = true;\n        String name = null;\n        if (args.length > 0) {\n            if (args[0].equals(\"new\")) {\n                name = args[1];\n            }\n            else {\n                name = args[0];\n                try {\n                    final ClassInfo myClassInfo = new ClassInfo(name);\n                    myClassInfo.printClassInfo();\n                }\n                catch (ClassNotFoundException e) {\n                    System.out.println(\"Class not found.\");\n                    System.exit(0);\n                }\n            }\n        }\n        else {\n            final ClassInfo myClassInfo = new ClassInfo();\n            myClassInfo.printClassInfo();\n        }\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\n    }\n}\n"
    },
    {
        "project_name": "commons-cli",
        "class": "HelpFormatter",
        "fqdn": "org.apache.commons.cli",
        "source_code": "package org.apache.commons.cli;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class HelpFormatter\n{\n    public static final int DEFAULT_WIDTH = 74;\n    public static final int DEFAULT_LEFT_PAD = 1;\n    public static final int DEFAULT_DESC_PAD = 3;\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n    public int defaultWidth;\n    public int defaultLeftPad;\n    public int defaultDescPad;\n    public String defaultSyntaxPrefix;\n    public String defaultNewLine;\n    public String defaultOptPrefix;\n    public String defaultLongOptPrefix;\n    public String defaultArgName;\n    protected Comparator optionComparator;\n    \n    public HelpFormatter() {\n        this.defaultWidth = 74;\n        this.defaultLeftPad = 1;\n        this.defaultDescPad = 3;\n        this.defaultSyntaxPrefix = \"usage: \";\n        this.defaultNewLine = System.getProperty(\"line.separator\");\n        this.defaultOptPrefix = \"-\";\n        this.defaultLongOptPrefix = \"--\";\n        this.defaultArgName = \"arg\";\n        this.optionComparator = new OptionComparator();\n    }\n    \n    public void setWidth(final int width) {\n        this.defaultWidth = width;\n    }\n    \n    public int getWidth() {\n        return this.defaultWidth;\n    }\n    \n    public void setLeftPadding(final int padding) {\n        this.defaultLeftPad = padding;\n    }\n    \n    public int getLeftPadding() {\n        return this.defaultLeftPad;\n    }\n    \n    public void setDescPadding(final int padding) {\n        this.defaultDescPad = padding;\n    }\n    \n    public int getDescPadding() {\n        return this.defaultDescPad;\n    }\n    \n    public void setSyntaxPrefix(final String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n    \n    public String getSyntaxPrefix() {\n        return this.defaultSyntaxPrefix;\n    }\n    \n    public void setNewLine(final String newline) {\n        this.defaultNewLine = newline;\n    }\n    \n    public String getNewLine() {\n        return this.defaultNewLine;\n    }\n    \n    public void setOptPrefix(final String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n    \n    public String getOptPrefix() {\n        return this.defaultOptPrefix;\n    }\n    \n    public void setLongOptPrefix(final String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n    \n    public String getLongOptPrefix() {\n        return this.defaultLongOptPrefix;\n    }\n    \n    public void setArgName(final String name) {\n        this.defaultArgName = name;\n    }\n    \n    public String getArgName() {\n        return this.defaultArgName;\n    }\n    \n    public Comparator getOptionComparator() {\n        return this.optionComparator;\n    }\n    \n    public void setOptionComparator(final Comparator comparator) {\n        if (comparator == null) {\n            this.optionComparator = new OptionComparator();\n        }\n        else {\n            this.optionComparator = comparator;\n        }\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final Options options) {\n        this.printHelp(this.defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {\n        this.printHelp(this.defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        this.printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n    \n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        this.printHelp(this.defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n    \n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        this.printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n    \n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        final PrintWriter pw = new PrintWriter(System.out);\n        this.printHelp(pw, width, cmdLineSyntax, header, options, this.defaultLeftPad, this.defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n    \n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad, final int descPad, final String footer) {\n        this.printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n    \n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad, final int descPad, final String footer, final boolean autoUsage) {\n        if (cmdLineSyntax == null || cmdLineSyntax.length() == 0) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n        if (autoUsage) {\n            this.printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else {\n            this.printUsage(pw, width, cmdLineSyntax);\n        }\n        if (header != null && header.trim().length() > 0) {\n            this.printWrapped(pw, width, header);\n        }\n        this.printOptions(pw, width, options, leftPad, descPad);\n        if (footer != null && footer.trim().length() > 0) {\n            this.printWrapped(pw, width, footer);\n        }\n    }\n    \n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {\n        final StringBuffer buff = new StringBuffer(this.defaultSyntaxPrefix).append(app).append(\" \");\n        final Collection processedGroups = new ArrayList();\n        final List optList = new ArrayList(options.getOptions());\n        Collections.sort((List<Object>)optList, this.getOptionComparator());\n        final Iterator i = optList.iterator();\n        while (i.hasNext()) {\n            final Option option = i.next();\n            final OptionGroup group = options.getOptionGroup(option);\n            if (group != null) {\n                if (!processedGroups.contains(group)) {\n                    processedGroups.add(group);\n                    this.appendOptionGroup(buff, group);\n                }\n            }\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n            if (i.hasNext()) {\n                buff.append(\" \");\n            }\n        }\n        this.printWrapped(pw, width, buff.toString().indexOf(32) + 1, buff.toString());\n    }\n    \n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n        final List optList = new ArrayList(group.getOptions());\n        Collections.sort((List<Object>)optList, this.getOptionComparator());\n        final Iterator i = optList.iterator();\n        while (i.hasNext()) {\n            appendOption(buff, i.next(), true);\n            if (i.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }\n    \n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required) {\n        if (!required) {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        if (option.hasArg() && option.hasArgName()) {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }\n    \n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {\n        final int argPos = cmdLineSyntax.indexOf(32) + 1;\n        this.printWrapped(pw, width, this.defaultSyntaxPrefix.length() + argPos, this.defaultSyntaxPrefix + cmdLineSyntax);\n    }\n    \n    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {\n        final StringBuffer sb = new StringBuffer();\n        this.renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n    \n    public void printWrapped(final PrintWriter pw, final int width, final String text) {\n        this.printWrapped(pw, width, 0, text);\n    }\n    \n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {\n        final StringBuffer sb = new StringBuffer(text.length());\n        this.renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n    \n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\n        final String lpad = this.createPadding(leftPad);\n        final String dpad = this.createPadding(descPad);\n        int max = 0;\n        final List prefixList = new ArrayList();\n        final List optList = options.helpOptions();\n        Collections.sort((List<Object>)optList, this.getOptionComparator());\n        for (final Option option : optList) {\n            final StringBuffer optBuf = new StringBuffer(8);\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \" + this.defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else {\n                optBuf.append(lpad).append(this.defaultOptPrefix).append(option.getOpt());\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(this.defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n            if (option.hasArg()) {\n                if (option.hasArgName()) {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else {\n                    optBuf.append(' ');\n                }\n            }\n            prefixList.add(optBuf);\n            max = ((optBuf.length() > max) ? optBuf.length() : max);\n        }\n        int x = 0;\n        final Iterator j = optList.iterator();\n        while (j.hasNext()) {\n            final Option option2 = j.next();\n            final StringBuffer optBuf = new StringBuffer(prefixList.get(x++).toString());\n            if (optBuf.length() < max) {\n                optBuf.append(this.createPadding(max - optBuf.length()));\n            }\n            optBuf.append(dpad);\n            final int nextLineTabStop = max + descPad;\n            if (option2.getDescription() != null) {\n                optBuf.append(option2.getDescription());\n            }\n            this.renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n            if (j.hasNext()) {\n                sb.append(this.defaultNewLine);\n            }\n        }\n        return sb;\n    }\n    \n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, int nextLineTabStop, String text) {\n        int pos = this.findWrapPos(text, width, 0);\n        if (pos == -1) {\n            sb.append(this.rtrim(text));\n            return sb;\n        }\n        sb.append(this.rtrim(text.substring(0, pos))).append(this.defaultNewLine);\n        if (nextLineTabStop >= width) {\n            nextLineTabStop = 1;\n        }\n        final String padding = this.createPadding(nextLineTabStop);\n        while (true) {\n            text = padding + text.substring(pos).trim();\n            pos = this.findWrapPos(text, width, 0);\n            if (pos == -1) {\n                break;\n            }\n            if (text.length() > width && pos == nextLineTabStop - 1) {\n                pos = width;\n            }\n            sb.append(this.rtrim(text.substring(0, pos))).append(this.defaultNewLine);\n        }\n        sb.append(text);\n        return sb;\n    }\n    \n    protected int findWrapPos(final String text, final int width, final int startPos) {\n        int pos = -1;\n        if (((pos = text.indexOf(10, startPos)) != -1 && pos <= width) || ((pos = text.indexOf(9, startPos)) != -1 && pos <= width)) {\n            return pos + 1;\n        }\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n        char c;\n        for (pos = startPos + width; pos >= startPos && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r'; --pos) {}\n        if (pos > startPos) {\n            return pos;\n        }\n        for (pos = startPos + width; pos <= text.length() && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r'; ++pos) {}\n        return (pos == text.length()) ? -1 : pos;\n    }\n    \n    protected String createPadding(final int len) {\n        final StringBuffer sb = new StringBuffer(len);\n        for (int i = 0; i < len; ++i) {\n            sb.append(' ');\n        }\n        return sb.toString();\n    }\n    \n    protected String rtrim(final String s) {\n        if (s == null || s.length() == 0) {\n            return s;\n        }\n        int pos;\n        for (pos = s.length(); pos > 0 && Character.isWhitespace(s.charAt(pos - 1)); --pos) {}\n        return s.substring(0, pos);\n    }\n    \n    private static class OptionComparator implements Comparator\n    {\n        public int compare(final Object o1, final Object o2) {\n            final Option opt1 = (Option)o1;\n            final Option opt2 = (Option)o2;\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n"
    },
    {
        "project_name": "commons-cli",
        "class": "Option",
        "fqdn": "org.apache.commons.cli",
        "source_code": "package org.apache.commons.cli;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Option implements Cloneable, Serializable\n{\n    private static final long serialVersionUID = 1L;\n    public static final int UNINITIALIZED = -1;\n    public static final int UNLIMITED_VALUES = -2;\n    private String opt;\n    private String longOpt;\n    private String argName;\n    private String description;\n    private boolean required;\n    private boolean optionalArg;\n    private int numberOfArgs;\n    private Object type;\n    private List values;\n    private char valuesep;\n    \n    public Option(final String opt, final String description) throws IllegalArgumentException {\n        this(opt, null, false, description);\n    }\n    \n    public Option(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(opt, null, hasArg, description);\n    }\n    \n    public Option(final String opt, final String longOpt, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this.argName = \"arg\";\n        this.numberOfArgs = -1;\n        this.values = new ArrayList();\n        OptionValidator.validateOption(opt);\n        this.opt = opt;\n        this.longOpt = longOpt;\n        if (hasArg) {\n            this.numberOfArgs = 1;\n        }\n        this.description = description;\n    }\n    \n    public int getId() {\n        return this.getKey().charAt(0);\n    }\n    \n    String getKey() {\n        if (this.opt == null) {\n            return this.longOpt;\n        }\n        return this.opt;\n    }\n    \n    public String getOpt() {\n        return this.opt;\n    }\n    \n    public Object getType() {\n        return this.type;\n    }\n    \n    public void setType(final Object type) {\n        this.type = type;\n    }\n    \n    public String getLongOpt() {\n        return this.longOpt;\n    }\n    \n    public void setLongOpt(final String longOpt) {\n        this.longOpt = longOpt;\n    }\n    \n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n    \n    public boolean hasOptionalArg() {\n        return this.optionalArg;\n    }\n    \n    public boolean hasLongOpt() {\n        return this.longOpt != null;\n    }\n    \n    public boolean hasArg() {\n        return this.numberOfArgs > 0 || this.numberOfArgs == -2;\n    }\n    \n    public String getDescription() {\n        return this.description;\n    }\n    \n    public void setDescription(final String description) {\n        this.description = description;\n    }\n    \n    public boolean isRequired() {\n        return this.required;\n    }\n    \n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n    \n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n    \n    public String getArgName() {\n        return this.argName;\n    }\n    \n    public boolean hasArgName() {\n        return this.argName != null && this.argName.length() > 0;\n    }\n    \n    public boolean hasArgs() {\n        return this.numberOfArgs > 1 || this.numberOfArgs == -2;\n    }\n    \n    public void setArgs(final int num) {\n        this.numberOfArgs = num;\n    }\n    \n    public void setValueSeparator(final char sep) {\n        this.valuesep = sep;\n    }\n    \n    public char getValueSeparator() {\n        return this.valuesep;\n    }\n    \n    public boolean hasValueSeparator() {\n        return this.valuesep > '\\0';\n    }\n    \n    public int getArgs() {\n        return this.numberOfArgs;\n    }\n    \n    void addValueForProcessing(final String value) {\n        switch (this.numberOfArgs) {\n            case -1: {\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n            }\n            default: {\n                this.processValue(value);\n            }\n        }\n    }\n    \n    private void processValue(String value) {\n        if (this.hasValueSeparator()) {\n            final char sep = this.getValueSeparator();\n            for (int index = value.indexOf(sep); index != -1; index = value.indexOf(sep)) {\n                if (this.values.size() == this.numberOfArgs - 1) {\n                    break;\n                }\n                this.add(value.substring(0, index));\n                value = value.substring(index + 1);\n            }\n        }\n        this.add(value);\n    }\n    \n    private void add(final String value) {\n        if (this.numberOfArgs > 0 && this.values.size() > this.numberOfArgs - 1) {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n        this.values.add(value);\n    }\n    \n    public String getValue() {\n        return this.hasNoValues() ? null : this.values.get(0);\n    }\n    \n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return this.hasNoValues() ? null : this.values.get(index);\n    }\n    \n    public String getValue(final String defaultValue) {\n        final String value = this.getValue();\n        return (value != null) ? value : defaultValue;\n    }\n    \n    public String[] getValues() {\n        return (String[])(this.hasNoValues() ? null : ((String[])this.values.toArray(new String[this.values.size()])));\n    }\n    \n    public List getValuesList() {\n        return this.values;\n    }\n    \n    public String toString() {\n        final StringBuffer buf = new StringBuffer().append(\"[ option: \");\n        buf.append(this.opt);\n        if (this.longOpt != null) {\n            buf.append(\" \").append(this.longOpt);\n        }\n        buf.append(\" \");\n        if (this.hasArgs()) {\n            buf.append(\"[ARG...]\");\n        }\n        else if (this.hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n        buf.append(\" :: \").append(this.description);\n        if (this.type != null) {\n            buf.append(\" :: \").append(this.type);\n        }\n        buf.append(\" ]\");\n        return buf.toString();\n    }\n    \n    private boolean hasNoValues() {\n        return this.values.isEmpty();\n    }\n    \n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || this.getClass() != o.getClass()) {\n            return false;\n        }\n        final Option option = (Option)o;\n        Label_0062: {\n            if (this.opt != null) {\n                if (this.opt.equals(option.opt)) {\n                    break Label_0062;\n                }\n            }\n            else if (option.opt == null) {\n                break Label_0062;\n            }\n            return false;\n        }\n        if (this.longOpt != null) {\n            if (this.longOpt.equals(option.longOpt)) {\n                return true;\n            }\n        }\n        else if (option.longOpt == null) {\n            return true;\n        }\n        return false;\n    }\n    \n    public int hashCode() {\n        int result = (this.opt != null) ? this.opt.hashCode() : 0;\n        result = 31 * result + ((this.longOpt != null) ? this.longOpt.hashCode() : 0);\n        return result;\n    }\n    \n    public Object clone() {\n        try {\n            final Option option = (Option)super.clone();\n            option.values = new ArrayList(this.values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse) {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n    \n    void clearValues() {\n        this.values.clear();\n    }\n    \n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. Subclasses should use the addValueForProcessing method instead. \");\n    }\n}\n"
    },
    {
        "project_name": "12_dsachat",
        "class": "Handler",
        "fqdn": "dsachat.server",
        "source_code": "package dsachat.server;\n\nimport java.io.*;\nimport dsachat.share.*;\nimport dsachat.share.hero.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class Handler implements InputListener\n{\n    private Vector<Entry> clients;\n    \n    public Handler() {\n        this.clients = new Vector<Entry>();\n    }\n    \n    public void addConnection(final ConnectionEndpoint cl) {\n        final Entry n = new Entry();\n        n.ce = cl;\n        n.name = \"\";\n        try {\n            while (!cl.isConnected()) {}\n            for (int i = 0; i < this.clients.size(); ++i) {\n                final UserEvent ev = new UserEvent(false, this.clients.elementAt(i).name);\n                cl.send(ev);\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n        this.clients.addElement(n);\n    }\n    \n    public void removeConnection(final ConnectionEndpoint cl) {\n        String name = null;\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).ce.getClientPort() == cl.getClientPort()) {\n                name = this.clients.elementAt(i).name;\n                this.clients.removeElementAt(i);\n                break;\n            }\n        }\n        if (name != null) {\n            final UserEvent newCon = new UserEvent(true, name);\n            this.sendAllObj(newCon);\n        }\n    }\n    \n    @Override\n    public void handleInput(final InputEvent e) {\n        final Object o = e.getData();\n        final ConnectionEndpoint con = e.getSource();\n        if (o.getClass().equals(String.class)) {\n            String msg = o.toString();\n            if (msg.startsWith(\"/\")) {\n                final String[] cmd = msg.substring(1).split(\"\\\\s\", 2);\n                msg = cmd[1];\n                if (cmd[0].matches(\"(d(ice)?)|(w\\u00fcrfel)\")) {\n                    this.rollDice(con, msg.trim());\n                    return;\n                }\n                if (cmd[0].matches(\"(w(hisper)?)|(f(l\\u00fcster)?)\")) {\n                    this.whisper(con, msg.trim());\n                    return;\n                }\n                if (cmd[0].matches(\"me\")) {\n                    this.sendAllObj(new String(\"*\" + this.getName(con) + \": \" + msg));\n                    return;\n                }\n                if (cmd[0].equals(\"/getheros\")) {\n                    this.sendHeros(con);\n                    return;\n                }\n                this.sendOneSystemMsg(con, \"command /\" + cmd[0] + \" not found\");\n                return;\n            }\n            else {\n                this.sendAllStr(con, o.toString());\n            }\n        }\n        if (o.getClass().equals(Challenge.class)) {\n            final Challenge c = (Challenge)o;\n            final String send = c.roll();\n            final String to = c.getTo();\n            if (to == null) {\n                this.sendAllStr(con, send);\n            }\n            else {\n                if (!c.isSilent()) {\n                    try {\n                        con.send(send);\n                    }\n                    catch (IOException e2) {\n                        e2.printStackTrace();\n                    }\n                }\n                this.sendToOneStr(con, to, send);\n            }\n        }\n        if (o.getClass().equals(ChallReq.class)) {\n            final ChallReq cr = (ChallReq)o;\n            for (final Entry i : this.clients) {\n                if (i.name.equals(cr.getTo())) {\n                    try {\n                        i.ce.send(cr);\n                    }\n                    catch (IOException e2) {\n                        e2.printStackTrace();\n                    }\n                    return;\n                }\n            }\n        }\n        if (o.getClass().equals(Hero.class)) {\n            final Hero h = (Hero)o;\n            final String name = this.updateHero(con, h);\n            if (name == null) {\n                System.out.println(this.getName(con) + \" updated his hero\");\n                return;\n            }\n            final UserEvent newCon = new UserEvent(false, name);\n            System.out.println(this.getName(con) + \" connected\");\n            this.sendAllObj(newCon);\n            try {\n                con.send(\"Welcome \" + h.getName());\n            }\n            catch (IOException e2) {\n                e2.printStackTrace();\n            }\n        }\n        if (o.getClass().equals(UserEvent.class) && !this.isGmConnected()) {\n            final UserEvent newCon2 = (UserEvent)o;\n            for (int j = 0; j < this.clients.size(); ++j) {\n                if (this.clients.elementAt(j).ce.getClientPort() == con.getClientPort()) {\n                    this.clients.elementAt(j).name = \"Gamemaster\";\n                }\n            }\n            System.out.println(\"Gamemaster connected\");\n            this.sendAllObj(newCon2);\n            try {\n                con.send(\"Welcome \" + newCon2.getName());\n            }\n            catch (IOException e3) {\n                e3.printStackTrace();\n            }\n        }\n    }\n    \n    private void sendHeros(final ConnectionEndpoint con) {\n        final Vector<Hero> vh = new Vector<Hero>();\n        for (final Entry e : this.clients) {\n            if (e.hero != null) {\n                vh.addElement(e.hero);\n            }\n        }\n        try {\n            con.send(vh);\n        }\n        catch (IOException e2) {\n            e2.printStackTrace();\n        }\n    }\n    \n    private boolean isGmConnected() {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).name.equals(\"Gamemaster\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private void sendOneSystemMsg(final ConnectionEndpoint con, final String string) {\n        try {\n            con.send(string);\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void sendAllSystemMsg(final String string) {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            try {\n                this.clients.elementAt(i).ce.send(string);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private void whisper(final ConnectionEndpoint con, final String cmd) {\n        final String[] split = cmd.split(\"\\\\s\", 2);\n        final String to = split[0];\n        final String tail = split[1];\n        String send = this.getName(con) + \" whispers: \" + tail;\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).name.equals(to)) {\n                this.sendOneSystemMsg(this.clients.elementAt(i).ce, send);\n            }\n        }\n        send = \"You whisper to \" + to + \": \" + tail;\n        this.sendOneSystemMsg(con, send);\n    }\n    \n    private void rollDice(final ConnectionEndpoint con, final String cmd) {\n        if (cmd.matches(\".*\\\\+.*\")) {\n            final Matcher m = Pattern.compile(\"(\\\\d*)[wd](\\\\d+)\\\\+(\\\\d+).*\").matcher(cmd);\n            if (m.matches()) {\n                final int count = (m.group(1) == null || m.group(1).equals(\"\")) ? 1 : Integer.parseInt(m.group(1));\n                final int sides = Integer.parseInt(m.group(2));\n                final int mod = Integer.parseInt(m.group(3));\n                String ret = this.getName(con) + \" rolled \" + cmd + \" --> \";\n                int sum = 0;\n                for (int i = 0; i < count; ++i) {\n                    sum += Challenge.dice(sides);\n                }\n                sum += mod;\n                ret += sum;\n                this.sendAllSystemMsg(ret);\n            }\n        }\n        else {\n            final Matcher m = Pattern.compile(\"(\\\\d*)[wd](\\\\d+).*\").matcher(cmd);\n            if (m.matches()) {\n                final int count = (m.group(1) == null || m.group(1).equals(\"\")) ? 1 : Integer.parseInt(m.group(1));\n                final int sides = Integer.parseInt(m.group(2));\n                String ret2 = this.getName(con) + \" rolls \" + cmd + \" --> \";\n                for (int j = 0; j < count; ++j) {\n                    ret2 = ret2 + Challenge.dice(sides) + \"  \";\n                }\n                this.sendAllSystemMsg(ret2);\n            }\n        }\n    }\n    \n    private void sendToOneStr(final ConnectionEndpoint con, final String to, final String send) {\n        final String sender = this.getName(con);\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).name.equals(to)) {\n                try {\n                    final String msg = sender + \": \" + send;\n                    this.clients.elementAt(i).ce.send(msg);\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    \n    private String updateHero(final ConnectionEndpoint con, final Hero h) {\n        int i = 0;\n        while (i < this.clients.size()) {\n            if (this.clients.elementAt(i).ce.getClientPort() == con.getClientPort()) {\n                this.clients.elementAt(i).hero = h;\n                if (this.clients.elementAt(i).name.equals(\"\")) {\n                    this.clients.elementAt(i).name = h.getName();\n                    return h.getName();\n                }\n                return null;\n            }\n            else {\n                ++i;\n            }\n        }\n        return null;\n    }\n    \n    private void sendAllStr(final ConnectionEndpoint con, final String string) {\n        final String sender = this.getName(con);\n        for (int i = 0; i < this.clients.size(); ++i) {\n            try {\n                final String msg = sender + \": \" + string;\n                this.clients.elementAt(i).ce.send(msg);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private void sendAllObj(final Object o) {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            try {\n                this.clients.elementAt(i).ce.send(o);\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private String getName(final ConnectionEndpoint con) {\n        for (int i = 0; i < this.clients.size(); ++i) {\n            if (this.clients.elementAt(i).ce.getClientPort() == con.getClientPort()) {\n                return this.clients.elementAt(i).name;\n            }\n        }\n        return null;\n    }\n}\n"
    }
]